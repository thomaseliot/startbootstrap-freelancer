#      Screens For Altia Help Dialogs
#
# The system references these Help Screens
# via lines that look like "screen #".  The
# text following such a line is read until
# the next occurrence of a "screen #" line.
#
# Copyright (c) Altia, Inc. 1991-1998
#
screen 1
DEFINING ANIMATION:

Animation is created by using the Animation
Editor with the Graphics Editor to inter-
actively define the states of an animation
sequence.  The process is similar to that of
filming frames with a motion picture camera.
Try the following step-by-step example:

1. Using the Graphics Editor, draw a circle
   in the upper left corner of the view and
   leave it selected - the Animation Editor
   defines animation states for the currently
   selected object(s).
2. Enter a name for the animation sequence,
   "bounce", in the "Name:" field of the Ani-
   mation Editor.
3. Set the state number in the "State:" field
   to 0.
4. Making sure the circle is still selected,
   press the Animation Editor's "Define"
   button to define state 0 of animation
   sequence "bounce" for the circle.
5. Increment the state number to 10 by enter-
   ing the number in the "State:" field or by
   simply clicking on the up arrow (to the
   right of the field) repeatedly with mouse
   button one (MB1) until 10 is displayed.
6. With the Graphics Editor, move the circle
   to the lower center portion of the view,
   then press "Define" to define state 10.
7. Increment the state number to 20.
8. Move the circle to the upper right corner
   of the view, then press "Define" to define
   state 20.

** Although this example only uses move, the
Animation Editor supports definitions involv-
ing moves, scales, rotates, stretches, shows,
hides, and color/pattern/brush changes, as
well as any combination of the above **

REPLAYING ANIMATION:
---------------------------------------------
Once an animation sequence is defined, its
states can be replayed in any order by:

A. "Calling" the sequence with the
   appropriate state values through Altia's
   programmatic interface (see Animation
   Editor "Connect Code" Help).
B. Generating input events from the mouse/
   keyboard, such as mouse motion or button
   presses, that objects have been "taught"
   to respond to by calling sequences with
   selected state values (see Stimulus Editor
   "Stimulus" Help).
C. Entering the sequence's name in the Anima-
   tion Editor's "Name:" field and cycling
   through the appropriate state numbers in
   the "State:" field by either entering them
   one at a time or by using the increment/
   decrement arrows (clicking on an arrow
   with MB1 increments/decrements the current
   state number by one, while leaving MB1
   depressed on an arrow changes the number
   rapidly).

9. Replay animation sequence "bounce" by
   cycling through state numbers 0 through 20
   in the "State:" field.

STATE INTERPOLATION:
---------------------------------------------
Only non-consecutive states of an animation
sequence need be defined - Altia Design will
linearly interpolate the missing states when
appropriate.  For instance, in the preceding
example, states 0, 10, and 20 were explicitly
defined because the circle's behavior changed
before and/or after each of them.  The re-
maining states, 1-9 and 11-19, were filled in
automatically.  In addition to move trans-
formations, scales, rotates, and stretches
will be interpolated for undefined states
between defined ones.

ANIMATION SEQUENCES AND FUNCTIONS:
---------------------------------------------
Animation sequences are sometimes called ani-
mation "functions."  And while the terms are
often used interchangeably, the difference
becomes apparent when different sequences for
different objects are given the same name.
Formally, an animation "sequence" is the
behavior of ONE OBJECT in response to changes
in the sequence's state.  An animation
"function" is the behavior of ONE OR MORE
SEQUENCES with the same name.  Therefore, it
is best to think of replaying animation as
changing the state of an animation function,
which causes all animation sequences with
that name to update appropriately.

It follows that the "Name:" and "State:"
fields of the Animation Editor really refer
to the animation function, since changing the
state affects all sequences with names that
match the "Name:" field.

WHAT HAPPENS ON A FUNCTION STATE CHANGE:
---------------------------------------------
When the state of an animation function is
changed (for example, by changing the State:
field in the Animation Editor, via input
or timer stimulus, or by an application pro-
gram), the state change is "broadcast" to
all objects that have animation sequences
with the same name.  As each object receives
the state change message, it decides how
it should change its visual appearance.

If the value for a state change is outside
of an object's own animation sequence range,
the object ignores the state change.

After all objects have a chance to determine
the visual changes they require, the actual
display is updated in an instantaneous
fashion.  If, however, the visual changes
span a large screen area (approximately
greater than 500x500 pixels), the update may
appear to flash.

DEFINED ANIMATIONS AND STATES LIST:
---------------------------------------------
Animation sequences that have been defined
for the selected object(s) appear in the
Defined Animations and States List of the
Animation Editor.  Each line of this horiz-
ontally/vertically scrollable list contains
information about one animation sequence.
Because several objects may have sequences
defined with the same name, names may appear
in the list several times.  In addition,
there may be many more sequences listed than
objects selected since objects may have mult-
iple sequences defined for them.

The "Low : High" columns of a line indicate
the range of state values defined for the
sequence in the "Name" column, while "State"
indicates the sequence's current state.  The
"Init" column lists the state that is to be-
come the sequence's current state when the
design is first opened.

If a sequence is for an object in a group and
not the group itself, "(Child)" appears after
the name.

EDITING DEFINED ANIMATIONS AND STATES:
---------------------------------------------
Animation sequences can be selected for edit-
ing/deleting by simply pressing MB1 down and
dragging the mouse over the desired selec-
tion(s) in the Defined Animations and States
List, then releasing the mouse button.  This
fills the "Name:" and "State:" fields with
the first selected animation sequence/func-
tion name and its current state.

To delete the selected animation sequence(s),
select the "Delete Selected Animation" item
from the Animation Editor's "Edit" menu.  To
delete the state of the FUNCTION in the
"State:" field (which will delete the state
from all SEQUENCES with that name of all
selected objects), select "Delete Current
State".  To rename the animation sequence,
select the "Rename Animation" item.

Any individual state of a FUNCTION can be
redefined by entering the name/state in the
"Name:"/"State:" fields, changing the ob-
ject(s), then pressing "Define" to overwrite
the earlier state definitions for all of its
sequences.  To redefine the state of an in-
dividual SEQUENCE, make sure that only the
object of interest is selected.

INITIAL STATES OF ANIMATIONS:
---------------------------------------------
The initial state of an animation sequence
becomes the sequence's current state when the
design is opened.  This state can be adjust-
ed from the Animation Editor's "Initial"
menu.  With "Set All Initial States To Cur-
rent States", the initial states of all the
listed animation sequences, selected or not,
are reset to the sequences' current states.
"Set Selected Initial State To Current" sets
the initial state for the sequences with the
name shown in the "Name:" field to the state
in the "State:" field.  Finally, "Execute All
Initial States" replays the initial states of
all sequences in the list.

** Multiple animation sequences with the same
name may be edited to have different initial
states.  If this occurs, the initial state
associated with the object "behind" all oth-
ers will have precedence and will become the
initial state for the animation function, ie
all of those sequences **

RESETTING INITIAL STATES DURING RUNTIME:
---------------------------------------------
Application programs or stimulus definitions
can execute a function to set all animations
in a design to their initial states.  The
function's name is

altiaExecuteInitialStates

and it must be executed with a value of 1.
Application programs call altiaSendEvent()
or AtSendEvent() to initiate the execution.
A stimulus definition must execute
altiaExecuteInitialStates with a state value
of 1.

** PLEASE NOTE:  Setting initial states will
not affect the state of text inputs or out-
puts, plots, strip charts, dynamic lines or
polygons, LCD panels, or clips. **

OBJECT ATTRIBUTES IN ANIMATIONS:
---------------------------------------------
Object attributes, such as Foreground Color,
Background Color, Pattern, and Brush, can be
stored as part of an animation state, or
considered a "don't care."  When an animation
state is replayed, whether each of these
attributes will be 1) set as it was when
the state was defined or 2) left unchanged
is determined by selections in the "Animation
Attributes" window.  The "Attributes" item
from the Animation Editor's "Options" menu
opens this window, from which more Help is
available.

OBJECT GROUPING AND ITS EFFECT ON ANIMATION:
---------------------------------------------
When an animated object is added to a group
or a group is created that just contains the
object, the object's animations execute
relative to the group's position and any
scale, rotate, or stretch that is applied to
the group.  The group can also be animated
to dynamically move, scale, rotate, and/or
stretch, etc..  When these group animations
occur, they will have a relative effect on
the object in the group and its own anima-
tions.

By creating levels of groups and animating
at the various group levels, very complex
animation sequences can be created.  For
example, a rotating wheel on a moving car
is quite easy to create.  A fully functional
robot arm on a moving platform is only a
few extra steps in comparison.

screen 2
CODE CONNECTION TO ANIMATION:

Controlling an Altia animation function from
an external program is as simple as calling
any program function.

Communication between the program and the
animation is provided by Altia with the use
of a Dynamic Data Exchange (DDE) (or a TCP/IP
socket, if available).  Let's try an example:

1. Draw a rectangle and define states 0-2 of
   animation sequence "move" by entering
   "move" in the Animation Editor's "Name:"
   field, 0 in the "State:" field, pressing
   "Define", and repetitively adjusting the
   state, moving the rectangle, and pressing
   "Define".
2. In another window, create/edit a text file
   called "mover.c" and add the following
   contents:

   #include "\usr\altia\lib\altia.h"

   main()
   {
   AtConnectId connectId;

     connectId = AtOpenConnection(NULL, NULL,
                                  0, NULL);
     AtSendEvent(connectId, "move", 2);
     AtFlushOutput(connectId);
   }

3. Compile and link the file using the
   following command:

   For Microsoft C/C++ users from an MS-DOS
   prompt window:

   cl -GA -Gx- -AL -c mover.c
   link /BATCH /ONEERROR:NOEXE /NOE /NOD
        mover.obj , mover.exe, ,
        \usr\altia\lib\libdde.lib llibcew
        libw toolhelp ddeml, mover.def

   where the 4 lines of the link command are
   actually combined on a single MS-DOS com-
   mand prompt line. The mover.def file is
   most easily created from a copy of a .def
   file found in one of the altia\demos\*
   directories.

   Because of the many compile and link op-
   tions, it is suggested that the Microsoft
   nmake command be used rather than at-
   tempting to do cl and link manually as
   shown above.  Copy
   \usr\altia\demos\stress\Makefile and
   \usr\altia\demos\stress\stress.def to your
   current directory as Makefile and
   mover.def, respectively.  Edit each and
   replace occurrences of stress or STRESS
   with mover and MOVER.  Then, simply exe-
   cute nmake from the command prompt.

   For Borland C/C++ users from an MS-DOS
   prompt window:

   Because of the many compile and link op-
   tions, it is suggested that the Borland
   make command be used rather than at-
   tempting to do bcc and tlink manually.
   Copy \usr\altia\demos\stress\Makefile.bor
   and \usr\altia\demos\stress\stress.def to
   your current directory as Makefile and
   mover.def, respectively.  Edit each and
   replace occurrences of stress or STRESS
   with mover and MOVER.  Then, simply exe-
   cute the Borland make program from the
   command prompt.

4. Using the Animation Editor, set the cur-
   rent state of "move" to 0.
5. In the separate window, run the program
   by typing "mover".  Notice that animation
   function "move" changes to state 2 and the
   rectangle positions itself appropriately.
   On Windows, you must run the mover
   program from the File Manager or use the
   "Start Client..." option from the Altia
   Graphics Editor's "Client" menu.

For a similar example on connecting code to
input stimulus, select the "Connect Code"
item from the Stimulus Editor's Help menu.
For more detailed information on all Altia
library functions, see the Altia Reference
Manual or the header file:

\usr\altia\lib\altia.h


screen 3
DEFINING INPUT STIMULUS:

Specifying how graphical objects are to
respond to key presses, mouse buttons, and
mouse motion is done interactively with the
Stimulus Editor.  Each stimulus definition
consists of at most four items:

1. The type of stimulus the object should re-
   spond to (key press, mouse button 1/2/3
   down/up, mouse motion, enter/leave,
   timer).
2. The area of the object in which the stim-
   ulus must occur, which may be the whole
   object or some portion of it (specified in
   rectangular or polar coordinates), OR
   start/stop/interval specifications (only
   for timer stimulus).
3. OPTIONALLY, any enabling condition (spec-
   ified as an animation or stimulus function
   whose current state value is <, <=, =, >=,
   >, or <> to a given value).
4. The animation or stimulus function to exe-
   cute once the above three conditions are
   met ("execute" simply means setting/
   incrementing/decrementing the function's
   current state).

** It should be noted that a "stimulus" func-
tion is simply a function that changes state
in response to input, but has no animation
sequence associated with it.  Such a function
is created from the Stimulus Editor when an
"Execute" function is specified that does not
have animation defined for it **

Similar to the Animation Editor, an object
must be selected with the Graphics Editor to
develop an input stimulus definition for it.
Unlike the Animation Editor, however, the
definition will not apply to all selected
objects - only to the selected object "be-
hind" all other selections.

WHEN THE INPUT STIMULUS IS:
---------------------------------------------
The body of the Stimulus Editor contains four
phrases that, when completed, specify the
four items above.  The first of these, "WHEN
THE INPUT STIMULUS IS:", defines what input
stimulus an object should respond to.  The
text field displays the current stimulus
selection, while the five icons on the right
are used to change it:

1. Pressing mouse button one (MB1) down on
   the stopwatch icon results in an input
   stimulus definition of "Timer".  Timers
   are started and stopped by animation or
   stimulus functions.  Once started, a timer
   will wait a specified period of time, then
   "wake up" to drive another function
   (unless stopped prior to its wait time
   elapsing).  Timers can be "one shots" or
   repetitive, and there can be multiple
   timer stimulus specifications for a single
   object.  For more information on timers,
   see the Timers menu item in the Stimulus
   Editor's Help menu.
2. Pressing MB1 down on the keycap icon
   results in an input stimulus definition of
   "Key(any)", meaning any key pressed on the
   keyboard while the mouse pointer is in the
   object's defined area of sensitivity (see
   IN THE AREA: below) will stimulate the
   object.  Pressing, for example, the "s"
   key while the pointer is over the icon
   results in a definition of "Key(s)", mean-
   ing the "s" key will stimulate the object.
3. Pressing MB1 down on one of the mouse
   icon's mouse buttons results in a defini-
   tion of "LeftDown/MiddleDown/RightDown,"
   depending on which icon button was
   pressed.  Pressing one of the icon's
   buttons once it is down changes the def-
   inition to "LeftUp/MiddleUp/RightUp".  In
   addition, pressing MB1 down on the mouse
   icon's palm rest selects "Motion" as the
   desired stimulus.
4. Pressing MB1 down on the enter icon (the
   box with the arrow "entering" it) defines
   the stimulus to be "Enter", meaning that
   entering the object's defined area of
   sensitivity with the mouse pointer will
   stimulate the object.
5. Pressing MB1 down on the leave icon (the
   box with the arrow "leaving" it) defines
   the stimulus to be "Leave", meaning that
   leaving the object's defined area of
   sensitivity with the mouse pointer will
   stimulate the object.

IN THE AREA:
---------------------------------------------
The area of the object that is to be sensi-
tive to the chosen input stimulus (see above)
is defined in the "IN THE AREA:" section of
the Stimulus Editor.  Three toggle buttons
select the method of specifying this area:

1. "Rect" allows a rectangular area to be
   defined:  "x:"/"y:" fields define the off-
   set (in points) of the center of the area
   from the center of the object, "Width:"/
   "Height:" fields define the width/height
   (again in points).
2. "Polar" allows a circular region/arc ("pie
   slice") to be defined:  the "Radius:"
   field defines the radius of the area (in
   points), "Angle" defines the angle of the
   area with the horizontal (in degrees),
   "Inner" specifies the radius of a "donut
   hole" in the center (in points) that will
   NOT respond to input, and "Span" defines
   the size of the arc's angle (in degrees).
   At the bottom, two toggle buttons, "Clock-
   wise" and "Counterclockwise", select the
   direction of interpolation, if used (see
   STATE INTERPOLATION: below).
3. "Whole" allows the entire object to be the
   area of sensitivity.

When either "Rect" or "Polar" is chosen, an
outline of the area as currently defined will
appear over the selected object for which
this stimulus definition applies.  As the
area definition is changed by entering new
values in the fields or using the increment/
decrement arrows adjacent to the fields, the
outline is dynamically updated.  The "Rect"
x:/y: fields and "Polar" Radius:/Angle:
fields can also be adjusted by pressing MB1
down on the palm rest of the example mouse
icon and dragging.

AND THE ENABLE CONDITION:
---------------------------------------------
Although optional, an enable condition allows
for more sophisticated stimulus definitions.
This notion is most easily explained by
imagining a knob that has the behavior of
rotating when the mouse pointer is moved
along its perimeter.  Typically, this is not
quite the desired behavior.  A more useful
knob could be created by requiring a MB1 down
stimulus on the knob to enable the motion
stimulus for the knob, and a MB1 up to turn
the enable off (ie disable it).  This would
ensure that the knob only rotates when MB1 is
depressed.

The enable condition is specified as an
animation or stimulus function whose current
state value is <, <=, =, >=, >, or <> to a
given value.  The function name is typed in
the text field, while the condition is chosen
by pressing MB1 down on the "button" between
the text and state fields and selecting the
condition from the "menu."  The state value
is either entered directly into its field or
adjusted with the field's increment/decrement
arrows.

** PLEASE NOTE:  To specify an enable condi-
tion that will always be true, enter the
function name "None", the condition "=", and
the value "0". **

THEN EXECUTE:
---------------------------------------------
The final element of the input stimulus def-
inition is the animation or stimulus function
to execute when the previous three conditions
are met (input stimulus in the area of sens-
itivity while the enable condition is true).

The function to execute is entered in the
text field and what to do to the current
state is chosen by pressing the "button" be-
tween the text and state fields and selecting
whether the current state should be set to or
incremented/decremented by the value entered
in the state field.

Once this and all other elements of the input
stimulus definition are complete, the Stim-
ulus Editor's "Define" button should be
pressed to enter the definition.

EFFECT OF THE EXECUTE FUNCTION:
---------------------------------------------
When input stimulus is generated, the effect
can be seen in two places:

1. The executed function may cause an anima-
   tion sequence to change state, directly
   controlling animation (see Animation
   Editor "Animate" Help).
2. The executed function may be polled or
   generate a "callback" through Altia's
   programmatic interface and action taken
   based on the function's new state (see
   Stimulus Editor "Connect Code" Help).

STATE INTERPOLATION:
---------------------------------------------
As with animation, stimulus can also be
interpolated.  The execution states for a
function can be interpolated if two separate
stimulus definitions for an object have
non-overlapping areas sensitive to "Motion"
stimulus and both definitions have the same
enable and execute functions.  For example:

1. Using the Graphics Editor, create a long,
   horizontal rectangle (leave it selected).
2. In the Stimulus Editor, set the input
   stimulus to "Motion" by pressing MB1 down
   on the palm rest of the example mouse.
3. Create a rectangular area of sensitivity
   the same height as the rectangle at the
   left end of the rectangle (adjust
   "Height:" and "x:").
4. Set the "THEN EXECUTE:" function to "mo-
   tion" and the execute state to 0 ("State:"
   should be displayed on the "button").
5. Press the "Define" button to define an
   area at the left end of the rectangle
   that is sensitive to motion.
6. Increment the execute state to 10.
7. Move the rectangular outline of the area
   of sensitivity to the right end of the
   rectangle by pressing MB1 down on the ex-
   ample mouse's palm rest and dragging the
   area to the right.
8. Press the "Define" button to define an
   area at the right end of the rectangle
   that is sensitive to motion.
9. Open the Animation Editor and enter the
   function name, "motion", in the "Name:"
   field.  The Editor will be used to monitor
   state changes to the function.
10. Put the Graphics Editor in "Run" mode
    by selecting the Run toggle button just
    below the Color/Pattern/Brush/Font pal-
    ettes.  In this mode, all keyboard and
    mouse events are passed directly to ob-
    jects - the Graphics Editor ignores them.
11. Move the workstation's mouse pointer
    along the length of the rectangle and
    observe the state changes that occur to
    the function "motion" in the Animation
    Editor.  While only states 0 and 10
    were explicitly defined, states 1-9 have
    been interpolated.

DEFINED STIMULUS LIST:
---------------------------------------------
Completed stimulus definitions for the se-
lected object appear in the Defined Stimulus
List of the Stimulus Editor.  Each line of
this horizontally/vertically scrollable list
contains information about one stimulus def-
inition.  There may be several definitions in
the list because the selected object may have
several areas/types of stimulus defined for
it.

The "Stimulus:" column of a line indicates
the type of stimulus that generates a re-
sponse, while the "Execute:" column contains
the execute function name, State/Inc+/Dec- to
indicate what to do to the function's state,
and the value to set/increment/decrement the
state to/by.  Following this is information
on the enable function and state (if any).
Finally, the type (Rect/Polar/Whole Object),
size, and location of the area of sensitivity
is listed (or START:, STOP:, and INTERVAL:
information for timers).

MULTIPLE DEFINITIONS FOR THE SAME INPUT:
---------------------------------------------
If multiple stimulus definitions respond to
to the same input, they are evaluated, in
sequence, at the time of the input occur-
rence.  All enable conditions are evaluated
first and then all "execute" statements are
conditionally performed.  If an "execute"
statement changes the state of a function
that is used in one or more of the enable
conditions, the change will not have an
effect until the next input event.

MULTIPLE OBJECTS WITH SIMILAR INPUT STIMULUS:
---------------------------------------------
When two or more objects have stimulus defi-
nitions that respond to the same input and
the stimulus areas overlap, the enable
conditions for all objects are evaluated
first.  All "execute" statements are then
conditionally performed based on the results
of the enable condition evaluations starting
with the object in front and finishing with
the object in back.

EDITING DEFINED STIMULUS:
---------------------------------------------
Stimulus definitions can be selected for
editing/cutting/copying by simply pressing
MB1 down and dragging the mouse over the
desired selection(s) in the Defined Stimulus
List, then releasing the mouse button (the
Edit menu's "Select All" menu item can be
used to select all definitions as well).
This fills all Stimulus Editor fields with
the first selected stimulus definition.

To cut the selected stimulus definition(s),
select the "Cut Stimulus" item from the
Stimulus Editor's "Edit" menu.  To copy,
select "Copy Stimulus".  Both these options
place the stimulus in a buffer for use with
the "Paste Stimulus" menu item.  When ready
to paste the stimulus definition(s), first
select (highlight) the existing definition
that should appear AFTER the pasted defini-
tion(s), then choose "Paste Stimulus" (note
that timer stimulus ALWAYS appears after all
other types of stimulus in the list regard-
less of what stimulus line is selected prior
to the paste).  To rename the enable or
execute function in a definition, select the
"Rename Stimulus" item.

Any portion of a stimulus definition can be
redefined by selecting the definition from
the list (which fills in all Stimulus Editor
fields), changing the appropriate portion(s)
of the definition (type of stimulus, area,
enable function/condition/state, execute
function/action/state), then pressing the
"Redefine" button (the "Define" button re-
labels itself).

screen 4
CODE CONNECTION TO STIMULUS:

Receiving an Altia stimulus event in an
external program is as simple as calling any
program function.

Communication between the program and the
stimulus is provided by Altia with the use
of a Dynamic Data Exchange (DDE) (or a TCP/IP
socket, if available).  Let's try an example:

1. Draw a rectangle and create the following
   input stimulus definition for it:
   WHEN THE INPUT STIMULUS IS:  LeftDown
   IN THE AREA:  Whole (object)
   AND THE ENABLE CONDITION:  None = 0
   THEN EXECUTE:  press State: 1
   Press the "Define" button.
2. Open the Animation Editor window by press-
   ing the "Animate" button in the Graphics
   Editor.
3. With the rectangle still selected, define
   states 0-2 of an animation sequence "move"
   by entering "move" in the Animation
   Editor's "Name:" field, 0 in the "State:"
   field, pressing the Animation Editor's
   "Define", and repetitively adjusting the
   state, moving the rectangle, and pressing
   "Define" for new state values 1 and 2.
4. In another window, create/edit a text file
   called "monitor.c" and add the following
   contents:

   #include "\usr\altia\lib\altia.h"

   void pressEvent(connectId, name, value,
                   data)
   AtConnectId connectId;
   char* name;
   int value;
   AtPointer data;
   {
     if (value == 1)
         {
         AtSendEvent(connectId,"move",0);
         AtSendEvent(connectId,"move",1);
         AtSendEvent(connectId,"move",2);
         AtFlushOutput(connectId);
         exit(0);
         }
   }
   main()
   {
   AtConnectId connectId;

     connectId = AtOpenConnection(NULL, NULL,
                                  0, NULL);
     AtAddCallback(connectId, "press",
                   pressEvent, NULL);
     AtMainLoop();
   }

5. Compile and link the file using the
   following command:

   For Microsoft C/C++ users from an MS-DOS
   prompt window:

   cl -GA -Gx- -AL -c monitor.c
   link /BATCH /ONEERROR:NOEXE /NOE /NOD
        monitor.obj , monitor.exe, ,
        \usr\altia\lib\libdde.lib llibcew
        libw toolhelp ddeml, monitor.def

   where the 4 lines of the link command are
   actually combined on a single MS-DOS com-
   mand prompt line. The monitor.def file is
   most easily created from a copy of a .def
   file found in one of the altia\demos\*
   directories.

   Because of the many compile and link op-
   tions, it is suggested that the Microsoft
   nmake command be used rather than at-
   tempting to do cl and link manually as
   shown above.  Copy
   \usr\altia\demos\stress\Makefile and
   \usr\altia\demos\stress\stress.def to your
   current directory as Makefile and
   monitor.def, respectively.  Edit each and
   replace occurrences of stress or STRESS
   with monitor and MONITOR.  Then, simply
   execute nmake from the command prompt.

   For Borland C/C++ users from an MS-DOS
   prompt window:

   Because of the many compile and link op-
   tions, it is suggested that the Borland
   make command be used rather than at-
   tempting to do bcc and tlink manually.
   Copy \usr\altia\demos\stress\Makefile.bor
   and \usr\altia\demos\stress\stress.def to
   your current directory as Makefile and
   monitor.def, respectively.  Edit each and
   replace occurrences of stress or STRESS
   with monitor and MONITOR.  Then, simply
   execute the Borland make program from the
   command prompt.

6. Open the Animation Editor and enter the
   function name, "press", in the "Name:"
   field.  The Editor will be used to monitor
   state changes to the function.
7. Put the Graphics Editor in "Run" mode
   by selecting the Run toggle button just
   below the Color/Pattern/Brush/Font pal-
   ettes.  In this mode, all keyboard and
   mouse events are passed directly to ob-
   jects - the Graphics Editor ignores them.
8. In the separate window, run the program
   by typing "monitor".  On Windows, you must
   run the monitor program from the File
   Manager or use the "Start Client..." item
   from the Altia Graphics Editor's "Client"
   menu.
9. Press mouse button one (MB1) down inside
   the rectangle.  Notice that animation
   function "press" changes to state 1 and
   the rectangle itself moves through its 0-2
   defined states for the "move" animation.
   The results only appear once for each
   execution of the monitor program because
   the program exits after sending events to
   the "move" animation.  Start the program
   again as in step 8 to see the results
   again.  Or, remove the exit(0); line from
   the monitor.c file and repeat the steps to
   build and execute the program.  Now, it
   will continue to run after each press and
   repeat the results automatically.  The
   program will stop when you exit the Altia
   Graphics Editor or stop it immediately by
   choosing "Disconnect All Clients" from the
   Editor's "Client" menu.

For a similar example on connecting code to
animation, select the "Connect Code" item
from the Animation Editor's Help menu.  For
more detailed information on all Altia lib-
rary functions, see the Altia Reference
Manual or the header file

\usr\altia\lib\altia.h.


screen 5
RENAMING ANIMATION AND STIMULUS FUNCTIONS:

The animation, stimulus, and control names
used by an object can be customized to avoid
conflicts with names associated with other
objects.  Adding a unique prefix to the names
is one suggested method.  The Function Rename
Dialog provides this and other possibilities.

The dialog supplies a default numeric prefix
for prepending to function names.  The number
is the selected object's identification number
which is unique to the specific object.  For
instance, if "1" appears in the text field
beside the "Prepend" button, "1_" will be
prepended to all function names in the list
if the button is pressed.  Another approach is
to provide a prefix that logically matches
the object's intended use.  For example, the
prefix "power" could be used if the object is
a power button.

Options for replacing one prefix with anoth-
er or for simply renaming a function are also
provided.  Simply fill in the appropriate
fields and press the appropriate button
(filling the rename function field can be
done by pressing mouse button one (MB1) down
on the function name in the list).  As
changes are made, the list of function names
is automatically updated.  Once all modifica-
tions have been completed, press the "Close"
button to close the dialog.

screen 6
PLAYING BACK AN ALTIA DESIGN LOG FILE:

The Playback portion of the Altia Logfile
Player/Recorder interface is used to replay
Altia log files previously created with the
Recorder.  For more information on creating
an Altia log file, select "Record" from the
Player/Recorder Help menu.

SELECTING A PLAYBACK FILE:
---------------------------------------------
Enter the file name of an Altia log file in
the "PLAYBACK File Selection:" text field.

STARTING PLAYBACK:
---------------------------------------------
Playback of the selected file is started by
simply pressing "PLAY".  The Player will up-
date the "Remaining Time(secs):" status field
as it plays back the commands from the file.
If the file contains recordings of tool com-
mands, buttons and menus in the Altia Editors
will be pushed/selected just as they were
when the file was originally recorded.  If
the file contains recordings of object input
stimulus, objects in the Altia Views will
respond as they did during the recording
session.

If "PLAY" is pressed and the "Remaining Time"
status field changes to "Unknown: file load
failed", the selected file is not readable.
It could be a file or directory permissions
problem or, most likely, the file does not
exist.

STOPPING AND RESTARTING PLAYBACK:
---------------------------------------------
Playback can be stopped at any time by press-
ing the "STOP" button.  To restart from that
point, press "PLAY" again.  To restart from
the beginning, press "REWIND", then "PLAY".
Once playback completes, 0.000 will be dis-
played as the remaining time.

CHANGING THE PLAYBACK SPEED:

Each press on the "FASTER PLAY"/"SLOWER PLAY"
buttons speeds up/slows down the playback by
a factor of 2 relative to its previous speed.

SINGLE STEPPING:
---------------------------------------------
Pressing "SINGLE STEP" allows stepping
through the log file one command at a time.
Single stepping should be reserved for log
files that only contain recordings of object
input stimulus.

STARTING PLAYBACK FROM THE COMMAND LINE:
---------------------------------------------
Log file playback can be initiated from the
command line when Altia is first started by
adding the option "-play [filename]".  If
[filename] is omitted, Altia will read log
commands from stdin.  If "-demo" is added,
the mouse cursor will mimic its movements
from when the log file was recorded.  This
provides a much better visual clue as to
what's happening during playback.

** If the log file contains recordings of
tool commands, the "-demo" option should al-
ways be included.  This guarantees consistent
playback behavior by locking out all incoming
keyboard and mouse events that could inter-
rupt the replay of tool commands **

Playback speed can also be adjusted from the
command line with the "-speed #" option,
where # is the factor relative to normal
speed.  For example, 2 would play back twice
as fast and .5 would play back at half speed.

screen 7
RECORDING AN ALTIA DESIGN LOG FILE:

The Record portion of the Altia Logfile
Player/Recorder interface is used to record
Altia logfiles for later playback with the
Player.  For more information on playing back
an Altia log file, select "Playback" from the
Player/Recorder Help menu.

SELECTING A RECORD FILE:
---------------------------------------------
Enter the file name to which the log file is
to be recorded in the "RECORD File Selec-
tion:" text field.

CHOOSING THE COMMANDS/EVENTS TO RECORD:
---------------------------------------------
When recording is begun, only commands/events
of the selected type(s) will be recorded.
The possibilities are:

  Object Input - when this toggle button is
    selected (the default), object input
    stimulus in Run mode will be recorded.
    For example, if there is a button in the
    design file that activates on a LeftDown
    stimulus and the button receives such a
    stimulus while in Run mode, the mouse
    button press will be recorded.  Recording
    of this type of event is usually enabled.

  Tool Commands - when selected (NOT the de-
    fault), all interactions with buttons,
    menus, dialog boxes, and other portions
    of the various Altia Editors will be re-
    corded.  For example, pulling down the
    "File" menu in the Graphics Editor would
    be recorded.

  Client Events - when selected (NOT the de-
    fault), function state changes received
    from client programs will be recorded.
    This allows replay of an Altia session
    without having the client program run-
    ning.  When played back, the function
    state changes initiated by the client
    program will be reproduced in their orig-
    inal sequence.  Client event recording is
    a rather esoteric feature and is normally
    disabled.

TO START RECORDING:
---------------------------------------------
Recording is initiated by simply pressing
"RECORD".  By default, the new log entries
will be APPENDED to the record file if the
file already exists.  The "LOAD FOR CREATE"
button can be pressed to overwrite the file.
Pressing "LOAD FOR APPEND" changes it back
to the default action of appending.

The "File Position(line#):" status field is
updated dynamically by the Recorder.  It
indicates the current position in the record
file and increments by 1 every time a new
command/event is recorded.  If "RECORD" is
pressed  and the field reads "Unknown: file
load failed", the requested file could not be
opened for writing.  The cause is most likely
a file or directory permissions problem.

TO STOP/RESTART RECORDING:
---------------------------------------------
To stop recording at any time, press the
"STOP" button.  To resume recording from that
point, press "RECORD" again.  To overwrite
the record file, press "LOAD FOR CREATE",
then "RECORD".

THE RECORD FILE FORMAT:
---------------------------------------------
Record files are created as text files.  As
a result, they can be easily created/edited/
customized with text editors, shell scripts,
simple programs, etc.

STARTING A RECORDING FROM THE COMMAND LINE:
---------------------------------------------
Log file recording can be initiated from the
command line when Altia is first started by
adding the option "-log [filename]".  If
[filename] is omitted, Altia will write log
commands to stdout.  By default, object in-
put stimulus and tool commands will be
recorded and [filename] will be overwritten,
not appended to.  The following options
allow for changing these defaults:

  +log FILENAME  append to file
  +/-loginput    do/don't record object
                 input stimulus (default=do)
  +/-logtool     do/don't record tool
                 commands (default=do)
  +/-logclient   do/don't record animation
                 state changes initiated
                 by client programs
                 (default=don't)

screen 8
USING A MODELS VIEW:

Altia design files are often used to maintain
libraries of component models.  Some librar-
ies are provided with Altia Design, while
others are created by designers themselves.
These libraries allow efficient standard-
ization on and reuse of certain models for
developers of Altia designs.

A Models View provides a view into any Altia
design file without affecting the design
being edited with the other Altia Editors.
A model can be copied from a Models View to
any Altia View used by the other Editors, and
vice-versa.  Multiple Models Views may even
be open at any one time.  In addition, some
limited editing features are provided for
Models Views, like moving/deleting models.

COPYING A MODEL FROM A MODELS VIEW TO A
GRAPHICS EDITOR VIEW:
---------------------------------------------
Although a "Copy Model" button is provided,
it is not necessary to use it if no other
button in the Models View is depressed.  Sim-
ply press mouse button one (MB1) down on the
model in the Models View and, while still
holding the button down, drag the model into
any Graphics Editor View, position it, and
release the mouse button.  If the model has
any animation or stimulus functions defined
for it, a dialog box will appear, allowing
the model's functions to be renamed.  If no
dialog appears for a model that has anima-
tion and/or stimulus, then the Graphics Edi-
tor is in auto-rename mode.  In this case, a
unique prefix is automatically added to the
model's animation and stimulus names.  In any
case, the model has now been added to the de-
sign being edited.

COPYING A MODEL FROM A GRAPHICS EDITOR VIEW
TO A MODELS VIEW:
---------------------------------------------
To add a model to the Models View, press the
"Add Model" button in the Models View.  It
will stay depressed until another mode is
chosen.  Move the mouse pointer over the ob-
ject in the Graphics Editor View that is to
be added to the Models View, press MB1 down
and, while still holding the button down,
drag the object into the Models View, posi-
tion it, and release the mouse button.  The
object has now been added to the Models
View's design.  The process can be repeated
as long as the "Add Model" button is depress-
ed.  To quit the "Add Model" mode, press the
button again (or any other button in any
Altia window).

MOVING AND DELETING MODELS:
---------------------------------------------
"Move Model"/"Delete Model" allow models to
be moved within/deleted from the Models View.
To move a model within the view, press MB1
down on the model and, while still holding
the button down, drag the model to its new
location.  To delete a model, just click MB1
down on the model in the Models View.

SAVING A MODELS VIEW:
---------------------------------------------
Once a Models View has been modified, it can
be saved to its original file by selecting
the "Save" item from the Models View's File
menu.  Selecting "Save As..." allows it to be
saved to a different file.  The Models View
will then update itself to refer to the new
file name and all subsequent "Save"s will be
to that file.

CLOSING A MODELS VIEW:
---------------------------------------------
Select the "Close" item from the Models
View's File menu to close the view.  If the
view has been modified in any way, a dialog
will appear allowing the file to be saved
before closing.

STANDARD MODELS:
---------------------------------------------
Altia Design comes with many useful component
libraries.  All components have appropriate
properties for customizing their look and
behavior.  After copying a component into the
Graphics Editor's drawing area, double-click
on it with the left mouse to view its
properties, or press Ctrl+I, or choose the
"Set Properties..." option from the Edit
menu.

If a component has dynamic behavior, it will
also have connections defined for it.  One
object's INPUT or OUTPUT connection can be
linked to another object's OUTPUT or INPUT
or an external signal OUTPUT or INPUT.  In
this way, objects can control each other and
objects can control or be controlled by
external signals associated with a
simulation.

After copying a component into the Graphics
Editor's drawing area, select it if it is
not already selected and press Ctrl+T or
choose the "Selected Objects..." option
from the editor's Connections menu to open a
Connections dialog for the component.  If
multiple objects are selected, a dialog will
appear for each object.  See the Help menu
in the Connections Dialog for more specific
information on how to link connections.

If you are interfacing to a simulation,
choose the "External Signals..." option from
the Connections menu to view the available
external signals.  You can link an external
signal INPUT or OUTPUT to an object's
OUTPUT or INPUT connection in the same way
that you can link connections between
objects.  See the Help menu in the
Connections Dialog for more specific
information on how to link connections.

Standard libraries from previous releases of
Altia Design are still available from the
"more" sub-directory of the "models"
directory.  Some of these libraries contain
models with built-in animation and/or stim-
ulus which cannot be easily duplicated using
the Animation and Stimulus Editors.  Select
the Models View's Help menu for more infor-
mation on these and other models.

screen 9
OBJECT ATTRIBUTES IN ANIMATIONS:

When animation states are defined, object
attributes such as Foreground Color, Back-
ground Color, Pattern, and Brush can be
stored as part of the state, or considered
a "don't care."  When an animation state
is replayed, whether each of these
attributes will be 1) set as it was when
the state was defined or 2) left unchanged
is determined by selections in the "Animation
Attributes" window.

In general, choose to store attributes that
are inherent to the type of animation being
defined.  For example, if the animation is
designed to change foreground colors, choose
"Foreground Color" as an attribute to be
saved with the definition.  If foreground
color is not involved in the animation, un-
select it.  By unselecting attributes not
directly involved in the animation, those
attributes can easily be changed for the
object at a later time without having to re-
define all states of the animation sequence.

There are different situations where one
choice is more appropriate than the other.
The following are two such examples.

ATTRIBUTES CHOSEN EXAMPLE:
---------------------------------------------
An animation sequence is being defined for a
warning light.  Animation function "warning"
is to turn the light red when in state 1,
green when in state 2.  In this case, the
"Foreground Color" attribute should be saved
as part of each state of animation sequence
"warning".  As a result, the warning light
will always change to red in state 1 and
green in state 2.  These colors will remain
part of the animation even if the color of
the light is changed with the Graphics Ed-
itor:  executing function "warning" with
state 1 (2) will change the light back to
red (green).

ATTRIBUTES NOT CHOSEN EXAMPLE:
---------------------------------------------
An animation sequence is being defined for a
bouncing ball.  Animation function "bounce"
is to trace the path of the ball with 20
states.  The ball just happens to be red when
the 20 animation states are defined.  If the
"Foreground Color" attribute toggle button
was selected, the ball will be red for each
state even if the color is temporarily
changed with the Graphics Editor:  executing
function "bounce" with states 1-20 will
immediately change the color back to red
again.  Making the ball blue becomes a tedius
task - each of the 20 states must be re-
defined with the ball being blue.  However,
if the "Foreground Color" attribute button
was not chosen, simply changing the ball's
color is sufficient:  no state definition
would change the color back so the ball would
be blue in all states.

screen 10
TEXT INPUT/OUTPUT MODELS:

The readouts.dsn and inputs.dsn libraries
contain configurable components for
displaying and entering numbers and text.

The design file

\usr\altia\models\more\textio.dsn

contains a basic text i/o object, several
complete text input areas (including one that
demonstrates the use of a custom cursor), a
number-only input area, and a text i/o object
that functions as a digital clock with the
help of control and timer stimulus.

With Altia Design 2.0, the earlier text input
and text output objects are replaced with a
single text i/o object.  The new object
combines the functionality of the previous
two objects and adds cursor, scrolling, and
append capabilities.

THE TEXT I/O OBJECT:
---------------------------------------------
The text i/o object has four animations
(named "character", "text", "integer", and
"clear") that output text characters to the
screen or clear the screen.  The remaining
animations ("justify_mode", "max_char_count",
"base_mode", "clip_on", "append_on",
"scroll", "scroll_on", "cursor_mode", and
"output_cursor") control the format of the
output.

THE TEXT I/O character ANIMATION:
---------------------------------------------
The state value of a "character" animation is
interpreted as an ASCII character code.  Each
time "character" is given a printable ASCII
state value, the new state value is added to
the current list of previous ASCII state
values and the new character is added to the
currently displayed text.  A new "character"
animation with a state of zero marks the end
of the current string of text. The next
"character" state will erase the current text
before displaying the new character. This
mode of displaying a new character imme-
diately upon receipt of the new state is re-
ferred to as non-buffered output.  The "text"
animation, in contrast,  works in a buffered
mode.  Buffered mode allows better character
throughput while non-buffered mode is neces-
sary for building text input areas.

The "character" animation is often used as
the execute name in a stimulus definition.
For example, on a Left Button Down event
over a push button, EXECUTE: character
State: '1'.  The Stimulus Editor converts
a state value in single quotes to its ASCII
value equivalent.  The "character" animation
is also useful in a control SET statement.
For example: SET character = '0' adds a '0'
character to the text i/o object.

THE TEXT I/O text ANIMATION:
---------------------------------------------
Like the "character" animation, the "text"
animation interprets new state values as
ASCII character codes.  But, instead of dis-
playing a new character immediately, the
character is stored internally.  When a zero
state value is received (which is the end of
string identifier), all characters stored in-
ternally replace the current string of text
shown on the display.

The "text" animation is often used within a
control SET statement.  For example:

  SET text = "Hello world"

will display the text: Hello world
on the screen.  Client application programs
can call altiaSendText("text", "Hello world")
or AtSendText(id, "text", "Hello world") to
accomplish the same results.

Control or client application code can also
query a "text" animation to determine the
current contents of a text i/o object.  This
is true even if the "character" or "integer"
animations were used to update the object.
For example, a control IF statement like:

  IF text == "Hello world"

will compare the current string content of
the text i/o object with "Hello world".

A client application program queries the
object by calling the library function
AtGetText(id,"text",char *buf,int bufSz)
or altiaGetText("text",char *buf,int bSz).
These routines return the object's currently
displayed text in the caller's character
buffer pointed to by buf whose size is given
by bufSz or bSz.  For more details, see the
manual page for AtGetText in Section II of
the Altia Reference Reference Manual.

To implement the query capability, the "text"
animation handles a new state value of -1 in
a special way.  When it receives a new state
of -1, it automatically generates a new set
of "text" animation state changes.  These
states are the ASCII character codes for the
currently displayed text ending with a state
change of 0 to identify the end of the text.

When a "text" animation name is used in a
control IF statement and the other operand of
the IF statement is double-quoted text or
another "text" animation name, a -1 state for
"text" is automatically generated.  The re-
sulting states are then compared against the
characters of the other operand.

The client application library functions
AtGetText() and altiaGetText() perform in a
similar fashion.  They send a -1 state for
the "text" animation and then listen for the
returning "text" states and capture them in a
character string.

THE TEXT I/O integer ANIMATION:
---------------------------------------------
The state value of an "integer" animation is
interpreted as a number and that number is
displayed in the text object.

A simple control SET statement like:

  SET integer = 582

will update a text i/o object with the text
"582".  Or, a stimulus definition can exe-
cute: integer state: 582 to achieve similar
results.  Finally, a client application pro-
gram can call AtSendEvent(id, "integer", 582)
or altiaSendEvent("integer", 582).

THE TEXT I/O clear ANIMATION:
---------------------------------------------
The state value of a "clear" animation can
be any number.  When the object receives any
"clear" animation event, it clears out the
text being display.

THE TEXT I/O justify_mode ANIMATION:
---------------------------------------------
By default, text or numbers are displayed
left justified.  The following values for
"justify_mode" determine the method of
justification:

 0  Left justified (default).
*1  Right justified.
*2  If text is a number, right justified with
    leading zeroes;  else, left justified.
*3  Center justified.

* For modes 1, 2, or 3 to work, the
  "max_char_count" animation must be set to a
  positive non-zero value.  The value speci-
  fies how many characters are allowed in the
  text.  And for modes 1,2, and 3, it also
  establishes the full width of the text area
  for determining text positioning.  In ad-
  dition, a mode of 1, 2, or 3 automatically
  disables any non-zero "cursor_mode" setting
  ("cursor_mode" is discussed later in this
  help screen).

** ALSO NOTE:  Left and center justifi-
cation is only accurate for fixed width text
fonts such as terminal type fonts or Courier
fonts.  Variable width fonts, like Helvetica
and Times, will shift position as characters
are changed because each character has a
unique width. **

THE TEXT I/O max_char_count ANIMATION:
---------------------------------------------
The "max_char_count" animation, if set to a
value greater than 0, limits the character
length of the text to the given value.  If
a new "character", "text", or "integer" state
would result in a string that is too long,
the output is truncated to the specified
number of characters.

THE TEXT I/O base_mode ANIMATION:
---------------------------------------------
By default, state changes for the "integer"
animation result in the displaying of decimal
number text.  To display numbers in hex, set
the state of "base_mode" to a 1. Or, set it
to 2 to display numbers in octal.  Setting
"base_mode" to any other value will set the
base to decimal.

THE TEXT I/O append_on ANIMATION:
---------------------------------------------
If the state of the "append_on" animation is
set to 1, then the text generated by new
"character", "text" or "integer" values is
always appended to the currently displayed
text.  This mode of operation is quite useful
for displaying text that is a combination of
of several existing values.  For example,
take the following sequence of control
statements:

  SET append_on = 1
  SET integer = hours
  SET text = ":"
  SET integer = minutes
  SET text = ":"
  SET integer = seconds

If the states of "hours", "minutes", and
"seconds" are 10, 26, and 56 respectively,
the displayed text would be "10:26:56".

THE TEXT I/O clip_on ANIMATION:
---------------------------------------------
If a text i/o object is part of a group con-
taining other objects, the text displayed by
the text i/o object can be forced to stay
within the boundaries established by the
other objects in the group.  This is referred
to as clipping and it can be enabled by
setting the state of the "clip_on" animation
to 1.

Clipping is especially useful for creating
text entry areas which are described later.

If the state of "max_char_count" is a value
greater than zero, its behavior takes pre-
cedence over clipping.

THE TEXT I/O scroll and scroll_on ANIMATIONS:
---------------------------------------------
If "scroll_on" is set to 1 and "clip_on" is
set to 1 or "max_char_count" is set to a
value greater than 0, then text will scroll
right to left as new characters are added
that would force the text to exceed its max-
imum length.  It is also possible to directly
scroll the text from left-to-right or right-
to-left by setting the state of "scroll" to
-1 or 1 respectively.

Scrolling is especially useful for creating
text entry areas which are described later.

THE TEXT I/O cursor_mode ANIMATION:
---------------------------------------------
The text i/o object supports a cursor for
creating text entry/edit areas.  For text
output only with no cursor, "cursor_mode" is
set to a state of 0.  The following states
produce more interesting behavior:

 1  A vertical cursor shown in the background
    color for the text i/o object appears at
    the beginning of the currently displayed
    text.
 2  A vertical cursor shown in the background
    color for the text i/o object appears at
    a position within the displayed text
    determined by the current position of the
    system's mouse cursor.
 3  A vertical cursor shown in the background
    color for the object appears at the end
    of the currently displayed text.
 4  The built-in cursor is turned off and a
    new state value of 0 is automatically
    given to the "output_cursor" animation.
 5  The built-in cursor is turned off and a
    new state value is automatically given to
    the "output_cursor" animation.  The value
    is determined by the current position of
    the system's mouse cursor.  The value is
    equivalent to the distance, in pixels,
    between the front of the text and the
    current mouse position.
 6  The built-in cursor is turned off and a
    new state value is automatically given to
    the "output_cursor" animation.  The value
    is equivalent to the distance, in pixels,
    from the front of the text to the end of
    the text.

State values of 1, 2, and 3 are used to cre-
ate a text entry/edit area that has a built-
in cursor.  Stimulus for a left button press
typically executes "cursor_mode" state 2.
Stimulus associated with alphanumeric key
presses executes "character" state changes to
allow inserting of new text in front of the
cursor.  The Backspace key deletes text in
front of the cursor.  And stimulus for the
left and right arrow keys sets the state of
the "scroll" animation to -1 or 1 to move the
cursor.

The 4, 5, and 6 state values automatically
generate events for the "output_cursor" ani-
mation.  A custom cursor object can then be
created that has its own "output_cursor"
animation created using the Animation Editor.
For state 0, it would position itself at the
beginning of the text.  For a maximum state,
say 500, it would position itself 500 pixels
to the right of the 0 state (state 500 would
be initially defined by using a precise move
of 500 points in the X direction).

Example text entry areas that use the built-
in cursor as well as a custom cursor are
found in the textio.dsn models library.

EDITOR MANIPULATION OF A TEXT I/O OBJECT:
---------------------------------------------
A text i/o object is derived from the text
object created using the TEXT tool in the
Graphics Editor.  As a result, you can change
a text output object's font, colors, or pat-
tern just as if it were a normal text object.
You can also manipulate it with move, rotate,
etc., and give it animation beyond its built-
in capabilities.

INITIALIZING THE TEXT OF A TEXT I/O OBJECT:
---------------------------------------------
With the Graphics Editor in edit mode, you
can edit a text output object by simply
double-clicking on the body of the text (not
on any of the selection handles) when the
object is selected.  All tool and command
buttons must be disengaged to insure that
the double-click is recognized as a text edit
request.

When you save a design to a file, the text
currently displayed by a text i/o object is
also saved.  When the design is opened again,
that same text will be shown.

INITIALIZING ANIMATIONS OF A TEXT I/O OBJECT:
---------------------------------------------
The various animations for a text i/o object
are initialized using the Animation Editor.
Select the object so that its animation func-
tion names appear in the Animation Editor's
"Defined STATES and FUNCTIONS:" list.  High-
light the animation name whose state you wish
to change.  The name will appear in the
"Name:" field of the Animation Editor.  In
the "State:" field, enter a new value or use
the up/down arrows to increment or decrement
the current value.

For the "character" and "text" animations, it
is possible to enter an entire text string.
In the "State:" field, enter your string de-
limited by double-quote marks.  For instance,
if you wanted to have "Hello World" as the
default string in your text output object,
you would have the following:

    Name:character   State:"Hello World"
OR
    Name:text   State:"Hello World"

As soon as you press Enter/Return while in
the "State:" field or move the cursor out of
the field, the text in the delimited string
will be sent in sequence to the text i/o
object and you will see it update.

When you save a design to a file, the current
states for the various animations are also
saved and the displayed text is saved as
well.  Next time you read in the design, the
various modes of the object will be the same
as when the design was saved and the dis-
played text will also look the same.

RENAMING ANIMATIONS:
---------------------------------------------
You can rename the animations for a partic-
ular text i/o object using the rename dialog
that appears when you move a copy of the ob-
ject from the Models View to the Graphics
Editor's drawing area.  In this way, you can
have multiple textio objects in a single de-
sign that work independently.

The recommended method of renaming is to add
a unique prefix to all existing names using
the Prepend option in the rename dialog. If
you do not rename animations and you copy or
paste more than one text i/o object into
your design, all of the text i/o objects will
update for the same "character", "text" and
"integer" animation state changes.

Animations for existing objects in the work
area can be renamed by selecting the object,
and then choosing the "Rename Animation" menu
item from the Animation Editor's Edit
pulldown menu.

THE TEXT I/O EXAMPLES in textio.dsn:
---------------------------------------------

- Text/Integer/Character Output
  This is a text i/o object with no frills
  added.  It is best suited for text and/or
  integer output.  It has all of the built-
  in animations described above.  The various
  mode animations ("justify_mode",
  "max_char_count", "base_mode", "clip_on",
  "append_on", "scroll_on", "cursor_mode")
  are set to 0 so this object will display
  left justified text without limits.  Any
  one or more of the mode states may be
  changed to produce varied behavior.

- Text input areas
  Several examples show the use of the text
  i/o object as a component in a text input
  area.  A text input area is created by
  adding mouse and keyboard input stimulus to
  a group containing a text i/o object and a
  shadowed background rectangle.

  A left mouse button press over the area
  turns on a cursor and enables input.  Key-
  strokes generate "character" events that
  update the text area.  Left or right arrow
  key presses move the cursor through the
  displayed text.  Characters can then be
  inserted between existing characters or
  deleted by pressing the Backspace key.

  A left mouse button press outside of the
  text area or a <Return> key press anywhere
  in the design hides the cursor and termi-
  nates input mode.  At the same time, the
  stimulus executes the name "done" with a
  state value of 1.  A designer can write a
  control block WHEN statement like:

     WHEN done == 1

  and it will execute each time text input
  terminates.  An IF statement like:

     IF text == "Hello"

  in the WHEN block can compare the contents
  of the text i/o object with a desired
  result.

  Client application programs can select to
  receive "done" events and call
  AtGetText(id,"text",char *buf,int bufSz)
  or altiaGetText("text",char *buf,int bSz)
  to get the text from the input area.
  For more details, see the manual page for
  AtGetText in Section II of the Altia
  Reference Manual.

  Immediately before the "done" event, the
  text input area also generates a set of
  "text" events - one event for each dis-
  played character and a final event with a
  value of 0 to terminate the set.  Instead
  of receiving the "done" event, Client
  applications can register a callback for
  the "text" events with AtAddTextCallback.
  For more details, see the manual page for
  AtAddTextCallback in Section II of the
  Altia Reference Manual.

  Note that the input areas accept any length
  of input.  When the end of the area is
  reached, the text begins to scroll.  This
  behavior results because the states for the
  the "clip_on" and "scroll_on" animations
  are set to 1.

  The text input area examples are of var-
  ious sizes and fonts.  The background and
  shadow colors can be changed by selecting a
  new BACKGROUND color for the group object.
  To change the font, select a new font from
  the Fonts Palette. The color of the text is
  changed by choosing a new FOREGROUND color.
  To make the area longer or shorter, focus
  into the group, select the background rec-
  tangle, and stretch its right side with
  the editor's stretch tool.  Make the back-
  ground taller or shorter by stretching its
  top or bottom edge.  You must also focus in
  to change the cursor's color.  Select the
  text and choose a new BACKGROUND color for
  it.

- Custom Cursor Input Area
  This example behaves like the text input
  areas just described but uses a custom cur-
  sor instead of the built-in cursor.

- Number-only input area
  This example is like the text input areas
  described above, but it only accepts number
  or minus sign (-) key presses.  When a
  control block or client application program
  detects a "done" == 1 event, it can
  immediately check the state of the object's
  "integer" animation to get the number from
  the input area.  Here is an example control
  block:

     WHEN done == 1
       IF integer >= 100
       ...
     END

  It is also possible to check the input as
  a text string using the "text" name as
  shown above for the text input areas.

- Digital clock example
  This text i/o object has control and timer
  stimulus to simulate a digital clock.  It
  easily demonstrates how control can manage
  the dynamic display of text.  The buttons
  provide a way to generate events to start,
  stop, and reset the clock.

  To view the control for this text i/o ob-
  ject, copy it to the Graphics Editor's
  drawing area from a Models View.  With it
  selected, press the Control button at the
  top of the editor to open the Control
  Editor.  To view the object's timer stim-
  ulus, press the Stimulate button to open
  the Stimulus Editor.

USING TEXT I/O OBJECTS FOR TEXT STORAGE:
---------------------------------------------
It is often useful to get text input from the
user and store it so it can be compared with
new input at a later time.  A text i/o object
that acts as a temporary storage area is
useful for this.

As an example, a design might have a text in-
put area with a "text" animation renamed to
"input_text".  To save the previous input
text for the area, one could copy the simple
Text/Integer/Character Output example from
textio.dsn into the design and place in an
area of the design that is not normally
visible.  Or, place it and use the Hide
tool to hide it.  If a prefix of "save" is
added to the animation names using the rename
dialog, then this object's "text" animation
would have the name "save_text". A control
block like the following could be written to
compare and copy text between the objects:

  WHEN input_done == 1
    IF input_text != save_text
      SET save_text = input_text
    END
    ELSE
      SET err_text = "Error! Try again..."
    END
  END

where "err_text" is the "text" animation for
a third text i/o object which is used for
displaying error or status messages.

THE TEXT I/O OBJECT INDIRECTION FEATURE:
---------------------------------------------
In control block statements, the contents
of a text i/o object can be used as a name to
reference the name's current state value.
This is known as an indirect reference.  It
is used when it is inconvenient to reference
an animation name directly during the cre-
ation of a control block.

As an example, a design might have a set of
text i/o objects that form a list of 20 items
and the animations for the objects have pre-
fixes "item1" through "item20" so each item
can be accessed uniquely.  Assume that a push
button in the design has stimulus that incre-
ments the state of "next_item" by 1 on each
press.  The value of "next_item" identifies
the currently selected text i/o item in the
list.  Then assume that a second button has
stimulus that sets the state of "clear_item"
to 1.  The desired functionality is to press
the next item button until "next_item" is a
desired value between 1 and 20 and then press
the clear item button to clear the text at
the current item.

To do this easily in control, one would just
add a text i/o object to the design to serve
as temporary text storage.  If this object
has a prefix of "temp", then a WHEN control
block like the following could be used to
clear the selected item:

  WHEN clear_item == 1
    SET temp_clear = 1
    SET temp_append_on = 1
    SET temp_text = "item"
    SET temp_integer = next_item
    SET temp_text = "_clear"
    SET @temp_text = 1
  END

This control block writes a text string of
the form "item#_clear" into the temporary
text i/o object where # is the current value
for "next_item".  The "append_on" animation
for the temporary text i/o object is set to 1
to allow text and integer values to be com-
bined into one string.

Note that the last SET statement uses an @
symbol in front of "temp_text".  This means
that the text held by the temporary text i/o
object should be used as an animation name
and the state for that name should be set to
1.  If "next_item" has a state value of 5,
then the text in the temporary text i/o ob-
ject would become "item5_clear".  This would
set the "clear" animation to 1 for the text
i/o item that has "item5" as a prefix.

The @ symbol only works in front of text i/o
"text" animation names.  Use of the @ symbol
in front of other names will cause errors.

screen 11
LINE PLOT MODELS:

The stripcharts.dsn library contains a strip
chart that is configurable from its proper-
ties and supports up to 8 simultaneous
signals via its input connections.

The file

\usr\altia\models\more\plot.dsn

contains several different line and polygon
drawing objects.  These objects have built-in
animations to facilitate the plotting and
charting of data for doing dynamic line or
polygon drawing.  There is the line plot ob-
ject, the fill plot object, the strip chart
object, and dynamic multi-line, polygon, and
filled polygon objects.

PLOT AND STRIP CHART OBJECTS OVERVIEW:
---------------------------------------------
Plot and strip chart objects have explicit
widths and heights and they only draw within
their defined areas. They are optimized for
plotting and charting within a defined area.

In the plot.dsn model, line plot and strip
chart objects appear in rows of different
sizes.  The first two objects in each row
are line plot objects.  The next is a fill
plot and the last is a strip chart. The width
or height of a plot or strip chart object can
be changed after it is copied to the drawing
area of the Graphics Editor by setting values
for the "setwidth" or "setheight" animations.
The rows of different object sizes are
provided simply as a convenience.

DYNAMIC MULTI-LINE, POLYGON, AND FILLED
POLYGON OBJECTS OVERVIEW:
---------------------------------------------
Dynamic multi-line, polygon and filled
polygon objects automatically change their
widths and heights to accommodate the data
points which they are given.  They are well
suited to situations where data points may
cover a variable size area.  If the area is
small, the object remains small and its
effect on the graphics updating of other
objects in the design is minimal.  As data
points are added, the object's effective
area may grow, but only large enough to
accommodate the new data points and thereby
minimize its effect on other objects.

There are only single copies of the dynamic
multi-line, polygon, and filled polygon
objects in plot.dsn because they have no
specific width or height settings.

LINE AND FILL PLOT DETAILS:
---------------------------------------------
The line and fill plot objects have the
following built-in animations:

 nextx     - takes the associated state value
             and stores it as the x coord-
             inate for the next point on
             the plot.
 nexty     - takes the associated state value
             and stores it as the y coord-
             inate for the next point on
             the plot.
 draw      - draws a multi-segment line
             sequentially connecting all of
             the points currently stored for
             the plot.
 clear     - clears all of the points
             currently stored for the plot.
 rewind    - rewinds to a point in the cur-
             rent point list as determined by
             the associated state value (e.g.
             rewind(5) rewinds to point 5 in
             the current point list).  New
             x,y pairs will overwrite current
             x,y pairs starting at the rewind
             point.
 setwidth  - this sets the max width of the
             plot object in number of
             pixels.
 setheight - this sets the max height of
             the plot object in number of
             pixels.

After copying a line or fill plot object to
the drawing area of the Graphics Editor, you
can change its width, height, or clear the
current data by selecting "setwidth",
"setheight", or "clear" from within the
Animation Editor and changing the animation's
value.  The state of the "clear" animation
simply needs to be toggled to do a clear.

A line plot object is derived from the
multi-line object that can be created using
the Graphics Editor.  As a result, you can
change a line plot object's color or brush
just as if it were a normal multi-line
object.  You can also manipulate it with
move, rotate, etc., and give it animation
beyond its built-in capabilities.

A fill plot object is derived from the fill
polygon object.  It creates a plot with
an area filled by a color/pattern combination
like the filled polygons created using the
graphics editor.  If the first point sent via
the nextx and nexty animations matches the
last point prior to a draw, a closed polygon
will be drawn.  If not, the object will fill
the area between the plot line and the bottom
of the plot area (i.e., the horizontal axis
at y=0) to create a closed polygon.

The first column of line plots in plot.dsn
have a shadowed background grouped with each
line plot.  The colors of the background
and shadows are changed by selecting a new
background color from the Color Palette.  The
attributes of the line plot object itself
are changed by focusing into the group,
selecting the plot object, and then making an
attribute change (e.g., new line style, new
foreground color).

STRIP CHART DETAILS:
---------------------------------------------
The strip chart object differs from the line
plot object by only adding points on one end
or the other and sliding the other points
over to make room.  It does not have a nextx
animation since points are always added on at
the end.  It has the following built-in
animations:

 nexty     - takes the associated state value
             and stores it as the y coord-
             inate for the next point on
             the plot.
 clear     - this clears all the points
             and draws an empty chart.  The
             value sent does not matter.
 draw      - this draws the points that
             have been sent to date.
 setwidth  - this sets the max width of the
             plot object in number of pixels.
 setheight - this sets the max height of the
             plot object in number of pixels.
 setxinc   - this sets the number of pixels
             to skip in the x direction
             before drawing the next point.
 setright  - this sets the strip chart's
             direction. If the value is non-
             zero, existing points move
             to the right as new points are
             added on the left. If the value
             is zero, old points move to the
             left as new points are added on
             the right (this is the default).

After copying a strip chart to the drawing
area of the Graphics Editor, you can change
its width, height, or clear the current data
by selecting "setwidth", "setheight", or
"clear" from within the Animation Editor and
changing the animation's value.  The state
of the "clear" animation simply needs to be
toggled to do a clear.

DYNAMIC MULTI-LINE & POLYGON OBJECT DETAILS:
---------------------------------------------
The dynamic multi-line, polygon, and filled
polygon objects behave similarly to the line
plot object accept that they have no
"setwidth" or "setheight" animations - their
widths and heights adjust based on the data
points they receive.  When the state of the
"clear" animation is set, it clears all
data points and sets an object's size to
15x15 pixels with the lower left corner of
the object representing the "origin".  All
x or y values represent pixel distances from
this origin. Negative x or y values are used
for specifying data points to the left or
below the origin.  All dynamic multi-line,
polygon, and filled polygon objects have the
following built-in animations:

 nextx     - takes the associated state value
             and stores it as the x coord-
             inate for the next point on
             the multi-line or polygon.
 nexty     - takes the associated state value
             and stores it as the y coord-
             inate for the next point on
             the multi-line or polygon.
 draw      - this draws the object using the
             points that have been sent
             since the last clear.
 clear     - this clears all the points
             and draws an empty object.  The
             value sent does not matter.
 rewind    - rewinds to a point in the cur-
             rent point list as determined by
             the associated state value (e.g.
             rewind(5) rewinds to point 5 in
             the current point list).  New
             x,y pairs will overwrite current
             x,y pairs starting at the rewind
             point.

After copying a multi-line or polygon object
to the drawing area of the Graphics Editor,
you can clear the current data by selecting
the "clear" animation from within the
Animation Editor and changing the animation's
value.  The state of the "clear" animation
simply needs to be toggled to do a clear.

A dynamic multi-line object is derived from
the multi-line object that can be created
using the Graphics Editor.  As a result, you
can change its color or brush just as if it
were a normal multi-line object.  You can
also manipulate it with move, rotate, etc.,
and give it animation beyond its built-in
capabilities.

A dynamic polygon or filled polygon object is
derived from the polygon object that can be
created using the Graphics Editor.  Brush
style, fill color, and fill pattern can be
changed using the appropriate Graphics Editor
palette.  A fill pattern can be given to the
unfilled version of the dynamic polygon to
create a "transparent" fill pattern (give it
a try to see how it works).

A LINE PLOT OBJECT DEMONSTRATION:
---------------------------------------------
The stress analyzer design

\usr\altia\demos\stress\stress.dsn

provides an example of how the line plot can
be used.  The associated client application
program, stress.c, demonstrates how the anim-
ations for a line plot object are utilized by
a program.

A DYNAMIC POLYGON OBJECT DEMONSTRATION:
---------------------------------------------
The map demonstration found in the directory

\usr\altia\demos\map

provides an example of how dynamic polygon
objects can be used.  The associated client
application program, map.c, demonstrates how
the animations for this type of object are
utilized by a program.

screen 12
GRAPHICS EDITOR ORGANIZATION:

Altia's Graphics Editor consists of the
following components:

- Editor menu bar, which contains seven pull-
  down menus:

  File - contains menu items for opening,
    saving, and importing design files,
    importing various types of image files,
    and for exporting design list files.
  Edit - menu items are provided for multi-
    level undo/redo, finding an object, set-
    ting an object's properties if any exist,
    adjusting an image's transparent colors,
    and for precisely moving/scaling/rotating
    formally selected objects.  In addition,
    a menu item to clear a selected group's
    color/pattern/brush/font attributes
    (which override each sub-object's
    individual attributes) is available.
  Arrange - menu items support shuffling
    formally selected objects to the front/
    back of all objects or forward one/back-
    ward one.  "Snapping" objects to the grid
    (their lower left corner) is also provid-
    ed, as well as aligning and distributing
    them relative to each other.
  Grid - items are included for hiding/show-
    ing the grid points, "snapping" to the
    grid when manipulating objects, and for
    setting the spacing between grid points.
  Options - contains menu items for showing/
    hiding objects that are not in the cur-
    rent "focus group" (see GROUPS AND FOCUS-
    ING: below), for controlling the object
    selection methodology (see FORMAL AND IN-
    FORMAL SELECTION: below), and for choos-
    ing how scaling or stretching affects
    text objects.
  Connections - contains menu items for open-
    ing a Connections dialog for the currently
    selected objects or external (e.g., client
    application program) signals.  If an
    object has input or output connections de-
    fined, they appear in the list area of the
    Connections dialog.  If an input or output
    is attached to another object's output or
    input or an external output or input, this
    is shown in the Connections dialog.  From
    the Connections dialog, inputs and outputs
    can be linked, added, or modified.
  Client - items for starting and disconnect-
    ing client application programs are
    provided, as well as for deleting all
    programmatically duplicated objects (see
    the Altia Reference manual or the ALTIA
    CLONE MANIPULATION FUNCTIONS/PROCEDURES
    DECLARATIONS in the altia.h header file).
  Help - accesses this Help dialog.

- Application buttons, which open various
  Altia application windows:

  Animate - opens the Altia Animation Editor
    for interactively defining output anima-
    tion (animation sequences) for objects.
  Stimulate - opens the Altia Stimulus Editor
    for interactively defining input stimulus
    for objects.
  Control - opens the Altia Control Editor
    for defining how individual objects
    interact with one another.
  Models - accesses libraries of previously
    designed and animated components.
  Rec/Play - opens the Player/Recorder for
    record/playback of Altia sessions.

- Palettes for choosing object attributes
  such as colors, patterns, brushes, and
  fonts.

- Edit/Run buttons, which affect the inter-
  active Altia Design environment.  In Edit
  mode, the various Editors are used to
  create and assign behavior to the design.
  In Run mode, the design and its animations
  can be run and tested immediately.

- Tool-Command Panel, which contains all the
  drawing tools and commands needed to create
  the design.

- Main Altia View, the initial view into the
  work area.  It has its own pull-down menus:

  View - contains items for creating a new,
    independent view into the work area, and
    for printing, renaming, refreshing,
    centering (on the selected object(s) or,
    if nothing is selected, the entire work
    area), swapping, and closing this view
    (these last two are not available for the
    main view, only "New"ed views).
  Attributes - contains menu items for hid-
    ing/showing the panner (in the lower left
    corner of the view) and for turning view
    status on/off (ie object creation/manip-
    ulation status).

THE MOUSE BUTTONS (MB):
---------------------------------------------
Three-button mouse      Two-button mouse
                           -- MB2 --
                           |       |
+-----------------+    +---------------+
| MB1 | MB2 | MB3 |    |  MB1  |  MB3  |
+-----------------+    +---------------+

      MB1 (left) is tool dependent;
      it is used to draw, select,
      and manipulate objects.

      MB2 (middle or, for a two-
      button mouse, both buttons)
      is used to cancel a tool
      selection while in the work
      area, end text entry, or end
      a multi-line or spline.

      MB3 (right) is used to select
      objects in the work area.
      Considered the preferred but-
      ton for selecting, it is not
      used for other operations.

** All selecting actions can be done with MB1
when no other tool/command is chosen, or with
MB3 at any time **

PALETTES:
---------------------------------------------
There are four palettes available for select-
ing various drawing attributes:

- Colors
- Patterns
- Brushes
- Fonts

All palettes are easily customized.  For ex-
ample, the number of colors/patterns/brushes/
fonts, as well as each, individual color/
pattern/brush/font, is user definable from
the app-defaults file.

Each palette uses the current foreground/
background color combination to display the
choices available.  For instance, the Pattern
Palette will display its patterns using the
colors in the Fg/Bg fields of the Color Pal-
ette (the Font Palette uses the chosen colors
AND chosen pattern for displaying its fonts).

Whenever an object is drawn, that object will
take on the attributes currently selected in
the palettes.  Likewise, changing an attri-
bute while an object is formally selected
will change the object's attribute.

To change the Foreground/Background color:

1. Using MB1, toggle the Palettes button to
   return to the Color Palette.
2. Press MB1 down on a colored square in the
   palette and, while still holding the but-
   ton down, drag the cursor up over the
   square labeled Fg/Bg and "drop" the color
   (release the mouse button).

In addition to the Fg field changing to blue,
a rectangle around the color in the palette
indicates the new foreground color (an octa-
gon is used for the background color).

** You can also "drag and drop" the Fg into
the Bg field, or vice-versa.  Similarly, if a
selected object's color is different from
that in the field, "clicking" on the field is
sufficient to change the object's color **

Color "Quick Pick"

Besides the "drag and drop" method of chang-
ing colors, you can also use the "quick pick"
method.  Clicking MB1 on a color in the pal-
ette selects that color as the new foreground
color.  Using MB3 in a similar manner selects
a new background color.

To change the Pattern/Brush/Font:

1. Using MB1, toggle the Palettes button to
   return to the appropriate palette.
2. Press MB1 down on the desired pattern/
   brush/font.

** Note the scroll bar along the right side
of the Font Palette.  Dragging the bar up/
down with MB1 reveals the other fonts that
are available **

CREATING LINES, RECTANGLES, ELLIPSES:
---------------------------------------------
Lines, rectangles, and ellipses are created
in the following manner:

1. Using MB1, select the appropriate tool in
   the Tool-Command Panel by pressing the
   appropriate button.
2. Position the cursor anywhere in the work
   area.  If status for the view is turned on
   (see Altia View's Attributes menu item
   "Turn Status On/Off"), the cursor's loca-
   tion will be displayed in the right corner
   of the view's menu bar in coordinates
   corresponding to the current grid selec-
   tion (see Graphics Editor's Grid menu item
   "Grid Spacing...").
3. Press MB1 and, while holding the mouse
   button down, create the object by dragging
   the mouse away from the initial point.
   When dragging, an outline, or rubberband,
   will appear showing the size and position
   the object will have if the button is re-
   leased.  If status for the view is turned
   on, object size information is displayed
   along the top of the view.  Release the
   mouse button when the object is the cor-
   rect size/shape.

** Pressing the keyboard's CTRL key at any
time while creating an object immediately
constrains the tool - lines are "snapped" to
the horizontal/vertical/diagonal, rectangles
are snapped to squares, and ellipses are
snapped to circles.  In addition, the tools
can be constantly constrained by selecting
"+ Switch Mode On +" **

** Selecting "+ Keep Tool On +" keeps the
chosen tool/command active.  If not selected,
the tool/command turns off after each use **

CREATING SPLINES, MULTI-LINES, POLYGONS:
---------------------------------------------
Splines and multi-lines (including closed
splines and polygons:  see the ** note **
below) are created in the following manner:

1. Using MB1, select the appropriate tool in
   the Tool-Command Panel by pressing the
   appropriate button.
2. Position the cursor anywhere in the work
   area.  As with lines/rectangles/ellipses,
   the cursor's location will be reported in
   the view's menu bar if view status is on.
3. Click (press and release) MB1 and move the
   mouse to where the next anchor point is to
   be, then click again.  If status for the
   view is turned on, information about the
   latest line segment is displayed along the
   top of the view.
4. Repeat step 3 for all anchor points except
   the last - then continue to step 5.
5. Click MB2 (middle) or MB3 (right) at the
   last anchor point to end the spline/multi-
   line.

** Pressing the keyboard's CTRL key at any
time while creating an object immediately
constrains the tool - the latest line segment
is "snapped" to the horizontal/vertical/diag-
onal.  In addition, selecting "+ Switch Mode
On +" transforms the spline tool into a
closed spline tool and the multi-line tool
into a polygon tool **

CREATING/EDITING TEXT:
---------------------------------------------
Text is created in the following manner:

1. Using MB1, select the Text tool in the
   Tool-Command Panel by pressing the
   appropriate button.
2. Position the cursor anywhere in the work
   area.  As with lines/rectangles/ellipses,
   the cursor's location will be reported in
   the view's menu bar if view status is on.
3. Click (press and release) MB1 where the
   lower left corner of the text string is
   to be.
4. Type in the text.
5. Press MB2 down (or carriage return) to end
   the text string.

** Both "+ Switch Mode On +" and the use of
the SHIFT key capitalize all text **

To edit existing text:

1. Make sure no tool/command is selected in
   the Tool-Command Panel.
2. Double click (quickly press/release twice)
   MB1 down on the text object to be edited.
   This highlights the text and places a text
   cursor at the end of the text string.
3. Type in additional characters or, using
   the backspace key, erase existing ones.
4. Press MB2 down (or carriage return) to end
   the text editing.

SELECTING OBJECTS:
---------------------------------------------
When no tool/command is chosen in the Tool-
Command Panel, use MB1 or MB3 to select an
object by pressing the mouse button down
while the cursor is over the object.  When
another tool/command is chosen, use MB3.

** Use of MB3 is highly recommended since
the current tool selection is irrelevant **

Selecting Multiple Objects (two methods):

Method 1:  After selecting the first object,
hold down the SHIFT key and use MB3 (or MB1
if no tool is selected) to select additional
objects.

Method 2:  "Drag" a selection box around
multiple objects by pressing MB3 (or MB1 if
no tool is selected) and, while holding the
button down, enclosing the object(s) to be
selected within the rubberband.

** When using the SHIFT key with either of
these methods, the set of additional objects
selected is XORed with the previous set of
selected objects.  This is much more powerful
than a simple OR of the two sets because in-
dividual objects can easily be unselected by
SHIFT selecting them again **

FORMAL AND INFORMAL SELECTION:
---------------------------------------------
Altia Design supports two selection method-
ologies:  Formal and Informal (see Graphics
Editor's Options menu item "Make Formal
Selection Required/Optional").  If formal
selection is optional, Altia's Graphics
Editor allows one to:

1) manipulate (move, scale, rotate, stretch,
   show, hide, cut, paste) an object WITHOUT
   formally selecting it (simply "hitting" it
   will do).  This permits manipulating an
   object while keeping another one selected,
   as well as keeping the "handles" (which
   denote selected objects) out of the way
   for precise editing.
                   AND...
2) manipulate objects WITHOUT "hitting" them.
   By simply pressing MB1 in an open, un-
   occupied region of the work area, the cur-
   rent manipulation tool will be applied to
   all formally selected objects.

If Formal Selection is required, Altia's
Graphics Editor disallows the above features,
requiring an object to be formally selected
AND "hit" before any operation can be
performed.

MANIPULATING OBJECTS WITH A COMMAND:
(Move, Scale, Rotate, Stretch, Show, Hide,
Cut, Paste)
---------------------------------------------
If formal selection is optional, pressing MB1
down on an object will activate the chosen
command for that object (including Cut/
Paste!).  If appropriate, a rubberband will
appear showing the size/location of the ob-
ject once the mouse button is released.  In
addition, pressing MB1 down in an open region
of the work area will activate the command
for ALL selected objects (exception:  Paste
will paste whatever is in the cut/copy/paste
buffer, NOT the selected object(s)).

If formal selection is required, pressing MB1
down on an object will only activate the
tool if the object is formally selected (has
handles).  In this case, ALL selected objects
will be affected by the manipulation.  If
appropriate, a rubberband will appear showing
the size/location of the object once the
mouse button is released.  Pressing MB1 down
in an open region of the work area has no
effect (exception:  Paste will paste whatever
is in the cut/copy/paste buffer).

** By default, rotation is done about the
center of an object.  To rotate about another
point, position the cursor over that point in
the work area and hold the keyboard's CTRL
key down prior to the MB1 press.  Pressing
the CTRL key during a move or paste will
constrain the move/paste to be in a horiz-
ontal/vertical direction only **

** Selecting "+ Keep Tool On +" keeps the
chosen tool/command active.  If not selected,
the tool/command turns off after each use **

MANIPULATING OBJECTS WITH ACTIVE HANDLES:
(Move, Scale, Rotate, Stretch)
---------------------------------------------
Altia Design supports "active handles" on
selected objects.  Thus, when no tool/command
is selected in the Tool-Command Panel, an
object can easily be moved/scaled/rotated/
stretched by pressing MB1 down on the appro-
priate handle (or, in the case of move, the
object itself), then dragging the mouse:

  7 6 5  The corner handles (1/3/5/7) scale/
  8   4  rotate the object, while the middle
  1 2 3  handles (2/4/6/8) stretch it.

(To use the corner handles to rotate, "double
click" on any one of them)

GROUPS AND FOCUSING:
---------------------------------------------
Groups are objects that contain one or more
other objects (which may be groups them-
selves).  Once grouped, a group of objects
can be treated as one.  To create a group,
press "Group" in the Tool-Command Panel while
all objects that are to be in the group are
formally selected.  To ungroup all selected
groups, press "Ungroup".

Focus is a powerful and unique feature that
permits "entering" a group to modify an
individual object's appearance or behavior
without "Ungrouping," which destroys the
attributes and assigned behavior of the group
itself.  New objects can even be created in-
side the group, or existing objects deleted.

To focus in on a group, press the "FocusIn"
button when one group is selected.  If "Hide
Out-Of-Focus Objects" from the Graphics Ed-
itor's Options menu is in effect, objects not
in the current focus group will temporarily
disappear.  When "FocusOut" is pressed, the
objects at that focus level will reappear.
Regardless, out-of-focus objects CANNOT be
manipulated, or even selected, with the
Graphics Editor.

** The FocusIn button is only enabled if one
and only one group is formally selected.
Similarly, the FocusOut button is only
enabled if not at Focus Level 0 **

The Focus Level indicator at the bottom shows
how deep (how many groups) in the object hi-
erarchy the current level is.  This indicator
becomes important when groups are created
within groups.

screen 13
HELP FOR OTHER MODELS:

Most model libraries found in the "models"
directory require no additional help.  Their
properties and connections should be self-
explanatory.

Some model libraries found in the "more"
sub-directory of the "models" directory
lack on-line help.  As a standard, all
such libraries have a documentation file
associated with them that can be viewed
using any available text editor utility.

For example, the models library "aero.dsn"
has an associated documentation file:

aero.txt

which can be viewed in a Notepad session,
DOS/Command Prompt window editor, etc.

Here is a short summary of the contents of
the "more" models libraries:

aero.dsn      contains models typically used
--------      in the aeronautical industry,
              such as altimeters, artificial
              horizons, turn coordinators,
              compasses, and switches.

clip.dsn      contains an instance of a clip
--------      object.  A clip object is a
              group object which shows its
              contents (i.e., other objects)
              "clipped", or trimmed, to the
              clip object's extent, like the
              viewfinder of a camera.  The
              view displayed by the clip ob-
              ject can be "panned" around its
              contents like a movie camera.
              THIS LIBRARY HAS ON-LINE HELP
              from the Models View Help menu.

computer.dsn  contains polygon symbols/icons
------------  for computers, displays, key-
              boards, etc.

deck.dsn      contains an instance of a deck
--------      object.  A deck object is a
              group object which permits
              stacking inserted objects on
              top of one another, like a deck
              of cards.  Any card can be
              "flipped" to the top, making it
              visible and hiding all others.
              THIS LIBRARY HAS ON-LINE HELP
              from the Models View Help menu.

gui.dsn       contains Motif look and feel
-------       graphical user interface (GUI)
              components - only on UNIX.

guiwin.dsn    contains Windows look and feel
----------    graphical user interface (GUI)
              components.

instrmnt.dsn  contains components that mimic
------------  real-world devices often found
              on physical instrument front
              panels, such as switches,
              knobs, and gauges.

lcd.dsn       contains an instance of the
-------       monochrome Liquid Crystal
              Display, or LCD, object.  THIS
              LIBRARY HAS ON-LINE HELP from
              the Models View Help menu.

lcdcolor.dsn  contains an instance of the
------------  color Liquid Crystal Display,
              or LCD, object.  THIS LIBRARY
              HAS ON-LINE HELP from the
              Models View Help menu.

menus.dsn     contains pulldown/popup menu
---------     objects for creating Motif look
              and feel menus - only on UNIX.

menuswin.dsn  contains pulldown/popup menu
------------  objects for creating Windows
              look and feel menus.

pie.dsn       contains instances of the pie
-------       chart object.  THIS LIBRARY
              HAS ON-LINE HELP from the
              Models View Help menu.

plot.dsn      contains instances of line
--------      plots, filled plots, and strip
              charts which can dynamically
              plot data.  Data is typically
              provided by an application
              program.  THIS LIBRARY HAS
              ON-LINE HELP from the Models
              View Help menu.

sound.dsn     contains instances of the sound
---------     object configured to play sound
              files installed in the Altia
              sound directory.  THIS LIBRARY
              HAS ON-LINE HELP from the
              Models View Help menu.

textio.dsn    contains instances of the text
----------    i/o object. Text i/o objects
              are variants of standard text
              objects; however, the text they
              display can be updated by con-
              trol, a client program or stim-
              ulus. Text i/o objects can also
              accept keyboard input when con-
              figured as text input areas.
              The resulting input text is
              available to control or an ap-
              plication program for pro-
              cessing.  THIS LIBRARY HAS ON-
              LINE HELP from the Models View
              Help menu.

timer.dsn     contains various models demon-
---------     strating timer stimulus func-
              tionality.  General timer stim-
              ulus help is available from the
              Stimulus Editor's Help menu.

screen 14
LCD PLOT MODELS:

The models files

\usr\altia\models\more\lcd.dsn and
\usr\altia\models\more\lcdcolor.dsn

contain LCD panel objects.  These objects
have built-in animations to simulate LCD
display devices (monochrome and color,
respectively).

The LCD panel's animations provide low
level control similar to a real LCD device.
For this reason, a C client application pro-
gram is usually necessary for "driving" the
panel.  This makes the object most useful for
prototyping LCD driver code.  Other higher
level functionality can also be prototyped,
but some amount of driver code is usually
necessary for interfacing with the panel.

The color LCD panel object is more flexible
than the monochrome version, but it is slower
at querying pixels.  If you need to use the
query capability (see below for a detailed
description) and a single color LCD is
sufficient, the monochrome LCD panel object
may be the better choice.

LCD OBJECT OVERVIEW:
---------------------------------------------
The LCD object has functions for setting and
querying individual rectangle elements that
represent pixels on a LCD display.  The
width and height for the pixel elements and
inter-pixel spacing can be set to create
different aspect ratios.  The width and/or
height (in number of pixel elements) of the
entire object can be set as well.  If a pixel
is on, a rectangle of the chosen pixel width
and height will be drawn.  If a pixel is off,
nothing is drawn.

LCD OBJECT DETAILS:
---------------------------------------------
The LCD object has the following built-in
animations (note that all animations are
applicable to both the monochrome and color
LCD objects unless otherwise indicated):

 setpen    - sets the current color pen to
 (COLOR      the associated state value.  A
  VERSION)   pen is normally set to initial-
             ize its color using setcolor.
             Or, if a data size greater than
             1 is chosen, setpen is used to
             set the pen for future data (see
             datasize and data below for more
             details).  Pen number 0 is res-
             erved as the "off" or trans-
             parent pen.  Pen numbers 1 to
             254 are available for setting to
             any colors.  Pen number 255 is
             initially set to the object's
             selected foreground color, but
             can be changed if necessary.
             All pens other than 0 and 255
             have no initial color settings
             and must be explicitly set with
             setpen/setcolor events.
 setpen    - when the LCD's drawing mode is
 (MONOCHROME greater than 0 (0 is the default
  VERSION)   mode - see the setmode descrip-
             tion for more information),
             setpen is used to switch between
             drawing transparent shapes (when
             setpen is set to 0) or drawing
             shapes in the object's chosen
             foreground color (when setpen
             is set to a value greater than
             0).
 setcolor  - takes a string of character
 (COLOR      values and sets the currently
  ONLY)      selected pen to the color ident-
             ified by the string.  The string
             should contain an R G B triplet
             where each item in the triplet
             is a number from 0 to 255.  For
             example, the following control
             statements set pens 1, 2, and 3
             to red, green, and blue,
             respectively:

               SET setpen = 1
               SET setcolor = "255 0 0"
               SET setpen = 2
               SET setcolor = "0 255 0"
               SET setpen = 3
               SET setcolor = "0 0 255"

             The following calls in a client
             application program would set
             pen 1 to red:

               AtSendEvent(id, "setpen", 1);
               AtSendText(id, "setcolor",
                          "255 0 0");
 setmode   - the value for setmode determines
             how nextx and nexty values are
             interpreted.  The LCD object
             initializes with a mode of 0.
             In this mode, nextx and nexty
             pairs set the starting location
             for future data and query opera-
             tions.  If setmode is given a
             value of 1, the LCD object goes
             into a rectangle drawing mode.
             In this mode, every 2 pairs of
             nextx and nexty values are in-
             terpreted as coordinates for the
             opposite corners of a rectangu-
             lar area.  One or more of these
             areas are then drawn in the cur-
             rent pen color (or cleared if
             the current pen is 0).  For
             more complete details and an
             example, see the descriptions
             for nextx and nexty.

 nextx     - when the LCD's drawing mode is
             0 (which is the default mode -
             see the setmode description
             for more information), nextx
             takes the associated state value
             and stores it as the x offset
             for the next data or query
             operation. Zero is the left side
             of the LCD.  The value should be
             the number of datasize pixels to
             move in from the left side of
             the LCD.  For example, if
             datasize is 8, and 4 is sent to
             nextx, then the next query or
             data operation will affect pixel
             32 from the left.  Once both
             nextx and nexty are sent the
             address index is updated to that
             location.

             When the LCD's drawing mode is
             set to 1 (i.e., setmode's value
             is 1), the LCD object is in a
             rectangle drawing mode.  In this
             case, nextx represents the x
             offset (where 0 is the left side
             of the LCD) for a corner of a
             rectangle to be drawn in the
             current pen color (or transpar-
             ent if the current pen is 0). To
             complete the rectangle, a nexty
             value must follow (or come be-
             fore) the nextx and then a sec-
             ond pair of nextx and nexty val-
             ues must be given to define the
             opposite corner of the rec-
             tangle.  With 2 sets of nextx
             and nexty values specified, the
             LCD object fills (or clears)
             pixels of the LCD for the given
             rectangle.  Additional double
             sets of nextx and nexty values
             can follow to fill or clear one
             or more additional rectangles.
             All of the rectangles will be
             drawn to the screen when a draw
             event occurs.  As an example,
             the following client application
             code would draw a transparent
             rectangle with the upper left
             corner at 5,10 (where 0,0 is the
             top left corner of the LCD
             object) and lower right corner
             at 20,25 and also draw a rec-
             tangle in the color for pen 1
             with corners at 10,15 and 15,20:

               AtSendEvent(id, "setmode",
                           1);
               AtSendEvent(id, "setpen", 0);
               AtSendEvent(id, "nextx", 5);
               AtSendEvent(id, "nexty", 10);
               AtSendEvent(id, "nextx", 20);
               AtSendEvent(id, "nexty", 25);
               AtSendEvent(id, "setpen", 1);
               AtSendEvent(id, "nextx", 10);
               AtSendEvent(id, "nexty", 15);
               AtSendEvent(id, "nextx", 15);
               AtSendEvent(id, "nexty", 20);
               AtSendEvent(id, "draw", 1);

             Note:  In rectangle drawing
             mode, the current datasize value
             has no affect on how rectangles
             are drawn and any new data
             operations are ignored.
 nexty     - when the LCD's drawing mode is
             0 (which is the default mode -
             see the setmode description
             for more information), nexty
             takes the associated state value
             and stores it as the y coord-
             inate for the next data or query
             operation. Zero is the top side
             of the LCD. Once both nextx and
             nexty are sent, the address
             index is updated to that loca-
             tion. The value should be the
             number of rows from the top you
             want to be at starting from
             zero.

             When the LCD's drawing mode is
             set to 1 (i.e., setmode's value
             is 1), the LCD object is in a
             rectangle drawing mode.  In this
             case, nexty represents the y
             offset (where 0 is the top of
             the LCD object) for a corner of
             a rectangle to be drawn in the
             current pen color.  For a com-
             plete description and example,
             see the second paragraph of the
             above nextx description.
 datasize  - this sets the number of bits to
             use in data or query operations.
             This should have a value in the
             range 1 to 16 (COLOR ONLY:  if
             the value is 1, then values of
             future data events are assumed
             to be actual pen numbers from
             0 to 255.  If datasize is given
             a value in the range 2 to 16,
             then data is assumed to be a
             datasize bit mask.  An on (1)
             bit indicates that the assoc-
             iated pixel location should be
             rendered in the current pen
             color as set by the last setpen
             event.  An off (0) bit indicates
             that the associated pixel should
             be left in its current state.
             See the COLOR data explanation
             for additional details).
 data      - if this animation is sent to the
 (MONOCHROME LCD it will take datasize bits
  VERSION)   in the value sent and store them
             starting at the address defined
             by nextx and nexty. You can make
             repeated data calls and the
             address index will be updated
             such that each data call will
             affect the next datasize bits.
             Bits should be stored such that
             the least significant bit is the
             first bit to be stored.

             Note:  In rectangle drawing
             mode (see setmode for more de-
             tails), new data values are
             simply ignored.
 data      - takes a value and stores it as
 (COLOR      pixel color information starting
  VERSION)   at the address set by the last
             nextx and nexty events. You can
             make repeated data calls and the
             address index will be updated
             such that each data call will
             affect the next datasize pixels.
             The format to use for the data
             value depends on the current
             state of datasize.  If datasize
             is currently set to 1, then the
             value for a data event should be
             an actual pen number previously
             initialized with a setpen/
             setcolor event combination.  If
             datasize is greater than 1, but
             less than or equal to 16, data
             is assumed to be a bit mask of
             size datasize.  If a bit in the
             mask is on (1), then the assoc-
             iated pixel location will be
             rendered in the color of the
             current pen as set with the last
             setpen event.  The pixel loca-
             tion associated with an off (0)
             bit is left unchanged.  Bits in
             the data mask are evaluated from
             the least significant bit to the
             most significant bit.  The least
             significant bit value will set
             the color of the pixel at the
             current address index and so on.
             As a first example, the follow-
             ing calls in a client applica-
             tion program would set the
             pixels at 50,50 through 50,52 to
             the colors associated with pens
             1, 2, and 3:

               AtSendEvent(id, "datasize",
                           1);
               AtSendEvent(id, "nextx", 50);
               AtSendEvent(id, "nexty", 50);
               AtSendEvent(id, "data", 1);
               AtSendEvent(id, "data", 2);
               AtSendEvent(id, "data", 3);

             In contrast, the next set of
             calls would set even address
             pixels to the color associated
             with pen 1 starting at address
             50,50 through 50,65.  The color
             of odd address pixels would not
             change:

               AtSendEvent(id, "datasize",
                           8);
               AtSendEvent(id, "nextx",
                           50\8);
               AtSendEvent(id, "nexty", 50);
               AtSendEvent(id, "setpen", 1);
               AtSendEvent(id, "data", 0x55);
               AtSendEvent(id, "data", 0x55);

             Note:  In rectangle drawing
             mode (see setmode for more de-
             tails), new data values are
             simply ignored.
 query     - if this animation is sent to the
 (MONOCHROME LCD, the LCD will send back to
  VERSION)   the program (via the "data" ani-
             mation function) the value of
             datasize bits stored in the LCD
             starting at the address defined
             by nextx and nexty. You can make
             repeated query calls and the
             address index will be updated
             such that each query call will
             return the next datasize bits.
             Bits will be stored such that
             the least significant bit is the
             first bit to be stored.
 query     - if this animation is sent to the
 (COLOR      LCD, the LCD will send back to
  VERSION)   the program (via the "data"
             animation function) the pen
             value of the pixel at the cur-
             rent address index as set by the
             last nextx and nexty events. You
             can make repeated query calls
             and the address index will be
             updated such that each query
             call will return the pen value
             for the next pixel.  The new
             value available from data is
             always a pen number for just the
             next pixel address.  In other
             words, the data format is not
             related to the current datasize
             setting as is the case with a
             monochrome LCD object.  As an
             example, the following client
             application code would query the
             pen values for pixel addresses
             50,50 through 50,52 and print
             the values to a stdout window
             if one is available:

               int value;
               AtSendEvent(id, "datasize",
                           1);
               AtSendEvent(id, "nextx", 50);
               AtSendEvent(id, "nexty", 50);
               AtSendEvent(id, "query", 0);
               AtPollEvent(id, "data",
                           &value);
               printf("Pen at 50,50 is %d\n",
                      value);
               AtSendEvent(id, "query", 0);
               AtPollEvent(id, "data",
                           &value);
               printf("Pen at 50,51 is %d\n",
                      value);
               AtSendEvent(id, "query", 0);
               AtPollEvent(id, "data",
                           &value);
               printf("Pen at 50,52 is %d\n",
                      value);

             Note that datasize is set to 1
             in the above example.  As
             discussed above, the query data
             format is not affected by
             datasize.  However, the inter-
             pretation of nextx is dependent
             on datasize (as discussed
             earlier in the nextx descrip-
             tion).  To insure that the
             nextx address is indeed set to
             50, datasize is first set to 1.
 draw      - draws all the pixels that have
             been sent (MONOCHROME)/
             changed (COLOR) since the last
             draw.  A draw MUST be performed
             to trigger a display update. The
             value for draw can be anything.
 clear     - clears all of the pixels
             currently stored for the LCD.
             The pixels become transparent
             when they are cleared.  The
             value for clear can be anything.
             For a Monochrome LCD, the clear
             automatically triggers a display
             update.  For a Color LCD, the
             clear does not affect the
             display until a draw operation.
 setwidth  - this sets the number of elements
             wide the LCD object should be.
             This causes all currently
             defined points to be set (COLOR
             ONLY:  set to the color assoc-
             iated with pen 255).
 setheight - this sets the number of elements
             tall the LCD object should be.
             This causes all currently
             defined points to be set (COLOR
             ONLY:  set to the color assoc-
             iated with pen 255).
 pixwidth  - this sets the number of screen
             pixels wide a LCD pixel element
             should be.  This must be a value
             greater than 0.
 pixheight - this sets the number of screen
             pixels tall a LCD pixel element
             should be.  This must be a value
             greater than 0.
 spacesize - this sets the number of screen
             pixels that separate each LCD
             pixel element from neighboring
             elements.  This must be a value
             greater than or equal to 0.

The origin of the LCD Object is the upper
left corner.  If you want it to be the
lower right corner, just do a precise scale
with an X value of 1.0 and a Y value of -1.0.

After copying a LCD object to the drawing
area of the Graphics Editor, you can change
its width, height, or clear the current data
by selecting "setwidth", "setheight", or
"clear", respectively, from within the
Animation Editor and changing the animation's
value.  The state of the "clear" animation
simply needs to be toggled to do a clear.

Please Note:  When a LCD object is saved,
the current drawing mode (as defined by the
last value for setmode) is not saved.  When
a design containing a LCD object is opened,
the LCD always initializes with a drawing
mode of 0 (independent of any initial
state settings for the setmode animation).
Similary, the current pen is not saved.  On
initialization, the current pen is set to 255
for a Color LCD or 1 for a Monochrome LCD
(independent of any initial state settings
for the setpen animation). As previously dis-
cussed, pen 255 for a Color LCD and pen 1 for
a Monochrome LCD default to the object's
selected foreground color.

Also Note:  When a Color LCD object is
saved to a design, the color data for the
individual pixels is not saved.  When a
design containing a Color LCD object is
opened, all pixels are automatically rendered
in the color associated with pen number 255.

RENAMING ANIMATIONS:
---------------------------------------------
You can rename the animations for any of the
objects described by using the rename dialog
that appears when you move a copy of an
object from the Models View to the Graphics
Editor's drawing area. In this way, you can
have multiple LCD objects in a single design
that work independently.  Animations for
existing objects in the work area can be
renamed by selecting the object, and then
choosing the "Rename Animation" menu item
from the Animation Editor's Edit pulldown
menu.

LCD PLOT OBJECT DEMONSTRATION(S):
---------------------------------------------
A demonstration design presenting Altia's
Color LCD object capabilities is installed
with the standard software.

On the PC, double-click on the Color LCD Demo
icon found in the Altia Design program group.
This will start an Altia Runtime interface
and load the
altia\demos\lcdcolor\lcdcolor.dsn design
file.  It also starts the associated
lcdcolor.exe program in the same directory.
This program is compiled from the C source
file lcdcolor.c.

On UNIX systems, execute the go script in the
altia/demos/lcdcolor directory.  It will load
the same lcdcolor.dsn design file into an
edit session and start the lcdcolor.out
client program.  To start a runtime session
instead, execute go with a -run argument.

Your software installation may also have a
demonstration of the monochrome LCD object.
If so, it is located in the lcdmono demos
directory.

screen 15
TIMER STIMULUS:

As with mouse or keyboard event stimulus,
timer stimulus specifies a response to an
event.  However, with timer stimulus, the
event is not a direct user action.  Instead,
the event which starts the execution of a
timer stimulus definition is a state change
in an animation or stimulus function.  In a
typical use, the state change would actually
result from the execution of a conventional
stimulus definition for a mouse or keyboard
action.  A client application program can
also start a timer stimulus by requesting
an animation state change using the
altiaSendEvent() or AtSendEvent() library
functions (see Section II of the Altia
Reference Manual for more details on
available programming functions).

Once a timer stimulus is started, it is eval-
uated at a specified milliseconds, seconds
or minutes interval.  At each interval, an
enable condition is tested.  If the condition
is satisfied, an animation or stimulus
function state change is performed.  The
timer stimulus will stop when a specified
animation or stimulus function state change
occurs.  This state change may be the result
of the timer's own execution or it could be
triggered by a separate mouse/keyboard
stimulus execution, another timer stimulus
execution, or a state change event generated
by a client application program.

PREPARING TO CREATE TIMER STIMULUS:
---------------------------------------------
Timer stimulus is attached to a specific
object just as the other types of stimulus.
You must select the object using the Graphics
Editor before proceeding.

Within the Stimulus Editor, press mouse
button one (MB1) down on the stopwatch icon
(just above the key icon).  The Stimulus
Editor is now in timer stimulus definition
mode as indicated by the appearance of the
word "Timer" under the "WHEN THE INPUT
STIMULUS IS:" heading.

TIMER INTERVAL:
---------------------------------------------
The body of the Stimulus Editor now contains
five statements that, when completed, specify
the entire timer definition.  Selecting
the timer interval is the first task.  The
field following "TIMER INTERVAL:" takes a
non-negative integer value.  To the right of
the input field is a pulldown menu initially
labeled "msecs".  This indicates that the
time base for the interval value is milli-
seconds.  Other menu choices are "secs"
(seconds) and "min" (minutes).

The timer interval describes how often the
timer definition's "enable" and "execute"
statements should be evaluated after the timer
is started.  For example, choosing "500 msecs"
would trigger evaluation 1/2 second after the
timer starts and it would continue to repeat
the evaluation at 1/2 second intervals until
the timer stops.

START:
---------------------------------------------
A timer waits for a specified animation or
stimulus function state change to occur
before it will begin evaluating its "enable"
and "execute" statements at the prescribed
interval.

A function name is typed into the text field
immediately to the right of the "START:"
phrase.  The state value that will trigger
the start is either entered directly into the
associated number field or adjusted with the
field's increment/decrement arrows.  By
pressing MB1 down on the "button" between the
name and number fields, it is possible to
change the value test to a =, <, <=, >, >=,
or <> comparison.

** PLEASE NOTE:  If the state value for a
function meets the START: statement con-
ditions when a design is loaded, the timer
will NOT automatically start.  An actual
state change event MUST occur as a result of
a mouse/keyboard stimulus execution or a
client application program event.  It is
possible to start a timer automatically on
design file load by setting the START:
statement to "altiaInitDesign = 0".  This
is a special function name whose state is
set to 0 when a design file is opened. **

STOP:
---------------------------------------------
As with starting the timer, the occurrence of
a particular state change is used to stop it.
When a timer is stopped, it discontinues the
periodic evaluation of its "enable" and
"execute" statements.

A function name is typed into the text field
immediately to the right of the "STOP:"
phrase.  The state value that will trigger
the stop is either entered directly into the
associated number field or adjusted with the
field's increment/decrement arrows.  By
pressing MB1 down on the "button" between the
name and number fields, it is possible to
change the value test to a =, <, <=, >, >=,
or <> comparison.

** PLEASE NOTE:  If the START: statement
is identical to the STOP: statement (i.e.,
the names, type of value comparisons,
and the values match identically), the timer
will never start.  Actually, it does start
momentarily, but then it is immediately
stopped. **

AND THE ENABLE CONDITION:
---------------------------------------------
Although optional, an enable condition allows
for more sophisticated timer definitions.

The enable condition provides a method of
testing the current state for any animation
or stimulus function and ignoring the
"execute" statement if the current value of
the function is inappropriate.

For timers, the enable condition is evaluated
after each time interval expires.  The
"execute" statement is performed if the
current state value of the enable function
passes the enable condition test.

The enable condition is specified as an
animation or stimulus function whose current
state value is =, <, <=, >, >=, or <> to a
given value.  The function name is typed in
the text field, while the condition is chosen
by pressing MB1 down on the "button" between
the text and state fields and selecting the
condition from the "menu."  The state value
is either entered directly into its field or
adjusted with the field's increment/decrement
arrows.

** PLEASE NOTE:  To specify an enable condi-
tion that will always be true, enter the
function name "None", the condition "=", and
the value "0". **

THEN EXECUTE:
---------------------------------------------
The final element of the timer stimulus def-
inition is the animation or stimulus function
to execute at each timer interval if the
enable condition is satisfied.

The function to execute is entered in the
text field.  What to do to its current state
is chosen by pressing the "button" between
the text and state fields and selecting
whether the current state should be set to or
incremented/decremented by the value entered
in the state field.

ADDING THE COMPLETE DEFINITION TO THE OBJECT:
---------------------------------------------
Once the five statements have been satis-
factorily edited, the Stimulus Editor's
"Define" button is pressed to add the
definition to the object.

TIMER STIMULUS ORDERING:
---------------------------------------------
As timer definitions are added to the object,
they appear in the Stimulus Editor's list
area.  If the object has any mouse or key-
board stimulus definitions, they will appear
first in the list with timer definitions
appearing last.

TIMER STIMULUS NUMBERING:
---------------------------------------------
Each timer definition is assigned an index
starting with 1 (i.e., you will see
"Timer   (1)" at the beginning of the first
timer definition shown in the list area).
If two or more timer definitions have
identical INTERVAL:, START:, and STOP:
statements, they will all be assigned the
same index number.  This is a visual clue
to the user that the timer definitions are
all defined to start on the same event,
evaluate at the same interval AND in the
same sequence as they appear in the list,
and stop on the same event.

** PLEASE NOTE:  When a set of timer defini-
tions have the same index number, they are
evaluated, in sequence, at the same time
intervals.  All "enable" statements are eval-
uated first and then all "execute" statements
are conditionally performed.  Even if one or
more "execute" statements change a function
state which would stop the timers, all
"execute" statements are still performed.  If
an "execute" statement changes the state of a
function that is used in one or more "enable"
statements, the change will not have an
effect until the next timer interval. **

EDITING AN EXISTING DEFINITION:
---------------------------------------------
As with all types of stimulus, an existing
timer definition can be edited by high-
lighting it in the list area, making adjust-
ments to one or more of the five statements
while it remains highlighted, and pressing
the "Redefine" button (which was previously
the "Define" button) to apply the changes to
the highlighted definition.

STOPPING A RUNAWAY TIMER:
---------------------------------------------
While developing timer definitions, it is not
uncommon to make a mistake and set off a
timer or sequence of timers which cannot be
easily stopped.  If this happens (and it most
likely will), simply select the "Stop All
Timers' option from the Stimulus Editor's
"Debug" menu.  This will stop all active
timers immediately for all objects in the
design.

A SIMPLE FLASHING EXAMPLE:
---------------------------------------------
Assume that an object exists which is ani-
mated to change color, the animation is named
"Flash", and it has two states - 0 and 1.
Also assume that a button exists that has
left button down stimulus which toggles the
stimulus function "StartFlash" between states
0 and 1.

The following shows the timer stimulus
definitions (there are 2) required to
continuously change "Flash" between 0 and 1
at 1 second intervals while "StartFlash" is
in state 1:

Definition #1:
--------------
TIMER INTERVAL:  1         secs
START:  StartFlash         =    1
STOP:   StartFlash         =    0
AND THE ENABLE CONDITION:
Flash                      =    0
THEN EXECUTE:
Flash                      =    1

Definition #2:
--------------
TIMER INTERVAL:  1         secs
START:  StartFlash         =    1
STOP:   StartFlash         =    0
AND THE ENABLE CONDITION:
Flash                      =    1
THEN EXECUTE:
Flash                      =    0

These 2 definitions could be added to the
button object or the object that is changing
color - its up to the designer.  As a helpful
hint, it is sometimes best to put the timer
stimulus on the object that is affected by it
rather than on the object that triggers it.
This way, the timer stimulus is copied when
the object is copied and the method used to
trigger the timers can be changed quite
easily (e.g., a toggle button is quickly
replaced with a switch).

When the 2 definitions are created, you
will notice that they are grouped together
with the same timer index (index 1 if these
are the only timer stimulus definitions).
As was discussed under "TIMER STIMULUS
NUMBERING", this is because the 2 definitions
have the same INTERVAL:,  START:, and STOP:
statements.  This grouping is also very
important for insuring reliable behavior.
The definitions are evaluated at exactly
the same time as each interval expires.  This
insures that the flashing is well synchro-
nized.

WHERE TO FIND MORE TIMER STIMULUS EXAMPLES:
---------------------------------------------
A Models Library of timer stimulus examples
is available to help users get acquainted
with this powerful feature.  To display the
examples in a Models View window, click on
the "Models" button which appears along the
top row of buttons in the Graphics Editor.
A dialog for choosing a file is subsequently
displayed.

On Windows, double-click on the "more"
directory that appears in the dialog.

On UNIX, double-click on the directory
"$ALTIAHOME/models/more/" found under
the "Standard Models Directories:" section
of the dialog.

After the dialog refreshes to show you the
contents of the "more" directory,
double-click on the file "timer.dsn".

A Models View window will appear containing
the various timer stimulus examples.  You
can scroll up and down through the examples
using the up/down arrow buttons found in
the panner associated with the Models View
(the panner is the box in the lower left
corner of the view which provides controls
for maneuvering around the view).

When you see an example that looks
interesting, press the left mouse button
(MB1) over it and drag it into the Graphics
Editor's drawing area.  You are given a
chance to rename the example's animation and
stimulus function names if you choose to
do so.

Try out the example by putting the Graphics
Editor into run mode and clicking on the
switch, knob, or buttons associated with the
example.  To see the example's stimulus,
switch to edit mode and select the object.
Most of the examples have the timer stimulus
attached to the example's group object. In
a a few cases, you may need to click on
FocusIn and select one or more of the sub-
components of the group to see the timer
stimulus definitions.

COPYING STIMULUS FROM THE EXAMPLES:
---------------------------------------------
Definitions can be easily copied from these
examples or your own future examples using
the "Copy Stimulus" and "Paste Stimulus"
options from the Stimulus Editor's "Edit"
menu.

screen 16
CLIP OBJECT MODEL:

The file

\usr\altia\models\more\clip.dsn

contains an example clip object which can be
copied into a design from a Models View
window and then customized to suit specific
needs.

A clip object is a special group object that
can clip the drawing of graphics objects con-
tained within it.  Like a camera view finder,
it allows you to view a select portion of a
larger picture.  Any objects outside of the
viewing region are "clipped" away - invisible
to the viewer but still very much present.

The clip object comes with animation to allow
its size and viewing region to be dynamically
adjusted.  This makes it suitable for build-
ing 1 or 2 dimensional scroll lists or view
areas for applications such as map displays,
aerospace components, and video camera
simulations.

EDITING OBJECTS IN A CLIP OBJECT GROUP:
---------------------------------------------
Objects in a clip are added, deleted, and
modified just like objects in a regular
group.  With the Graphics Editor in edit
mode, select the clip and then click on the
FocusIn button found in the Tool-Command
panel.  This will focus the editor into the
clip object group where new objects can be
added or existing objects can be modified or
deleted.  When editing is complete, click on
FocusOut to leave the group.

To copy an existing object into a clip object
group, select the object to be copied and
press the Copy button.  Then, focus into the
group as described above and use the Paste
command to add the copied object to the
group.

Objects can also be copied into the clip
group from a Models View by dragging and
dropping a Models View object into the
drawing area while the Graphics Editor is
focused into the clip group.

ADJUSTING THE SIZE OF THE CLIP AREA:
---------------------------------------------
The clip object's "height" and "width" anima-
tions are available for adjusting the size
of the clip area.

With the clip object selected, open the
Animation Editor window.  You will see two
animations named width and height listed
along with several others.

When the value for width or height is
changed, the width or height of the clip
area changes.  The anchor point for the size
is the lower left corner of the object so
an increase in width will grow the clip area
to the right and it will grow taller with an
increase in the state of height.

The width or height of the clip can be ad-
justed during editing and left fixed, or each
can be adjusted in run mode by stimulus or
an application program.

ADJUSTING THE ORIGIN OF THE CLIP'S VIEW:
---------------------------------------------
By default, the lower left corner position
of the objects in the clip is the lower left
corner of the clip's view (i.e., its origin).
By adjusting the states of the "xorigin" and
"yorigin" animations, it is possible to
change the origin of the clip's view.

To give an example, if xorigin and yorigin
are both changed to 10, the objects in the
clip would appear to move to the left and
down.  That is, 10 pixels up and to the right
of the original lower left corner would be-
come the clips new origin.

As with width and height, xorigin and yorigin
can be adjusted during editing and left
fixed, or each can be adjusted in run mode by
stimulus or an application program.

THE CLIP'S EFFECT ON ANIMATION AND STIMULUS:
---------------------------------------------
When an object in a clip is hidden, its ani-
mations, if it has any, are still updated
as new states arrive.  If the object comes
into view at a later time, its graphics will
be properly redrawn.

Any portion of a mouse/keyboard input stim-
ulus area which is hidden will be disabled.
If a portion of a leave area stimulus is
hidden, the clip object`s border that inter-
sects the area becomes the new stimulus area
border.  This is true for an enter area stim-
ulus as well.

Timer stimulus on hidden objects will behave
normally.  However, if mouse or keyboard in-
put stimulus triggers the timer stimulus and
the input stimulus is hidden, nothing can
happen.

USING DUET MODE:
---------------------------------------------
A fifth and final animation is provided with
the clip object named "duet".  When duet is
set to state 0 (the default mode), the
width animation can be set independent of
the height animation and xorigin can be set
independent of yorigin.

When duet is set to state 1, each width state
change must be accompanied by a height state
change before the clip object is visually
modified.  Similarly, each xorigin change
must be accompanied by a yorigin change.
This mode allows for smooth 2 dimensional
size adjustment and panning.

RENAMING A CLIP'S ANIMATION:
---------------------------------------------
If more than one clip object is used in a de-
sign, it is usually necessary to rename the
animations of the various clip objects so
that they do not conflict with each other.
This can be done from the Rename Dialog that
appears when an object is copied from a
Models View to the drawing area.  You can
also open the Rename Dialog from the "Rename"
option found in the "Edit" menu of the Anima-
tion Editor or Stimulus Editor.

MODIFYING THE CLIP'S ORIGIN ANCHOR:
---------------------------------------------
Having the clip origin anchored in the lower
left corner means that increasing yorigin
state values cause objects in the clip to
scroll down and increasing height state
values cause the clip to grow in size towards
the top of the screen.

For something like a text scroll list, it is
more desirable to have the objects scroll up
instead of down and have the size grow
towards the bottom of the screen.  This
behavior can be produced by precisely scaling
the clip by a factor of -1 along the y axis.

In detail, select the clip object, open the
Precise Scale Dialog by choosing "Precise
Scale..." from the Graphics Editor's "Edit"
menu, set the y: field to -1, and press OK.

** PLEASE NOTE:  Before performing the pre-
cise scale, it is advised that you make
copies of all of the objects in the clip so
that they can be pasted back into the clip
after the scaling.  Otherwise, you will be
left with objects in the clip that have been
flipped over.

The precise scale method can also be used
to change the width and xorigin animation
behaviors by precisely scaling the clip
by a factor of -1 along the x axis.

GENERAL CHARACTERISTICS OF A CLIP:
---------------------------------------------
A clip is derived from a standard group ob-
ject so it inherits all capabilities of a
group.  For example, if the clip is stretched
or rotated, the objects in the clip will also
stretch or rotate.  The clip can be given
user-defined animation in addition to its
existing animations.  For example, an anima-
tion called "move" could be assigned to the
clip to move it around the screen.

If the foreground color, background color,
pattern, brush, or font is set for a clip
object, the attribute will be forced onto
all of the objects in the clip just as would
happen with a normal group object.  To clear
such an attribute setting, choose "Clear
Group Attributes" from the Graphics Editor's
"Edit" menu while the clip is selected.

SPECIAL CONSIDERATIONS WHEN ROTATING A CLIP:
---------------------------------------------
Due to windowing system and performance con-
siderations, a clip is forced to maintain a
rectangular clip region.  If a clip object
is rotated, the objects it contains will ro-
tate and the behavior of the width, height,
xorigin, and yorigin animations will change
as a result of the transformation.  However,
the clip region will remain rectangular with
its sides exactly aligned with the vertical
and horizontal axes.  The size of the clip
area will probably also change for imple-
mentation reasons.

screen 17
DECK OBJECT MODEL:

The decks.dsn library contains example 
deck objects complete with properties and
connections.

The file

\usr\altia\models\more\deck.dsn

contains basic deck objects which can be
copied into a design from a Models View
window and then customized to suit specific
needs.

A deck object is a special group object that
controls the displaying of one-of-n sub-
groups of objects.  The state of the anima-
tion named "card" is changed to hide the
current sub-group and display a new sub-
group.  This help will refer to the sub-
groups of the deck as "cards".

ADDING OBJECTS TO THE CARDS OF A DECK:
---------------------------------------------
To populate a specific card with objects:

1.  Put the Graphics Editor into edit mode.

2.  Select a deck object.

3.  If this is a deck from the decks.dsn
    library, double-click on it to display
    its properties and set the current card
    to the card you wish to display.

    If this is a deck from more/deck.dsn,
    open the Animation Editor and highlight
    the line for the "card" animation as it
    appears in the defined animations list.
    This will place the "card" animation name
    in the Name: field of the Animation
    Editor.  Change the state of the card an-
    imation by incrementing or decrementing
    the value displayed in the State: field or
    edit the current value using keyboard in-
    put.

4.  If this is the first edit of the deck,
    you probably want to start with card
    state 0.  This is the default card that
    will be shown on design file loading.

5.  If this is a deck from the decks.dsn
    library, you can enter the current card's
    sub-group by choosing "Yes" for the "En-
    ter This Card Now!" property or click on
    the FocusIn button.

    If this is a deck from more/deck.dsn,
    you must click on the FocusIn button to
    enter the current card sub-group.

6.  Add objects as you wish while focused in
    and focus out when you are done.  If you
    wish to copy an existing object into the
    deck, select it and press the Copy button
    before selecting and focusing into the
    card.  Then, use the Paste command to add
    a copy of the original object to the card
    group.  You can also add objects from
    a Models View while you are focused into
    a card.

7.  After focusing out of the current card,
    change the card as described in step 3
    and repeat steps 5 and 6 to add objects
    to other cards.

There is no limit to the number of cards you
can have in a deck or the number of decks
you can have in a design.

Cards of a deck can contain additional decks
themselves which makes it possible to design
very interesting hierarchical display
scenarios.

EDITING EXISTING OBJECTS IN A CARD:
---------------------------------------------
As with adding objects to a card, you must
set the appropriate state of the card anima-
tion and use FocusIn to edit any existing
objects.

THE DETAILS OF A CARD ANIMATION STATE CHANGE:
---------------------------------------------
When the state of a deck's card animation is
changed, all objects in the current card are
removed from the graphics "universe".  They
are still part of the design, but they cannot
redraw and they ignore all input stimulus.
They will, however, continue to receive
animation state change events if they have
animation.  When they are displayed again,
they will be correctly updated based on any
state changes which occurred while they were
"hidden".

If any objects in a hidden card have timer
stimulus, it CAN be activated while the
card is hidden.  If it is active at the
time the card is hidden, it will remain
active until it receives a stop event.

THE CHARACTERISTICS OF A DECK:
---------------------------------------------
A deck is derived from a standard group ob-
ject so it inherits all capabilities of a
group.  For example, if the deck is stretched
or rotated, the objects in the deck will also
stretch or rotate.  The deck can be given
user-defined animation in addition to its
existing card animation.  For example, an
animation called "move" could be assigned to
the deck to move it around the screen.

If the foreground color, background color,
pattern, brush, or font is set for a deck
object, the attribute will be forced onto
all of the objects in the deck just as would
happen with a normal group object.  To clear
such an attribute setting, choose "Clear
Group Attributes" from the Graphics Editor's
"Edit" menu while the deck is selected.

SETTING THE INITIAL STATE OF A DECK:
---------------------------------------------
By default, the card animation for a deck is
set to a 0 value when a design is initially
loaded.  To set the initial state to some-
thing other than 0, select the deck object.

If this is a deck from the decks.dsn library,
double-click on the deck object to open its
properties and set the initial card property.

If this is a deck from more/deck.dsn, set the
card animation to the desired initial state
using the Animation Editor and then choose
"Set Selected Initial State to Current State"
from the Animation Editor's "Initial" menu.

RENAMING THE CARD ANIMATION:
---------------------------------------------
If you use more than one deck object in a
design, you will probably want to rename one
or more of the card animations so that they
do not conflict with each other.  This can be
done from the Rename Dialog that appears when
an object is copied from a Models View to the
drawing area.  You can also open the Rename
Dialog from the "Rename" option found in the
"Edit" menu of the Animation Editor or
Stimulus Editor.

HOW A DECK IS TYPICALLY USED:
---------------------------------------------
In run mode, it is customary to control a
deck's card animation from input stimulus,
timer stimulus, or an application program.
A deck is ideally suited for controlling
multiple screen applications, hierarchical
soft-key style menuing systems, or dynamic
presentations.

screen 18
CONTROL EDITOR OVERVIEW:

The Control Editor is used to specify how
individual components of an interface
interact with one another.  While simple
cases, such as a power switch illuminating
an indicator, are readily handled by the
Stimulus Editor, more involved scenarios
are created with the Control Editor.

The Control Editor allows you to specify
what to do when certain events happen.  The
events can be any animation or stimulus name,
originating from user input, Altia's code
connection, or the Control Editor itself.
"What to do" can be anything from setting
the value of an animation or stimulus name
to reading/writing file information to
making more complicated logical decisions
based on other animation, stimulus or
control name values.

DEFINING CONTROL:
---------------------------------------------
Like animation and stimulus, control is
defined/displayed for the object currently
selected in the Graphics Editor.  Control is
"attached" to the object, and multiple ob-
jects may have control definitions.

A control definition looks like this:

WHEN condition #1 is true
  DO whatever is appropriate for condition #1

WHEN condition #2 is true
  DO whatever is appropriate for condition #2

     .
     .
     .

At the top-most level, you specify what con-
ditions to look for with one or more "WHEN"
statements.  Each "WHEN" statement consists
of an animation/stimulus name, a value,
and a relationship (==, <, <=, >, >=, !=)
between the two.  When the relationship is
true, the control statements under that
"WHEN" will be executed.

Optionally, you may also create any number of
"ROUTINE"s at the top level:

ROUTINE one
  DO whatever is appropriate for sub-task one

ROUTINE two
  DO whatever is appropriate for sub-task two

     .
     .
     .

A "ROUTINE" is a named sequence of control
statements for accomplishing a sub-task.
Creating a "ROUTINE" encapsulates the sub-
task so it can be invoked, or "CALL"ed, with-
out duplicating the sequence.  "ROUTINE"s are
listed along with "WHEN" statements, but only
execute when explicitly "CALL"ed (see THE
"CALL" STATEMENT under "Help/Primary
Statements").

Additionally, "COMMENT" and "GLOBALS" state-
ments (see "Help/Primary Statements") may
also be specified at this top-most level.

TYPES OF CONTROL STATEMENTS:
---------------------------------------------
There are several different types of control
statements that can be added under a "WHEN"
or in a "ROUTINE":

"Primary" statements (basic control):

- "IF" allows you to test the value of an
  animation/stimulus/control name and take
  action based on the outcome of the test.
- "ELSE" can be used under an "IF" to handle
  the alternative case where the "IF" test
  fails.
- "ELSEIF" provides a simpler way of specify-
  ing an "ELSE" followed by an "IF".
- "AND"/"OR" permit the creation of more
  complicated "IF" conditions.
- "LOOP" indicates control that is to be
  repeated while a test condition is true.
- "CALL" transfers control to a "ROUTINE"
  that should execute prior to continuing
  with the next statement.
- "SET" allows you to set the value of an
  animation/stimulus/control name.
- "MATH" is used to set an animation/
  stimulus/control name to a mathematical
  expression (usually involving another
  animation/stimulus/control name).
- "EXPR" is used to compute more complicated
  expressions than those possible with "SET"
  or "MATH".
- "COMMENT" can be used to add comments to
  the control.
- "END" indicates the end of the block of
  control statements under the nearest
  "WHEN", "IF", "ELSE", "ELSEIF", "LOOP",
  or "ROUTINE".
- "RETURN" (only available under "ROUTINE")
  returns a value and control to the
  "CALL"er.

"Advanced" statements (specialized control):

- "File_I/O" advanced statements for opening
  ("OPEN"), reading ("READ"), writing
  ("WRITE"), and closing ("CLOSE") text
  files.
- "Views" advanced statements for opening
  ("OPEN_VIEW") and closing ("CLOSE_VIEW")
  additional windows into a design, and
  also for opening ("OPEN_DESIGN") and clos-
  ing ("CLOSE_DESIGN") one or more designs
  during a single Altia session.
- "Misc" advanced statements for calling a
  routine in an external shared, or dynamic-
  ally linked, library ("EXTERN").

The Control Editor guides you through the
entire definition process by only allowing
the addition of syntactically-valid
statements.  All you need to do is fill in
the necessary animation/stimulus/control
names, values, and relationships/operators
inside the statements.

THE ADD... BUTTON:
---------------------------------------------
Once an object is selected in the Graphics
Editor, pressing the Control Editor's
"Add..." button displays the list of valid
control statements which can be attached to
that object at that position in the control
definition.  When a statement is added, the
statement appears in the Control Editor's
view and becomes "selected" (ie "handles"
appear around the statement like those on a
selected object in the Graphics Editor).  You
complete the statement by filling in the text
fields with animation/stimulus/control names
and values.  Pressing MB1 down on any button
in the statement that displays a mathematical
or relational operator reveals a menu from
which other operators can be selected.

To add additional statements, press the
"Add..." button again.  The displayed list
will always reflect what statements can be
added after the previous statement.

EDITING CONTROL:
---------------------------------------------
A statement can be "selected" for editing/
adding control by pressing MB1/MB3 down over
the statement in the view.  In the case of a
"WHEN" or "ROUTINE" statement, it will expand
to display all control statements under it.
Once selected, any field in the statement can
be edited.  In addition, the Control Editor's
"Edit" menu allows you to "Cut"/"Copy" one or
more statements, or "Paste" previously cut/
copied statements.  The "Rename..." menu
item permits renaming any animation/stimulus
name.

Multiple statements can be selected for
"Cut"/"Copy" operations as follows:

- holding the SHIFT key down while pressing
  MB1/MB3 down over a statement selects all
  statements between that one and the last
  selected statement
- holding the CTRL key down while pressing
  MB1/MB3 down over a statement adds that
  statement to the set of selected state-
  ments if not already selected, otherwise
  it unselects it

STARTING/STOPPING THE CONTROL DEFINITION:
---------------------------------------------
Control definitions are active immediately
upon creation.  Whenever the Control Editor
receives an event (animation/stimulus name
with a value) for which a "WHEN" is true,
the statements underneath that "WHEN" will
be executed.  As mentioned previously, the
event could come from an animation/stimulus
definition (for instance, pressing the power
button on your virtual instrument), your
C/C++/Visual Basic code via Altia's code
connection, or from a "MATH", "SET", or
"EXPR" statement in this or another object's
control definition.

To stop control execution, simply press the
Control Editor's "Stop" button and ALL
control definitions for ALL objects are
halted until the button (now labeled "Cont")
is pressed again.

THE ANIMATION NAME "altiaInitDesign":
---------------------------------------------
"altiaInitDesign" is a special, pre-defined
animation name.  Each time an Altia design is
loaded, an "altiaInitDesign" event is gen-
erated with a value equal to 0 in edit mode
and the "design number" in run mode (see The
Views "OPEN_DESIGN" STATEMENT under Help/
Advanced Statements and The Altia Design
Reference Manual for information regarding
opening multiple designs in run mode).
Creating a "WHEN" statement to catch this
event provides an opportunity to do any
initialization the design requires.

screen 19
THE PRIMARY STATEMENTS:

There are several types of primary (basic)
control statements:

THE "WHEN" STATEMENT:
---------------------------------------------
"WHEN" tests the relationship (==, <, <=, >,
>=, !=) between an animation/stimulus name
and a value.  When true, all control state-
ments under the "WHEN" are executed.

WHEN [animation/stimulus name]
 ==     equals
 <      is less than
 <=     is less than or equal to
 >      is greater than
 >=     is greater than or equal to
 !=     does not equal                [value]

"WHEN" can only be added at the top-most
level.  Fill in the animation/stimulus name
and the value you wish to test for.  The
value may be numeric or another animation/
stimulus or global name.  The relationship
between the two is specified by pressing MB1
down on the button labeled with a relational
operator (==, <. <=, >, >=, !=), revealing a
menu from which the selection is made.

THE "ROUTINE" STATEMENT:
---------------------------------------------
A "ROUTINE" is a named sequence of control
statements for accomplishing a sub-task.

ROUTINE [routine name]
PARAMS  [routine parameters]
LOCALS  [routine locals]

Creating a "ROUTINE" encapsulates the sub-
task so it can be invoked, or "CALL"ed, with-
out duplicating the sequence.  "ROUTINE"s are
listed along with "WHEN" statements, but only
execute when explicitly "CALL"ed (see THE
"CALL" STATEMENT below).

To create a "ROUTINE", you fill in the
routine name and, optionally, any routine
parameters and locals (parameters are names
that represent values given the "ROUTINE"
when it is "CALL"ed.  Locals are names needed
to hold temporary values inside the routine
when it executes).  All control statements
necessary to accomplish the sub-task are then
added underneath the "ROUTINE" statement.

A Note On Control Names:
------------------------
Control names (parameters, locals and
globals) can be used in all control state-
ments that accept animation/stimulus names.
Note, however, that no event routing takes
place when a control name's value changes.

Control names can take on:

- integer values, like 5
- floating point values, like 1.234
- string values in double quotes, like
  "this is a string"
- arrays of values, as in value[0] = 3.14,
  value[name] = "testing" (using the name
  with subscripts, [], makes the name an
  array)

And, like Text I/O Objects, a control name
preceded by "@" (ie @param) means use that
name's value as the name of the name whose
value is to be substituted.

Conflicts between parameter/local, global,
and animation/stimulus names can occur and
are resolved by scope - parameter/local
names have priority over global names, which
have priority over animation/stimulus names.

THE "GLOBALS" STATEMENT:
---------------------------------------------
The "GLOBALS" statement declares the listed
names to be global in scope, meaning ALL
control statements for ALL objects can
access them.

GLOBALS [global names]

Like the "WHEN" statement, the "GLOBALS"
statement can only be added at the top-most
level.  See "A Note On Control Names" in THE
"ROUTINE" STATEMENT section above regarding
the types of values globals can have.

THE "IF" STATEMENT:
---------------------------------------------
"IF" allows you to test the value of an
animation/stimulus/control name and take
action based on the outcome of the test.

IF [animation/stimulus/control name]
 ==     equals
 <      is less than
 <=     is less than or equal to
 >      is greater than
 >=     is greater than or equal to
 !=     does not equal                [value]

"IF" permits conditional execution of control
based on whether the relationship between the
animation/stimulus/control name and the value
is true.  Fill in the animation/stimulus/
control name and the value to test for.
Select the relationship by pressing MB1 down
on the button labeled with a relational
operator (==, <, <=, >, >=, !=), then
selecting the appropriate one from the menu.

A Note On [value]:
-----------------
If [... name] is an animation/stimulus name,
[value] may be:

- an integer value, like 5
- if name is a Text I/O Object's "text"
  animation:
  - a string value in double quotes, like
    "this is a string"
  - another Text I/O Object's "text" anima-
    tion name preceded by "@" (ie @name),
    meaning use that name's value as the
    name of the name whose value is to be
    substituted
- another animation/stimulus/control name
  with one of the above types

If [... name] is a control name (parameter/
local/global), [value] may be:

- an integer value, like 5
- a floating point value, like 1.234
- a string value in double quotes, like
  "this is a string"
- another control name preceded by "@"
  (ie @name), meaning use that name's value
  as the name of the name whose value is to
  be substituted
- an array value, like value[0] or
  value[name]
- another animation/stimulus/control name
  with one of the above types

THE "ELSE" STATEMENT:
---------------------------------------------
"ELSE" can be used under an "IF" to handle
the alternative case where the "IF" test
fails.

ELSE

Based on the tested condition, either the
control statements under the "IF" or those
under the "ELSE" will be executed.  The
"ELSE" has no fields to fill in since the
matching "IF" defines the test.

THE "ELSEIF" STATEMENT:
---------------------------------------------
"ELSEIF" provides a simpler way of specifying
an "ELSE" followed by an "IF".

ELSEIF [animation/stimulus/control name]
 ==     equals
 <      is less than
 <=     is less than or equal to
 >      is greater than
 >=     is greater than or equal to
 !=     does not equal                [value]

If the preceding "IF" condition is false,
the test of the "ELSEIF" condition will
take place.  If true, the control statements
under the "ELSEIF" will be executed.  The
statement is filled in just like the "IF"
statement:  with the animation/stimulus/
control name, value, and relationship to
test for.

Note that [value] may be any value that can
be used in an "IF" statement (see "A Note On
[value]" in THE "IF" STATEMENT section
above).

THE "AND"/"OR" STATEMENTS:
---------------------------------------------
"AND"/"OR" permit the creation of more
complicated "IF" conditions.

AND/OR [animation/stimulus/control name]
 ==     equals
 <      is less than
 <=     is less than or equal to
 >      is greater than
 >=     is greater than or equal to
 !=     does not equal                [value]

"AND"/"OR" let you test multiple relation-
ships between animation/stimulus/control
names and values in one "IF".  For instance,
you could test IF NAME_A == 5 AND
NAME_B > 100.  Likewise, NAME_C != NAME_D OR
NAME_E == "test" would be a valid test as
well.  The statement is filled in just like
the "IF" statement:  with the animation/
stimulus/control name, value, and relation-
ship to test for.

Note that [value] may be any value that can
be used in an "IF" statement (see "A Note On
[value]" in THE "IF" STATEMENT section
above).

THE "LOOP" STATEMENT:
---------------------------------------------
"LOOP" indicates control that is to be
repeated while a test condition is true.

LOOP WHILE [animation/stimulus/control name]
 ==     equals
 <      is less than
 <=     is less than or equal to
 >      is greater than
 >=     is greater than or equal to
 !=     does not equal                [value]

"LOOP" precedes control statements that
should be repeated while the given condition
remains true.  The condition is tested and,
if true, all statements under the "LOOP" are
executed and the condition is tested again.
This cycle repeats until the test fails.  As
with other primary statements, fill in the
animation/stimulus/control name and the value
to test for.  Select the relationship by
pressing MB1 down on the button labeled with
a relational operator (==, <, <=, >, >=, !=),
then selecting the appropriate one from the
menu.

Note that [value] may be any value that can
be used in an "IF" statement (see "A Note On
[value]" in THE "IF" STATEMENT section
above).

THE "CALL" STATEMENT:
---------------------------------------------
"CALL" transfers control to a "ROUTINE" that
should execute prior to continuing with the
next statement (see THE "ROUTINE" STATEMENT
above).

CALL
ROUTINE [routine name]
PARAMS  [routine parameters]
RESULT  [animation/stimulus/control name]

"CALL" executes the named routine, giving it
the listed parameters (values).  If filled
in, the name in the "RESULT" field will be
given the value returned by the routine.
Fill in the routine name, any required
parameters, and the name to assign the
result to.  For instance, suppose:

ROUTINE [test]
PARAMS  [message num_times]
LOCALS  [ ]
    .
    .
    .
RETURN [999]
END

is defined and is called:

CALL
ROUTINE [test]
PARAMS ["Testing..." 10]
RESULT [value]

For that invocation of routine "test",
"message" will have a value of "Testing..."
(the string) and "num_times" will have a
value of 10 (the integer).  Upon returning,
999 will be assigned to "value".

THE "SET" STATEMENT:
---------------------------------------------
"SET" allows you to set the value of an
animation/stimulus/control name.

SET [animation/stimulus/control name]
 =                                    [value]

Fill in the animation/stimulus/control name
along with the value to set it to.  If the
name is an animation or stimulus name, the
Control Editor itself will generate an event
that could drive control by triggering a
matching "WHEN" statement (if one exists).

Note that [value] may be any value that can
be used in an "IF" statement (see "A Note On
[value]" in THE "IF" STATEMENT section
above).

THE "MATH" STATEMENT:
---------------------------------------------
"MATH" is used to set an animation/stimulus/
control name to a mathematical expression
(usually involving another animation/
stimulus/control name).

MATH [animation/stimulus/control name]
 =   [animation/stimulus/control name]
 +      plus
 -      minus
 *      times
 /      divided by
 %      remainder
        no operation (left blank)     [value]

"MATH" is a more involved "SET" statement in
that it allows basic mathematical operations
to be performed before setting the animation/
stimulus/control name to a value.  For
instance, you could set NAME_A = NAME_B + 5,
or NAME_C = NAME_D / NAME_E.  Notice that
when "no operation" is chosen as the
operator, the "MATH" statement degenerates
to a "SET".

Fill in the animation/stimulus/control name
to be set and the operand name and value.
Select the operation by pressing MB1 down on
the button labeled with an operator (+ -, *,
/, %, blank), then selecting the appropriate
one from the menu.

Note that [value] may be any value that can
be used in an "IF" statement (see "A Note On
[value]" in THE "IF" STATEMENT section
above).

THE "EXPR" STATEMENT:
---------------------------------------------
"EXPR" is used to compute more complicated
expressions than those possible with "SET"
or "MATH".

EXPR [animation/stimulus/control name]
 =                               [expression]

The "EXPR" statement allows setting an
animation/stimulus/control name to the
result of almost any mathematical or logical
expression.  Legal operands are:

 - an integer or floating point value
 - an animation/stimulus name (whose integer
   value will be used)
 - a control name (parameter or local of
   a "ROUTINE" or a global)
 - a string enclosed in double-quotes
 - a library function, specified by placing
   a $ in front of the name (ie $sin - see
   below for supported library functions)
 - an interpreter command enclosed in
   brackets (see $format and $scan in the
   library functions section below)

Legal operators are (grouped in decreasing
order of precedence):

- ~ ! unary minus, bit-wise NOT, logical
      NOT.  Valid for all numeric operands
      except bit-wise NOT, which only
      applies to integers.
* / % multiply, divide, remainder.  Valid
      for all numeric operands except
      remainder, which only applies to
      integers.
+ -   add, subtract.  Valid for all numeric
      operands.
<< >> left shift, right shift. Valid for
      integer operands.
< <=  boolean less, less than or equal,
> >=  boolean greater, greater than or
      equal.  Each produces a 1 if true,
      0 if false.  Valid for all numeric and
      string operands (in which case string
      comparison is used).
== != boolean equal, not equal. Each
      produces 1 if true, 0 if false.  Valid
      for all numeric and string operands.
&     bit-wise AND.  Valid for integer
      operands.
^     bit-wise exclusive OR.  Valid for
      integer operands.
|     bit-wise OR.  Valid for integer
      operands.
&&    logical AND.  Produces 1 if both
      operands are non-zero, 0 if not.
      Valid for all numeric operands.
||    logical OR.  Produces 1 if either
      operand is non-zero, 0 if not.
      Valid for all numeric operands.
x?y:z if-then-else.  if x evaluates to non-
      zero, then y is value of expression,
      otherwise z.  x must be numeric.

Evaluation is left to right and "lazy",
meaning operands are only evaluated if
needed to determine the final result.  Note
that precedence can also be controlled by
grouping sub-expressions with parentheses,
as in 5+(3/4) vs. (5+3)/4.

Library functions for use in expressions
take floating point OR integer values as
parameters and return floats (unless other-
wise noted) and are listed in alphabetical
order:

$abs(x)   - absolute value of x
$acos(x)  - arccosine of x
$asin(x)  - arcsine of x
$atan(x)  - arctangent of x
$atan2(y,x) - arctangent of y/x
$ceil(x)  - smallest integer not less than x
$cos(x)   - cosine of x
$cosh(x)  - hyperbolic cosine of x
$double(x)  - convert integer x to floating
              point value
$exp(x)   - e raised to the x power
$floor(x) - largest integer not greater
            than x
$fmod(x,y)  - floating point remainder of x
              divided by y
$hypot(x,y) - square root of ((x*x)+(y*y))
$int(x)   - floating point value x truncated
            (returns integer)
$log(x)   - natural logarithm of x
$log10(x) - logarithm base 10 of x
$pow(x,y) - x raised to the y power
$round(x) - floating point value x rounded
            (returns integer)
$sin(x)   - sine of x
$sinh(x)  - hyperbolic sine of x
$sqrt(x)  - square root of x
$tan(x)   - tangent of x
$tanh(x)  - hyperbolic tangent of x

Two interpreter commands which are accessed
similarly to library functions are worthy of
special note:

$format   - provides output capability
            similar to C's sprintf().
$scan     - provides input capability
            similar to C's sscanf().

Common conversion characters are:  %d for
decimal (integer), %c for character, %s for
string, and %f for floating point value.
For example (notice the brackets around the
entire command, which are NOT used around
regular library functions):

[$format "%s times %s is %d" "two" "five" 10]

returns the string:  "two times five is 10"

Note that $format ALWAYS returns a string
value.

If string = "the answer is 10",
[$scan string "%s %s %s %f" #a #b #c #d]

assigns "the" to a, "answer" to b, "is" to
c, and the floating point value 10.0 to d.

Note the '#' preceding all variable names
being set by $scan - it is ALWAYS required,
but ONLY for the $scan command.

For more information on $format and $scan,
see sprintf() and sscanf() documentation in
any C reference manual.  Likewise all
supported library functions have equivalent
routines in a C reference manual.

THE "COMMENT" STATEMENT:
---------------------------------------------
"COMMENT" can be used to add comments to the
control.

[any text you like]

The "COMMENT" statement allows you to inter-
sperse comments in your control definition.
Comments generally document what and why
something was done the way it was.

THE "END" STATEMENT:
---------------------------------------------
"END" indicates the end of the block of
control statements under the nearest "WHEN",
"IF", "ELSE", "ELSEIF", "LOOP", or "ROUTINE".

END

For instance:

IF [name1]
== [value1]
  SET [name2]
  =   [value2]
  SET [name3]
  =   [value3]
END         <- End of statements under "IF"
ELSE
  SET [name4]
  =   [value4]
  SET [name5]
  =   [value5]
END         <- End of statements under "ELSE"

THE "RETURN" STATEMENT:
---------------------------------------------
"RETURN" (only available under "ROUTINE")
returns a value and control to the "CALL"er.

RETURN [value]

The "RETURN" statement allows a routine to
exit prior to the end of the routine and,
optionally, return a value which will be
assigned to the name in the matching "CALL"
statement's "RESULT" field.

Note that [value] may be any value that can
be used in an "IF" statement (see "A Note On
[value]" in THE "IF" STATEMENT section
above).

screen 20
THE ADVANCED STATEMENTS:

The advanced statements perform special oper-
ations that are beyond the capabilities of
primary statements.  As an example, the
"File_I/O" advanced statements open, read,
write, and close text files.  The "Advanced"
button is at the bottom of the list presented
after the "Add..." button is pressed under
a "WHEN" or "ROUTINE" statement.  Choosing
that button pulls down a menu with a
"File_I/O" item, a "Views" item, and a
"Misc" item.

Selecting the "File_I/O" menu item presents
another statement list with:

- "OPEN" for opening a text file.
- "WRITE" for writing to a text file.
- "READ" for reading from a text file.
- "CLOSE" for closing a text file.

Selecting the "Views" menu item presents
another statement list with:

- "OPEN_VIEW" for opening a new view into the
  current design.
- "CLOSE_VIEW" for closing a view.
- "OPEN_DESIGN" for opening a new design file
  in the current Altia session.
- "CLOSE_DESIGN" for closing a design file.

Selecting the "Misc" menu item reveals:

- "EXTERN" for executing an external routine
  located in a shared, or dynamically
  linked, library.

The File I/O "OPEN" STATEMENT:
---------------------------------------------
"OPEN" opens the given text file for the
given operation.

OPEN [file name] [mode]
                 r     open for reading from
                 w     open for writing to
                 a+    open for appending to

Pressing MB1 down on the button at the end of
the file name text entry field reveals a menu
that allows selection of the operation:  "r"
for reading, "w" for writing, and "a+" for
appending.

A Note On [file name]:
---------------------
[file name] may be:

- a string value in double quotes, like
  "filename"
- a control name (parameter/local/global)
  containing a string
- a Text I/O Object's "text" animation name
  whose value is to be used
- a control name or Text I/O Object's "text"
  animation name preceded by "@" (ie @name),
  meaning use that name's value as the name
  of the name whose value is to be
  substituted

The File I/O "WRITE" STATEMENT"
---------------------------------------------
"WRITE" writes the given value to the given
text file, appending the given delimiter.

WRITE [value]      [delimiter]
FILE  [file name]  SPACE     delimit w/space
                   TAB       delimit w/tab
                   RETURN    delimit w/return

The file name should be of a file previously
"OPEN"ed (see the "OPEN" statement).  The
value is written to the file, followed by
the chosen delimiter.

A Note On [value]:
-----------------
[value] may be:

- a string value in double quotes, like
  "this is a string"
- a control name (parameter/local/global)
  containing a string
- a Text I/O Object's "text" animation name
  whose value is to be used
- a control name or Text I/O Object's "text"
  animation name preceded by "@" (ie @name),
  meaning use that name's value as the name
  of the name whose value is to be
  substituted

The File I/O "READ" STATEMENT:
---------------------------------------------
"READ" sets the given animation/stimulus/
control name to the value read from the file.

READ [name]        [delimiter]
FILE  [file name]  SPACE     delimit w/space
                   TAB       delimit w/tab
                   RETURN    delimit w/return

The file name should be of a file previously
"OPEN"ed (see the "OPEN" statement).  The
text in the file should be numeric or a
double-quoted string, delimited by the chosen
delimiter.

A Note On [name]:
----------------
[name] may be:

- any animation/stimulus/control name
- a control name or Text I/O Object's "text"
  animation name preceded by "@" (ie @name),
  meaning use that name's value as the name
  of the name whose value is to be set

The File I/O "CLOSE" STATEMENT:
---------------------------------------------
"CLOSE" does just that:  it closes the given
file.

CLOSE [file name]

The file name should be of a file previously
"OPEN"ed (see the "OPEN" statement).

The Views "OPEN_VIEW" STATEMENT:
---------------------------------------------
"OPEN_VIEW" opens a new view into the current
design.  The new view is a completely
separate window, and usually displays a
different portion of the design.

OPEN_VIEW [id] [x] [y]
 ref win [Root/Main/ID] [width] [height]
 ref x [ry] style [Toplevel/Child] mag [mag]
 ref y [ry] name [name]

A unique identification number [id] is
assigned to the new view.  If [id] is the
number of an existing view, that view is
updated according to the remaining values in
the OPEN_VIEW statement.  [id] cannot be 0
because this id is reserved for the main
view.

The area of the design that should appear in
the view is specified with [x] and [y], the
design file coordinates that should appear at
the lower left corner of the view.  If
unspecified, the defaults for the main view
are used.

A new view is positioned relative to an
existing reference window.  The reference
window can be the [Root] Window, which is the
screen itself, the [Main] Window, which is
the main Altia view, or another view window
that has a specific [ID] number.  Use the
"ref win" menu to select the appropriate
option.  The relative position of the new
view to the reference window's lower left
corner is specified by setting [rx] and [ry].
If unspecified, the center of the reference
window is chosen.

The new view's [width] and [height] are given
in screen pixels.  If left empty, the width
and heigth of the main view are used.

The window style for a new view is specified
by choosing [Toplevel] or [Child] from the
"style" menu.  A window with a Toplevel style
is independent from its reference window.  A
Child style window will stay on top of its
reference window and move when the reference
window moves.  Currently, only [Toplevel] is
supported.

The magnification factor for the view is
specified by setting [mag] (which can be a
floating point value, such as .75).  If
empty, the magnification of the main view is
used.

The [name] field specifies the name of the
view.  If unspecified, the view will have a
name of the form "UserView#[id]".

A Note On [id], [x], [y], [width], [height],
[ID], [rx], [ry], [mag]
--------------------------------------------
These fields may be numeric or any animation/
stimulus/control name whose current value is
numeric.

A Note On [name]:
-----------------
[name] may be a string in double quotes or
any control name whose current value is a
string.  In addition, a Text I/O object's
"text" animation name can be used, as can
@name, meaning use that name's value as the
name of the name whose value is to be
substituted.

The Views "CLOSE_VIEW" STATEMENT:
---------------------------------------------
"CLOSE_VIEW" closes a view previously opened
with "OPEN_VIEW".

CLOSE_VIEW [id]

[id] is the identification number of the view
to close.  It must be an id number for a view
previously opened with an "OPEN_VIEW" state-
ment.  An [id] of 0 is ignored because it
refers to the main view.  To close an Altia
session, use a SET statement that looks like:

  SET altiaQuit = 1

The Views "OPEN_DESIGN" STATEMENT:
---------------------------------------------
"OPEN_DESIGN" opens a new design file in
the current Altia session.

OPEN_DESIGN [id]
  FILE [file name]

A unique identification number [id] is
assigned to the new design.  If [id] is the
number of a design already open, that design
is replaced by the new one and all its
views are updated appropriately.

After a design is opened with "OPEN_DESIGN",
additional views into the new design can
be opened using the "OPEN_VIEW" statement.

A Note On [id]:
---------------
This field may be numeric or any animation/
stimulus/control name whose current value is
numeric.

A Note On [file name]:
----------------------
[file name] may be a string in double quotes
or any control name whose current value is a
string.  In addition, a Text I/O object's
"text" animation name can be used, as can
@name, meaning use that name's value as the
name of the name whose value is to be
substituted.

A Note On the "altiaInitDesign" Animation
-----------------------------------------
After all objects in a new design have been
loaded and initialized, Altia automatically
generates an event with the name
"altiaInitDesign" with a value equal to [id].
Creating a "WHEN" block to catch this event
provides an opportunity to do further ini-
tialization of the design.  For example,
the "WHEN" block might contain one or more
"SET" statements to clear Text I/O Objects in
the new design.  A design can have any num-
ber of "WHEN" blocks for "altiaInitDesign".
Also remember that the value for the event
is equal to [id].  This allows different
"WHEN" blocks to execute when different
design files are loaded.  When the main
design is loaded, the value for the event
is 0.

A Note On the "altiaSetDesignId" Animation
------------------------------------------
"OPEN_DESIGN" sets an internal Altia anima-
tion named "altiaSetDesignId" to the value
of [id].  Subsequent "OPEN_VIEW" statements
check this value when they execute to decide
which design a new view belongs to.  Another
"Views" statement should be available to
change the active design id value at any
time, but is not yet available.  Instead,
the internal "altiaSetDesignId" animation
must be changed with a "SET" statement that
looks like:

  SET altiaSetDesignId = [value]

The Views "CLOSE_DESIGN" STATEMENT:
---------------------------------------------
"CLOSE_DESIGN" closes a design previously
opened with "OPEN_DESIGN".

CLOSE_DESIGN [id]

If one or more views are opened for the
design with the identification number [id],
the views are closed automatically.  An [id]
of 0 is ignored because it refers to the main
view.  To close an Altia session, use a SET
statement that looks like:

  SET altiaQuit = 1

The Misc "EXTERN" STATEMENT:
---------------------------------------------
"EXTERN" executes an external routine located
in a shared, or dynamically linked, library.

EXTERN
ROUTINE [routine name]
PARAMS  [routine parameters]
LIBRARY [file name]
RESULT  [animation/stimulus/control name]
                                  RETURN
                                  TYPE [type]

"EXTERN" executes the named routine, giving
it the listed parameters (values).  If
filled in, the name in the "RESULT" field
will be given the value returned by the
routine and will be of the indicated type:
"STRING", "INTEGER", or "NONE".  Fill in the
routine name, any required parameters, the
file name of the shared library in which the
routine is located, and the name to assign
the result to.  Select the return type by
pressing MB1 down on the button labeled
with a type, then selecting the appropriate
one from the menu.

screen 21
DEBUGGING CONTROL:

The Control Editor has several features that
aid in the debugging of control definitions.
Selecting the "List All Control..." menu item
from the "Options" menu lists all control
definitions, in textual format, to the given
file.  The "Stop/Cont", "Step", and "BreakPt"
buttons provide run-time control over those
same definitions.

The "List All Control Names..." menu item
from the "Options" menu lists all animation/
stimulus/control names used by all objects
in the current design, in textual format, to
the given file.  This list includes a cross
reference between names and referencing
objects.

RUN-TIME CONTROL:
---------------------------------------------
The Control Editor has several buttons to
provide "run-time control" over the control
definitions:

- "Stop/Cont" is labeled "Stop" when control
  is executing, "Cont" when "Stop" was
  pressed previously.  It permits you to
  stop/start execution of ALL control defini-
  tions for ALL objects.
- "Step" executes the next control statement,
  then stops.
- "BreakPt" sets a break point at the
  selected statement.  If and when execution
  reaches that statement, execution will
  stop PRIOR to its execution.  Note that
  break points are automatically cleared once
  they are reached.

When a statement is "Step"ped to or a break-
point is reached, the graphic object to which
that statement is "attached" is selected in
the Graphics Editor and the statement itself
is selected (ie "handles" appear around the
statement) in the Control Editor.  In the
case of a "WHEN" or "ROUTINE" statement, it
will expand to display all control statements
under it.

screen 22
PIE OBJECT MODELS:

The design file

\usr\altia\models\more\pie.dsn

contains a basic pie object, and several pie
objects that include control and stimulus
to demonstrate the object's capabilities.

Previous to Altia Design 2.0, the pie.dsn
models library contained pie objects that
were created using standard animation.  This
new library contains examples of a pie object
that has built-in animations.  This gives it
far more flexibility than the previous pie
examples.  For example, this latest pie ob-
ject supports more than one "slice".  Each
slice can have a specific span, color, and
optionally a text label.  Slices can be added
or deleted dynamically using control state-
ments or client application code.  It is
also possible to set and change the radius of
the pie dynamically.

THE PIE set ANIMATION:
---------------------------------------------
To change the label, color, or span of an
existing slice or add a new slice, the "set"
animation state must first be set to identify
the number of the slice.  The identifying
number for a slice can be any value.  A slice
with a greater identifying number covers all
slices with lower numbers if they happen to
overlap.

The default state for the "set" animation is
0.  Any label, color, or span changes made
without setting the "set" animation will
affect the number 0 slice.

THE PIE label ANIMATION:
---------------------------------------------
To add a text label to a slice, the char-
acters for the label are send as state values
to the "label" animation.  For example, the
following set of control statements would
set the label for slice 2 to the text XXX:

  SET set = 2
  SET label = "XXX"
  SET draw = 0

And the following calls in a client appli-
cation program would do the same:

  AtSendEvent(id, "set", 2);
  AtSendText(id, "label", "XXX");
  AtSendEvent(id, "draw", 0);

A label change will not show on the display
until the "draw" animation state is set to
any value.  This is also true for color or
span changes.

To clear an existing label, send the text
string " " (A string containing a single
Space character).

The FOREGROUND color for the pie object is
the color used to draw each label.  Different
labels for different slices cannot be shown
in different colors.

THE PIE color ANIMATION:
---------------------------------------------
To set the color for a slice, the "color"
animations is sent a string of state values
giving the color's name in text form.  The
color name can be in one of 3 forms:

- A literal color name:
  For example, "red" or "white".  On Windows
  systems, recognizable names are defined
  by entries in the \usr\altia\bin\colors.ali
  file.  Upper or lower case characters can
  be used (e.g., "red" is the same as "Red"
  or "RED").  On UNIX system, the X window
  system's rgb.txt file defines the names
  that can be recognized.

- A decimal RGB color specification:
  This is a string of the form "X Y Z" where
  X, Y, and Z are the intensity values for
  red, green, and blue respectively.  For ex-
  ample, "0 0 255" is the color blue.  Nor-
  mally, the intensity values are in the
  range from 0 to 255.

- A hex RGB color specification:
  This is a string of the form "#XXYYZZ"
  where XX, YY, and ZZ are 2-digit hex num-
  bers representing the intensities for red,
  green, and blue respectively.  For example,
  "#0000ff" is the color blue.

As an example, the following set of control
statements would set the color for slice 2
to green (RGB 0 255 0) and its label to "A":

  SET set = 2
  SET color = "0 255 0"
  SET label = "A"
  SET draw = 0

And the following calls in a client appli-
cation program would do the same:

  AtSendEvent(id, "set", 2);
  AtSendText(id, "color", "0 255 0");
  AtSendText(id, "label", "A");
  AtSendEvent(id, "draw", 0);

A color change will not show on the display
until the "draw" animation state is set to
any value.  This is also true for label or
span changes.

If the "color" animation for a particular
slice is never set, then the slice is drawn
using the current BACKGROUND color for the
pie object.

THE PIE percent ANIMATION:
---------------------------------------------
The "percent" animation is set to define the
span for a slice where 0 is no span and 100
is a span of 360 degrees.  The slice with the
lowest identifying number starts at the angle
0 origin (3 o'clock) and spreads counter-
clockwise.  Additional slices start where the
previous slice stops and also spread in the
counter-clockwise direction.

As an example, the following set of control
statements would set the span for slice 2
to 30 and its label to "A":

  SET set = 2
  SET span = 30
  SET label = "A"
  SET draw = 0

And the following calls in a client appli-
cation program would do the same:

  AtSendEvent(id, "set", 2);
  AtSendEvent(id, "span", 30);
  AtSendText(id, "label", "A");
  AtSendEvent(id, "draw", 0);

A span change will not show on the display
until the "draw" animation state is set to
any value.  This is also true for label or
color changes.

If the total span for all slices exceeds 100,
then the slices with higher identifying num-
bers will spread OVER the lowest slices.

If an individual slice's "percent" animation
is set to a value less than 0 or greater
than 100, the slice will have a span of 0.

Finally, to change the origin for the first
slice, simply rotate the pie object using the
Graphics Editor's rotate tool or precise ro-
tate dialog.  To change the span direction,
scale the object in the X or Y direction by
-1 using the precise scale dialog.

THE PIE draw ANIMATION:
---------------------------------------------
Before "label", "color", "percent", or
"delete" animation changes can change the
appearance of a pie object, the "draw" ani-
mation state value must be set.  It can be
set to any value.  This behavior allows for
the changing of multiple attributes for one
or more slices in an "instantaneous" manner.

THE PIE radius ANIMATION:
---------------------------------------------
A new state value for the "radius" animation
changes the radius for all slices in the pie.
The value defines the new radius in pixel
units.  The radius changes immediately.  It
does not require the setting of the "draw"
animation as with the "label", "color",
"percent", and "delete" animations.

THE PIE delete ANIMATION:
---------------------------------------------
To delete a specific slice from a pie, set
the state of the "delete" animation to the
identifying number for the slice and then
set the state for the "draw" animation to
any value.

As an example, the following set of control
statements set the label and span for slice
2 and delete slice 3:

  SET set = 2
  SET span = 30
  SET label = "A"
  SET delete = 3
  SET draw = 0

INITIALIZING ANIMATIONS OF A PIE:
---------------------------------------------
The various animations for a pie object are
initialized using the Animation Editor. Se-
lect the object so that its animation func-
tion names appear in the Animation Editor's
"Defined STATES and FUNCTIONS:" list.  High-
light the animation name whose state you wish
to change.  The name will appear in the
"Name:" field of the Animation Editor.  In
the "State:" field, enter a new value or use
the up/down arrows to increment or decrement
the current value.

For the "label", "color", and "percent"
animations, you must first adjust the state
of the "set" animation to identify the slice
that should be changed.  For these same ani-
mations with the addition of "delete", you
must finish by setting the "draw" state to
see the new changes.

For the "label" and "color" animations, it is
possible to enter an entire text string.  In
the "State:" field, enter your string de-
limited by double-quote marks.  For instance,
to set the "label" animation to the string
"XYZ", you would have the following:

    Name:label   State:"XYZ"

As soon as you press Enter/Return while in
the "State:" field or move the cursor out of
the field, the text in the delimited string
will be sent in sequence to the "label"
animation.

When you save a design to a file, the current
states for the various animations are also
saved.  Next time you read in the design, the
various modes of the object will be the same
as when the design was saved.

RENAMING ANIMATIONS:
---------------------------------------------
You can rename the animations for a partic-
ular pie object using the rename dialog that
appears when you move a copy of the object
from the Models View to the Graphics Editor's
drawing area.  In this way, you can have mul-
tiple textio objects in a single design that
work independently.

The recommended method of renaming is to add
a unique prefix to all existing names using
the Prepend option in the rename dialog. If
you do not rename animations and you copy or
paste more than one pie object into your de-
sign, all of the pie objects will update for
the same "set", "label", etc. animation state
changes.

Animations for existing objects in the work
area can be renamed by selecting the object,
and then choosing the "Rename Animation" menu
item from the Animation Editor's Edit
pulldown menu.

THE PIE EXAMPLES in pie.dsn:
---------------------------------------------

- Primitive pie
  This is a pie object with no additions.  It
  currently has only one slice - slice 0 -
  which appears in the BACKGROUND color last
  selected for the object from the Graphics
  Editor's color palette.  The color can be
  changed be selecting a new background color
  for the object after dragging it into the
  drawing area from a Models View.  This pie
  can be expanded into a multi-slice pie with
  labels and multiple colors by setting the
  various animations as summarized earlier in
  INITIALIZING ANIMATIONS OF A PIE.

- Sweeping seconds pie
  This pie is much like the primitive pie ex-
  ample in that it has a single slice - slice
  0 - which appears in the BACKGROUND color
  for the object.  In addition, however, it
  has control and timer stimulus that allows
  it to change the state of its percent ani-
  mation at 1 second intervals.  The buttons
  next to the object can be used in run mode
  to start and stop the pie's timer stimulus
  and execute one of its WHEN control blocks
  to reset the pie slice.

  To view the control for this pie, drag it
  from a Models View into the drawing area.
  With the object selected, press the Control
  button along the top of the editor to open
  the Control Editor.  To see the object's
  timer stimulus, press the Stimulate button
  to open the Stimulus Editor.

- 3 slice pie
  This pie object has interesting control
  added so it is easy to set the span of
  its 3 slices, enable/disable labels, and
  enable/disable a background.  The various
  sliders and switches can be copied with
  the object to exercise its capabilities
  in run mode.  This example demonstrates
  how control can be used to uniquely manage
  a pie's behavior.

  To view the control for this pie, drag it
  from a Models View into the drawing area.
  With the object selected, press the Control
  button along the top of the editor to open
  the Control Editor.

screen 23
SOUND OBJECT MODELS:

The design file

\usr\altia\models\more\sound.dsn

contains special objects for playing the set
of sounds supplied with the Altia Design
software.  It also includes a simple example
of a push button playing a sound.

Any one of these sound objects may be modi-
fied to play custom sounds as well.

Previous to Altia Design 2.0, the sound ob-
jects were just text input objects with stim-
ulus added for executing sounds.  With this
new release, a specialized sound object has
been added to the product.  This object has
built-in animations for improved sound capa-
bilities.  However, the improvements only
enhance the functionality on Windows systems
that have a Sound Blaster compatible sound
card.  Other PC systems with a built-in PC
speaker or UNIX systems may have reduced
capabilities which are noted throughout this
help topic.

USING SOUNDS FROM sound.dsn:
---------------------------------------------
Open the sound.dsn file from the "more"
Altia models directory into a Models View
window and drag one or more of the sound text
items from the Models View into your drawing
area.

To hear a particular sound, select the text
for it.  Open the Animation Editor using the
Animate button in the Graphics Editor.  A
list area in the Animation Editor displays
the various animations associated with the
object.  The first item in the list should
match the text displayed by the object.
Highlight this item in the list.  The Name:
field in the Animation Editor will update
automatically with the name.  Now change the
state for the animation by changing the value
in the State: edit field (you can edit it or
use the arrow buttons to increment or decre-
ment it).  You should hear the appropriate
sound play.

The value for a sound object's <sound> ani-
mation  may be set from stimulus, control,
or a client application program.  For ex-
ample, the following control statement would
play a ring sound if the associated ring
sound object is in the design:

    SET ring = 1

Note:  If you copy the same sound object into
the drawing area multiple times, you may get
multiple sounds every time that sound is
played.

THE SOUND <sound> ANIMATION:
---------------------------------------------
Each sound object has a <sound> animation.
The sounds supplied in the sound.dsn models
library have their <sound> animations named
the same as the sound that they play.  For
example, the beep sound object has a <sound>
animation named "beep".  Setting the state
of the <sound> animation to any value starts
the playing of the sound.

If a sound is already playing, the new sound
may interrupt the current sound or play after
the new sound finishes.  The behavior is
sound hardware dependent.

THE SOUND "soundStop" ANIMATION:
---------------------------------------------
For PC Windows systems with a Sound Blaster
compatible sound card, setting the state of
the "soundStop" animation to any value stops
the playing of the current sound.  State
changes for this animation are ignored for
all other types of sound hardware.

THE SOUND <sound>_done ANIMATION:
---------------------------------------------
For PC Windows systems with a Sound Blaster
compatible sound card, the value of
<sound>_done is set to a 1 when the <sound>
sound stops playing. A timer stimulus or con-
trol WHEN block can execute on the setting of
<sound>_done.  Here is a control example:

  WHEN beep_done = 1
    IF play_it_again_sam == 1
      SET beep = 1
    END
  END

In addition, a client application program can
receive <sound>_done state changes using
AtSelectEvent()/altiaSelectEvent with
AtNextEvent()/altiaNextEvent(), or
AtAddCallback() with an event callback.

A <sound>_done with state 1 occurs when a
sound stops because it finishes, when it is
stopped with a "soundStop" state change, or
when it is stopped because another sound is
started.

NOTE:  A <sound>_done with state 1 is only
generated for PC Windows systems with a Sound
Blaster compatible sound card.


THE SOUND <sound>_name ANIMATION:
---------------------------------------------
The sound played by a particular sound object
can be changed dynamically by sending a
string of character values to the
<sound>_name animation.  Consider the fol-
lowing control statements as an example:

    SET beep_name = "hello"
    SET beep = 1

This approach allows a design to have only
one or just a few actual sound objects that
are changed dynamically to play any number of
different sounds.

A client application program would use the
following calls to achieve the same result as
the control statements shown above:

  AtSendText(id, "beep_name", "hello");
  AtSendEvent(id, "beep", 1);

Also note that when the <sound>_name is given
a new text string, the text displayed by the
object automatically updates to the new name.
This is very useful for debugging purposes.

The new sound name must be the name of a
sound file that exists on the system.  The
file must reside in the current working
directory, a directory named sound under the
current working directory, or in the standard
Altia sound directory.  The file's format
must also be compatible with the system's
sound hardware.  If no file extension is pro-
vided (which is the recommended usage), then
the extension appropriate for the system will
be assumed.  For PC systems, this is .WAV.
For UNIX systems, this is .au (SUN audio file
format).

NOTE:  If a directory named sound is created
under the current working directory, all of
the sounds used by a design must reside in
this directory or the working directory.  If
a design uses sounds from the Altia sound di-
rectory, the sounds must be copied to the
local sound directory or the working direc-
tory.  On UNIX, it is also necessary to copy
the "soundit" program from the Altia sound
directory into the local sound directory.

THE SOUND "soundShow" ANIMATION:
---------------------------------------------
Each sound object found in the sound.dsn li-
brary displays the name of the sound it will
play as text.  This is helpful during the
design of an interface.  However, it may be
desirable to hide the objects when the design
is near completion or for demonstration pur-
poses.  This is easily done by setting the
state of the "soundShow" animation to 0.
Because all objects in sound.dsn have this
animation, they will all hide their text when
the state is set to 0.  The text will re-
appear if the state is set to 1 again.

Instead of hiding objects using the
"soundShow" animation, you can also place
them in a portion of the drawing area that
is not normally visible.  Use the left or
right arrows of the Graphics Editor's panner
to move the view into your design to an empty
area and copy or move the objects into this
area.  You can always view the objects again
in the editor by panning over to the same
area of the design.

THE SOUND <sound>_wait ANIMATION:
---------------------------------------------
For PC Windows systems with a Sound Blaster
compatible sound card, setting the value of
<sound>_wait to a 1 makes the Altia interface
process wait for a sound to finish playing
before continuing normal execution.  This is
useful for short sounds that must play in
their entirety without interruption.  The
<sound>_wait animation should NOT be set to 1
for long sounds - this will suspend execution
of the Altia interface process for a long
period of time (which will also suspend the
entire computer system if it is running
Windows 3.1).

THE SOUND PLAYING PROCESS:
---------------------------------------------
For PC systems, the actual playing, stopping,
and setting of the <sound>_done animation
when a sound finishes is performed directly
by the Altia interface process.  This can be
the Altia Design editor or Altia Runtime.

On UNIX systems, the sound is played by a
shell script or program named "soundit" lo-
cated in the Altia sound directory.  The en-
vironment variable ALTIASOUND indicates the
location of the "soundit" program.  This is
typically /usr/altia/sound.  The Altia Design
editor and Altia Runtime set ALTIASOUND auto-
matically if it is not already set.  If a di-
rectory named sound exists under the current
working directory, then ALTIASOUND is set to
this directory rather than the default Altia
sound directory.

For a discussion of the search algorithm for
the sound files themselves, please read the
earlier section labeled "THE SOUND
<sound>_name ANIMATION:"


SOUND HARDWARE REQUIREMENTS:
---------------------------------------------
Most UNIX computers are equipped with built-
in sound hardware and drivers.  AN EXCEPTION
is the HP/700 for which you must start the
Audio Server before sound can be used.  Re-
fer to the HP system's Aserver(1M) manual
page for more details.

On a PC, sound hardware, such as a Sound
Blaster compatible card, is an extra hardware
component.  Altia's sound playing process
will work with all sound cards that are
Windows compatible.  If you do not have a
sound card, you can use the small speaker
built into your system.  The sound from this
speaker will be poor quality and it will
temporarily lock your system while it is
playing a sound.  Using this speaker, how-
ever, will be better than nothing.  The fol-
lowing section explains how you can use this
speaker without special sound hardware.


INSTALLING A DRIVER TO USE THE BUILT-IN
PC SPEAKER:
---------------------------------------------
If you have no special sound hardware, you
can use the built-in PC speaker.  To use the
PC speaker, you must install the speaker dri-
ver.  Altia supplies this driver which can be
found in the Altia sound directory.  To in-
stall this driver, use the following Windows
procedure:

1. Double click on the Control Panel in the
   Main Windows program group.
2. Double click on the Drivers icon.
3. Select the Add button.
4. Choose the "Unlisted or Updated Driver"
   item and hit OK.
5. Enter the path to the Altia sound di-
   rectory - usually: c:\usr\altia\sound.
6. Select OK
7. Select OK again on the confirmation
   dialogue.
8. Follow the installation directions as you
   go.

Once the speaker driver is installed, 8 bit
sounds can be played without modification.


A SOUND DEMONSTRATION DESIGN:
---------------------------------------------
A demonstration design presenting Altia's
sound capabilities is installed with the
standard software.

On the PC, double-click on the Sound Demo
icon found in the Altia Design program group.
This will start an Altia Runtime interface
and load the design example.dsn from the
Altia sound directory.  Exercise the various
interface objects to try out the sounds.

On UNIX systems, execute the go script in the
altia/demos/sound directory.  It will load
the same example.dsn design file into an edit
session.  To start a runtime session instead,
execute go with a -run argument.


ADDING YOUR OWN SOUNDS:
---------------------------------------------
Altia has provided a small number of sounds
for you to use.  Each sound is stored as a
file in a format that your computer can play.
For example, PC sounds are stored as .WAV
files.  UNIX sounds are stored as .au files.
There are many more sounds available from
other sources, or you can record your own
using your own sound hardware.  These new
sounds can also be played by Altia.

To add your own sounds to Altia, do the
following:

1. Move the new sound file to the Altia sound
   directory. On Windows, use the File mana-
   ger or DOS copy to do the copy.  On UNIX,
   use the shell cp command.  The Altia sound
   directory is typically \usr\altia\sound on
   a PC or /usr/altia/sound on UNIX.
2. Within the Altia Design editor, copy an
   existing sound object from the sound.dsn
   library into your own design.  If the
   sound.dsn library is in a Models View,
   just drag and drop a sound string from the
   Models View window into the drawing area.
3. Edit the text in the object by selecting
   the object and then double-clicking on it.
   You must double-click on the body of the
   text and not on any of the handles.  In
   addition, all editor tool and command
   buttons must be off.
4. In text edit mode, change the sound name
   to match your new sound name and press the
   Enter/Return key to end text editing.
   NOTE:  The file name extension is not
   necessary if you use standard file for-
   mats - .WAV on the PC and .au on UNIX.
5. From the Animation Editor's "Edit" menu,
   open the rename dialogue and change the
   current prefix for the animation names to
   a new prefix using the Prepend option. For
   example, if you started with the "beep"
   object and your new sound is goodbye.wav
   (goodbye.au on UNIX), change the prefix
   "beep" to "goodbye".

A sound file may also be located in the cur-
rent working directory or a directory named
sound under the working directory.  Altia
will check for the sound file in these di-
rectories before trying to read it from the
Altia sound directory.  Or, a full path name
may be specified for the sound file as well
(e.g., c:\mysounds\hippo).  However, using a
full path name is not advised if you plan on
moving the sound files to a directory with a
different name at a later time.

NOTE:  If a directory named sound is created
under the current working directory, all of
the sounds used by a design must reside in
this directory or the working directory.  If
a design uses sounds from the Altia sound di-
rectory, the sounds must be copied to the
local sound directory or the working direc-
tory.  On UNIX, it is also necessary to copy
the "soundit" program from the Altia sound
directory into the local sound directory.


CONVERTING SOUND FILES:
---------------------------------------------
All UNIX systems support the SUN .au sound
file format while the .WAV format is most
popular on the PC.  UNIX users can convert
between these formats and additional formats
using the altia/sound/soundconvert program.
This is a freely distributed program being
supplied at no charge with the Altia Design
software.  For more details on this program,
UNIX users should read the text file
altia/sound/soundconvert.doc.


CREATING AN ALTIA RUNTIME APPLICATION
WITH SOUNDS:
---------------------------------------------
If you are distributing your design as an
Altia Runtime application and it uses sounds,
you have several ways of organizing your
files.

If you are setting up a single directory con-
taining your Altia design(s) and the Altia
Runtime program, simply copy the sound files
you are using to this same directory.  UNIX
users must also copy the "soundit" program as
well.  On the PC, you may wish to also in-
clude the speaker.drv and eomsetup.inf files
from the Altia sound directory so your users
can enable their built-in speaker if they
have no commercial sound hardware.

If you are setting up a hierarchy of direc-
tories, you can place the sound files in a
directory named "sound" along with the
"soundit" program.

For more information on creating an Altia
Runtime application, please read the Runtime
Application Note or call Altia technical
support to request a copy.

screen 24
BUILT-IN ALTIA FUNCTIONS:

Altia has a number of built-in functions with
capabilities beyond those of user-defined
animation/stimulus functions.  These func-
tions are listed below, grouped by category.

OBJECT INPUT:
---------------------------------------------
Functions controlling object input:

altiaEnableOnlyInput:
  when assigned/passed an object ID number,
  function disables all input areas of all
  OTHER objects (ie only the given object
  will receive input).  Subsequent calls
  with object ID numbers re-enable the input
  areas of those objects as well.

altiaDisableOnlyInput:
  when assigned/passed an object ID number,
  function disables all input areas of that
  object IF altiaEnableOnlyInput was
  previously called with that ID number.
  If the object ID number is 0, all input
  areas of all objects are re-enabled.

OBJECT STACKING ORDER:
---------------------------------------------
Functions controlling object stacking order:

altiaPopToTop:
  the object with the assigned/passed object
  ID number is moved to the top of the stack
  of objects, even if the object was inside
  a group.

altiaUnpop:
  the object with the assigned/passed object
  ID number is returned to its original
  position in the stacking order before
  altiaPopToTop was called.  If the object
  ID number is 0, all objects popped with
  altiaPopToTop are returned to their
  original positions.

OBJECT MOVEMENT:
---------------------------------------------
Functions controlling object movement:

altiaSetObj:
  identifies the object to be manipulated by
  the assigned/passed object ID number
  - should be called first!

altiaMoveObjX:
  sets the x pixel offset to the assigned/
  passed value.

altiaMoveObjY:
  sets the y pixel offset to the assigned/
  passed value.

Once BOTH offsets are set, the object ident-
ified by the previous call to altiaSetObj
moves relative to its current position.

OBJECT CLONING:
---------------------------------------------
Functions controlling object cloning:

altiaSetObj:
  sets the object ID number of the about-to-
  be-created clone to the assigned/passed
  value
  - should be called first!

altiaCloneObj:
  identifies the object to be cloned as the
  one with the assigned/passed object ID
  number, then clones the object and gives
  it the object ID number from the preceding
  call to altiaSetObj.

All animation/stimulus/control defined for
the original object is retained by the clone.
However, two types of modifications to these
definitions are made automatically to ease
manipulation of the clone:

1) all user-defined animation/stimulus
   functions are renamed by prepending "#:"
   to the original name (where # is the ob-
   ject ID number of the clone).  Note that
   the built-in functions being discussed
   here are NOT renamed.
2) any statement in the control definition
   that sets the value of a built-in function
   (other than altiaSetObj) to the object ID
   number of the original object is modified
   to use the ID number of the clone instead.

CLONE MANIPULATION:
---------------------------------------------
Functions manipulating cloned objects:

altiaSetObj:
  identifies the clone to be manipulated by
  the assigned/passed object ID number
  - should be called first!

altiaMoveClonedObjX:
  sets the x pixel offset to the assigned/
  passed value.

altiaMoveClonedObjY:
  sets the y pixel offset to the assigned/
  passed value.

Once BOTH offsets are set, the clone ident-
ified by the previous call to altiaSetObj
moves relative to its current position.

altiaDeleteClonedObj:
  deletes the clone with the assigned/passed
  object ID number.

altiaDeleteAllClones:
  when assigned/passed a value of 1, all
  clones will be deleted.

VIEW MANIPULATION:
---------------------------------------------
Functions manipulating views:

altiaSetView:
  identifies the view to be manipulated by
  the assigned/passed view ID number
  - should be called first!

altiaSetViewX:
  sets the x coordinate of the design which
  should appear in the lower left corner of
  the view.

altiaSetViewY:
  sets the y coordinate of the design which
  should appear in the lower left corner of
  the view.

Once BOTH coordinates are set, the view
identified by the previous call to
altiaSetView is updated to display the
indicated portion of the design.

altiaSetViewWidth:
  sets the width of the view to the
  assigned/passed value.

altiaSetViewHeight:
  sets the height of the view to the
  assigned/passed value.

Once BOTH dimensions are set, the view
identified by the previous call to
altiaSetView is updated to the new size.

altiaSetViewMag:
  sets the view's magnification to the
  assigned/passed value divided by 100.

altiaSetViewName:
  sets the name of the view:  call the
  function once with each ASCII character of
  the name and once with 0 after the entire
  name has been sent.  The view's banner is
  then updated with the new name.

altiaOpenView:
  opens a new view with the assigned/passed
  view ID number.

altiaOpenViewId:
  treats the window with the assigned/passed
  windowing system ID number as a new Altia
  view.

altiaCloseView:
  closes the view with the assigned/passed
  view ID number.

altiaCloseViewPending: (ONLY APPLICABALE IN
                    THE RUN_TIME ENVIRONMENT)
  if this event/function has been selected
  via the function "altiaSelectEvent()" in
  Altia's API, then a user action to close
  a run-time view will NOT close the view.
  Instead, this event will be routed, with
  the value being the ID number of the view
  the user tried to close.  This allows
  client control over the view exiting
  process, which could close the view via
  "altiaCloseView" (above), exit the run-time
  Altia session via "altiaQuit" (under DESIGN
  MANIPULATION below), or ignore the request
  altogether.

altiaGetViewSize:
  when assigned/passed a view ID number,
  two events/functions are routed:
  "altiaViewWidth" and "altiaViewHeight"
  with values of the view's width and height,
  respectively.

altiaWindowId:
  when assigned/passed a view ID number,
  routes the same event/function
  (altiaWindowId) with the windowing system
  ID number of the view's window.

altiaViewResize:
  Altia automatically routes this event/
  function when a view is resized by the
  user.  The value routed is the ID number
  of the view that was resized.

DESIGN MANIPULATION:
---------------------------------------------
Functions manipulating designs:

altiaOpenDesignFile:
  sets the name of a design file to open:
  call the function once with each ASCII
  character of the file name and once with 0
  after the entire name has been sent.  Note
  that to make the design visible, a view
  must also be opened.

altiaSetDesignId:
  identifies the design to be manipulated by
  the assigned/passed design ID number
  - should be called to identify the design
  prior to manipulating/cloning objects of
  or opening views into the design!

altiaCloseDesignId:
  closes the design with the assigned/passed
  design ID number.

altiaExecuteInitialStates:
  when assigned/passed a non-zero value, all
  open designs will have all their functions
  set to their initial states.

altiaQuit: (ONLY APPLICABALE IN THE
            RUN_TIME ENVIRONMENT)
  when assigned/passed any value, Altia will
  quit/exit.  The name of this function can
  be changed via an entry in the Altia
  configuration file.

altiaInitDesign:
  Altia automatically routes this event/
  function when a design is loaded.  The
  value routed is the ID number of the
  design that was loaded, starting with 0.

PROTOPLAY FUNCTIONS:
---------------------------------------------
Functions used in conjunction with ProtoPlay,
Altia's Netscape plug-in:

altiaURLCapable:
  ProtoPlay automatically routes this event/
  function once it has completed all
  necessary initialization.  The value
  routed is not significant.

altiaGetURL/altiaPutURL:
  retrieves the file associated with a URL:
  call "altiaGetURL" once with each ASCII
  character of the URL address and once with
  0 after the entire address has been sent.
  When retrieved, ProtoPlay will route the
  function "altiaPutURL" once with each ASCII
  character of the local file name and once
  with 0 after the entire name has been sent.

altiaGoToURL:
  displays the file associated with a URL in
  the web browser:  call the function once
  with each ASCII character of the URL add-
  ress and once with 0 after the entire
  address has been sent.  ProtoPlay will then
  ask the browser to display the file.

MISCELLANEOUS FUNCTIONS:
---------------------------------------------
Functions not appropriate for any of the
above categories:

altiaGetTimeCount:
  returns an ever-increasing time count, in
  milliseconds.  The count "wraps" back
  around to 0 when it overflows, and is
  always positive.

altiaStartProgram:
  gives the assigned/passed value (assumed
  to be a string containing the name of
  an executable program) to the system for
  execution.

altiaGenXRef:
  generates a name cross-reference of all
  symbols in the current design to a file:
  call the function once with each ASCII
  character of the file name and once with 0
  after the entire name has been sent.  Each
  symbol name in the generated cross-
  reference is followed by a hexadecimal
  code in parentheses.  Each bit of the code
  provides information about the symbol:

    bit 0 - if set, indicates symbol is an
            integer animation name
    bit 1 - if set, indicates symbol is a
            string animation name
    bit 2 - if set, indicates symbol is
            referenced by stimulus
    bit 3 - if set, indicates symbol is
            modified by stimulus
    bit 4 - if set, indicates symbol is
            reference by a timer
    bit 5 - if set, indicates symbol is
            modified by a timer
    bit 6 - if set, indicates symbol is
            referenced by a control statement
    bit 7 - if set, indicates symbol is
            modified by a control statement
    bit 8 - if set, indicates symbol is
            a global control variable
    bit 9 - if set, indicates symbol is
            a local control variable

screen 25
THE CONNECTIONS DIALOG:

The Connections dialog is used to view the
defined input and output connections for an
object and change the link(s) associated with
connections.  Connections link the behavior
of one object to another (e.g., the stimulus
value resulting from a knob's rotation is
linked to a meter's needle animation) or to
the external world (i.e., simulations or cli-
ent programs).  The objects to be connected
must have input connections and/or output
connections defined for them.  If an object
does not have any inputs or outputs, the list
area of the Connections dialog will be empty.
Adding connections to an object is described
later.

The dialog displays two basic types of
information.  The lines that start with
"INPUT" or "OUTPUT" list the input and
outputs defined for an object.  These lines
display an input/output name as well as the
type of data for the input/output.  The
lines that begin with "->" or "<-" describe
the other input/outputs that are connected to
the above input/output.  We call these lines
links since they represent links to other
objects.  The link lines list the name of the
input/output that is connected to and the id
number of the object that owns the
input/output.  If the connection is to the
external world then "external" is displayed.

LINKING TWO OBJECTS USING CONNECTIONS:
---------------------------------------------
To connect two objects together, do the
following steps.

1.  Select the first object you want to
    connect to.
2.  Shift-select the second object you want
    to connect to. Both objects should be 
    selected.
3.  Go to the connections menu and choose
    "Selected Objects".  This brings up a
    connection dialog for each object.
4.  Select the input/output of each object 
    that you want to connect to.  Note that
    inputs must be connected to outputs.
5.  Hit the connect button on either dialog
    and the objects are now connected.

UNLINKING A CONNECTION BETWEEN TWO OBJECTS:
---------------------------------------------
To disconnect two objects do the following.

1.  Bring up the connection dialog for one of
    the objects you want to disconnect.
2.  Select the "link" that you want to break.
3.  Hit the disconnect button.  This will
    disconnect the two objects and remove the
    links.

SHOWING THE OBJECTS ASSOCIATED WITH A LINK:
---------------------------------------------
To see what object a link is referring to
just select the link and from the Show menu,
choose "Connected Object".  This will select
the object that is connected by that link.

To see which object a specific Connections
dialog is associated with, choose "This
Object" from the Show menu.  This will
select the object for the dialog.

ADDING A NEW CONNECTION FOR AN OBJECT:
---------------------------------------------
To add a new connection for an object, select
the "Add Connection..." option from the Edit
menu.  You must do this from the Connections
dialog that is associated with the object.
In the resulting EditConnection dialog, you
choose a logical I/O name for the connection.
Next, you must choose the animation name that
the connection delivers values to or gets
values from.  In reality, the name entered
into this field can also be a stimulus or con-
trol name in addition to an animation name.

If a new connection is going to be an input
into the object, then the name is most often
an animation name as displayed by the Anima-
tion Editor when the object is the selected
object.  It can also be the name from a con-
trol WHEN block that is attached to the ob-
ject or one of its children if the object is
a group.  Or, it might be the name used to
start or stop a timer stimulus definition
that is attached to the object or one of its
children.

If a connection is going to be an output from
the object, it is most likely going to be a
stimulus execute name from a stimulus defini-
tion for the object or one of its children
if the object is a group.  It can also be the
destination name from a SET, MATH, or EXPR
statement that is part of a control block at-
tached to the object or one of its children.

Whether a new connection is going to be an
input or output, the name entered into the
Animation: field must be an animation, stimu-
lus or control name explicitly defined or
used by the object or one of its children.

After choosing the animation name, you must
confirm whether the connection is an input
our an output.  You also confirm the type for
the connection.  If this is an ordinary object
with animation, stimulus, or control created
directly from the Animation, Stimulus or Con-
trol Editor, the type is most likely Integer.
Some newer special Altia objects have built-
in animations that accept or generate float-
ing point numbers (e.g., 1.23 is a floating
point number while 1, 2, 5, 10 are integers).
If the name in the Animation: field refers to
one of these animations, then the Float type
should be chosen.

The Options: field is only used for the
special needs of specific simulation product
connections supported by Altia.  Please
refer to specific simulation connection
documentation for further details.

When you are satisfied with the settings for
the new definition, press the OK button.  If
a field contains inappropriate data, an error
dialog will appear.  You must press OK in the
error dialog and make appropriate changes to
the definition.  A common error is to mis-
spell the name entered into the Animation:
field or to provide an animation, stimulus,
or control name that is not actually associ-
ated with the object or any of its children.
Another common mistake is to choose an I/O
name that is already defined as a connection
for the object.

VIEWING/MODIFYING A CONNECTION'S DEFINITION:
---------------------------------------------
Highlight a connection in the list area and
choose the "Modify Connection..." option from
the Edit menu to open the EditConnection
dialog for the connection.  You can study the
connection's definition and make changes to
it if necessary.

screen 26
THE PROPERTY DIALOG:

The standard "models" directory (which you
can view by choosing the Models button from
the Graphics Editor) is now home to the Altia
FacePlate component libraries which contain
full featured and superbly rendered reusable
components.  Most of these components have
properties which allow you to customize their
behavior.

Drag one of these components into your draw-
ing area from a Models View window, select it
and double-click on it to display the Proper-
ty Dialog.  The dialog will immediately show
you the properties for the selected object
(i.e., component).

If you select a different object, the dialog
will refresh to show you the newly selected
object's properties.  You can also open the
Property Dialog from the Set Properties op-
tion in the Graphics Editor's Edit menu or
by using the Ctrl+I keyboard shortcut.

You can even add properties to objects that
you create if the objects have animation,
stimulus, or control.  To open the Property
Editor, choose Add Property... from the
Property Dialog's Edit menu.  You will be
asked to furnish a name for the property.
After entering a name, press the OK button
and the Property Editor will open.  Choose
Property Editor... from its Help menu for
further details.

screen 27
THE PROPERTY EDITOR:

Detailed help for the Property Editor is not
yet available.  However, if you are already a
power user of Altia Design, you can probably
teach yourself how to add properties using an
existing component as a starting point.

For example, open the sliders.dsn library and
drag in one of the slider components.

Double-click on it to display the Property
Dialog.  Now, double-click on one of the
property lines in the dialog (the Initial
Value line is a good one to start with).

This opens the Property Editor window for the
selected property.  You can highlight lines
in the Specifications section and the rest of
the editor fills in appropriately for the
specification.  Isn't it interesting that it
behaves a lot like the Stimulus Editor (i.e.,
fills in the rest of the editor, changes the
Define button to Redefine or vice-a-versa de-
pending on what's highlighted or not high-
lighted in the Specifications area).

If you open the Animation Editor and Stimulus
Editor in conjunction with the Property
Editor, you can see how an animation name
used in a property specification relates to
actual animation and stimulus definitions.
Some components also have control so you may
need to display the Control Editor and study
the control to completely understand why a
component works as well as it does.

You can cut, copy, and paste individual
specifications from the options in the Edit
menu of the Property Editor.  A specification
can even be copied and pasted between differ-
ent properties.  Just highlight a specifica-
tion and copy it. Then, select a new property
in the Property Dialog.  The Property Editor
window will refresh to show the specifica-
tions for the newly selected property.  Now
just paste the copied specification into
the current list of specifications using
the Paste Specification option from the
Property Editor's Edit menu.  You can only
cut/copy and paste one specification at a
time.

The Property Display... option in the Edit
menu lets you choose how a property's current
value should be displayed in the Property
Dialog.

You can also cut, copy, paste, add, or rename
complete properties from the Edit menu in
the Property Dialog.  The cut/copy and paste
even works between different components which
is very handy.  You can only cut/copy and
paste one property at a time.
