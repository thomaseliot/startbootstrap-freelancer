/* $Revision: 1.42 $    $Date: 2010-04-12 21:59:42 $
 * Copyright (c) 2001 Altia Inc.
 *
 * Permission to use, copy, and modify this software for any purpose is
 * hereby granted, provided that this copyright notice appears in all
 * copies and that the entity using, copying, or modifying this software
 * has purchased an Altia Deep Screen license. Permission to sell or
 * distribute this source code is denied. Altia makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without express or implied warranty.
 *
 * ALTIA INC. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
 * IN NO EVENT SHALL ALTIA INC. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "altiaBase.h"
#include "altiaTypes.h"


#ifdef ALTIAGL
/* For embedded target types like EGL_POS, include the
 * embedded target header file.
 */
#include "egl_Wrapper.h"
#endif /* ALTIAGL */

/* Windows only */
#if defined(WIN32) && !defined(MICROWIN)
#pragma warning( disable: 4244 4245 4305 4049 )
#endif

/*
 * This code was generated by Altia Design version:
 * STM32F4 Chrom-ART SW-Render for No O/S (v8.0.1)
 */

ALTIA_CONST ALTIA_INT test_window_width = 320;
ALTIA_CONST ALTIA_INT test_window_height = 240;
ALTIA_CONST ALTIA_INT test_window_xoffset = 0;
ALTIA_CONST ALTIA_INT test_window_yoffset = 0;
ALTIA_COLOR test_window_background = 0;

#ifdef ALTIA_TASKING
/* Size of Task Queue */
#ifndef ALTIA_TASK_QUEUE_SIZE
    #define ALTIA_TASK_QUEUE_SIZE   (100 + 22 + (1 * 64))
#endif

/* Size of Object Queue */
#ifndef ALTIA_OBJECT_QUEUE_SIZE
    #define ALTIA_OBJECT_QUEUE_SIZE (6 + 6)
#endif

/* Queues */
ALTIA_CONST ALTIA_INT altiaTaskQueue_count = ALTIA_TASK_QUEUE_SIZE;
AltiaTaskElementType altiaTaskQueue[ALTIA_TASK_QUEUE_SIZE];

ALTIA_CONST ALTIA_INT altiaObjectQueue_count = ALTIA_OBJECT_QUEUE_SIZE;
AltiaObjectElementType altiaObjectQueue[ALTIA_OBJECT_QUEUE_SIZE];
#endif /* ALTIA_TASKING */





#ifndef MAXLAYERS
    #define MAXLAYERS 1
#endif
ALTIA_CONST ALTIA_INT test_layers_count  = MAXLAYERS;
AltiaDevInfo test_layerDevInfo[MAXLAYERS];







ALTIA_CONST ALTIA_INT test_dobjs_count  = 6;

ALTIA_INDEX test_dobjsCurFunc[6];
AltiaEventType test_dobjsCurValue[6];
Altia_DynamicObjectRAM_type test_dobjsRAM[] =
{
    { 0, 1, { 0, 0, 64, 240 }, { 16384, 0, 0, 16384, 0, 0, 0, 0, 0 }, { 16384, 0, 0, 16384, 0, 0, 0, 0, 0 } },
    { 1, 1, { 18, 94, 293, 135 }, { 16384, 0, 0, 16384, 0, 0, 0, 0, 0 }, { 16384, 0, 0, 16384, 0, 0, 0, 0, 0 } },
    { 3, 2, { -285, 24, -60, 83 }, { 16384, 0, 0, 16384, 0, 0, 0, 0, 0 }, { 16384, 0, 0, 16384, 0, 0, 0, 0, 0 } },
    { 5, 1, { -220, 46, -125, 60 }, { 16384, 0, 0, 16384, -8519680, -20250624, 0, -8519680, -20250624 }, { 16384, 0, 0, 16384, -8519680, -20250624, 0, -8519680, -20250624 } },
    { 6, 2, { -220, 46, -125, 60 }, { 16384, 0, 0, 16384, -9879552, -20234240, 0, -9879552, -20234240 }, { 16384, 0, 0, 16384, -1359872, 16384, 0, -1359872, 16384 } },
    { -1, 0, { -220, 46, -125, 60 }, { 16384, 0, 0, 16384, -3596288, 753664, 0, -3596288, 753664 }, { 16384, 0, 0, 16384, 6283264, 20987904, 0, 6283264, 20987904 } }
};
ALTIA_CONST Altia_DynamicObjectROM_type test_dobjsROM[] =
{
    { 3, 14, -1, -1, 0, 6, 0, 0, 0, 1 },
    { 5, 14, -1, -1, 6, 6, 1, 0, 0, 1 },
    { 8, 14, -1, -1, -1, 0, 0, 0, 0, 0 },
    { 10, 14, -1, 2, 21, 1, 1, 0, 0, 0 },
    { 11, 14, -1, 3, -1, 0, 2, 0, 0, 0 },
    { 13, 16, 0, 4, 12, 9, 3, 0, 0, 0 }
};

#if (2 == 0)
Altia_DynamicState_type test_dstates[1];
#else
Altia_DynamicState_type test_dstates[] =
{
    { 0xffffffff, 0xffffffff, -1, -1, 1, -1, {16384, 0, 0, 16384, -3719166, -6012928, 0, -3719166, -6012928} },
    { 0xffffffff, 0xffffffff, -1, -1, 1, -1, {16384, 0, 0, 16384, -3719166, -6012928, 0, -3719166, -6012928} }
};
#endif

#if (4 == 0)
ALTIA_CONST Altia_DynamicStateC_type test_dstatesROM[1];
#else
ALTIA_CONST Altia_DynamicStateC_type test_dstatesROM[] =
{
    { 0xffffffff, 0xffffffff, -1, -1, 1, -1 },
    { 0xffffff, 0xffffffff, -1, -1, 1, -1 },
    { 0, 0xffffffff, -1, -1, 1, -1 },    { 0, 0xffffff, 0, 0, 1, -1 }
};
#endif






ALTIA_CONST ALTIA_INT test_sobjs_count  = 6;


Altia_StaticObjectRAM_type test_sobjsRAM[] =
{
    { { 0, 0, 321, 240 }, { 0, 0, 0, 0 }, { 16384, 0, 0, 16384, 0, 0, 0, 0, 0 } },
    { { 0, 0, 64, 240 }, { 0, 0, 0, 0 }, { 16384, 0, 0, 16384, 0, 0, 0, 0, 0 } },
    { { 18, 94, 293, 135 }, { 296089, 1546291, -81920, 1490944 }, { 14028, 0, 0, 14028, 296089, 1546291, 0, -81920, 1490944 } },
    { { 21, 188, 310, 233 }, { 344883, 3087564, 81920, -81920 }, { 14745, 0, 0, 14745, 344883, 3087564, 0, 81920, -81920 } },
    { { -285, 24, -60, 83 }, { 0, 0, 0, 0 }, { 16384, 0, 0, 16384, 0, 0, 0, 0, 0 } },
    { { -175, 50, -170, 60 }, { -1048576, 11952128, -1048576, 11952128 }, { 16384, 0, 0, 16384, -10928128, -8282112, 0, -10928128, -8282112 } }
};
ALTIA_CONST Altia_StaticObjectROM_type test_sobjsROM[] =
{
    { 0, 16777215, 2, -1, -1, -1, -1, 12, 0, 0, 1 },
    { 0, 16777215, 4, -1, -1, 0, -1, 12, 1, 0, 1 },
    { 0, 16777215, 6, -1, -1, 1, -1, 12, 2, 1, 1 },
    { 0, 16777215, 7, -1, -1, 1, -1, 12, 3, 2, 1 },
    { 0, 16777215, 9, 0, 0, 2, -1, 3, 0, 0, 1 },
    { 0, 16777215, 12, 0, 0, 4, -1, 3, 1, 0, 0 }
};





ALTIA_CONST ALTIA_INT test_states_count  = 10;

ALTIA_CONST Altia_StateEntryROM_type test_states[] =
{
    { 1, 0, 0, 0, -1, -1, -1, -1, -1 },
    { 0, 0, 0, 0, -1, -1, -1, -1, -1 },
    { 0, 0, 0, 0, -1, -1, -1, -1, -1 },
    { 0, 0, 0, 0, -1, -1, -1, -1, -1 },
    { 1, 0, 0, 0, -1, -1, -1, -1, -1 },
    { 1, 0, 0, 0, -1, -1, -1, -1, -1 },
    { 0, 0, 0, 0, -1, -1, -1, -1, -1 },
    { 0, 0, 0, 0, -1, -1, -1, -1, -1 },
    { 0, 0, 0, 0, -1, -1, -1, -1, -1 },
    { 1, 0, 0, 0, -1, -1, -1, -1, -1 }
};





ALTIA_CONST ALTIA_INT test_funcs_count  = 22;

ALTIA_CONST Altia_FunctionNameROM_type test_funcs[] =
{
    { 0, 1, 0, 2 },
    { 0, 1, 0, 1 },
    { 1, 1, 0, 1 },
    { 2, 1, 0, 1 },
    { 3, 1, 0, 1 },
    { 4, 1, 0, 1 },
    { 1, 2, 1, 2 },
    { 5, 1, 1, 1 },
    { 6, 1, 1, 1 },
    { 7, 1, 1, 1 },
    { 8, 1, 1, 1 },
    { 9, 1, 1, 1 },
    { 0, 0, 5, 5 },
    { 0, 0, 5, 3 },
    { 1, 0, 5, 5 },
    { 2, 0, 5, 5 },
    { 3, 0, 5, 5 },
    { 4, 0, 5, 5 },
    { 5, 0, 5, 5 },
    { 0, 0, 5, 4 },
    { 6, 0, 5, 5 },
    { -1, 0, 3, 1 }
};





ALTIA_CONST ALTIA_INT test_funcIndex_count  = 66;
ALTIA_CONST Altia_FunctionIndex_type test_funcIndex[] =
{
     {ALT_TEXT("GUI_ctrl_block_label_base_mode"), 0, 1},
{ALT_TEXT("GUI_ctrl_block_label_character"), 1, 1},
{ALT_TEXT("GUI_ctrl_block_label_clear"), 2, 1},
{ALT_TEXT("GUI_ctrl_block_label_decimal_pts"), 3, 1},
{ALT_TEXT("GUI_ctrl_block_label_float"), 4, 1},
{ALT_TEXT("GUI_ctrl_block_label_integer"), 5, 1},
{ALT_TEXT("GUI_ctrl_block_label_justify_mode"), 6, 1},
{ALT_TEXT("GUI_ctrl_block_label_set_style"), 7, 2},
{ALT_TEXT("GUI_ctrl_block_label_slide_append_on"), 9, 1},
{ALT_TEXT("GUI_ctrl_block_label_text"), 10, 1},
{ALT_TEXT("dash_home_card"), 11, 1},{ALT_TEXT("dash_home_change_card"), 12, 0},
{ALT_TEXT("dash_home_dec_bounds_test"), 12, 0},
{ALT_TEXT("dash_home_dec_card"), 12, 1},
{ALT_TEXT("dash_home_dec_change_val"), 13, 0},
{ALT_TEXT("dash_home_deckButtonInput"), 13, 1},
{ALT_TEXT("dash_home_decrement_event"), 14, 0},
{ALT_TEXT("dash_home_inc_bounds_test"), 14, 0},
{ALT_TEXT("dash_home_inc_card"), 14, 1},
{ALT_TEXT("dash_home_inc_change_val"), 15, 0},
{ALT_TEXT("dash_home_increment_event"), 15, 0},
{ALT_TEXT("dash_home_jump_to_card"), 15, 1},
{ALT_TEXT("dash_home_loop"), 16, 1},{ALT_TEXT("dash_home_looptype"), 17, 1},
{ALT_TEXT("dash_home_max_card"), 18, 1},
{ALT_TEXT("dash_home_min_card"), 19, 1},
{ALT_TEXT("dash_home_once"), 20, 1},{ALT_TEXT("dash_home_once_animation_done"), 21, 0},
{ALT_TEXT("dash_home_pingpong"), 21, 1},
{ALT_TEXT("dash_home_pointerLoop"), 22, 0},
{ALT_TEXT("dash_home_pointingToLayer"), 22, 0},
{ALT_TEXT("dash_home_pongDirection"), 22, 1},
{ALT_TEXT("dash_home_slider_or_knob_flag"), 23, 0},
{ALT_TEXT("dash_home_startTimer"), 23, 2},
{ALT_TEXT("dash_home_stop_animation"), 25, 1},
{ALT_TEXT("dash_home_timerToggler"), 26, 1},
{ALT_TEXT("dash_home_timer_event"), 27, 1},
{ALT_TEXT("dash_home_toggle_timer"), 28, 0},
{ALT_TEXT("status_bar_card"), 28, 1},{ALT_TEXT("status_bar_change_card"), 29, 0},
{ALT_TEXT("status_bar_dec_bounds_test"), 29, 0},
{ALT_TEXT("status_bar_dec_card"), 29, 1},
{ALT_TEXT("status_bar_dec_change_val"), 30, 0},
{ALT_TEXT("status_bar_deckButtonInput"), 30, 1},
{ALT_TEXT("status_bar_decrement_event"), 31, 0},
{ALT_TEXT("status_bar_inc_bounds_test"), 31, 0},
{ALT_TEXT("status_bar_inc_card"), 31, 1},
{ALT_TEXT("status_bar_inc_change_val"), 32, 0},
{ALT_TEXT("status_bar_increment_event"), 32, 0},
{ALT_TEXT("status_bar_jump_to_card"), 32, 1},
{ALT_TEXT("status_bar_loop"), 33, 1},{ALT_TEXT("status_bar_looptype"), 34, 1},
{ALT_TEXT("status_bar_max_card"), 35, 1},
{ALT_TEXT("status_bar_min_card"), 36, 1},
{ALT_TEXT("status_bar_once"), 37, 1},{ALT_TEXT("status_bar_once_animation_done"), 38, 0},
{ALT_TEXT("status_bar_pingpong"), 38, 1},
{ALT_TEXT("status_bar_pointerLoop"), 39, 0},
{ALT_TEXT("status_bar_pointingToLayer"), 39, 0},
{ALT_TEXT("status_bar_pongDirection"), 39, 1},
{ALT_TEXT("status_bar_slider_or_knob_flag"), 40, 0},
{ALT_TEXT("status_bar_startTimer"), 40, 2},
{ALT_TEXT("status_bar_stop_animation"), 42, 1},
{ALT_TEXT("status_bar_timerToggler"), 43, 1},
{ALT_TEXT("status_bar_timer_event"), 44, 1},
{ALT_TEXT("status_bar_toggle_timer"), 45, 0}
};
AltiaEventType test_curValue[] =
{
     3,0,0,2,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
0,0,0,0,0,0
};



ALTIA_CONST ALTIA_INT test_funcFIndexs_count = 45;

ALTIA_CONST Altia_FunctionFIndexROM_type test_funcFIndexs[] =
{
    { 0, 17 },
    { 0, 12 },
    { 0, 16 },
    { 0, 20 },
    { 0, 19 },
    { 0, 18 },
    { 0, 14 },
    { 0, 21 },
    { 1, 0 },
    { 0, 15 },
    { 0, 13 },
    { 0, 6 },
    { 1, 12 },
    { 1, 10 },
    { 1, 13 },
    { 1, 11 },
    { 1, 14 },
    { 0, 9 },
    { 0, 7 },
    { 0, 8 },
    { 1, 15 },
    { 1, 16 },
    { 0, 11 },
    { 3, 1 },
    { 4, 1 },
    { 1, 17 },
    { 0, 10 },
    { 1, 18 },
    { 0, 0 },
    { 1, 3 },
    { 1, 1 },
    { 1, 4 },
    { 1, 2 },
    { 1, 5 },
    { 0, 3 },
    { 0, 1 },
    { 0, 2 },
    { 1, 6 },
    { 1, 7 },
    { 0, 5 },
    { 3, 0 },
    { 4, 0 },
    { 1, 8 },
    { 0, 4 },
    { 1, 9 }
};





ALTIA_CONST ALTIA_INT test_basetrans_count = 3;
ALTIA_CONST Altia_BaseTrans_type test_basetrans[] =
{
    {16384, 0, 0, 16384, 0},{14028, 0, 0, 14028, 0},
{14745, 0, 0, 14745, 0}
};



ALTIA_CONST ALTIA_INT test_offtrans_count = 1;
ALTIA_CONST Altia_OffsetTrans_type test_offtrans[] =
{
    {3719166, 6012928, 3719166, 6012928}
};



ALTIA_CONST ALTIA_INT test_children_count  = 8;



ALTIA_CONST Altia_ChildEntryROM_type test_children[] =
{
    { 2, 1 },
    { 2, 2 },
    { 2, 3 },
    { 2, 4 },
    { 1, 3 },
    { 1, 4 },
    { 2, 5 },
    { 1, 5 }
};






ALTIA_CONST ALTIA_INT test_sequence_count  = 4;



ALTIA_CONST Altia_SequenceROM_type test_sequence[] =
{
    { 2, 0 },
    { 1, 0 },
    { 1, 1 },
    { 1, 2 }
};








ALTIA_INT test_patterns_count  = 1;
Altia_Pattern_type test_patterns[] =
{
     {-1, 0, 0}
};




ALTIA_CONST ALTIA_INT test_brushes_count  = 1;
Altia_Brush_type test_brushes[] =
{
     {0, 0, 0xffff, 0}
};



ALTIA_CONST ALTIA_INT test_fonts_count  = 1;
Altia_Font_type test_fonts[] =
{
     {ALT_TEXT("-msdpi-Arial-medium-r-normal--*-80-*-*-*-*-*-*"), 10, 3, 0}
};







ALTIA_CONST ALTIA_INT test_rects_count  = 2;
ALTIA_CONST Altia_Rect_type test_rects[] =
{
{ -285, 24, -60, 83, 1  },{ 492, 556, 497, 565, 1  }
};






/*
 * Temp array used to hold window coords after transform.
 * This array is used to draw most objects.  This array is
 * typically in the format required by the target's polygon
 * drawing routine.  The Altia routines that initiate the
 * actual drawing must properly handle the format.  Add an
 * extra point to close polygons (i.e., make a final point
 * that is the same as the first point) in case it is
 * necessary for polygon drawing on this target.
 *
 * NOTE:  Some compilers (e.g., Green Hills) require explicitly 
 *        aligning the array to an 8-byte boundary because it 
 *        gets cast to a structure and members of the structure 
 *        must be aligned (especially on MIPS).
 */
#ifndef ALTIA_NUMPTS_COUNT
#define ALTIA_NUMPTS_COUNT     5
#endif
ALTIA_CONST ALTIA_INT test_altiaDrawPtCount = (ALTIA_NUMPTS_COUNT + 1);
EGL_POS test_altiaDrawPts[(ALTIA_NUMPTS_COUNT + 1) * 2] ALTIA_ALIGN;










ALTIA_CONST ALTIA_INT test_labels_count  = 1;
Altia_Label_type test_labels[] =
{
     {ALT_TEXT("GUI_Control_Code"), 0, {0, 0, 93, 13}}
};





#if !ALTIA_DIB_MALLOC
/*
 * Next is one or more temp arrays used to build device
 * independent bitmaps (DIBs) when memory allocation is NOT
 * allowed.  Each is used during init time when rasters or
 * stencils get decoded and bitmaps are created.  Each is also
 * used when a raster or stencil needs to be scaled.  It stores
 * the uncompressed raster.
 *
 * The code generator sets the array size based on 3 bytes
 * required per color pixel (one byte each for red, green, and
 * blue).  This target uses 4 bytes per color pixel so we
 * adjust the array size by dividing by 3 and then multiplying
 * by 4.  The code generator pads an additional 40 bytes to
 * the array size to allow room for the target's bitmap data
 * structure as well.  For this target, 40 bytes is adequate.
 *
 * NOTE:  Some compilers (e.g., Green Hills) require explicitly aligning
 *        the array to a 4-byte boundary because it will hold a structure
 *        and members of the structure must be aligned (especially on MIPS).
 */
#define ALTIA_DIB_HEADER_MAX            (sizeof(EGL_DIB) + 256 * 4)

#define ALTIA_DIB_BITMAP_SIZE           ((77040 + 1) * 4)


#define ALTIA_DIB_MAX_SIZE              (ALTIA_DIB_HEADER_MAX + ALTIA_DIB_BITMAP_SIZE)
#define ALTIA_DIB_SCALED_BITMAP_SIZE    ((77601 + 1) * 4)
#define ALTIA_DIB_SCALED_MAX_SIZE       (ALTIA_DIB_HEADER_MAX + ALTIA_DIB_SCALED_BITMAP_SIZE)

ALTIA_CONST ALTIA_INT test_altiaMaxBitmap = ALTIA_DIB_MAX_SIZE;
ALTIA_UBYTE test_altiaBitmapData[ALTIA_DIB_MAX_SIZE] ALTIA_ALIGN;

ALTIA_CONST ALTIA_INT test_altiaMaxBitmap2 = ALTIA_DIB_SCALED_MAX_SIZE;
ALTIA_UBYTE test_altiaBitmapData2[ALTIA_DIB_SCALED_MAX_SIZE] ALTIA_ALIGN;

#endif /* !ALTIA_DIB_MALLOC */




/* Define arrays of scaled bitmap data structures
 * that are large enough for holding scaled versions
 * of all bitmaps in the unlikely event that every
 * bitmap gets scaled.
 */

ALTIA_CONST ALTIA_INT test_scaled_rasters_count  = 4;
Altia_Scaled_Raster_type test_scaledRaster[4];
Altia_Scaled_Save_Bits_type test_scaledSaveBits[4];






ALTIA_CONST ALTIA_INT test_rasters_count  = 4;





Altia_RasterID_type test_rasterid[4];
ALTIA_CONST Altia_RasterROM_type test_rastersROM[] =
{
    { 0, 0, 3, 0, 1214, -1, -1, 1214, 1214, 0, 0, 0, 0, 1214, 1216, 321, 240 },
    { 2430, 2672, 2, 2914, -1, -1, -1, 242, 242, 0, 0, 0, 0, 242, 0, 64, 240 },
    { 3156, 3600, 3, 4044, 4486, -1, -1, 444, 444, 0, 0, 0, 0, 442, 274, 321, 47 },
    { 4760, 5173, 3, 5594, 6025, -1, -1, 413, 421, 0, 0, 0, 0, 431, 284, 321, 49 }
};





#ifdef NO_PRELOAD
#if defined(PRELOAD_CNT) && (PRELOAD_CNT > 0)
ALTIA_CONST ALTIA_INT preload_raster_count = PRELOAD_CNT;
ALTIA_INDEX preLoadRaster[PRELOAD_CNT];
#endif  /* PRELOAD_CNT > 0 */
#endif  /* NO_PRELOAD */



ALTIA_CONST ALTIA_INT test_decks_count  = 3;

ALTIA_CONST Altia_DeckROM_type test_decks[] =
{
    { 0, 0, 1 },
    { 0, 1, 1 },
    { 1, 2, 1 }
};
























ALTIA_INT test_extents_count = 0;
ALTIA_CONST ALTIA_INT test_extents_max = 100;
Altia_Extent_type test_extents[100];




ALTIA_CONST ALTIA_INT test_custI_count = 7;

Altia_CustomIValueRAM_type test_custIRAM[] =
{
    { 1, 0 },
    { 9, 6 },
    { 1, 0 },
    { 1, 0 },
    { 17, 3 },
    { 1, 0 },
    { 17, 2 }
};
ALTIA_CONST Altia_CustomIValueROM_type test_custIROM[] =
{
    { 1, 0, 0 },
    { 4, 0, 7 },
    { 16, 0, 0 },
    { 32, 0, -1 },
    { 64, 0, 4 },
    { 128, 0, 0 },
    { 16384, 0, 256 }
};





ALTIA_CONST ALTIA_INT test_custF_count = 1;

Altia_CustomFValueRAM_type test_custFRAM[] =
{
    { 1, 0 }
};
ALTIA_CONST Altia_CustomFValueROM_type test_custFROM[] =
{
    { 8192, 0, 0 }
};





ALTIA_CONST ALTIA_INT test_custS_count = 1;
Altia_CustomSValue_type test_custS[] =
{
    {2, 0x1, ALT_TEXT("GUI_Control_Code"), 0}
};







ALTIA_CONST ALTIA_INT test_textios_count = 1;
Altia_TextioBSS_type test_textiosBSS[1];

Altia_TextioRAM_type test_textiosRAM[] =
{
    { 0, 0, 0, 6, 3, 2, 0, 0, 0 }
};
ALTIA_CONST Altia_TextioROM_type test_textiosROM[] =
{
    { 0, -1 }
};




#if (0 == 0)
ALTIA_CONST ALTIA_INT test_textioInputsBSS_count = 1;
Altia_TextioInputBSS_type test_textioInputsBSS[1];
Altia_TextioInput_type test_textioInputs[1];
#else
ALTIA_CONST ALTIA_INT test_textioInputsBSS_count = 0;
Altia_TextioInputBSS_type test_textioInputsBSS[0];
Altia_TextioInput_type test_textioInputs[] =
{

};
#endif






















ALTIA_CONST ALTIA_INT test_timerState_count = 2;
ALTIA_CONST Altia_TimerState_type test_timerState[] =
{
    {0, 0,  0, 1, ALT_TEXT("status_bar_timer_event"), ALT_TEXT("None")},
{0, 0,  0, 1, ALT_TEXT("dash_home_timer_event"), ALT_TEXT("None")}
};





ALTIA_CONST ALTIA_INT test_localTimers_count = 2;
AltiaTimerTime_t test_localTimers[2];




ALTIA_CONST ALTIA_INT test_timers_count = 2;

Altia_TimerRAM_type test_timersRAM[] =
{
    { 1 },
    { 1 }
};
ALTIA_CONST Altia_TimerROM_type test_timersROM[] =
{
    { 0, 0, 1, 0, 150, 0, 1 },
    { 0, 0, 1, 0, 150, 1, 1 }
};













































