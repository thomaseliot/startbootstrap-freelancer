
FrontSensorModule.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000a  00800100  00000cd2  00000d66  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000cd2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000063b  0080010a  0080010a  00000d70  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d70  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000da0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000218  00000000  00000000  00000de0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000022e2  00000000  00000000  00000ff8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000008cd  00000000  00000000  000032da  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000d0c  00000000  00000000  00003ba7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000005dc  00000000  00000000  000048b4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000cbb  00000000  00000000  00004e90  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002075  00000000  00000000  00005b4b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000230  00000000  00000000  00007bc0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
   4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
   8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
   c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  40:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
  7c:	11 24       	eor	r1, r1
  7e:	1f be       	out	0x3f, r1	; 63
  80:	cf ef       	ldi	r28, 0xFF	; 255
  82:	d0 e1       	ldi	r29, 0x10	; 16
  84:	de bf       	out	0x3e, r29	; 62
  86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
  88:	11 e0       	ldi	r17, 0x01	; 1
  8a:	a0 e0       	ldi	r26, 0x00	; 0
  8c:	b1 e0       	ldi	r27, 0x01	; 1
  8e:	e2 ed       	ldi	r30, 0xD2	; 210
  90:	fc e0       	ldi	r31, 0x0C	; 12
  92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
  94:	05 90       	lpm	r0, Z+
  96:	0d 92       	st	X+, r0
  98:	aa 30       	cpi	r26, 0x0A	; 10
  9a:	b1 07       	cpc	r27, r17
  9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
  9e:	27 e0       	ldi	r18, 0x07	; 7
  a0:	aa e0       	ldi	r26, 0x0A	; 10
  a2:	b1 e0       	ldi	r27, 0x01	; 1
  a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
  a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
  a8:	a5 34       	cpi	r26, 0x45	; 69
  aa:	b2 07       	cpc	r27, r18
  ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
  ae:	0e 94 5d 00 	call	0xba	; 0xba <main>
  b2:	0c 94 67 06 	jmp	0xcce	; 0xcce <_exit>

000000b6 <__bad_interrupt>:
  b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <main>:
#include "task.h"

#define mainLED_TASK_PRIORITY           ( tskIDLE_PRIORITY )

int main(void)
{
  ba:	af 92       	push	r10
  bc:	bf 92       	push	r11
  be:	cf 92       	push	r12
  c0:	df 92       	push	r13
  c2:	ef 92       	push	r14
  c4:	ff 92       	push	r15
  c6:	0f 93       	push	r16
    xTaskCreate( vLEDFlashTask, ( signed char * ) "LED", configMINIMAL_STACK_SIZE, 
  c8:	a1 2c       	mov	r10, r1
  ca:	b1 2c       	mov	r11, r1
  cc:	c1 2c       	mov	r12, r1
  ce:	d1 2c       	mov	r13, r1
  d0:	e1 2c       	mov	r14, r1
  d2:	f1 2c       	mov	r15, r1
  d4:	00 e0       	ldi	r16, 0x00	; 0
  d6:	20 e0       	ldi	r18, 0x00	; 0
  d8:	30 e0       	ldi	r19, 0x00	; 0
  da:	45 e5       	ldi	r20, 0x55	; 85
  dc:	50 e0       	ldi	r21, 0x00	; 0
  de:	60 e0       	ldi	r22, 0x00	; 0
  e0:	71 e0       	ldi	r23, 0x01	; 1
  e2:	8e e4       	ldi	r24, 0x4E	; 78
  e4:	96 e0       	ldi	r25, 0x06	; 6
  e6:	0e 94 96 02 	call	0x52c	; 0x52c <xTaskGenericCreate>
		NULL, mainLED_TASK_PRIORITY, NULL );
	
	vTaskStartScheduler();
  ea:	0e 94 a2 03 	call	0x744	; 0x744 <vTaskStartScheduler>
}
  ee:	80 e0       	ldi	r24, 0x00	; 0
  f0:	90 e0       	ldi	r25, 0x00	; 0
  f2:	0f 91       	pop	r16
  f4:	ff 90       	pop	r15
  f6:	ef 90       	pop	r14
  f8:	df 90       	pop	r13
  fa:	cf 90       	pop	r12
  fc:	bf 90       	pop	r11
  fe:	af 90       	pop	r10
 100:	08 95       	ret

00000102 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 102:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 104:	03 96       	adiw	r24, 0x03	; 3
 106:	92 83       	std	Z+2, r25	; 0x02
 108:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 10a:	2f ef       	ldi	r18, 0xFF	; 255
 10c:	3f ef       	ldi	r19, 0xFF	; 255
 10e:	34 83       	std	Z+4, r19	; 0x04
 110:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 112:	96 83       	std	Z+6, r25	; 0x06
 114:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 116:	90 87       	std	Z+8, r25	; 0x08
 118:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 11a:	10 82       	st	Z, r1
 11c:	08 95       	ret

0000011e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 11e:	fc 01       	movw	r30, r24
 120:	11 86       	std	Z+9, r1	; 0x09
 122:	10 86       	std	Z+8, r1	; 0x08
 124:	08 95       	ret

00000126 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 126:	cf 93       	push	r28
 128:	df 93       	push	r29
 12a:	9c 01       	movw	r18, r24
 12c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 12e:	dc 01       	movw	r26, r24
 130:	11 96       	adiw	r26, 0x01	; 1
 132:	cd 91       	ld	r28, X+
 134:	dc 91       	ld	r29, X
 136:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 138:	d3 83       	std	Z+3, r29	; 0x03
 13a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 13c:	8c 81       	ldd	r24, Y+4	; 0x04
 13e:	9d 81       	ldd	r25, Y+5	; 0x05
 140:	95 83       	std	Z+5, r25	; 0x05
 142:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 144:	8c 81       	ldd	r24, Y+4	; 0x04
 146:	9d 81       	ldd	r25, Y+5	; 0x05
 148:	dc 01       	movw	r26, r24
 14a:	13 96       	adiw	r26, 0x03	; 3
 14c:	7c 93       	st	X, r23
 14e:	6e 93       	st	-X, r22
 150:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 152:	7d 83       	std	Y+5, r23	; 0x05
 154:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 156:	31 87       	std	Z+9, r19	; 0x09
 158:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 15a:	f9 01       	movw	r30, r18
 15c:	80 81       	ld	r24, Z
 15e:	8f 5f       	subi	r24, 0xFF	; 255
 160:	80 83       	st	Z, r24
}
 162:	df 91       	pop	r29
 164:	cf 91       	pop	r28
 166:	08 95       	ret

00000168 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 168:	cf 93       	push	r28
 16a:	df 93       	push	r29
 16c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 16e:	48 81       	ld	r20, Y
 170:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 172:	4f 3f       	cpi	r20, 0xFF	; 255
 174:	2f ef       	ldi	r18, 0xFF	; 255
 176:	52 07       	cpc	r21, r18
 178:	21 f4       	brne	.+8      	; 0x182 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 17a:	fc 01       	movw	r30, r24
 17c:	a7 81       	ldd	r26, Z+7	; 0x07
 17e:	b0 85       	ldd	r27, Z+8	; 0x08
 180:	0d c0       	rjmp	.+26     	; 0x19c <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 182:	dc 01       	movw	r26, r24
 184:	13 96       	adiw	r26, 0x03	; 3
 186:	01 c0       	rjmp	.+2      	; 0x18a <vListInsert+0x22>
 188:	df 01       	movw	r26, r30
 18a:	12 96       	adiw	r26, 0x02	; 2
 18c:	ed 91       	ld	r30, X+
 18e:	fc 91       	ld	r31, X
 190:	13 97       	sbiw	r26, 0x03	; 3
 192:	20 81       	ld	r18, Z
 194:	31 81       	ldd	r19, Z+1	; 0x01
 196:	42 17       	cp	r20, r18
 198:	53 07       	cpc	r21, r19
 19a:	b0 f7       	brcc	.-20     	; 0x188 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 19c:	12 96       	adiw	r26, 0x02	; 2
 19e:	ed 91       	ld	r30, X+
 1a0:	fc 91       	ld	r31, X
 1a2:	13 97       	sbiw	r26, 0x03	; 3
 1a4:	fb 83       	std	Y+3, r31	; 0x03
 1a6:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 1a8:	d5 83       	std	Z+5, r29	; 0x05
 1aa:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 1ac:	bd 83       	std	Y+5, r27	; 0x05
 1ae:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 1b0:	13 96       	adiw	r26, 0x03	; 3
 1b2:	dc 93       	st	X, r29
 1b4:	ce 93       	st	-X, r28
 1b6:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1b8:	99 87       	std	Y+9, r25	; 0x09
 1ba:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 1bc:	fc 01       	movw	r30, r24
 1be:	20 81       	ld	r18, Z
 1c0:	2f 5f       	subi	r18, 0xFF	; 255
 1c2:	20 83       	st	Z, r18
}
 1c4:	df 91       	pop	r29
 1c6:	cf 91       	pop	r28
 1c8:	08 95       	ret

000001ca <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 1ca:	cf 93       	push	r28
 1cc:	df 93       	push	r29
 1ce:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 1d0:	a0 85       	ldd	r26, Z+8	; 0x08
 1d2:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 1d4:	c2 81       	ldd	r28, Z+2	; 0x02
 1d6:	d3 81       	ldd	r29, Z+3	; 0x03
 1d8:	84 81       	ldd	r24, Z+4	; 0x04
 1da:	95 81       	ldd	r25, Z+5	; 0x05
 1dc:	9d 83       	std	Y+5, r25	; 0x05
 1de:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 1e0:	c4 81       	ldd	r28, Z+4	; 0x04
 1e2:	d5 81       	ldd	r29, Z+5	; 0x05
 1e4:	82 81       	ldd	r24, Z+2	; 0x02
 1e6:	93 81       	ldd	r25, Z+3	; 0x03
 1e8:	9b 83       	std	Y+3, r25	; 0x03
 1ea:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 1ec:	11 96       	adiw	r26, 0x01	; 1
 1ee:	cd 91       	ld	r28, X+
 1f0:	dc 91       	ld	r29, X
 1f2:	12 97       	sbiw	r26, 0x02	; 2
 1f4:	ce 17       	cp	r28, r30
 1f6:	df 07       	cpc	r29, r31
 1f8:	31 f4       	brne	.+12     	; 0x206 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 1fa:	8c 81       	ldd	r24, Y+4	; 0x04
 1fc:	9d 81       	ldd	r25, Y+5	; 0x05
 1fe:	12 96       	adiw	r26, 0x02	; 2
 200:	9c 93       	st	X, r25
 202:	8e 93       	st	-X, r24
 204:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 206:	11 86       	std	Z+9, r1	; 0x09
 208:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 20a:	8c 91       	ld	r24, X
 20c:	81 50       	subi	r24, 0x01	; 1
 20e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 210:	df 91       	pop	r29
 212:	cf 91       	pop	r28
 214:	08 95       	ret

00000216 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
 216:	31 e1       	ldi	r19, 0x11	; 17
 218:	fc 01       	movw	r30, r24
 21a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
 21c:	31 97       	sbiw	r30, 0x01	; 1
 21e:	22 e2       	ldi	r18, 0x22	; 34
 220:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
 222:	31 97       	sbiw	r30, 0x01	; 1
 224:	a3 e3       	ldi	r26, 0x33	; 51
 226:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 228:	31 97       	sbiw	r30, 0x01	; 1
 22a:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 22c:	31 97       	sbiw	r30, 0x01	; 1
 22e:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
 230:	31 97       	sbiw	r30, 0x01	; 1
 232:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
 234:	31 97       	sbiw	r30, 0x01	; 1
 236:	60 e8       	ldi	r22, 0x80	; 128
 238:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
 23a:	31 97       	sbiw	r30, 0x01	; 1
 23c:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
 23e:	31 97       	sbiw	r30, 0x01	; 1
 240:	62 e0       	ldi	r22, 0x02	; 2
 242:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
 244:	31 97       	sbiw	r30, 0x01	; 1
 246:	63 e0       	ldi	r22, 0x03	; 3
 248:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
 24a:	31 97       	sbiw	r30, 0x01	; 1
 24c:	64 e0       	ldi	r22, 0x04	; 4
 24e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
 250:	31 97       	sbiw	r30, 0x01	; 1
 252:	65 e0       	ldi	r22, 0x05	; 5
 254:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
 256:	31 97       	sbiw	r30, 0x01	; 1
 258:	66 e0       	ldi	r22, 0x06	; 6
 25a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
 25c:	31 97       	sbiw	r30, 0x01	; 1
 25e:	67 e0       	ldi	r22, 0x07	; 7
 260:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
 262:	31 97       	sbiw	r30, 0x01	; 1
 264:	68 e0       	ldi	r22, 0x08	; 8
 266:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
 268:	31 97       	sbiw	r30, 0x01	; 1
 26a:	69 e0       	ldi	r22, 0x09	; 9
 26c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
 26e:	31 97       	sbiw	r30, 0x01	; 1
 270:	60 e1       	ldi	r22, 0x10	; 16
 272:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
 274:	31 97       	sbiw	r30, 0x01	; 1
 276:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
 278:	31 97       	sbiw	r30, 0x01	; 1
 27a:	32 e1       	ldi	r19, 0x12	; 18
 27c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
 27e:	31 97       	sbiw	r30, 0x01	; 1
 280:	33 e1       	ldi	r19, 0x13	; 19
 282:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
 284:	31 97       	sbiw	r30, 0x01	; 1
 286:	34 e1       	ldi	r19, 0x14	; 20
 288:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
 28a:	31 97       	sbiw	r30, 0x01	; 1
 28c:	35 e1       	ldi	r19, 0x15	; 21
 28e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
 290:	31 97       	sbiw	r30, 0x01	; 1
 292:	36 e1       	ldi	r19, 0x16	; 22
 294:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
 296:	31 97       	sbiw	r30, 0x01	; 1
 298:	37 e1       	ldi	r19, 0x17	; 23
 29a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
 29c:	31 97       	sbiw	r30, 0x01	; 1
 29e:	38 e1       	ldi	r19, 0x18	; 24
 2a0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
 2a2:	31 97       	sbiw	r30, 0x01	; 1
 2a4:	39 e1       	ldi	r19, 0x19	; 25
 2a6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
 2a8:	31 97       	sbiw	r30, 0x01	; 1
 2aa:	30 e2       	ldi	r19, 0x20	; 32
 2ac:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
 2ae:	31 97       	sbiw	r30, 0x01	; 1
 2b0:	31 e2       	ldi	r19, 0x21	; 33
 2b2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
 2b4:	31 97       	sbiw	r30, 0x01	; 1
 2b6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
 2b8:	31 97       	sbiw	r30, 0x01	; 1
 2ba:	23 e2       	ldi	r18, 0x23	; 35
 2bc:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 2be:	31 97       	sbiw	r30, 0x01	; 1
 2c0:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 2c2:	31 97       	sbiw	r30, 0x01	; 1
 2c4:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
 2c6:	31 97       	sbiw	r30, 0x01	; 1
 2c8:	26 e2       	ldi	r18, 0x26	; 38
 2ca:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
 2cc:	31 97       	sbiw	r30, 0x01	; 1
 2ce:	27 e2       	ldi	r18, 0x27	; 39
 2d0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
 2d2:	31 97       	sbiw	r30, 0x01	; 1
 2d4:	28 e2       	ldi	r18, 0x28	; 40
 2d6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
 2d8:	31 97       	sbiw	r30, 0x01	; 1
 2da:	29 e2       	ldi	r18, 0x29	; 41
 2dc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
 2de:	31 97       	sbiw	r30, 0x01	; 1
 2e0:	20 e3       	ldi	r18, 0x30	; 48
 2e2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
 2e4:	31 97       	sbiw	r30, 0x01	; 1
 2e6:	21 e3       	ldi	r18, 0x31	; 49
 2e8:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
 2ea:	86 97       	sbiw	r24, 0x26	; 38
 2ec:	08 95       	ret

000002ee <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
 2ee:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
 2f2:	89 ef       	ldi	r24, 0xF9	; 249
 2f4:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
 2f8:	8b e0       	ldi	r24, 0x0B	; 11
 2fa:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
 2fe:	ef e6       	ldi	r30, 0x6F	; 111
 300:	f0 e0       	ldi	r31, 0x00	; 0
 302:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
 304:	80 61       	ori	r24, 0x10	; 16
	TIMSK1 = ucLowByte;
 306:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
 308:	a0 91 43 07 	lds	r26, 0x0743
 30c:	b0 91 44 07 	lds	r27, 0x0744
 310:	cd 91       	ld	r28, X+
 312:	cd bf       	out	0x3d, r28	; 61
 314:	dd 91       	ld	r29, X+
 316:	de bf       	out	0x3e, r29	; 62
 318:	ff 91       	pop	r31
 31a:	ef 91       	pop	r30
 31c:	df 91       	pop	r29
 31e:	cf 91       	pop	r28
 320:	bf 91       	pop	r27
 322:	af 91       	pop	r26
 324:	9f 91       	pop	r25
 326:	8f 91       	pop	r24
 328:	7f 91       	pop	r23
 32a:	6f 91       	pop	r22
 32c:	5f 91       	pop	r21
 32e:	4f 91       	pop	r20
 330:	3f 91       	pop	r19
 332:	2f 91       	pop	r18
 334:	1f 91       	pop	r17
 336:	0f 91       	pop	r16
 338:	ff 90       	pop	r15
 33a:	ef 90       	pop	r14
 33c:	df 90       	pop	r13
 33e:	cf 90       	pop	r12
 340:	bf 90       	pop	r11
 342:	af 90       	pop	r10
 344:	9f 90       	pop	r9
 346:	8f 90       	pop	r8
 348:	7f 90       	pop	r7
 34a:	6f 90       	pop	r6
 34c:	5f 90       	pop	r5
 34e:	4f 90       	pop	r4
 350:	3f 90       	pop	r3
 352:	2f 90       	pop	r2
 354:	1f 90       	pop	r1
 356:	0f 90       	pop	r0
 358:	0f be       	out	0x3f, r0	; 63
 35a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
 35c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
 35e:	81 e0       	ldi	r24, 0x01	; 1
 360:	08 95       	ret

00000362 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 362:	0f 92       	push	r0
 364:	0f b6       	in	r0, 0x3f	; 63
 366:	f8 94       	cli
 368:	0f 92       	push	r0
 36a:	1f 92       	push	r1
 36c:	11 24       	eor	r1, r1
 36e:	2f 92       	push	r2
 370:	3f 92       	push	r3
 372:	4f 92       	push	r4
 374:	5f 92       	push	r5
 376:	6f 92       	push	r6
 378:	7f 92       	push	r7
 37a:	8f 92       	push	r8
 37c:	9f 92       	push	r9
 37e:	af 92       	push	r10
 380:	bf 92       	push	r11
 382:	cf 92       	push	r12
 384:	df 92       	push	r13
 386:	ef 92       	push	r14
 388:	ff 92       	push	r15
 38a:	0f 93       	push	r16
 38c:	1f 93       	push	r17
 38e:	2f 93       	push	r18
 390:	3f 93       	push	r19
 392:	4f 93       	push	r20
 394:	5f 93       	push	r21
 396:	6f 93       	push	r22
 398:	7f 93       	push	r23
 39a:	8f 93       	push	r24
 39c:	9f 93       	push	r25
 39e:	af 93       	push	r26
 3a0:	bf 93       	push	r27
 3a2:	cf 93       	push	r28
 3a4:	df 93       	push	r29
 3a6:	ef 93       	push	r30
 3a8:	ff 93       	push	r31
 3aa:	a0 91 43 07 	lds	r26, 0x0743
 3ae:	b0 91 44 07 	lds	r27, 0x0744
 3b2:	0d b6       	in	r0, 0x3d	; 61
 3b4:	0d 92       	st	X+, r0
 3b6:	0e b6       	in	r0, 0x3e	; 62
 3b8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 3ba:	0e 94 a2 05 	call	0xb44	; 0xb44 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 3be:	a0 91 43 07 	lds	r26, 0x0743
 3c2:	b0 91 44 07 	lds	r27, 0x0744
 3c6:	cd 91       	ld	r28, X+
 3c8:	cd bf       	out	0x3d, r28	; 61
 3ca:	dd 91       	ld	r29, X+
 3cc:	de bf       	out	0x3e, r29	; 62
 3ce:	ff 91       	pop	r31
 3d0:	ef 91       	pop	r30
 3d2:	df 91       	pop	r29
 3d4:	cf 91       	pop	r28
 3d6:	bf 91       	pop	r27
 3d8:	af 91       	pop	r26
 3da:	9f 91       	pop	r25
 3dc:	8f 91       	pop	r24
 3de:	7f 91       	pop	r23
 3e0:	6f 91       	pop	r22
 3e2:	5f 91       	pop	r21
 3e4:	4f 91       	pop	r20
 3e6:	3f 91       	pop	r19
 3e8:	2f 91       	pop	r18
 3ea:	1f 91       	pop	r17
 3ec:	0f 91       	pop	r16
 3ee:	ff 90       	pop	r15
 3f0:	ef 90       	pop	r14
 3f2:	df 90       	pop	r13
 3f4:	cf 90       	pop	r12
 3f6:	bf 90       	pop	r11
 3f8:	af 90       	pop	r10
 3fa:	9f 90       	pop	r9
 3fc:	8f 90       	pop	r8
 3fe:	7f 90       	pop	r7
 400:	6f 90       	pop	r6
 402:	5f 90       	pop	r5
 404:	4f 90       	pop	r4
 406:	3f 90       	pop	r3
 408:	2f 90       	pop	r2
 40a:	1f 90       	pop	r1
 40c:	0f 90       	pop	r0
 40e:	0f be       	out	0x3f, r0	; 63
 410:	0f 90       	pop	r0

	asm volatile ( "ret" );
 412:	08 95       	ret

00000414 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 414:	cf 93       	push	r28
 416:	df 93       	push	r29
 418:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
 41a:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 41e:	80 91 0a 01 	lds	r24, 0x010A
 422:	90 91 0b 01 	lds	r25, 0x010B
 426:	89 2b       	or	r24, r25
 428:	31 f4       	brne	.+12     	; 0x436 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 42a:	8f e0       	ldi	r24, 0x0F	; 15
 42c:	91 e0       	ldi	r25, 0x01	; 1
 42e:	90 93 0b 01 	sts	0x010B, r25
 432:	80 93 0a 01 	sts	0x010A, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 436:	20 91 0c 01 	lds	r18, 0x010C
 43a:	30 91 0d 01 	lds	r19, 0x010D
 43e:	ce 01       	movw	r24, r28
 440:	82 0f       	add	r24, r18
 442:	93 1f       	adc	r25, r19
 444:	8b 3d       	cpi	r24, 0xDB	; 219
 446:	45 e0       	ldi	r20, 0x05	; 5
 448:	94 07       	cpc	r25, r20
 44a:	70 f4       	brcc	.+28     	; 0x468 <pvPortMalloc+0x54>
 44c:	28 17       	cp	r18, r24
 44e:	39 07       	cpc	r19, r25
 450:	70 f4       	brcc	.+28     	; 0x46e <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 452:	c0 91 0a 01 	lds	r28, 0x010A
 456:	d0 91 0b 01 	lds	r29, 0x010B
 45a:	c2 0f       	add	r28, r18
 45c:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
 45e:	90 93 0d 01 	sts	0x010D, r25
 462:	80 93 0c 01 	sts	0x010C, r24
 466:	05 c0       	rjmp	.+10     	; 0x472 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 468:	c0 e0       	ldi	r28, 0x00	; 0
 46a:	d0 e0       	ldi	r29, 0x00	; 0
 46c:	02 c0       	rjmp	.+4      	; 0x472 <pvPortMalloc+0x5e>
 46e:	c0 e0       	ldi	r28, 0x00	; 0
 470:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 472:	0e 94 a1 04 	call	0x942	; 0x942 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 476:	ce 01       	movw	r24, r28
 478:	df 91       	pop	r29
 47a:	cf 91       	pop	r28
 47c:	08 95       	ret

0000047e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 47e:	08 95       	ret

00000480 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 480:	e0 91 0b 07 	lds	r30, 0x070B
 484:	f0 91 0c 07 	lds	r31, 0x070C
 488:	80 81       	ld	r24, Z
 48a:	81 11       	cpse	r24, r1
 48c:	07 c0       	rjmp	.+14     	; 0x49c <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 48e:	8f ef       	ldi	r24, 0xFF	; 255
 490:	9f ef       	ldi	r25, 0xFF	; 255
 492:	90 93 ec 06 	sts	0x06EC, r25
 496:	80 93 eb 06 	sts	0x06EB, r24
 49a:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 49c:	e0 91 0b 07 	lds	r30, 0x070B
 4a0:	f0 91 0c 07 	lds	r31, 0x070C
 4a4:	05 80       	ldd	r0, Z+5	; 0x05
 4a6:	f6 81       	ldd	r31, Z+6	; 0x06
 4a8:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 4aa:	06 80       	ldd	r0, Z+6	; 0x06
 4ac:	f7 81       	ldd	r31, Z+7	; 0x07
 4ae:	e0 2d       	mov	r30, r0
 4b0:	82 81       	ldd	r24, Z+2	; 0x02
 4b2:	93 81       	ldd	r25, Z+3	; 0x03
 4b4:	90 93 ec 06 	sts	0x06EC, r25
 4b8:	80 93 eb 06 	sts	0x06EB, r24
 4bc:	08 95       	ret

000004be <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
 4be:	cf 93       	push	r28
 4c0:	df 93       	push	r29
 4c2:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 4c4:	e0 91 43 07 	lds	r30, 0x0743
 4c8:	f0 91 44 07 	lds	r31, 0x0744
 4cc:	93 83       	std	Z+3, r25	; 0x03
 4ce:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
 4d0:	80 91 f3 06 	lds	r24, 0x06F3
 4d4:	90 91 f4 06 	lds	r25, 0x06F4
 4d8:	c8 17       	cp	r28, r24
 4da:	d9 07       	cpc	r29, r25
 4dc:	68 f4       	brcc	.+26     	; 0x4f8 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 4de:	60 91 43 07 	lds	r22, 0x0743
 4e2:	70 91 44 07 	lds	r23, 0x0744
 4e6:	80 91 09 07 	lds	r24, 0x0709
 4ea:	90 91 0a 07 	lds	r25, 0x070A
 4ee:	6e 5f       	subi	r22, 0xFE	; 254
 4f0:	7f 4f       	sbci	r23, 0xFF	; 255
 4f2:	0e 94 b4 00 	call	0x168	; 0x168 <vListInsert>
 4f6:	17 c0       	rjmp	.+46     	; 0x526 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 4f8:	60 91 43 07 	lds	r22, 0x0743
 4fc:	70 91 44 07 	lds	r23, 0x0744
 500:	80 91 0b 07 	lds	r24, 0x070B
 504:	90 91 0c 07 	lds	r25, 0x070C
 508:	6e 5f       	subi	r22, 0xFE	; 254
 50a:	7f 4f       	sbci	r23, 0xFF	; 255
 50c:	0e 94 b4 00 	call	0x168	; 0x168 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 510:	80 91 eb 06 	lds	r24, 0x06EB
 514:	90 91 ec 06 	lds	r25, 0x06EC
 518:	c8 17       	cp	r28, r24
 51a:	d9 07       	cpc	r29, r25
 51c:	20 f4       	brcc	.+8      	; 0x526 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
 51e:	d0 93 ec 06 	sts	0x06EC, r29
 522:	c0 93 eb 06 	sts	0x06EB, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 526:	df 91       	pop	r29
 528:	cf 91       	pop	r28
 52a:	08 95       	ret

0000052c <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 52c:	4f 92       	push	r4
 52e:	5f 92       	push	r5
 530:	6f 92       	push	r6
 532:	7f 92       	push	r7
 534:	8f 92       	push	r8
 536:	9f 92       	push	r9
 538:	af 92       	push	r10
 53a:	bf 92       	push	r11
 53c:	cf 92       	push	r12
 53e:	df 92       	push	r13
 540:	ef 92       	push	r14
 542:	ff 92       	push	r15
 544:	0f 93       	push	r16
 546:	1f 93       	push	r17
 548:	cf 93       	push	r28
 54a:	df 93       	push	r29
 54c:	4c 01       	movw	r8, r24
 54e:	eb 01       	movw	r28, r22
 550:	5a 01       	movw	r10, r20
 552:	29 01       	movw	r4, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 554:	c1 14       	cp	r12, r1
 556:	d1 04       	cpc	r13, r1
 558:	39 f4       	brne	.+14     	; 0x568 <xTaskGenericCreate+0x3c>
 55a:	ca 01       	movw	r24, r20
 55c:	0e 94 0a 02 	call	0x414	; 0x414 <pvPortMalloc>
 560:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
 562:	89 2b       	or	r24, r25
 564:	09 f4       	brne	.+2      	; 0x568 <xTaskGenericCreate+0x3c>
 566:	dc c0       	rjmp	.+440    	; 0x720 <xTaskGenericCreate+0x1f4>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 568:	86 e2       	ldi	r24, 0x26	; 38
 56a:	90 e0       	ldi	r25, 0x00	; 0
 56c:	0e 94 0a 02 	call	0x414	; 0x414 <pvPortMalloc>
 570:	3c 01       	movw	r6, r24

			if( pxNewTCB != NULL )
 572:	00 97       	sbiw	r24, 0x00	; 0
 574:	79 f0       	breq	.+30     	; 0x594 <xTaskGenericCreate+0x68>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
 576:	fc 01       	movw	r30, r24
 578:	d0 8e       	std	Z+24, r13	; 0x18
 57a:	c7 8a       	std	Z+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 57c:	f1 e0       	ldi	r31, 0x01	; 1
 57e:	af 1a       	sub	r10, r31
 580:	b1 08       	sbc	r11, r1
 582:	ca 0c       	add	r12, r10
 584:	db 1c       	adc	r13, r11
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 586:	88 81       	ld	r24, Y
 588:	f3 01       	movw	r30, r6
 58a:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 58c:	88 81       	ld	r24, Y
 58e:	81 11       	cpse	r24, r1
 590:	05 c0       	rjmp	.+10     	; 0x59c <xTaskGenericCreate+0x70>
 592:	14 c0       	rjmp	.+40     	; 0x5bc <xTaskGenericCreate+0x90>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
 594:	c6 01       	movw	r24, r12
 596:	0e 94 3f 02 	call	0x47e	; 0x47e <vPortFree>
 59a:	c2 c0       	rjmp	.+388    	; 0x720 <xTaskGenericCreate+0x1f4>
 59c:	d3 01       	movw	r26, r6
 59e:	5a 96       	adiw	r26, 0x1a	; 26
 5a0:	fe 01       	movw	r30, r28
 5a2:	31 96       	adiw	r30, 0x01	; 1
 5a4:	9e 01       	movw	r18, r28
 5a6:	28 5f       	subi	r18, 0xF8	; 248
 5a8:	3f 4f       	sbci	r19, 0xFF	; 255
 5aa:	ef 01       	movw	r28, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 5ac:	81 91       	ld	r24, Z+
 5ae:	8d 93       	st	X+, r24

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 5b0:	88 81       	ld	r24, Y
 5b2:	88 23       	and	r24, r24
 5b4:	19 f0       	breq	.+6      	; 0x5bc <xTaskGenericCreate+0x90>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 5b6:	e2 17       	cp	r30, r18
 5b8:	f3 07       	cpc	r31, r19
 5ba:	b9 f7       	brne	.-18     	; 0x5aa <xTaskGenericCreate+0x7e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 5bc:	f3 01       	movw	r30, r6
 5be:	10 a2       	std	Z+32, r1	; 0x20
 5c0:	10 2f       	mov	r17, r16
 5c2:	04 30       	cpi	r16, 0x04	; 4
 5c4:	08 f0       	brcs	.+2      	; 0x5c8 <xTaskGenericCreate+0x9c>
 5c6:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
 5c8:	f3 01       	movw	r30, r6
 5ca:	16 8b       	std	Z+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 5cc:	e3 01       	movw	r28, r6
 5ce:	22 96       	adiw	r28, 0x02	; 2
 5d0:	ce 01       	movw	r24, r28
 5d2:	0e 94 8f 00 	call	0x11e	; 0x11e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 5d6:	c3 01       	movw	r24, r6
 5d8:	0c 96       	adiw	r24, 0x0c	; 12
 5da:	0e 94 8f 00 	call	0x11e	; 0x11e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 5de:	f3 01       	movw	r30, r6
 5e0:	71 86       	std	Z+9, r7	; 0x09
 5e2:	60 86       	std	Z+8, r6	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 5e4:	84 e0       	ldi	r24, 0x04	; 4
 5e6:	90 e0       	ldi	r25, 0x00	; 0
 5e8:	81 1b       	sub	r24, r17
 5ea:	91 09       	sbc	r25, r1
 5ec:	95 87       	std	Z+13, r25	; 0x0d
 5ee:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 5f0:	73 8a       	std	Z+19, r7	; 0x13
 5f2:	62 8a       	std	Z+18, r6	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
 5f4:	11 a2       	std	Z+33, r1	; 0x21
 5f6:	12 a2       	std	Z+34, r1	; 0x22
 5f8:	13 a2       	std	Z+35, r1	; 0x23
 5fa:	14 a2       	std	Z+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
 5fc:	15 a2       	std	Z+37, r1	; 0x25
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 5fe:	a2 01       	movw	r20, r4
 600:	b4 01       	movw	r22, r8
 602:	c6 01       	movw	r24, r12
 604:	0e 94 0b 01 	call	0x216	; 0x216 <pxPortInitialiseStack>
 608:	f3 01       	movw	r30, r6
 60a:	91 83       	std	Z+1, r25	; 0x01
 60c:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
 60e:	e1 14       	cp	r14, r1
 610:	f1 04       	cpc	r15, r1
 612:	19 f0       	breq	.+6      	; 0x61a <xTaskGenericCreate+0xee>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 614:	f7 01       	movw	r30, r14
 616:	71 82       	std	Z+1, r7	; 0x01
 618:	60 82       	st	Z, r6
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
 61a:	0f b6       	in	r0, 0x3f	; 63
 61c:	f8 94       	cli
 61e:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
 620:	80 91 f5 06 	lds	r24, 0x06F5
 624:	8f 5f       	subi	r24, 0xFF	; 255
 626:	80 93 f5 06 	sts	0x06F5, r24
			if( pxCurrentTCB == NULL )
 62a:	80 91 43 07 	lds	r24, 0x0743
 62e:	90 91 44 07 	lds	r25, 0x0744
 632:	89 2b       	or	r24, r25
 634:	a9 f5       	brne	.+106    	; 0x6a0 <xTaskGenericCreate+0x174>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 636:	70 92 44 07 	sts	0x0744, r7
 63a:	60 92 43 07 	sts	0x0743, r6

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 63e:	80 91 f5 06 	lds	r24, 0x06F5
 642:	81 30       	cpi	r24, 0x01	; 1
 644:	e1 f5       	brne	.+120    	; 0x6be <xTaskGenericCreate+0x192>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 646:	8f e1       	ldi	r24, 0x1F	; 31
 648:	97 e0       	ldi	r25, 0x07	; 7
 64a:	0e 94 81 00 	call	0x102	; 0x102 <vListInitialise>
 64e:	88 e2       	ldi	r24, 0x28	; 40
 650:	97 e0       	ldi	r25, 0x07	; 7
 652:	0e 94 81 00 	call	0x102	; 0x102 <vListInitialise>
 656:	81 e3       	ldi	r24, 0x31	; 49
 658:	97 e0       	ldi	r25, 0x07	; 7
 65a:	0e 94 81 00 	call	0x102	; 0x102 <vListInitialise>
 65e:	8a e3       	ldi	r24, 0x3A	; 58
 660:	97 e0       	ldi	r25, 0x07	; 7
 662:	0e 94 81 00 	call	0x102	; 0x102 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
 666:	86 e1       	ldi	r24, 0x16	; 22
 668:	97 e0       	ldi	r25, 0x07	; 7
 66a:	0e 94 81 00 	call	0x102	; 0x102 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 66e:	8d e0       	ldi	r24, 0x0D	; 13
 670:	97 e0       	ldi	r25, 0x07	; 7
 672:	0e 94 81 00 	call	0x102	; 0x102 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 676:	80 e0       	ldi	r24, 0x00	; 0
 678:	97 e0       	ldi	r25, 0x07	; 7
 67a:	0e 94 81 00 	call	0x102	; 0x102 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 67e:	87 ef       	ldi	r24, 0xF7	; 247
 680:	96 e0       	ldi	r25, 0x06	; 6
 682:	0e 94 81 00 	call	0x102	; 0x102 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 686:	86 e1       	ldi	r24, 0x16	; 22
 688:	97 e0       	ldi	r25, 0x07	; 7
 68a:	90 93 0c 07 	sts	0x070C, r25
 68e:	80 93 0b 07 	sts	0x070B, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 692:	8d e0       	ldi	r24, 0x0D	; 13
 694:	97 e0       	ldi	r25, 0x07	; 7
 696:	90 93 0a 07 	sts	0x070A, r25
 69a:	80 93 09 07 	sts	0x0709, r24
 69e:	0f c0       	rjmp	.+30     	; 0x6be <xTaskGenericCreate+0x192>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 6a0:	80 91 f1 06 	lds	r24, 0x06F1
 6a4:	81 11       	cpse	r24, r1
 6a6:	0b c0       	rjmp	.+22     	; 0x6be <xTaskGenericCreate+0x192>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 6a8:	e0 91 43 07 	lds	r30, 0x0743
 6ac:	f0 91 44 07 	lds	r31, 0x0744
 6b0:	86 89       	ldd	r24, Z+22	; 0x16
 6b2:	08 17       	cp	r16, r24
 6b4:	20 f0       	brcs	.+8      	; 0x6be <xTaskGenericCreate+0x192>
					{
						pxCurrentTCB = pxNewTCB;
 6b6:	70 92 44 07 	sts	0x0744, r7
 6ba:	60 92 43 07 	sts	0x0743, r6
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 6be:	80 91 ed 06 	lds	r24, 0x06ED
 6c2:	8f 5f       	subi	r24, 0xFF	; 255
 6c4:	80 93 ed 06 	sts	0x06ED, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 6c8:	f3 01       	movw	r30, r6
 6ca:	86 89       	ldd	r24, Z+22	; 0x16
 6cc:	90 91 f2 06 	lds	r25, 0x06F2
 6d0:	98 17       	cp	r25, r24
 6d2:	10 f4       	brcc	.+4      	; 0x6d8 <xTaskGenericCreate+0x1ac>
 6d4:	80 93 f2 06 	sts	0x06F2, r24
 6d8:	90 e0       	ldi	r25, 0x00	; 0
 6da:	9c 01       	movw	r18, r24
 6dc:	22 0f       	add	r18, r18
 6de:	33 1f       	adc	r19, r19
 6e0:	22 0f       	add	r18, r18
 6e2:	33 1f       	adc	r19, r19
 6e4:	22 0f       	add	r18, r18
 6e6:	33 1f       	adc	r19, r19
 6e8:	82 0f       	add	r24, r18
 6ea:	93 1f       	adc	r25, r19
 6ec:	be 01       	movw	r22, r28
 6ee:	81 5e       	subi	r24, 0xE1	; 225
 6f0:	98 4f       	sbci	r25, 0xF8	; 248
 6f2:	0e 94 93 00 	call	0x126	; 0x126 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 6f6:	0f 90       	pop	r0
 6f8:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 6fa:	80 91 f1 06 	lds	r24, 0x06F1
 6fe:	88 23       	and	r24, r24
 700:	59 f0       	breq	.+22     	; 0x718 <xTaskGenericCreate+0x1ec>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 702:	e0 91 43 07 	lds	r30, 0x0743
 706:	f0 91 44 07 	lds	r31, 0x0744
 70a:	86 89       	ldd	r24, Z+22	; 0x16
 70c:	80 17       	cp	r24, r16
 70e:	30 f4       	brcc	.+12     	; 0x71c <xTaskGenericCreate+0x1f0>
			{
				taskYIELD_IF_USING_PREEMPTION();
 710:	0e 94 b1 01 	call	0x362	; 0x362 <vPortYield>
 714:	81 e0       	ldi	r24, 0x01	; 1
 716:	05 c0       	rjmp	.+10     	; 0x722 <xTaskGenericCreate+0x1f6>
 718:	81 e0       	ldi	r24, 0x01	; 1
 71a:	03 c0       	rjmp	.+6      	; 0x722 <xTaskGenericCreate+0x1f6>
 71c:	81 e0       	ldi	r24, 0x01	; 1
 71e:	01 c0       	rjmp	.+2      	; 0x722 <xTaskGenericCreate+0x1f6>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 720:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
 722:	df 91       	pop	r29
 724:	cf 91       	pop	r28
 726:	1f 91       	pop	r17
 728:	0f 91       	pop	r16
 72a:	ff 90       	pop	r15
 72c:	ef 90       	pop	r14
 72e:	df 90       	pop	r13
 730:	cf 90       	pop	r12
 732:	bf 90       	pop	r11
 734:	af 90       	pop	r10
 736:	9f 90       	pop	r9
 738:	8f 90       	pop	r8
 73a:	7f 90       	pop	r7
 73c:	6f 90       	pop	r6
 73e:	5f 90       	pop	r5
 740:	4f 90       	pop	r4
 742:	08 95       	ret

00000744 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 744:	af 92       	push	r10
 746:	bf 92       	push	r11
 748:	cf 92       	push	r12
 74a:	df 92       	push	r13
 74c:	ef 92       	push	r14
 74e:	ff 92       	push	r15
 750:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 752:	a1 2c       	mov	r10, r1
 754:	b1 2c       	mov	r11, r1
 756:	c1 2c       	mov	r12, r1
 758:	d1 2c       	mov	r13, r1
 75a:	e1 2c       	mov	r14, r1
 75c:	f1 2c       	mov	r15, r1
 75e:	00 e0       	ldi	r16, 0x00	; 0
 760:	20 e0       	ldi	r18, 0x00	; 0
 762:	30 e0       	ldi	r19, 0x00	; 0
 764:	45 e5       	ldi	r20, 0x55	; 85
 766:	50 e0       	ldi	r21, 0x00	; 0
 768:	64 e0       	ldi	r22, 0x04	; 4
 76a:	71 e0       	ldi	r23, 0x01	; 1
 76c:	85 e6       	ldi	r24, 0x65	; 101
 76e:	95 e0       	ldi	r25, 0x05	; 5
 770:	0e 94 96 02 	call	0x52c	; 0x52c <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 774:	81 30       	cpi	r24, 0x01	; 1
 776:	81 f4       	brne	.+32     	; 0x798 <vTaskStartScheduler+0x54>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 778:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 77a:	8f ef       	ldi	r24, 0xFF	; 255
 77c:	9f ef       	ldi	r25, 0xFF	; 255
 77e:	90 93 ec 06 	sts	0x06EC, r25
 782:	80 93 eb 06 	sts	0x06EB, r24
		xSchedulerRunning = pdTRUE;
 786:	81 e0       	ldi	r24, 0x01	; 1
 788:	80 93 f1 06 	sts	0x06F1, r24
		xTickCount = ( TickType_t ) 0U;
 78c:	10 92 f4 06 	sts	0x06F4, r1
 790:	10 92 f3 06 	sts	0x06F3, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 794:	0e 94 77 01 	call	0x2ee	; 0x2ee <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 798:	0f 91       	pop	r16
 79a:	ff 90       	pop	r15
 79c:	ef 90       	pop	r14
 79e:	df 90       	pop	r13
 7a0:	cf 90       	pop	r12
 7a2:	bf 90       	pop	r11
 7a4:	af 90       	pop	r10
 7a6:	08 95       	ret

000007a8 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 7a8:	80 91 ea 06 	lds	r24, 0x06EA
 7ac:	8f 5f       	subi	r24, 0xFF	; 255
 7ae:	80 93 ea 06 	sts	0x06EA, r24
 7b2:	08 95       	ret

000007b4 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
 7b4:	0f b6       	in	r0, 0x3f	; 63
 7b6:	f8 94       	cli
 7b8:	0f 92       	push	r0
	{
		xTicks = xTickCount;
 7ba:	80 91 f3 06 	lds	r24, 0x06F3
 7be:	90 91 f4 06 	lds	r25, 0x06F4
	}
	portTICK_TYPE_EXIT_CRITICAL();
 7c2:	0f 90       	pop	r0
 7c4:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
 7c6:	08 95       	ret

000007c8 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 7c8:	cf 92       	push	r12
 7ca:	df 92       	push	r13
 7cc:	ef 92       	push	r14
 7ce:	ff 92       	push	r15
 7d0:	0f 93       	push	r16
 7d2:	1f 93       	push	r17
 7d4:	cf 93       	push	r28
 7d6:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 7d8:	80 91 ea 06 	lds	r24, 0x06EA
 7dc:	81 11       	cpse	r24, r1
 7de:	9b c0       	rjmp	.+310    	; 0x916 <xTaskIncrementTick+0x14e>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
 7e0:	80 91 f3 06 	lds	r24, 0x06F3
 7e4:	90 91 f4 06 	lds	r25, 0x06F4
 7e8:	01 96       	adiw	r24, 0x01	; 1
 7ea:	90 93 f4 06 	sts	0x06F4, r25
 7ee:	80 93 f3 06 	sts	0x06F3, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 7f2:	e0 90 f3 06 	lds	r14, 0x06F3
 7f6:	f0 90 f4 06 	lds	r15, 0x06F4

			if( xConstTickCount == ( TickType_t ) 0U )
 7fa:	e1 14       	cp	r14, r1
 7fc:	f1 04       	cpc	r15, r1
 7fe:	b9 f4       	brne	.+46     	; 0x82e <xTaskIncrementTick+0x66>
			{
				taskSWITCH_DELAYED_LISTS();
 800:	80 91 0b 07 	lds	r24, 0x070B
 804:	90 91 0c 07 	lds	r25, 0x070C
 808:	20 91 09 07 	lds	r18, 0x0709
 80c:	30 91 0a 07 	lds	r19, 0x070A
 810:	30 93 0c 07 	sts	0x070C, r19
 814:	20 93 0b 07 	sts	0x070B, r18
 818:	90 93 0a 07 	sts	0x070A, r25
 81c:	80 93 09 07 	sts	0x0709, r24
 820:	80 91 ee 06 	lds	r24, 0x06EE
 824:	8f 5f       	subi	r24, 0xFF	; 255
 826:	80 93 ee 06 	sts	0x06EE, r24
 82a:	0e 94 40 02 	call	0x480	; 0x480 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 82e:	80 91 eb 06 	lds	r24, 0x06EB
 832:	90 91 ec 06 	lds	r25, 0x06EC
 836:	e8 16       	cp	r14, r24
 838:	f9 06       	cpc	r15, r25
 83a:	10 f4       	brcc	.+4      	; 0x840 <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 83c:	d1 2c       	mov	r13, r1
 83e:	53 c0       	rjmp	.+166    	; 0x8e6 <xTaskIncrementTick+0x11e>
 840:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
 842:	cc 24       	eor	r12, r12
 844:	c3 94       	inc	r12
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 846:	e0 91 0b 07 	lds	r30, 0x070B
 84a:	f0 91 0c 07 	lds	r31, 0x070C
 84e:	90 81       	ld	r25, Z
 850:	91 11       	cpse	r25, r1
 852:	07 c0       	rjmp	.+14     	; 0x862 <xTaskIncrementTick+0x9a>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 854:	8f ef       	ldi	r24, 0xFF	; 255
 856:	9f ef       	ldi	r25, 0xFF	; 255
 858:	90 93 ec 06 	sts	0x06EC, r25
 85c:	80 93 eb 06 	sts	0x06EB, r24
						break;
 860:	42 c0       	rjmp	.+132    	; 0x8e6 <xTaskIncrementTick+0x11e>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 862:	e0 91 0b 07 	lds	r30, 0x070B
 866:	f0 91 0c 07 	lds	r31, 0x070C
 86a:	05 80       	ldd	r0, Z+5	; 0x05
 86c:	f6 81       	ldd	r31, Z+6	; 0x06
 86e:	e0 2d       	mov	r30, r0
 870:	c6 81       	ldd	r28, Z+6	; 0x06
 872:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 874:	2a 81       	ldd	r18, Y+2	; 0x02
 876:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
 878:	e2 16       	cp	r14, r18
 87a:	f3 06       	cpc	r15, r19
 87c:	28 f4       	brcc	.+10     	; 0x888 <xTaskIncrementTick+0xc0>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
 87e:	30 93 ec 06 	sts	0x06EC, r19
 882:	20 93 eb 06 	sts	0x06EB, r18
							break;
 886:	2f c0       	rjmp	.+94     	; 0x8e6 <xTaskIncrementTick+0x11e>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 888:	8e 01       	movw	r16, r28
 88a:	0e 5f       	subi	r16, 0xFE	; 254
 88c:	1f 4f       	sbci	r17, 0xFF	; 255
 88e:	c8 01       	movw	r24, r16
 890:	0e 94 e5 00 	call	0x1ca	; 0x1ca <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 894:	8c 89       	ldd	r24, Y+20	; 0x14
 896:	9d 89       	ldd	r25, Y+21	; 0x15
 898:	89 2b       	or	r24, r25
 89a:	21 f0       	breq	.+8      	; 0x8a4 <xTaskIncrementTick+0xdc>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 89c:	ce 01       	movw	r24, r28
 89e:	0c 96       	adiw	r24, 0x0c	; 12
 8a0:	0e 94 e5 00 	call	0x1ca	; 0x1ca <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 8a4:	2e 89       	ldd	r18, Y+22	; 0x16
 8a6:	80 91 f2 06 	lds	r24, 0x06F2
 8aa:	82 17       	cp	r24, r18
 8ac:	10 f4       	brcc	.+4      	; 0x8b2 <xTaskIncrementTick+0xea>
 8ae:	20 93 f2 06 	sts	0x06F2, r18
 8b2:	30 e0       	ldi	r19, 0x00	; 0
 8b4:	c9 01       	movw	r24, r18
 8b6:	88 0f       	add	r24, r24
 8b8:	99 1f       	adc	r25, r25
 8ba:	88 0f       	add	r24, r24
 8bc:	99 1f       	adc	r25, r25
 8be:	88 0f       	add	r24, r24
 8c0:	99 1f       	adc	r25, r25
 8c2:	82 0f       	add	r24, r18
 8c4:	93 1f       	adc	r25, r19
 8c6:	b8 01       	movw	r22, r16
 8c8:	81 5e       	subi	r24, 0xE1	; 225
 8ca:	98 4f       	sbci	r25, 0xF8	; 248
 8cc:	0e 94 93 00 	call	0x126	; 0x126 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8d0:	e0 91 43 07 	lds	r30, 0x0743
 8d4:	f0 91 44 07 	lds	r31, 0x0744
 8d8:	9e 89       	ldd	r25, Y+22	; 0x16
 8da:	86 89       	ldd	r24, Z+22	; 0x16
 8dc:	98 17       	cp	r25, r24
 8de:	08 f4       	brcc	.+2      	; 0x8e2 <xTaskIncrementTick+0x11a>
 8e0:	b2 cf       	rjmp	.-156    	; 0x846 <xTaskIncrementTick+0x7e>
							{
								xSwitchRequired = pdTRUE;
 8e2:	dc 2c       	mov	r13, r12
 8e4:	b0 cf       	rjmp	.-160    	; 0x846 <xTaskIncrementTick+0x7e>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8e6:	e0 91 43 07 	lds	r30, 0x0743
 8ea:	f0 91 44 07 	lds	r31, 0x0744
 8ee:	86 89       	ldd	r24, Z+22	; 0x16
 8f0:	90 e0       	ldi	r25, 0x00	; 0
 8f2:	fc 01       	movw	r30, r24
 8f4:	ee 0f       	add	r30, r30
 8f6:	ff 1f       	adc	r31, r31
 8f8:	ee 0f       	add	r30, r30
 8fa:	ff 1f       	adc	r31, r31
 8fc:	ee 0f       	add	r30, r30
 8fe:	ff 1f       	adc	r31, r31
 900:	8e 0f       	add	r24, r30
 902:	9f 1f       	adc	r25, r31
 904:	fc 01       	movw	r30, r24
 906:	e1 5e       	subi	r30, 0xE1	; 225
 908:	f8 4f       	sbci	r31, 0xF8	; 248
 90a:	80 81       	ld	r24, Z
 90c:	82 30       	cpi	r24, 0x02	; 2
 90e:	48 f0       	brcs	.+18     	; 0x922 <xTaskIncrementTick+0x15a>
			{
				xSwitchRequired = pdTRUE;
 910:	dd 24       	eor	r13, r13
 912:	d3 94       	inc	r13
 914:	06 c0       	rjmp	.+12     	; 0x922 <xTaskIncrementTick+0x15a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 916:	80 91 f0 06 	lds	r24, 0x06F0
 91a:	8f 5f       	subi	r24, 0xFF	; 255
 91c:	80 93 f0 06 	sts	0x06F0, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 920:	d1 2c       	mov	r13, r1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 922:	80 91 ef 06 	lds	r24, 0x06EF
 926:	88 23       	and	r24, r24
 928:	11 f0       	breq	.+4      	; 0x92e <xTaskIncrementTick+0x166>
		{
			xSwitchRequired = pdTRUE;
 92a:	dd 24       	eor	r13, r13
 92c:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 92e:	8d 2d       	mov	r24, r13
 930:	df 91       	pop	r29
 932:	cf 91       	pop	r28
 934:	1f 91       	pop	r17
 936:	0f 91       	pop	r16
 938:	ff 90       	pop	r15
 93a:	ef 90       	pop	r14
 93c:	df 90       	pop	r13
 93e:	cf 90       	pop	r12
 940:	08 95       	ret

00000942 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 942:	df 92       	push	r13
 944:	ef 92       	push	r14
 946:	ff 92       	push	r15
 948:	0f 93       	push	r16
 94a:	1f 93       	push	r17
 94c:	cf 93       	push	r28
 94e:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 950:	0f b6       	in	r0, 0x3f	; 63
 952:	f8 94       	cli
 954:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
 956:	80 91 ea 06 	lds	r24, 0x06EA
 95a:	81 50       	subi	r24, 0x01	; 1
 95c:	80 93 ea 06 	sts	0x06EA, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 960:	80 91 ea 06 	lds	r24, 0x06EA
 964:	81 11       	cpse	r24, r1
 966:	62 c0       	rjmp	.+196    	; 0xa2c <xTaskResumeAll+0xea>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 968:	80 91 f5 06 	lds	r24, 0x06F5
 96c:	81 11       	cpse	r24, r1
 96e:	33 c0       	rjmp	.+102    	; 0x9d6 <xTaskResumeAll+0x94>
 970:	60 c0       	rjmp	.+192    	; 0xa32 <xTaskResumeAll+0xf0>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 972:	d7 01       	movw	r26, r14
 974:	15 96       	adiw	r26, 0x05	; 5
 976:	ed 91       	ld	r30, X+
 978:	fc 91       	ld	r31, X
 97a:	16 97       	sbiw	r26, 0x06	; 6
 97c:	c6 81       	ldd	r28, Z+6	; 0x06
 97e:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 980:	ce 01       	movw	r24, r28
 982:	0c 96       	adiw	r24, 0x0c	; 12
 984:	0e 94 e5 00 	call	0x1ca	; 0x1ca <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 988:	8e 01       	movw	r16, r28
 98a:	0e 5f       	subi	r16, 0xFE	; 254
 98c:	1f 4f       	sbci	r17, 0xFF	; 255
 98e:	c8 01       	movw	r24, r16
 990:	0e 94 e5 00 	call	0x1ca	; 0x1ca <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 994:	2e 89       	ldd	r18, Y+22	; 0x16
 996:	80 91 f2 06 	lds	r24, 0x06F2
 99a:	82 17       	cp	r24, r18
 99c:	10 f4       	brcc	.+4      	; 0x9a2 <xTaskResumeAll+0x60>
 99e:	20 93 f2 06 	sts	0x06F2, r18
 9a2:	30 e0       	ldi	r19, 0x00	; 0
 9a4:	c9 01       	movw	r24, r18
 9a6:	88 0f       	add	r24, r24
 9a8:	99 1f       	adc	r25, r25
 9aa:	88 0f       	add	r24, r24
 9ac:	99 1f       	adc	r25, r25
 9ae:	88 0f       	add	r24, r24
 9b0:	99 1f       	adc	r25, r25
 9b2:	82 0f       	add	r24, r18
 9b4:	93 1f       	adc	r25, r19
 9b6:	b8 01       	movw	r22, r16
 9b8:	81 5e       	subi	r24, 0xE1	; 225
 9ba:	98 4f       	sbci	r25, 0xF8	; 248
 9bc:	0e 94 93 00 	call	0x126	; 0x126 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 9c0:	e0 91 43 07 	lds	r30, 0x0743
 9c4:	f0 91 44 07 	lds	r31, 0x0744
 9c8:	9e 89       	ldd	r25, Y+22	; 0x16
 9ca:	86 89       	ldd	r24, Z+22	; 0x16
 9cc:	98 17       	cp	r25, r24
 9ce:	58 f0       	brcs	.+22     	; 0x9e6 <xTaskResumeAll+0xa4>
					{
						xYieldPending = pdTRUE;
 9d0:	d0 92 ef 06 	sts	0x06EF, r13
 9d4:	08 c0       	rjmp	.+16     	; 0x9e6 <xTaskResumeAll+0xa4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 9d6:	0f 2e       	mov	r0, r31
 9d8:	f0 e0       	ldi	r31, 0x00	; 0
 9da:	ef 2e       	mov	r14, r31
 9dc:	f7 e0       	ldi	r31, 0x07	; 7
 9de:	ff 2e       	mov	r15, r31
 9e0:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
 9e2:	dd 24       	eor	r13, r13
 9e4:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 9e6:	f7 01       	movw	r30, r14
 9e8:	80 81       	ld	r24, Z
 9ea:	81 11       	cpse	r24, r1
 9ec:	c2 cf       	rjmp	.-124    	; 0x972 <xTaskResumeAll+0x30>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
 9ee:	80 91 f0 06 	lds	r24, 0x06F0
 9f2:	88 23       	and	r24, r24
 9f4:	99 f0       	breq	.+38     	; 0xa1c <xTaskResumeAll+0xda>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 9f6:	80 91 f0 06 	lds	r24, 0x06F0
 9fa:	88 23       	and	r24, r24
 9fc:	79 f0       	breq	.+30     	; 0xa1c <xTaskResumeAll+0xda>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
 9fe:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
 a00:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <xTaskIncrementTick>
 a04:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
 a06:	c0 93 ef 06 	sts	0x06EF, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
 a0a:	80 91 f0 06 	lds	r24, 0x06F0
 a0e:	81 50       	subi	r24, 0x01	; 1
 a10:	80 93 f0 06 	sts	0x06F0, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 a14:	80 91 f0 06 	lds	r24, 0x06F0
 a18:	81 11       	cpse	r24, r1
 a1a:	f2 cf       	rjmp	.-28     	; 0xa00 <xTaskResumeAll+0xbe>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
 a1c:	80 91 ef 06 	lds	r24, 0x06EF
 a20:	81 30       	cpi	r24, 0x01	; 1
 a22:	31 f4       	brne	.+12     	; 0xa30 <xTaskResumeAll+0xee>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 a24:	0e 94 b1 01 	call	0x362	; 0x362 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 a28:	81 e0       	ldi	r24, 0x01	; 1
 a2a:	03 c0       	rjmp	.+6      	; 0xa32 <xTaskResumeAll+0xf0>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
 a2c:	80 e0       	ldi	r24, 0x00	; 0
 a2e:	01 c0       	rjmp	.+2      	; 0xa32 <xTaskResumeAll+0xf0>
 a30:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 a32:	0f 90       	pop	r0
 a34:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
 a36:	df 91       	pop	r29
 a38:	cf 91       	pop	r28
 a3a:	1f 91       	pop	r17
 a3c:	0f 91       	pop	r16
 a3e:	ff 90       	pop	r15
 a40:	ef 90       	pop	r14
 a42:	df 90       	pop	r13
 a44:	08 95       	ret

00000a46 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
 a46:	0f 93       	push	r16
 a48:	1f 93       	push	r17
 a4a:	cf 93       	push	r28
 a4c:	df 93       	push	r29
 a4e:	8c 01       	movw	r16, r24
 a50:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
 a52:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 a56:	80 91 f3 06 	lds	r24, 0x06F3
 a5a:	90 91 f4 06 	lds	r25, 0x06F4

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 a5e:	f8 01       	movw	r30, r16
 a60:	20 81       	ld	r18, Z
 a62:	31 81       	ldd	r19, Z+1	; 0x01
 a64:	c2 0f       	add	r28, r18
 a66:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
 a68:	82 17       	cp	r24, r18
 a6a:	93 07       	cpc	r25, r19
 a6c:	48 f4       	brcc	.+18     	; 0xa80 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 a6e:	c2 17       	cp	r28, r18
 a70:	d3 07       	cpc	r29, r19
 a72:	10 f5       	brcc	.+68     	; 0xab8 <vTaskDelayUntil+0x72>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 a74:	d1 83       	std	Z+1, r29	; 0x01
 a76:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
 a78:	8c 17       	cp	r24, r28
 a7a:	9d 07       	cpc	r25, r29
 a7c:	90 f4       	brcc	.+36     	; 0xaa2 <vTaskDelayUntil+0x5c>
 a7e:	07 c0       	rjmp	.+14     	; 0xa8e <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 a80:	c2 17       	cp	r28, r18
 a82:	d3 07       	cpc	r29, r19
 a84:	a8 f0       	brcs	.+42     	; 0xab0 <vTaskDelayUntil+0x6a>
 a86:	8c 17       	cp	r24, r28
 a88:	9d 07       	cpc	r25, r29
 a8a:	90 f0       	brcs	.+36     	; 0xab0 <vTaskDelayUntil+0x6a>
 a8c:	15 c0       	rjmp	.+42     	; 0xab8 <vTaskDelayUntil+0x72>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 a8e:	80 91 43 07 	lds	r24, 0x0743
 a92:	90 91 44 07 	lds	r25, 0x0744
 a96:	02 96       	adiw	r24, 0x02	; 2
 a98:	0e 94 e5 00 	call	0x1ca	; 0x1ca <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
 a9c:	ce 01       	movw	r24, r28
 a9e:	0e 94 5f 02 	call	0x4be	; 0x4be <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 aa2:	0e 94 a1 04 	call	0x942	; 0x942 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 aa6:	81 11       	cpse	r24, r1
 aa8:	0b c0       	rjmp	.+22     	; 0xac0 <vTaskDelayUntil+0x7a>
		{
			portYIELD_WITHIN_API();
 aaa:	0e 94 b1 01 	call	0x362	; 0x362 <vPortYield>
 aae:	08 c0       	rjmp	.+16     	; 0xac0 <vTaskDelayUntil+0x7a>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 ab0:	f8 01       	movw	r30, r16
 ab2:	d1 83       	std	Z+1, r29	; 0x01
 ab4:	c0 83       	st	Z, r28
 ab6:	eb cf       	rjmp	.-42     	; 0xa8e <vTaskDelayUntil+0x48>
 ab8:	f8 01       	movw	r30, r16
 aba:	d1 83       	std	Z+1, r29	; 0x01
 abc:	c0 83       	st	Z, r28
 abe:	f1 cf       	rjmp	.-30     	; 0xaa2 <vTaskDelayUntil+0x5c>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 ac0:	df 91       	pop	r29
 ac2:	cf 91       	pop	r28
 ac4:	1f 91       	pop	r17
 ac6:	0f 91       	pop	r16
 ac8:	08 95       	ret

00000aca <prvIdleTask>:
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 aca:	07 ef       	ldi	r16, 0xF7	; 247
 acc:	16 e0       	ldi	r17, 0x06	; 6

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 ace:	0f 2e       	mov	r0, r31
 ad0:	ff e1       	ldi	r31, 0x1F	; 31
 ad2:	ef 2e       	mov	r14, r31
 ad4:	f7 e0       	ldi	r31, 0x07	; 7
 ad6:	ff 2e       	mov	r15, r31
 ad8:	f0 2d       	mov	r31, r0
 ada:	29 c0       	rjmp	.+82     	; 0xb2e <prvIdleTask+0x64>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
 adc:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 ae0:	d8 01       	movw	r26, r16
 ae2:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
 ae4:	0e 94 a1 04 	call	0x942	; 0x942 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 ae8:	cc 23       	and	r28, r28
 aea:	09 f1       	breq	.+66     	; 0xb2e <prvIdleTask+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 aec:	0f b6       	in	r0, 0x3f	; 63
 aee:	f8 94       	cli
 af0:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 af2:	d8 01       	movw	r26, r16
 af4:	15 96       	adiw	r26, 0x05	; 5
 af6:	ed 91       	ld	r30, X+
 af8:	fc 91       	ld	r31, X
 afa:	16 97       	sbiw	r26, 0x06	; 6
 afc:	c6 81       	ldd	r28, Z+6	; 0x06
 afe:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 b00:	ce 01       	movw	r24, r28
 b02:	02 96       	adiw	r24, 0x02	; 2
 b04:	0e 94 e5 00 	call	0x1ca	; 0x1ca <uxListRemove>
					--uxCurrentNumberOfTasks;
 b08:	80 91 f5 06 	lds	r24, 0x06F5
 b0c:	81 50       	subi	r24, 0x01	; 1
 b0e:	80 93 f5 06 	sts	0x06F5, r24
					--uxTasksDeleted;
 b12:	80 91 f6 06 	lds	r24, 0x06F6
 b16:	81 50       	subi	r24, 0x01	; 1
 b18:	80 93 f6 06 	sts	0x06F6, r24
				}
				taskEXIT_CRITICAL();
 b1c:	0f 90       	pop	r0
 b1e:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
 b20:	8f 89       	ldd	r24, Y+23	; 0x17
 b22:	98 8d       	ldd	r25, Y+24	; 0x18
 b24:	0e 94 3f 02 	call	0x47e	; 0x47e <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
 b28:	ce 01       	movw	r24, r28
 b2a:	0e 94 3f 02 	call	0x47e	; 0x47e <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 b2e:	80 91 f6 06 	lds	r24, 0x06F6
 b32:	81 11       	cpse	r24, r1
 b34:	d3 cf       	rjmp	.-90     	; 0xadc <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 b36:	f7 01       	movw	r30, r14
 b38:	80 81       	ld	r24, Z
 b3a:	82 30       	cpi	r24, 0x02	; 2
 b3c:	c0 f3       	brcs	.-16     	; 0xb2e <prvIdleTask+0x64>
			{
				taskYIELD();
 b3e:	0e 94 b1 01 	call	0x362	; 0x362 <vPortYield>
 b42:	f5 cf       	rjmp	.-22     	; 0xb2e <prvIdleTask+0x64>

00000b44 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 b44:	80 91 ea 06 	lds	r24, 0x06EA
 b48:	88 23       	and	r24, r24
 b4a:	21 f0       	breq	.+8      	; 0xb54 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 b4c:	81 e0       	ldi	r24, 0x01	; 1
 b4e:	80 93 ef 06 	sts	0x06EF, r24
 b52:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 b54:	10 92 ef 06 	sts	0x06EF, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 b58:	80 91 f2 06 	lds	r24, 0x06F2
 b5c:	90 e0       	ldi	r25, 0x00	; 0
 b5e:	fc 01       	movw	r30, r24
 b60:	ee 0f       	add	r30, r30
 b62:	ff 1f       	adc	r31, r31
 b64:	ee 0f       	add	r30, r30
 b66:	ff 1f       	adc	r31, r31
 b68:	ee 0f       	add	r30, r30
 b6a:	ff 1f       	adc	r31, r31
 b6c:	8e 0f       	add	r24, r30
 b6e:	9f 1f       	adc	r25, r31
 b70:	fc 01       	movw	r30, r24
 b72:	e1 5e       	subi	r30, 0xE1	; 225
 b74:	f8 4f       	sbci	r31, 0xF8	; 248
 b76:	80 81       	ld	r24, Z
 b78:	81 11       	cpse	r24, r1
 b7a:	17 c0       	rjmp	.+46     	; 0xbaa <vTaskSwitchContext+0x66>
 b7c:	80 91 f2 06 	lds	r24, 0x06F2
 b80:	81 50       	subi	r24, 0x01	; 1
 b82:	80 93 f2 06 	sts	0x06F2, r24
 b86:	80 91 f2 06 	lds	r24, 0x06F2
 b8a:	90 e0       	ldi	r25, 0x00	; 0
 b8c:	fc 01       	movw	r30, r24
 b8e:	ee 0f       	add	r30, r30
 b90:	ff 1f       	adc	r31, r31
 b92:	ee 0f       	add	r30, r30
 b94:	ff 1f       	adc	r31, r31
 b96:	ee 0f       	add	r30, r30
 b98:	ff 1f       	adc	r31, r31
 b9a:	8e 0f       	add	r24, r30
 b9c:	9f 1f       	adc	r25, r31
 b9e:	fc 01       	movw	r30, r24
 ba0:	e1 5e       	subi	r30, 0xE1	; 225
 ba2:	f8 4f       	sbci	r31, 0xF8	; 248
 ba4:	80 81       	ld	r24, Z
 ba6:	88 23       	and	r24, r24
 ba8:	49 f3       	breq	.-46     	; 0xb7c <vTaskSwitchContext+0x38>
 baa:	80 91 f2 06 	lds	r24, 0x06F2
 bae:	90 e0       	ldi	r25, 0x00	; 0
 bb0:	9c 01       	movw	r18, r24
 bb2:	22 0f       	add	r18, r18
 bb4:	33 1f       	adc	r19, r19
 bb6:	22 0f       	add	r18, r18
 bb8:	33 1f       	adc	r19, r19
 bba:	22 0f       	add	r18, r18
 bbc:	33 1f       	adc	r19, r19
 bbe:	28 0f       	add	r18, r24
 bc0:	39 1f       	adc	r19, r25
 bc2:	d9 01       	movw	r26, r18
 bc4:	a1 5e       	subi	r26, 0xE1	; 225
 bc6:	b8 4f       	sbci	r27, 0xF8	; 248
 bc8:	11 96       	adiw	r26, 0x01	; 1
 bca:	ed 91       	ld	r30, X+
 bcc:	fc 91       	ld	r31, X
 bce:	12 97       	sbiw	r26, 0x02	; 2
 bd0:	02 80       	ldd	r0, Z+2	; 0x02
 bd2:	f3 81       	ldd	r31, Z+3	; 0x03
 bd4:	e0 2d       	mov	r30, r0
 bd6:	12 96       	adiw	r26, 0x02	; 2
 bd8:	fc 93       	st	X, r31
 bda:	ee 93       	st	-X, r30
 bdc:	11 97       	sbiw	r26, 0x01	; 1
 bde:	2e 5d       	subi	r18, 0xDE	; 222
 be0:	38 4f       	sbci	r19, 0xF8	; 248
 be2:	e2 17       	cp	r30, r18
 be4:	f3 07       	cpc	r31, r19
 be6:	29 f4       	brne	.+10     	; 0xbf2 <vTaskSwitchContext+0xae>
 be8:	22 81       	ldd	r18, Z+2	; 0x02
 bea:	33 81       	ldd	r19, Z+3	; 0x03
 bec:	fd 01       	movw	r30, r26
 bee:	32 83       	std	Z+2, r19	; 0x02
 bf0:	21 83       	std	Z+1, r18	; 0x01
 bf2:	fc 01       	movw	r30, r24
 bf4:	ee 0f       	add	r30, r30
 bf6:	ff 1f       	adc	r31, r31
 bf8:	ee 0f       	add	r30, r30
 bfa:	ff 1f       	adc	r31, r31
 bfc:	ee 0f       	add	r30, r30
 bfe:	ff 1f       	adc	r31, r31
 c00:	8e 0f       	add	r24, r30
 c02:	9f 1f       	adc	r25, r31
 c04:	fc 01       	movw	r30, r24
 c06:	e1 5e       	subi	r30, 0xE1	; 225
 c08:	f8 4f       	sbci	r31, 0xF8	; 248
 c0a:	01 80       	ldd	r0, Z+1	; 0x01
 c0c:	f2 81       	ldd	r31, Z+2	; 0x02
 c0e:	e0 2d       	mov	r30, r0
 c10:	86 81       	ldd	r24, Z+6	; 0x06
 c12:	97 81       	ldd	r25, Z+7	; 0x07
 c14:	90 93 44 07 	sts	0x0744, r25
 c18:	80 93 43 07 	sts	0x0743, r24
 c1c:	08 95       	ret

00000c1e <config_io_pin>:

#include "tasks.h"
#include <avr/io.h>

void config_io_pin(uint8_t port, uint8_t port_ch, uint8_t dir){
	switch(port){
 c1e:	81 30       	cpi	r24, 0x01	; 1
 c20:	b9 f0       	breq	.+46     	; 0xc50 <config_io_pin+0x32>
 c22:	18 f0       	brcs	.+6      	; 0xc2a <config_io_pin+0xc>
 c24:	82 30       	cpi	r24, 0x02	; 2
 c26:	39 f1       	breq	.+78     	; 0xc76 <config_io_pin+0x58>
 c28:	08 95       	ret
		case IO_PORT_B:
		//Crazy bit trickery that sets the port_ch bit of DDRB to dir
		DDRB ^= ((-dir) ^ DDRB) & (1 << port_ch);
 c2a:	84 b1       	in	r24, 0x04	; 4
 c2c:	24 b1       	in	r18, 0x04	; 4
 c2e:	50 e0       	ldi	r21, 0x00	; 0
 c30:	51 95       	neg	r21
 c32:	41 95       	neg	r20
 c34:	51 09       	sbc	r21, r1
 c36:	48 27       	eor	r20, r24
 c38:	81 e0       	ldi	r24, 0x01	; 1
 c3a:	90 e0       	ldi	r25, 0x00	; 0
 c3c:	02 c0       	rjmp	.+4      	; 0xc42 <config_io_pin+0x24>
 c3e:	88 0f       	add	r24, r24
 c40:	99 1f       	adc	r25, r25
 c42:	6a 95       	dec	r22
 c44:	e2 f7       	brpl	.-8      	; 0xc3e <config_io_pin+0x20>
 c46:	48 23       	and	r20, r24
 c48:	59 23       	and	r21, r25
 c4a:	42 27       	eor	r20, r18
 c4c:	44 b9       	out	0x04, r20	; 4
		break;
 c4e:	08 95       	ret
		case IO_PORT_C:
		DDRC ^= ((-dir) ^ DDRC) & (1 << port_ch);
 c50:	87 b1       	in	r24, 0x07	; 7
 c52:	27 b1       	in	r18, 0x07	; 7
 c54:	50 e0       	ldi	r21, 0x00	; 0
 c56:	51 95       	neg	r21
 c58:	41 95       	neg	r20
 c5a:	51 09       	sbc	r21, r1
 c5c:	48 27       	eor	r20, r24
 c5e:	81 e0       	ldi	r24, 0x01	; 1
 c60:	90 e0       	ldi	r25, 0x00	; 0
 c62:	02 c0       	rjmp	.+4      	; 0xc68 <config_io_pin+0x4a>
 c64:	88 0f       	add	r24, r24
 c66:	99 1f       	adc	r25, r25
 c68:	6a 95       	dec	r22
 c6a:	e2 f7       	brpl	.-8      	; 0xc64 <config_io_pin+0x46>
 c6c:	48 23       	and	r20, r24
 c6e:	59 23       	and	r21, r25
 c70:	42 27       	eor	r20, r18
 c72:	47 b9       	out	0x07, r20	; 7
		break;
 c74:	08 95       	ret
		case IO_PORT_D:
		DDRD ^= ((-dir) ^ DDRD) & (1 << port_ch);
 c76:	8a b1       	in	r24, 0x0a	; 10
 c78:	2a b1       	in	r18, 0x0a	; 10
 c7a:	50 e0       	ldi	r21, 0x00	; 0
 c7c:	51 95       	neg	r21
 c7e:	41 95       	neg	r20
 c80:	51 09       	sbc	r21, r1
 c82:	48 27       	eor	r20, r24
 c84:	81 e0       	ldi	r24, 0x01	; 1
 c86:	90 e0       	ldi	r25, 0x00	; 0
 c88:	02 c0       	rjmp	.+4      	; 0xc8e <config_io_pin+0x70>
 c8a:	88 0f       	add	r24, r24
 c8c:	99 1f       	adc	r25, r25
 c8e:	6a 95       	dec	r22
 c90:	e2 f7       	brpl	.-8      	; 0xc8a <config_io_pin+0x6c>
 c92:	48 23       	and	r20, r24
 c94:	59 23       	and	r21, r25
 c96:	42 27       	eor	r20, r18
 c98:	4a b9       	out	0x0a, r20	; 10
 c9a:	08 95       	ret

00000c9c <vLEDFlashTask>:
		default:
		break;
	}
}

void vLEDFlashTask(void *pvParameters) {
 c9c:	cf 93       	push	r28
 c9e:	df 93       	push	r29
 ca0:	00 d0       	rcall	.+0      	; 0xca2 <vLEDFlashTask+0x6>
 ca2:	cd b7       	in	r28, 0x3d	; 61
 ca4:	de b7       	in	r29, 0x3e	; 62
	config_io_pin(IO_PORT_C, 0, IO_DIR_OUTPUT);
 ca6:	41 e0       	ldi	r20, 0x01	; 1
 ca8:	60 e0       	ldi	r22, 0x00	; 0
 caa:	81 e0       	ldi	r24, 0x01	; 1
 cac:	0e 94 0f 06 	call	0xc1e	; 0xc1e <config_io_pin>
	
	portTickType xLastWakeTime;
	const portTickType xFrequency = 1000;
	xLastWakeTime = xTaskGetTickCount();
 cb0:	0e 94 da 03 	call	0x7b4	; 0x7b4 <xTaskGetTickCount>
 cb4:	9a 83       	std	Y+2, r25	; 0x02
 cb6:	89 83       	std	Y+1, r24	; 0x01
	
	for(;;) {
		PORTC ^= 1;
 cb8:	11 e0       	ldi	r17, 0x01	; 1
 cba:	88 b1       	in	r24, 0x08	; 8
 cbc:	81 27       	eor	r24, r17
 cbe:	88 b9       	out	0x08, r24	; 8
		vTaskDelayUntil(&xLastWakeTime, xFrequency);
 cc0:	68 ee       	ldi	r22, 0xE8	; 232
 cc2:	73 e0       	ldi	r23, 0x03	; 3
 cc4:	ce 01       	movw	r24, r28
 cc6:	01 96       	adiw	r24, 0x01	; 1
 cc8:	0e 94 23 05 	call	0xa46	; 0xa46 <vTaskDelayUntil>
	}
 ccc:	f6 cf       	rjmp	.-20     	; 0xcba <vLEDFlashTask+0x1e>

00000cce <_exit>:
 cce:	f8 94       	cli

00000cd0 <__stop_program>:
 cd0:	ff cf       	rjmp	.-2      	; 0xcd0 <__stop_program>
