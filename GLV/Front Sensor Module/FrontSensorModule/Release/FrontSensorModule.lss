
FrontSensorModule.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800100  00003918  000039ac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003918  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000046c  0080011e  0080011e  000039ca  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000039ca  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000039fc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000120  00000000  00000000  00003a3c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002750  00000000  00000000  00003b5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000a27  00000000  00000000  000062ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002376  00000000  00000000  00006cd3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000bdc  00000000  00000000  0000904c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000ebc0  00000000  00000000  00009c28  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000186c  00000000  00000000  000187e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000018  00000000  00000000  0001a054  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00004da4  00000000  00000000  0001a06c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 a2 08 	jmp	0x1144	; 0x1144 <__vector_12>
      34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 5d 00 	jmp	0xba	; 0xba <__vector_18>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d0 e1       	ldi	r29, 0x10	; 16
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	11 e0       	ldi	r17, 0x01	; 1
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	e8 e1       	ldi	r30, 0x18	; 24
      90:	f9 e3       	ldi	r31, 0x39	; 57
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	ae 31       	cpi	r26, 0x1E	; 30
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	25 e0       	ldi	r18, 0x05	; 5
      a0:	ae e1       	ldi	r26, 0x1E	; 30
      a2:	b1 e0       	ldi	r27, 0x01	; 1
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	aa 38       	cpi	r26, 0x8A	; 138
      aa:	b2 07       	cpc	r27, r18
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 02 04 	call	0x804	; 0x804 <main>
      b2:	0c 94 8a 1c 	jmp	0x3914	; 0x3914 <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <__vector_18>:

//! CAN interrupt service routine

//! presently only used for reception of CAN packets
ISR( CAN_INT_vect )
	{
      ba:	1f 92       	push	r1
      bc:	0f 92       	push	r0
      be:	00 90 5f 00 	lds	r0, 0x005F
      c2:	0f 92       	push	r0
      c4:	11 24       	eor	r1, r1
      c6:	1f 93       	push	r17
      c8:	2f 93       	push	r18
      ca:	3f 93       	push	r19
      cc:	4f 93       	push	r20
      ce:	5f 93       	push	r21
      d0:	6f 93       	push	r22
      d2:	7f 93       	push	r23
      d4:	8f 93       	push	r24
      d6:	9f 93       	push	r25
      d8:	af 93       	push	r26
      da:	bf 93       	push	r27
      dc:	ef 93       	push	r30
      de:	ff 93       	push	r31
      e0:	cf 93       	push	r28
      e2:	df 93       	push	r29
      e4:	cd b7       	in	r28, 0x3d	; 61
      e6:	de b7       	in	r29, 0x3e	; 62
      e8:	25 97       	sbiw	r28, 0x05	; 5
      ea:	de bf       	out	0x3e, r29	; 62
      ec:	cd bf       	out	0x3d, r28	; 61
	unsigned i;
	static CAN_packet packet;
	char save_canpage=CANPAGE;
      ee:	8d ee       	ldi	r24, 0xED	; 237
      f0:	90 e0       	ldi	r25, 0x00	; 0
      f2:	fc 01       	movw	r30, r24
      f4:	80 81       	ld	r24, Z
      f6:	8b 83       	std	Y+3, r24	; 0x03
	
	unsigned mob=CANHPMOB; // get highest prio mob
      f8:	8c ee       	ldi	r24, 0xEC	; 236
      fa:	90 e0       	ldi	r25, 0x00	; 0
      fc:	fc 01       	movw	r30, r24
      fe:	80 81       	ld	r24, Z
     100:	88 2f       	mov	r24, r24
     102:	90 e0       	ldi	r25, 0x00	; 0
     104:	9d 83       	std	Y+5, r25	; 0x05
     106:	8c 83       	std	Y+4, r24	; 0x04
    CANPAGE = mob & 0xf0;
     108:	8d ee       	ldi	r24, 0xED	; 237
     10a:	90 e0       	ldi	r25, 0x00	; 0
     10c:	2c 81       	ldd	r18, Y+4	; 0x04
     10e:	20 7f       	andi	r18, 0xF0	; 240
     110:	fc 01       	movw	r30, r24
     112:	20 83       	st	Z, r18
	mob >>= 4; // -> mob number 0..15
     114:	8c 81       	ldd	r24, Y+4	; 0x04
     116:	9d 81       	ldd	r25, Y+5	; 0x05
     118:	92 95       	swap	r25
     11a:	82 95       	swap	r24
     11c:	8f 70       	andi	r24, 0x0F	; 15
     11e:	89 27       	eor	r24, r25
     120:	9f 70       	andi	r25, 0x0F	; 15
     122:	89 27       	eor	r24, r25
     124:	9d 83       	std	Y+5, r25	; 0x05
     126:	8c 83       	std	Y+4, r24	; 0x04
	assert( (CANSTMOB & ~0xa0) ==0); // allow only RX ready and DLC warning
	register char length;
	packet.id=(CANIDT2>>5) | (CANIDT1 <<3);
     128:	82 ef       	ldi	r24, 0xF2	; 242
     12a:	90 e0       	ldi	r25, 0x00	; 0
     12c:	fc 01       	movw	r30, r24
     12e:	80 81       	ld	r24, Z
     130:	82 95       	swap	r24
     132:	86 95       	lsr	r24
     134:	87 70       	andi	r24, 0x07	; 7
     136:	28 2f       	mov	r18, r24
     138:	30 e0       	ldi	r19, 0x00	; 0
     13a:	83 ef       	ldi	r24, 0xF3	; 243
     13c:	90 e0       	ldi	r25, 0x00	; 0
     13e:	fc 01       	movw	r30, r24
     140:	80 81       	ld	r24, Z
     142:	88 2f       	mov	r24, r24
     144:	90 e0       	ldi	r25, 0x00	; 0
     146:	88 0f       	add	r24, r24
     148:	99 1f       	adc	r25, r25
     14a:	88 0f       	add	r24, r24
     14c:	99 1f       	adc	r25, r25
     14e:	88 0f       	add	r24, r24
     150:	99 1f       	adc	r25, r25
     152:	82 2b       	or	r24, r18
     154:	93 2b       	or	r25, r19
     156:	90 93 1f 01 	sts	0x011F, r25
     15a:	80 93 1e 01 	sts	0x011E, r24
	length=CANCDMOB & 0x0f;
     15e:	8f ee       	ldi	r24, 0xEF	; 239
     160:	90 e0       	ldi	r25, 0x00	; 0
     162:	fc 01       	movw	r30, r24
     164:	80 81       	ld	r24, Z
     166:	18 2f       	mov	r17, r24
     168:	1f 70       	andi	r17, 0x0F	; 15
	packet.length=length;
     16a:	81 2f       	mov	r24, r17
     16c:	80 93 20 01 	sts	0x0120, r24
	for (i = 0; i <length; ++i)
     170:	1a 82       	std	Y+2, r1	; 0x02
     172:	19 82       	std	Y+1, r1	; 0x01
     174:	0f c0       	rjmp	.+30     	; 0x194 <__vector_18+0xda>
		{
		 packet.data[i] = CANMSG;
     176:	8a ef       	ldi	r24, 0xFA	; 250
     178:	90 e0       	ldi	r25, 0x00	; 0
     17a:	fc 01       	movw	r30, r24
     17c:	20 81       	ld	r18, Z
     17e:	89 81       	ldd	r24, Y+1	; 0x01
     180:	9a 81       	ldd	r25, Y+2	; 0x02
     182:	8f 5d       	subi	r24, 0xDF	; 223
     184:	9e 4f       	sbci	r25, 0xFE	; 254
     186:	fc 01       	movw	r30, r24
     188:	20 83       	st	Z, r18
	assert( (CANSTMOB & ~0xa0) ==0); // allow only RX ready and DLC warning
	register char length;
	packet.id=(CANIDT2>>5) | (CANIDT1 <<3);
	length=CANCDMOB & 0x0f;
	packet.length=length;
	for (i = 0; i <length; ++i)
     18a:	89 81       	ldd	r24, Y+1	; 0x01
     18c:	9a 81       	ldd	r25, Y+2	; 0x02
     18e:	01 96       	adiw	r24, 0x01	; 1
     190:	9a 83       	std	Y+2, r25	; 0x02
     192:	89 83       	std	Y+1, r24	; 0x01
     194:	21 2f       	mov	r18, r17
     196:	01 2e       	mov	r0, r17
     198:	00 0c       	add	r0, r0
     19a:	33 0b       	sbc	r19, r19
     19c:	89 81       	ldd	r24, Y+1	; 0x01
     19e:	9a 81       	ldd	r25, Y+2	; 0x02
     1a0:	82 17       	cp	r24, r18
     1a2:	93 07       	cpc	r25, r19
     1a4:	40 f3       	brcs	.-48     	; 0x176 <__vector_18+0xbc>
		{
		 packet.data[i] = CANMSG;
		}
	CANSTMOB=0;		// reset INT reason
     1a6:	8e ee       	ldi	r24, 0xEE	; 238
     1a8:	90 e0       	ldi	r25, 0x00	; 0
     1aa:	fc 01       	movw	r30, r24
     1ac:	10 82       	st	Z, r1
	CANCDMOB=0x80;	// re-enable RX on this channel
     1ae:	8f ee       	ldi	r24, 0xEF	; 239
     1b0:	90 e0       	ldi	r25, 0x00	; 0
     1b2:	20 e8       	ldi	r18, 0x80	; 128
     1b4:	fc 01       	movw	r30, r24
     1b6:	20 83       	st	Z, r18
	canlist[ mob]( &packet, mob);
     1b8:	8c 81       	ldd	r24, Y+4	; 0x04
     1ba:	9d 81       	ldd	r25, Y+5	; 0x05
     1bc:	88 0f       	add	r24, r24
     1be:	99 1f       	adc	r25, r25
     1c0:	80 59       	subi	r24, 0x90	; 144
     1c2:	9a 4f       	sbci	r25, 0xFA	; 250
     1c4:	fc 01       	movw	r30, r24
     1c6:	20 81       	ld	r18, Z
     1c8:	31 81       	ldd	r19, Z+1	; 0x01
     1ca:	8c 81       	ldd	r24, Y+4	; 0x04
     1cc:	68 2f       	mov	r22, r24
     1ce:	8e e1       	ldi	r24, 0x1E	; 30
     1d0:	91 e0       	ldi	r25, 0x01	; 1
     1d2:	f9 01       	movw	r30, r18
     1d4:	09 95       	icall
	CANPAGE=save_canpage;	// restore CANPAGE
     1d6:	8d ee       	ldi	r24, 0xED	; 237
     1d8:	90 e0       	ldi	r25, 0x00	; 0
     1da:	2b 81       	ldd	r18, Y+3	; 0x03
     1dc:	fc 01       	movw	r30, r24
     1de:	20 83       	st	Z, r18
	}
     1e0:	0f 90       	pop	r0
     1e2:	0f 90       	pop	r0
     1e4:	0f 90       	pop	r0
     1e6:	0f 90       	pop	r0
     1e8:	0f 90       	pop	r0
     1ea:	df 91       	pop	r29
     1ec:	cf 91       	pop	r28
     1ee:	ff 91       	pop	r31
     1f0:	ef 91       	pop	r30
     1f2:	bf 91       	pop	r27
     1f4:	af 91       	pop	r26
     1f6:	9f 91       	pop	r25
     1f8:	8f 91       	pop	r24
     1fa:	7f 91       	pop	r23
     1fc:	6f 91       	pop	r22
     1fe:	5f 91       	pop	r21
     200:	4f 91       	pop	r20
     202:	3f 91       	pop	r19
     204:	2f 91       	pop	r18
     206:	1f 91       	pop	r17
     208:	0f 90       	pop	r0
     20a:	00 92 5f 00 	sts	0x005F, r0
     20e:	0f 90       	pop	r0
     210:	1f 90       	pop	r1
     212:	18 95       	reti

00000214 <can_tx>:

bool can_tx( char mob, 	CAN_packet *packet)
	{
     214:	cf 93       	push	r28
     216:	df 93       	push	r29
     218:	00 d0       	rcall	.+0      	; 0x21a <can_tx+0x6>
     21a:	00 d0       	rcall	.+0      	; 0x21c <can_tx+0x8>
     21c:	1f 92       	push	r1
     21e:	cd b7       	in	r28, 0x3d	; 61
     220:	de b7       	in	r29, 0x3e	; 62
     222:	8b 83       	std	Y+3, r24	; 0x03
     224:	7d 83       	std	Y+5, r23	; 0x05
     226:	6c 83       	std	Y+4, r22	; 0x04
	unsigned cnt;
	assert( packet->id <= 0x7ff);
	assert( packet->length <=8);
	assert( mob <=14);
    CANPAGE = mob << 4;
     228:	8d ee       	ldi	r24, 0xED	; 237
     22a:	90 e0       	ldi	r25, 0x00	; 0
     22c:	2b 81       	ldd	r18, Y+3	; 0x03
     22e:	22 95       	swap	r18
     230:	20 7f       	andi	r18, 0xF0	; 240
     232:	fc 01       	movw	r30, r24
     234:	20 83       	st	Z, r18
	if(
		(  CANCDMOB & 0b11000000) // if MOB in use
     236:	8f ee       	ldi	r24, 0xEF	; 239
     238:	90 e0       	ldi	r25, 0x00	; 0
     23a:	fc 01       	movw	r30, r24
     23c:	80 81       	ld	r24, Z
     23e:	88 2f       	mov	r24, r24
     240:	90 e0       	ldi	r25, 0x00	; 0
     242:	80 7c       	andi	r24, 0xC0	; 192
     244:	99 27       	eor	r25, r25
	unsigned cnt;
	assert( packet->id <= 0x7ff);
	assert( packet->length <=8);
	assert( mob <=14);
    CANPAGE = mob << 4;
	if(
     246:	89 2b       	or	r24, r25
     248:	61 f0       	breq	.+24     	; 0x262 <can_tx+0x4e>
		(  CANCDMOB & 0b11000000) // if MOB in use
		&& 
	  	( (CANSTMOB & 0x40) ==0)   // TX not ready
     24a:	8e ee       	ldi	r24, 0xEE	; 238
     24c:	90 e0       	ldi	r25, 0x00	; 0
     24e:	fc 01       	movw	r30, r24
     250:	80 81       	ld	r24, Z
     252:	88 2f       	mov	r24, r24
     254:	90 e0       	ldi	r25, 0x00	; 0
     256:	80 74       	andi	r24, 0x40	; 64
     258:	99 27       	eor	r25, r25
	assert( packet->length <=8);
	assert( mob <=14);
    CANPAGE = mob << 4;
	if(
		(  CANCDMOB & 0b11000000) // if MOB in use
		&& 
     25a:	89 2b       	or	r24, r25
     25c:	11 f4       	brne	.+4      	; 0x262 <can_tx+0x4e>
	  	( (CANSTMOB & 0x40) ==0)   // TX not ready
	  )
		return false;
     25e:	80 e0       	ldi	r24, 0x00	; 0
     260:	9c c0       	rjmp	.+312    	; 0x39a <can_tx+0x186>
	CANSTMOB = 0x00;    	// cancel pending operation 
     262:	8e ee       	ldi	r24, 0xEE	; 238
     264:	90 e0       	ldi	r25, 0x00	; 0
     266:	fc 01       	movw	r30, r24
     268:	10 82       	st	Z, r1
	CANCDMOB = 0x00;		
     26a:	8f ee       	ldi	r24, 0xEF	; 239
     26c:	90 e0       	ldi	r25, 0x00	; 0
     26e:	fc 01       	movw	r30, r24
     270:	10 82       	st	Z, r1
	if( packet->length!=RTR)
     272:	8c 81       	ldd	r24, Y+4	; 0x04
     274:	9d 81       	ldd	r25, Y+5	; 0x05
     276:	fc 01       	movw	r30, r24
     278:	82 81       	ldd	r24, Z+2	; 0x02
     27a:	8f 3f       	cpi	r24, 0xFF	; 255
     27c:	09 f4       	brne	.+2      	; 0x280 <can_tx+0x6c>
     27e:	52 c0       	rjmp	.+164    	; 0x324 <can_tx+0x110>
		{
		CANIDT1=packet->id >>3;
     280:	83 ef       	ldi	r24, 0xF3	; 243
     282:	90 e0       	ldi	r25, 0x00	; 0
     284:	2c 81       	ldd	r18, Y+4	; 0x04
     286:	3d 81       	ldd	r19, Y+5	; 0x05
     288:	f9 01       	movw	r30, r18
     28a:	20 81       	ld	r18, Z
     28c:	31 81       	ldd	r19, Z+1	; 0x01
     28e:	36 95       	lsr	r19
     290:	27 95       	ror	r18
     292:	36 95       	lsr	r19
     294:	27 95       	ror	r18
     296:	36 95       	lsr	r19
     298:	27 95       	ror	r18
     29a:	fc 01       	movw	r30, r24
     29c:	20 83       	st	Z, r18
		CANIDT2=packet->id <<5;
     29e:	82 ef       	ldi	r24, 0xF2	; 242
     2a0:	90 e0       	ldi	r25, 0x00	; 0
     2a2:	2c 81       	ldd	r18, Y+4	; 0x04
     2a4:	3d 81       	ldd	r19, Y+5	; 0x05
     2a6:	f9 01       	movw	r30, r18
     2a8:	20 81       	ld	r18, Z
     2aa:	31 81       	ldd	r19, Z+1	; 0x01
     2ac:	22 95       	swap	r18
     2ae:	22 0f       	add	r18, r18
     2b0:	20 7e       	andi	r18, 0xE0	; 224
     2b2:	fc 01       	movw	r30, r24
     2b4:	20 83       	st	Z, r18
        CANIDT3 = 0;
     2b6:	81 ef       	ldi	r24, 0xF1	; 241
     2b8:	90 e0       	ldi	r25, 0x00	; 0
     2ba:	fc 01       	movw	r30, r24
     2bc:	10 82       	st	Z, r1
        CANIDT4 = 0;
     2be:	80 ef       	ldi	r24, 0xF0	; 240
     2c0:	90 e0       	ldi	r25, 0x00	; 0
     2c2:	fc 01       	movw	r30, r24
     2c4:	10 82       	st	Z, r1
		for (cnt=0; cnt < packet->length; ++cnt) 
     2c6:	1a 82       	std	Y+2, r1	; 0x02
     2c8:	19 82       	std	Y+1, r1	; 0x01
     2ca:	13 c0       	rjmp	.+38     	; 0x2f2 <can_tx+0xde>
			CANMSG = packet->data[cnt];         
     2cc:	8a ef       	ldi	r24, 0xFA	; 250
     2ce:	90 e0       	ldi	r25, 0x00	; 0
     2d0:	4c 81       	ldd	r20, Y+4	; 0x04
     2d2:	5d 81       	ldd	r21, Y+5	; 0x05
     2d4:	29 81       	ldd	r18, Y+1	; 0x01
     2d6:	3a 81       	ldd	r19, Y+2	; 0x02
     2d8:	24 0f       	add	r18, r20
     2da:	35 1f       	adc	r19, r21
     2dc:	2d 5f       	subi	r18, 0xFD	; 253
     2de:	3f 4f       	sbci	r19, 0xFF	; 255
     2e0:	f9 01       	movw	r30, r18
     2e2:	20 81       	ld	r18, Z
     2e4:	fc 01       	movw	r30, r24
     2e6:	20 83       	st	Z, r18
		{
		CANIDT1=packet->id >>3;
		CANIDT2=packet->id <<5;
        CANIDT3 = 0;
        CANIDT4 = 0;
		for (cnt=0; cnt < packet->length; ++cnt) 
     2e8:	89 81       	ldd	r24, Y+1	; 0x01
     2ea:	9a 81       	ldd	r25, Y+2	; 0x02
     2ec:	01 96       	adiw	r24, 0x01	; 1
     2ee:	9a 83       	std	Y+2, r25	; 0x02
     2f0:	89 83       	std	Y+1, r24	; 0x01
     2f2:	8c 81       	ldd	r24, Y+4	; 0x04
     2f4:	9d 81       	ldd	r25, Y+5	; 0x05
     2f6:	fc 01       	movw	r30, r24
     2f8:	82 81       	ldd	r24, Z+2	; 0x02
     2fa:	28 2f       	mov	r18, r24
     2fc:	30 e0       	ldi	r19, 0x00	; 0
     2fe:	89 81       	ldd	r24, Y+1	; 0x01
     300:	9a 81       	ldd	r25, Y+2	; 0x02
     302:	82 17       	cp	r24, r18
     304:	93 07       	cpc	r25, r19
     306:	10 f3       	brcs	.-60     	; 0x2cc <can_tx+0xb8>
			CANMSG = packet->data[cnt];         
    	CANCDMOB|=packet->length;
     308:	8f ee       	ldi	r24, 0xEF	; 239
     30a:	90 e0       	ldi	r25, 0x00	; 0
     30c:	2f ee       	ldi	r18, 0xEF	; 239
     30e:	30 e0       	ldi	r19, 0x00	; 0
     310:	f9 01       	movw	r30, r18
     312:	40 81       	ld	r20, Z
     314:	2c 81       	ldd	r18, Y+4	; 0x04
     316:	3d 81       	ldd	r19, Y+5	; 0x05
     318:	f9 01       	movw	r30, r18
     31a:	22 81       	ldd	r18, Z+2	; 0x02
     31c:	24 2b       	or	r18, r20
     31e:	fc 01       	movw	r30, r24
     320:	20 83       	st	Z, r18
     322:	31 c0       	rjmp	.+98     	; 0x386 <can_tx+0x172>
		}
	else
		{
		CANIDT1=packet->id >>3;
     324:	83 ef       	ldi	r24, 0xF3	; 243
     326:	90 e0       	ldi	r25, 0x00	; 0
     328:	2c 81       	ldd	r18, Y+4	; 0x04
     32a:	3d 81       	ldd	r19, Y+5	; 0x05
     32c:	f9 01       	movw	r30, r18
     32e:	20 81       	ld	r18, Z
     330:	31 81       	ldd	r19, Z+1	; 0x01
     332:	36 95       	lsr	r19
     334:	27 95       	ror	r18
     336:	36 95       	lsr	r19
     338:	27 95       	ror	r18
     33a:	36 95       	lsr	r19
     33c:	27 95       	ror	r18
     33e:	fc 01       	movw	r30, r24
     340:	20 83       	st	Z, r18
		CANIDT2=packet->id <<5;
     342:	82 ef       	ldi	r24, 0xF2	; 242
     344:	90 e0       	ldi	r25, 0x00	; 0
     346:	2c 81       	ldd	r18, Y+4	; 0x04
     348:	3d 81       	ldd	r19, Y+5	; 0x05
     34a:	f9 01       	movw	r30, r18
     34c:	20 81       	ld	r18, Z
     34e:	31 81       	ldd	r19, Z+1	; 0x01
     350:	22 95       	swap	r18
     352:	22 0f       	add	r18, r18
     354:	20 7e       	andi	r18, 0xE0	; 224
     356:	fc 01       	movw	r30, r24
     358:	20 83       	st	Z, r18
        CANIDT3 = 0;
     35a:	81 ef       	ldi	r24, 0xF1	; 241
     35c:	90 e0       	ldi	r25, 0x00	; 0
     35e:	fc 01       	movw	r30, r24
     360:	10 82       	st	Z, r1
        CANIDT4 = 1<<RTRTAG;
     362:	80 ef       	ldi	r24, 0xF0	; 240
     364:	90 e0       	ldi	r25, 0x00	; 0
     366:	24 e0       	ldi	r18, 0x04	; 4
     368:	fc 01       	movw	r30, r24
     36a:	20 83       	st	Z, r18
		CANCDMOB|=packet->length;
     36c:	8f ee       	ldi	r24, 0xEF	; 239
     36e:	90 e0       	ldi	r25, 0x00	; 0
     370:	2f ee       	ldi	r18, 0xEF	; 239
     372:	30 e0       	ldi	r19, 0x00	; 0
     374:	f9 01       	movw	r30, r18
     376:	40 81       	ld	r20, Z
     378:	2c 81       	ldd	r18, Y+4	; 0x04
     37a:	3d 81       	ldd	r19, Y+5	; 0x05
     37c:	f9 01       	movw	r30, r18
     37e:	22 81       	ldd	r18, Z+2	; 0x02
     380:	24 2b       	or	r18, r20
     382:	fc 01       	movw	r30, r24
     384:	20 83       	st	Z, r18
		}
    CANCDMOB|=0x40; //enable TX
     386:	8f ee       	ldi	r24, 0xEF	; 239
     388:	90 e0       	ldi	r25, 0x00	; 0
     38a:	2f ee       	ldi	r18, 0xEF	; 239
     38c:	30 e0       	ldi	r19, 0x00	; 0
     38e:	f9 01       	movw	r30, r18
     390:	20 81       	ld	r18, Z
     392:	20 64       	ori	r18, 0x40	; 64
     394:	fc 01       	movw	r30, r24
     396:	20 83       	st	Z, r18
	return true;
     398:	81 e0       	ldi	r24, 0x01	; 1
	}
     39a:	0f 90       	pop	r0
     39c:	0f 90       	pop	r0
     39e:	0f 90       	pop	r0
     3a0:	0f 90       	pop	r0
     3a2:	0f 90       	pop	r0
     3a4:	df 91       	pop	r29
     3a6:	cf 91       	pop	r28
     3a8:	08 95       	ret

000003aa <prepare_rx>:

bool prepare_rx( char mob, unsigned id, unsigned idmask, CAN_cbf callback)
	{
     3aa:	cf 93       	push	r28
     3ac:	df 93       	push	r29
     3ae:	cd b7       	in	r28, 0x3d	; 61
     3b0:	de b7       	in	r29, 0x3e	; 62
     3b2:	2b 97       	sbiw	r28, 0x0b	; 11
     3b4:	0f b6       	in	r0, 0x3f	; 63
     3b6:	f8 94       	cli
     3b8:	de bf       	out	0x3e, r29	; 62
     3ba:	0f be       	out	0x3f, r0	; 63
     3bc:	cd bf       	out	0x3d, r28	; 61
     3be:	8d 83       	std	Y+5, r24	; 0x05
     3c0:	7f 83       	std	Y+7, r23	; 0x07
     3c2:	6e 83       	std	Y+6, r22	; 0x06
     3c4:	59 87       	std	Y+9, r21	; 0x09
     3c6:	48 87       	std	Y+8, r20	; 0x08
     3c8:	3b 87       	std	Y+11, r19	; 0x0b
     3ca:	2a 87       	std	Y+10, r18	; 0x0a
	if( mob >= 15) 				// illegal MOB number
     3cc:	8d 81       	ldd	r24, Y+5	; 0x05
     3ce:	8f 30       	cpi	r24, 0x0F	; 15
     3d0:	14 f0       	brlt	.+4      	; 0x3d6 <prepare_rx+0x2c>
		return true;
     3d2:	81 e0       	ldi	r24, 0x01	; 1
     3d4:	ba c0       	rjmp	.+372    	; 0x54a <prepare_rx+0x1a0>
	canlist[ (unsigned)mob]=callback;
     3d6:	8d 81       	ldd	r24, Y+5	; 0x05
     3d8:	08 2e       	mov	r0, r24
     3da:	00 0c       	add	r0, r0
     3dc:	99 0b       	sbc	r25, r25
     3de:	88 0f       	add	r24, r24
     3e0:	99 1f       	adc	r25, r25
     3e2:	80 59       	subi	r24, 0x90	; 144
     3e4:	9a 4f       	sbci	r25, 0xFA	; 250
     3e6:	2a 85       	ldd	r18, Y+10	; 0x0a
     3e8:	3b 85       	ldd	r19, Y+11	; 0x0b
     3ea:	fc 01       	movw	r30, r24
     3ec:	31 83       	std	Z+1, r19	; 0x01
     3ee:	20 83       	st	Z, r18
    CANPAGE = mob << 4;
     3f0:	8d ee       	ldi	r24, 0xED	; 237
     3f2:	90 e0       	ldi	r25, 0x00	; 0
     3f4:	2d 81       	ldd	r18, Y+5	; 0x05
     3f6:	22 95       	swap	r18
     3f8:	20 7f       	andi	r18, 0xF0	; 240
     3fa:	fc 01       	movw	r30, r24
     3fc:	20 83       	st	Z, r18
	if( callback==0)			// release this MOB 
     3fe:	8a 85       	ldd	r24, Y+10	; 0x0a
     400:	9b 85       	ldd	r25, Y+11	; 0x0b
     402:	89 2b       	or	r24, r25
     404:	81 f5       	brne	.+96     	; 0x466 <prepare_rx+0xbc>
		{
		CANSTMOB = 0x00;    	// cancel pending operation 
     406:	8e ee       	ldi	r24, 0xEE	; 238
     408:	90 e0       	ldi	r25, 0x00	; 0
     40a:	fc 01       	movw	r30, r24
     40c:	10 82       	st	Z, r1
		CANCDMOB = 0x00;		
     40e:	8f ee       	ldi	r24, 0xEF	; 239
     410:	90 e0       	ldi	r25, 0x00	; 0
     412:	fc 01       	movw	r30, r24
     414:	10 82       	st	Z, r1
		unsigned mask=1<<mob;
     416:	8d 81       	ldd	r24, Y+5	; 0x05
     418:	28 2f       	mov	r18, r24
     41a:	88 0f       	add	r24, r24
     41c:	33 0b       	sbc	r19, r19
     41e:	81 e0       	ldi	r24, 0x01	; 1
     420:	90 e0       	ldi	r25, 0x00	; 0
     422:	02 c0       	rjmp	.+4      	; 0x428 <prepare_rx+0x7e>
     424:	88 0f       	add	r24, r24
     426:	99 1f       	adc	r25, r25
     428:	2a 95       	dec	r18
     42a:	e2 f7       	brpl	.-8      	; 0x424 <prepare_rx+0x7a>
     42c:	9a 83       	std	Y+2, r25	; 0x02
     42e:	89 83       	std	Y+1, r24	; 0x01
		CANIE2 &=  ~mask;
     430:	8e ed       	ldi	r24, 0xDE	; 222
     432:	90 e0       	ldi	r25, 0x00	; 0
     434:	2e ed       	ldi	r18, 0xDE	; 222
     436:	30 e0       	ldi	r19, 0x00	; 0
     438:	f9 01       	movw	r30, r18
     43a:	30 81       	ld	r19, Z
     43c:	29 81       	ldd	r18, Y+1	; 0x01
     43e:	20 95       	com	r18
     440:	23 23       	and	r18, r19
     442:	fc 01       	movw	r30, r24
     444:	20 83       	st	Z, r18
		CANIE1 &= ~(mask>>8);
     446:	8f ed       	ldi	r24, 0xDF	; 223
     448:	90 e0       	ldi	r25, 0x00	; 0
     44a:	2f ed       	ldi	r18, 0xDF	; 223
     44c:	30 e0       	ldi	r19, 0x00	; 0
     44e:	f9 01       	movw	r30, r18
     450:	40 81       	ld	r20, Z
     452:	29 81       	ldd	r18, Y+1	; 0x01
     454:	3a 81       	ldd	r19, Y+2	; 0x02
     456:	23 2f       	mov	r18, r19
     458:	33 27       	eor	r19, r19
     45a:	20 95       	com	r18
     45c:	24 23       	and	r18, r20
     45e:	fc 01       	movw	r30, r24
     460:	20 83       	st	Z, r18
		return false;
     462:	80 e0       	ldi	r24, 0x00	; 0
     464:	72 c0       	rjmp	.+228    	; 0x54a <prepare_rx+0x1a0>
		}
	if( CANCDMOB & 0b11000000) 	// if MOB already in use
     466:	8f ee       	ldi	r24, 0xEF	; 239
     468:	90 e0       	ldi	r25, 0x00	; 0
     46a:	fc 01       	movw	r30, r24
     46c:	80 81       	ld	r24, Z
     46e:	88 2f       	mov	r24, r24
     470:	90 e0       	ldi	r25, 0x00	; 0
     472:	80 7c       	andi	r24, 0xC0	; 192
     474:	99 27       	eor	r25, r25
     476:	89 2b       	or	r24, r25
     478:	11 f0       	breq	.+4      	; 0x47e <prepare_rx+0xd4>
		return true;			// no vacancy ...
     47a:	81 e0       	ldi	r24, 0x01	; 1
     47c:	66 c0       	rjmp	.+204    	; 0x54a <prepare_rx+0x1a0>
	CANSTMOB = 0x00;    	// cancel pending operation 
     47e:	8e ee       	ldi	r24, 0xEE	; 238
     480:	90 e0       	ldi	r25, 0x00	; 0
     482:	fc 01       	movw	r30, r24
     484:	10 82       	st	Z, r1
	CANCDMOB = 0x00;		
     486:	8f ee       	ldi	r24, 0xEF	; 239
     488:	90 e0       	ldi	r25, 0x00	; 0
     48a:	fc 01       	movw	r30, r24
     48c:	10 82       	st	Z, r1
	CANHPMOB = 0x00;		// enable direct mob indexing, see docu
     48e:	8c ee       	ldi	r24, 0xEC	; 236
     490:	90 e0       	ldi	r25, 0x00	; 0
     492:	fc 01       	movw	r30, r24
     494:	10 82       	st	Z, r1
	CANIDT1=id >>3;
     496:	83 ef       	ldi	r24, 0xF3	; 243
     498:	90 e0       	ldi	r25, 0x00	; 0
     49a:	2e 81       	ldd	r18, Y+6	; 0x06
     49c:	3f 81       	ldd	r19, Y+7	; 0x07
     49e:	36 95       	lsr	r19
     4a0:	27 95       	ror	r18
     4a2:	36 95       	lsr	r19
     4a4:	27 95       	ror	r18
     4a6:	36 95       	lsr	r19
     4a8:	27 95       	ror	r18
     4aa:	fc 01       	movw	r30, r24
     4ac:	20 83       	st	Z, r18
	CANIDT2=id <<5;
     4ae:	82 ef       	ldi	r24, 0xF2	; 242
     4b0:	90 e0       	ldi	r25, 0x00	; 0
     4b2:	2e 81       	ldd	r18, Y+6	; 0x06
     4b4:	22 95       	swap	r18
     4b6:	22 0f       	add	r18, r18
     4b8:	20 7e       	andi	r18, 0xE0	; 224
     4ba:	fc 01       	movw	r30, r24
     4bc:	20 83       	st	Z, r18
	CANIDM1=idmask >>3;
     4be:	87 ef       	ldi	r24, 0xF7	; 247
     4c0:	90 e0       	ldi	r25, 0x00	; 0
     4c2:	28 85       	ldd	r18, Y+8	; 0x08
     4c4:	39 85       	ldd	r19, Y+9	; 0x09
     4c6:	36 95       	lsr	r19
     4c8:	27 95       	ror	r18
     4ca:	36 95       	lsr	r19
     4cc:	27 95       	ror	r18
     4ce:	36 95       	lsr	r19
     4d0:	27 95       	ror	r18
     4d2:	fc 01       	movw	r30, r24
     4d4:	20 83       	st	Z, r18
	CANIDM2=idmask <<5;
     4d6:	86 ef       	ldi	r24, 0xF6	; 246
     4d8:	90 e0       	ldi	r25, 0x00	; 0
     4da:	28 85       	ldd	r18, Y+8	; 0x08
     4dc:	22 95       	swap	r18
     4de:	22 0f       	add	r18, r18
     4e0:	20 7e       	andi	r18, 0xE0	; 224
     4e2:	fc 01       	movw	r30, r24
     4e4:	20 83       	st	Z, r18
	CANIDM3=0;
     4e6:	85 ef       	ldi	r24, 0xF5	; 245
     4e8:	90 e0       	ldi	r25, 0x00	; 0
     4ea:	fc 01       	movw	r30, r24
     4ec:	10 82       	st	Z, r1
	CANIDM4=0;
     4ee:	84 ef       	ldi	r24, 0xF4	; 244
     4f0:	90 e0       	ldi	r25, 0x00	; 0
     4f2:	fc 01       	movw	r30, r24
     4f4:	10 82       	st	Z, r1
	CANCDMOB=0x80; // enable RX
     4f6:	8f ee       	ldi	r24, 0xEF	; 239
     4f8:	90 e0       	ldi	r25, 0x00	; 0
     4fa:	20 e8       	ldi	r18, 0x80	; 128
     4fc:	fc 01       	movw	r30, r24
     4fe:	20 83       	st	Z, r18
	unsigned mask=1<<mob;
     500:	8d 81       	ldd	r24, Y+5	; 0x05
     502:	28 2f       	mov	r18, r24
     504:	88 0f       	add	r24, r24
     506:	33 0b       	sbc	r19, r19
     508:	81 e0       	ldi	r24, 0x01	; 1
     50a:	90 e0       	ldi	r25, 0x00	; 0
     50c:	02 c0       	rjmp	.+4      	; 0x512 <prepare_rx+0x168>
     50e:	88 0f       	add	r24, r24
     510:	99 1f       	adc	r25, r25
     512:	2a 95       	dec	r18
     514:	e2 f7       	brpl	.-8      	; 0x50e <prepare_rx+0x164>
     516:	9c 83       	std	Y+4, r25	; 0x04
     518:	8b 83       	std	Y+3, r24	; 0x03
	CANIE2 |=  mask;
     51a:	8e ed       	ldi	r24, 0xDE	; 222
     51c:	90 e0       	ldi	r25, 0x00	; 0
     51e:	2e ed       	ldi	r18, 0xDE	; 222
     520:	30 e0       	ldi	r19, 0x00	; 0
     522:	f9 01       	movw	r30, r18
     524:	30 81       	ld	r19, Z
     526:	2b 81       	ldd	r18, Y+3	; 0x03
     528:	23 2b       	or	r18, r19
     52a:	fc 01       	movw	r30, r24
     52c:	20 83       	st	Z, r18
	CANIE1 |= (mask>>8);
     52e:	8f ed       	ldi	r24, 0xDF	; 223
     530:	90 e0       	ldi	r25, 0x00	; 0
     532:	2f ed       	ldi	r18, 0xDF	; 223
     534:	30 e0       	ldi	r19, 0x00	; 0
     536:	f9 01       	movw	r30, r18
     538:	40 81       	ld	r20, Z
     53a:	2b 81       	ldd	r18, Y+3	; 0x03
     53c:	3c 81       	ldd	r19, Y+4	; 0x04
     53e:	23 2f       	mov	r18, r19
     540:	33 27       	eor	r19, r19
     542:	24 2b       	or	r18, r20
     544:	fc 01       	movw	r30, r24
     546:	20 83       	st	Z, r18
	return false;
     548:	80 e0       	ldi	r24, 0x00	; 0
	}
     54a:	2b 96       	adiw	r28, 0x0b	; 11
     54c:	0f b6       	in	r0, 0x3f	; 63
     54e:	f8 94       	cli
     550:	de bf       	out	0x3e, r29	; 62
     552:	0f be       	out	0x3f, r0	; 63
     554:	cd bf       	out	0x3d, r28	; 61
     556:	df 91       	pop	r29
     558:	cf 91       	pop	r28
     55a:	08 95       	ret

0000055c <can_init>:


void can_init( void)
	{
     55c:	cf 93       	push	r28
     55e:	df 93       	push	r29
     560:	00 d0       	rcall	.+0      	; 0x562 <can_init+0x6>
     562:	cd b7       	in	r28, 0x3d	; 61
     564:	de b7       	in	r29, 0x3e	; 62
#if configCPU_CLOCK_HZ==8000000l
	CANBT1=0x06;	// 8MHz, 100kbit/s
	CANBT2=0x0c;
	CANBT3=0x5a;
#else
	CANBT1=0x06;	// 16 MHz, 500kbit/s
     566:	82 ee       	ldi	r24, 0xE2	; 226
     568:	90 e0       	ldi	r25, 0x00	; 0
     56a:	26 e0       	ldi	r18, 0x06	; 6
     56c:	fc 01       	movw	r30, r24
     56e:	20 83       	st	Z, r18
	CANBT2=0x04;
     570:	83 ee       	ldi	r24, 0xE3	; 227
     572:	90 e0       	ldi	r25, 0x00	; 0
     574:	24 e0       	ldi	r18, 0x04	; 4
     576:	fc 01       	movw	r30, r24
     578:	20 83       	st	Z, r18
	CANBT3=0x13;
     57a:	84 ee       	ldi	r24, 0xE4	; 228
     57c:	90 e0       	ldi	r25, 0x00	; 0
     57e:	23 e1       	ldi	r18, 0x13	; 19
     580:	fc 01       	movw	r30, r24
     582:	20 83       	st	Z, r18
#endif
	
	for (mob = 0; mob < NO_MOBS; mob++)
     584:	1a 82       	std	Y+2, r1	; 0x02
     586:	19 82       	std	Y+1, r1	; 0x01
     588:	14 c0       	rjmp	.+40     	; 0x5b2 <can_init+0x56>
		{
		CANPAGE  = (mob << 4);
     58a:	8d ee       	ldi	r24, 0xED	; 237
     58c:	90 e0       	ldi	r25, 0x00	; 0
     58e:	29 81       	ldd	r18, Y+1	; 0x01
     590:	22 95       	swap	r18
     592:	20 7f       	andi	r18, 0xF0	; 240
     594:	fc 01       	movw	r30, r24
     596:	20 83       	st	Z, r18
		CANSTMOB = 0;
     598:	8e ee       	ldi	r24, 0xEE	; 238
     59a:	90 e0       	ldi	r25, 0x00	; 0
     59c:	fc 01       	movw	r30, r24
     59e:	10 82       	st	Z, r1
		CANCDMOB = 0;
     5a0:	8f ee       	ldi	r24, 0xEF	; 239
     5a2:	90 e0       	ldi	r25, 0x00	; 0
     5a4:	fc 01       	movw	r30, r24
     5a6:	10 82       	st	Z, r1
	CANBT1=0x06;	// 16 MHz, 500kbit/s
	CANBT2=0x04;
	CANBT3=0x13;
#endif
	
	for (mob = 0; mob < NO_MOBS; mob++)
     5a8:	89 81       	ldd	r24, Y+1	; 0x01
     5aa:	9a 81       	ldd	r25, Y+2	; 0x02
     5ac:	01 96       	adiw	r24, 0x01	; 1
     5ae:	9a 83       	std	Y+2, r25	; 0x02
     5b0:	89 83       	std	Y+1, r24	; 0x01
     5b2:	89 81       	ldd	r24, Y+1	; 0x01
     5b4:	9a 81       	ldd	r25, Y+2	; 0x02
     5b6:	06 97       	sbiw	r24, 0x06	; 6
     5b8:	40 f3       	brcs	.-48     	; 0x58a <can_init+0x2e>
		{
		CANPAGE  = (mob << 4);
		CANSTMOB = 0;
		CANCDMOB = 0;
		}
	CANGCON |= 0x02;
     5ba:	88 ed       	ldi	r24, 0xD8	; 216
     5bc:	90 e0       	ldi	r25, 0x00	; 0
     5be:	28 ed       	ldi	r18, 0xD8	; 216
     5c0:	30 e0       	ldi	r19, 0x00	; 0
     5c2:	f9 01       	movw	r30, r18
     5c4:	20 81       	ld	r18, Z
     5c6:	22 60       	ori	r18, 0x02	; 2
     5c8:	fc 01       	movw	r30, r24
     5ca:	20 83       	st	Z, r18
	CANGIE=(1<<ENIT) | (1<< ENRX);
     5cc:	8b ed       	ldi	r24, 0xDB	; 219
     5ce:	90 e0       	ldi	r25, 0x00	; 0
     5d0:	20 ea       	ldi	r18, 0xA0	; 160
     5d2:	fc 01       	movw	r30, r24
     5d4:	20 83       	st	Z, r18
	}
     5d6:	0f 90       	pop	r0
     5d8:	0f 90       	pop	r0
     5da:	df 91       	pop	r29
     5dc:	cf 91       	pop	r28
     5de:	08 95       	ret

000005e0 <can_dump_init>:
static void CAN_callback( CAN_packet *p, unsigned char mob);
xQueueHandle CANdumpQueue; //!< Global queue for all CAN packets (CAN dump)
xQueueHandle channels[NO_MOBS]; //!< mob -> FreeRTOS Queue list

void can_dump_init( unsigned items)
	{
     5e0:	cf 93       	push	r28
     5e2:	df 93       	push	r29
     5e4:	00 d0       	rcall	.+0      	; 0x5e6 <can_dump_init+0x6>
     5e6:	cd b7       	in	r28, 0x3d	; 61
     5e8:	de b7       	in	r29, 0x3e	; 62
     5ea:	9a 83       	std	Y+2, r25	; 0x02
     5ec:	89 83       	std	Y+1, r24	; 0x01
	CANdumpQueue = xQueueCreate( items, sizeof( CAN_packet));
     5ee:	89 81       	ldd	r24, Y+1	; 0x01
     5f0:	40 e0       	ldi	r20, 0x00	; 0
     5f2:	6b e0       	ldi	r22, 0x0B	; 11
     5f4:	0e 94 b6 09 	call	0x136c	; 0x136c <xQueueGenericCreate>
     5f8:	90 93 89 05 	sts	0x0589, r25
     5fc:	80 93 88 05 	sts	0x0588, r24
	assert( CANdumpQueue !=0);
// catch all "floating" IDs using MOB 14
	channels[ 14]=CANdumpQueue;
     600:	80 91 88 05 	lds	r24, 0x0588
     604:	90 91 89 05 	lds	r25, 0x0589
     608:	90 93 99 05 	sts	0x0599, r25
     60c:	80 93 98 05 	sts	0x0598, r24
	assert( 0 == prepare_rx( 14, 0x7ff, 0x000, CAN_callback));
	}
     610:	0f 90       	pop	r0
     612:	0f 90       	pop	r0
     614:	df 91       	pop	r29
     616:	cf 91       	pop	r28
     618:	08 95       	ret

0000061a <CAN_callback>:

	this routine scans the list of all MOBs 
	to find the responsible FreeRTOS queue to enqueue this CAN packet to.
*/
static void CAN_callback( CAN_packet *p, unsigned char mob)
	{
     61a:	cf 93       	push	r28
     61c:	df 93       	push	r29
     61e:	00 d0       	rcall	.+0      	; 0x620 <CAN_callback+0x6>
     620:	00 d0       	rcall	.+0      	; 0x622 <CAN_callback+0x8>
     622:	cd b7       	in	r28, 0x3d	; 61
     624:	de b7       	in	r29, 0x3e	; 62
     626:	9b 83       	std	Y+3, r25	; 0x03
     628:	8a 83       	std	Y+2, r24	; 0x02
     62a:	6c 83       	std	Y+4, r22	; 0x04
	portBASE_TYPE xTaskWoken = pdFALSE;
     62c:	19 82       	std	Y+1, r1	; 0x01
	assert( channels[mob] !=0);
	xQueueSendFromISR( channels[mob], p, &xTaskWoken);
     62e:	8c 81       	ldd	r24, Y+4	; 0x04
     630:	88 2f       	mov	r24, r24
     632:	90 e0       	ldi	r25, 0x00	; 0
     634:	88 0f       	add	r24, r24
     636:	99 1f       	adc	r25, r25
     638:	84 58       	subi	r24, 0x84	; 132
     63a:	9a 4f       	sbci	r25, 0xFA	; 250
     63c:	fc 01       	movw	r30, r24
     63e:	80 81       	ld	r24, Z
     640:	91 81       	ldd	r25, Z+1	; 0x01
     642:	6a 81       	ldd	r22, Y+2	; 0x02
     644:	7b 81       	ldd	r23, Y+3	; 0x03
     646:	20 e0       	ldi	r18, 0x00	; 0
     648:	ae 01       	movw	r20, r28
     64a:	4f 5f       	subi	r20, 0xFF	; 255
     64c:	5f 4f       	sbci	r21, 0xFF	; 255
     64e:	0e 94 cc 0a 	call	0x1598	; 0x1598 <xQueueGenericSendFromISR>
	if( CANdumpQueue && (mob!=14)) // do not double-dump 14, packet already sent!
     652:	80 91 88 05 	lds	r24, 0x0588
     656:	90 91 89 05 	lds	r25, 0x0589
     65a:	89 2b       	or	r24, r25
     65c:	79 f0       	breq	.+30     	; 0x67c <CAN_callback+0x62>
     65e:	8c 81       	ldd	r24, Y+4	; 0x04
     660:	8e 30       	cpi	r24, 0x0E	; 14
     662:	61 f0       	breq	.+24     	; 0x67c <CAN_callback+0x62>
		xQueueSendFromISR( CANdumpQueue, p, &xTaskWoken);
     664:	80 91 88 05 	lds	r24, 0x0588
     668:	90 91 89 05 	lds	r25, 0x0589
     66c:	6a 81       	ldd	r22, Y+2	; 0x02
     66e:	7b 81       	ldd	r23, Y+3	; 0x03
     670:	20 e0       	ldi	r18, 0x00	; 0
     672:	ae 01       	movw	r20, r28
     674:	4f 5f       	subi	r20, 0xFF	; 255
     676:	5f 4f       	sbci	r21, 0xFF	; 255
     678:	0e 94 cc 0a 	call	0x1598	; 0x1598 <xQueueGenericSendFromISR>
	if( xTaskWoken) 
     67c:	89 81       	ldd	r24, Y+1	; 0x01
     67e:	88 23       	and	r24, r24
     680:	11 f0       	breq	.+4      	; 0x686 <CAN_callback+0x6c>
		taskYIELD();
     682:	0e 94 86 07 	call	0xf0c	; 0xf0c <vPortYield>
	}
     686:	0f 90       	pop	r0
     688:	0f 90       	pop	r0
     68a:	0f 90       	pop	r0
     68c:	0f 90       	pop	r0
     68e:	df 91       	pop	r29
     690:	cf 91       	pop	r28
     692:	08 95       	ret

00000694 <xCANQueueCreate>:

xQueueHandle xCANQueueCreate( unsigned id, unsigned idmask, portBASE_TYPE uxQueueLength)
	{
     694:	cf 93       	push	r28
     696:	df 93       	push	r29
     698:	cd b7       	in	r28, 0x3d	; 61
     69a:	de b7       	in	r29, 0x3e	; 62
     69c:	29 97       	sbiw	r28, 0x09	; 9
     69e:	0f b6       	in	r0, 0x3f	; 63
     6a0:	f8 94       	cli
     6a2:	de bf       	out	0x3e, r29	; 62
     6a4:	0f be       	out	0x3f, r0	; 63
     6a6:	cd bf       	out	0x3d, r28	; 61
     6a8:	9e 83       	std	Y+6, r25	; 0x06
     6aa:	8d 83       	std	Y+5, r24	; 0x05
     6ac:	78 87       	std	Y+8, r23	; 0x08
     6ae:	6f 83       	std	Y+7, r22	; 0x07
     6b0:	49 87       	std	Y+9, r20	; 0x09
	xQueueHandle theQ;
	unsigned mob;
//	taskENTER_CRITICAL();
	theQ= xQueueCreate( uxQueueLength, sizeof( CAN_packet));
     6b2:	89 85       	ldd	r24, Y+9	; 0x09
     6b4:	40 e0       	ldi	r20, 0x00	; 0
     6b6:	6b e0       	ldi	r22, 0x0B	; 11
     6b8:	0e 94 b6 09 	call	0x136c	; 0x136c <xQueueGenericCreate>
     6bc:	9c 83       	std	Y+4, r25	; 0x04
     6be:	8b 83       	std	Y+3, r24	; 0x03
	if( theQ==0)
     6c0:	8b 81       	ldd	r24, Y+3	; 0x03
     6c2:	9c 81       	ldd	r25, Y+4	; 0x04
     6c4:	89 2b       	or	r24, r25
     6c6:	19 f4       	brne	.+6      	; 0x6ce <xCANQueueCreate+0x3a>
		return theQ;
     6c8:	8b 81       	ldd	r24, Y+3	; 0x03
     6ca:	9c 81       	ldd	r25, Y+4	; 0x04
     6cc:	37 c0       	rjmp	.+110    	; 0x73c <xCANQueueCreate+0xa8>
	// find free mob
	for( mob=0; mob < NO_MOBS; ++mob)
     6ce:	1a 82       	std	Y+2, r1	; 0x02
     6d0:	19 82       	std	Y+1, r1	; 0x01
     6d2:	11 c0       	rjmp	.+34     	; 0x6f6 <xCANQueueCreate+0x62>
		if( channels[mob]==0)
     6d4:	89 81       	ldd	r24, Y+1	; 0x01
     6d6:	9a 81       	ldd	r25, Y+2	; 0x02
     6d8:	88 0f       	add	r24, r24
     6da:	99 1f       	adc	r25, r25
     6dc:	84 58       	subi	r24, 0x84	; 132
     6de:	9a 4f       	sbci	r25, 0xFA	; 250
     6e0:	fc 01       	movw	r30, r24
     6e2:	80 81       	ld	r24, Z
     6e4:	91 81       	ldd	r25, Z+1	; 0x01
     6e6:	89 2b       	or	r24, r25
     6e8:	09 f4       	brne	.+2      	; 0x6ec <xCANQueueCreate+0x58>
			break;
     6ea:	09 c0       	rjmp	.+18     	; 0x6fe <xCANQueueCreate+0x6a>
//	taskENTER_CRITICAL();
	theQ= xQueueCreate( uxQueueLength, sizeof( CAN_packet));
	if( theQ==0)
		return theQ;
	// find free mob
	for( mob=0; mob < NO_MOBS; ++mob)
     6ec:	89 81       	ldd	r24, Y+1	; 0x01
     6ee:	9a 81       	ldd	r25, Y+2	; 0x02
     6f0:	01 96       	adiw	r24, 0x01	; 1
     6f2:	9a 83       	std	Y+2, r25	; 0x02
     6f4:	89 83       	std	Y+1, r24	; 0x01
     6f6:	89 81       	ldd	r24, Y+1	; 0x01
     6f8:	9a 81       	ldd	r25, Y+2	; 0x02
     6fa:	06 97       	sbiw	r24, 0x06	; 6
     6fc:	58 f3       	brcs	.-42     	; 0x6d4 <xCANQueueCreate+0x40>
		if( channels[mob]==0)
			break;
	if( mob==NO_MOBS)
     6fe:	89 81       	ldd	r24, Y+1	; 0x01
     700:	9a 81       	ldd	r25, Y+2	; 0x02
     702:	06 97       	sbiw	r24, 0x06	; 6
     704:	19 f4       	brne	.+6      	; 0x70c <xCANQueueCreate+0x78>
		return 0; // out of MOBs
     706:	80 e0       	ldi	r24, 0x00	; 0
     708:	90 e0       	ldi	r25, 0x00	; 0
     70a:	18 c0       	rjmp	.+48     	; 0x73c <xCANQueueCreate+0xa8>
	channels[ mob]=theQ;
     70c:	89 81       	ldd	r24, Y+1	; 0x01
     70e:	9a 81       	ldd	r25, Y+2	; 0x02
     710:	88 0f       	add	r24, r24
     712:	99 1f       	adc	r25, r25
     714:	84 58       	subi	r24, 0x84	; 132
     716:	9a 4f       	sbci	r25, 0xFA	; 250
     718:	2b 81       	ldd	r18, Y+3	; 0x03
     71a:	3c 81       	ldd	r19, Y+4	; 0x04
     71c:	fc 01       	movw	r30, r24
     71e:	31 83       	std	Z+1, r19	; 0x01
     720:	20 83       	st	Z, r18
	prepare_rx( mob, id, idmask, CAN_callback);
     722:	e9 81       	ldd	r30, Y+1	; 0x01
     724:	4f 81       	ldd	r20, Y+7	; 0x07
     726:	58 85       	ldd	r21, Y+8	; 0x08
     728:	8d 81       	ldd	r24, Y+5	; 0x05
     72a:	9e 81       	ldd	r25, Y+6	; 0x06
     72c:	2d e0       	ldi	r18, 0x0D	; 13
     72e:	33 e0       	ldi	r19, 0x03	; 3
     730:	bc 01       	movw	r22, r24
     732:	8e 2f       	mov	r24, r30
     734:	0e 94 d5 01 	call	0x3aa	; 0x3aa <prepare_rx>
//	taskEXIT_CRITICAL();
	return theQ;
     738:	8b 81       	ldd	r24, Y+3	; 0x03
     73a:	9c 81       	ldd	r25, Y+4	; 0x04
	}
     73c:	29 96       	adiw	r28, 0x09	; 9
     73e:	0f b6       	in	r0, 0x3f	; 63
     740:	f8 94       	cli
     742:	de bf       	out	0x3e, r29	; 62
     744:	0f be       	out	0x3f, r0	; 63
     746:	cd bf       	out	0x3d, r28	; 61
     748:	df 91       	pop	r29
     74a:	cf 91       	pop	r28
     74c:	08 95       	ret

0000074e <can_send>:

portBASE_TYPE can_send( CAN_packet *p, unsigned mob, portTickType xTicksToWait)
	{
     74e:	cf 93       	push	r28
     750:	df 93       	push	r29
     752:	cd b7       	in	r28, 0x3d	; 61
     754:	de b7       	in	r29, 0x3e	; 62
     756:	27 97       	sbiw	r28, 0x07	; 7
     758:	0f b6       	in	r0, 0x3f	; 63
     75a:	f8 94       	cli
     75c:	de bf       	out	0x3e, r29	; 62
     75e:	0f be       	out	0x3f, r0	; 63
     760:	cd bf       	out	0x3d, r28	; 61
     762:	9b 83       	std	Y+3, r25	; 0x03
     764:	8a 83       	std	Y+2, r24	; 0x02
     766:	7d 83       	std	Y+5, r23	; 0x05
     768:	6c 83       	std	Y+4, r22	; 0x04
     76a:	5f 83       	std	Y+7, r21	; 0x07
     76c:	4e 83       	std	Y+6, r20	; 0x06
	char retv=false;
     76e:	19 82       	std	Y+1, r1	; 0x01

	assert( channels[mob]==(CAN_cbf)0); // must be vacated
	channels[mob]=(CAN_cbf)0xffff; // this mob is in use now!
     770:	8c 81       	ldd	r24, Y+4	; 0x04
     772:	9d 81       	ldd	r25, Y+5	; 0x05
     774:	88 0f       	add	r24, r24
     776:	99 1f       	adc	r25, r25
     778:	84 58       	subi	r24, 0x84	; 132
     77a:	9a 4f       	sbci	r25, 0xFA	; 250
     77c:	2f ef       	ldi	r18, 0xFF	; 255
     77e:	3f ef       	ldi	r19, 0xFF	; 255
     780:	fc 01       	movw	r30, r24
     782:	31 83       	std	Z+1, r19	; 0x01
     784:	20 83       	st	Z, r18

	while( xTicksToWait--)
     786:	22 c0       	rjmp	.+68     	; 0x7cc <can_send+0x7e>
		{
		retv=can_tx( mob, p);
     788:	2c 81       	ldd	r18, Y+4	; 0x04
     78a:	8a 81       	ldd	r24, Y+2	; 0x02
     78c:	9b 81       	ldd	r25, Y+3	; 0x03
     78e:	bc 01       	movw	r22, r24
     790:	82 2f       	mov	r24, r18
     792:	0e 94 0a 01 	call	0x214	; 0x214 <can_tx>
     796:	89 83       	std	Y+1, r24	; 0x01
		if( retv==true) // transmission succsessful
     798:	89 81       	ldd	r24, Y+1	; 0x01
     79a:	81 30       	cpi	r24, 0x01	; 1
     79c:	99 f4       	brne	.+38     	; 0x7c4 <can_send+0x76>
			{
			if( CANdumpQueue)
     79e:	80 91 88 05 	lds	r24, 0x0588
     7a2:	90 91 89 05 	lds	r25, 0x0589
     7a6:	89 2b       	or	r24, r25
     7a8:	61 f0       	breq	.+24     	; 0x7c2 <can_send+0x74>
				xQueueSend( CANdumpQueue, p, xTicksToWait);
     7aa:	80 91 88 05 	lds	r24, 0x0588
     7ae:	90 91 89 05 	lds	r25, 0x0589
     7b2:	4e 81       	ldd	r20, Y+6	; 0x06
     7b4:	5f 81       	ldd	r21, Y+7	; 0x07
     7b6:	6a 81       	ldd	r22, Y+2	; 0x02
     7b8:	7b 81       	ldd	r23, Y+3	; 0x03
     7ba:	20 e0       	ldi	r18, 0x00	; 0
     7bc:	0e 94 1a 0a 	call	0x1434	; 0x1434 <xQueueGenericSend>
			break;
     7c0:	0e c0       	rjmp	.+28     	; 0x7de <can_send+0x90>
     7c2:	0d c0       	rjmp	.+26     	; 0x7de <can_send+0x90>
			}
		// this method is not really elegant
		// but it is save and simple
		// since in usual systems 
		// this "busy" waiting will not be used at all
		vTaskDelay(1);
     7c4:	81 e0       	ldi	r24, 0x01	; 1
     7c6:	90 e0       	ldi	r25, 0x00	; 0
     7c8:	0e 94 03 11 	call	0x2206	; 0x2206 <vTaskDelay>
	char retv=false;

	assert( channels[mob]==(CAN_cbf)0); // must be vacated
	channels[mob]=(CAN_cbf)0xffff; // this mob is in use now!

	while( xTicksToWait--)
     7cc:	8e 81       	ldd	r24, Y+6	; 0x06
     7ce:	9f 81       	ldd	r25, Y+7	; 0x07
     7d0:	9c 01       	movw	r18, r24
     7d2:	21 50       	subi	r18, 0x01	; 1
     7d4:	31 09       	sbc	r19, r1
     7d6:	3f 83       	std	Y+7, r19	; 0x07
     7d8:	2e 83       	std	Y+6, r18	; 0x06
     7da:	89 2b       	or	r24, r25
     7dc:	a9 f6       	brne	.-86     	; 0x788 <can_send+0x3a>
		// since in usual systems 
		// this "busy" waiting will not be used at all
		vTaskDelay(1);
		}
	
	channels[mob]=(CAN_cbf)0; // mob vacated
     7de:	8c 81       	ldd	r24, Y+4	; 0x04
     7e0:	9d 81       	ldd	r25, Y+5	; 0x05
     7e2:	88 0f       	add	r24, r24
     7e4:	99 1f       	adc	r25, r25
     7e6:	84 58       	subi	r24, 0x84	; 132
     7e8:	9a 4f       	sbci	r25, 0xFA	; 250
     7ea:	fc 01       	movw	r30, r24
     7ec:	11 82       	std	Z+1, r1	; 0x01
     7ee:	10 82       	st	Z, r1

	return  retv;
     7f0:	89 81       	ldd	r24, Y+1	; 0x01
	}
     7f2:	27 96       	adiw	r28, 0x07	; 7
     7f4:	0f b6       	in	r0, 0x3f	; 63
     7f6:	f8 94       	cli
     7f8:	de bf       	out	0x3e, r29	; 62
     7fa:	0f be       	out	0x3f, r0	; 63
     7fc:	cd bf       	out	0x3d, r28	; 61
     7fe:	df 91       	pop	r29
     800:	cf 91       	pop	r28
     802:	08 95       	ret

00000804 <main>:

//st_cmd_t can_receive_msg;
//uint64_t can_receive_buffer;

int main(void)
{	
     804:	af 92       	push	r10
     806:	bf 92       	push	r11
     808:	cf 92       	push	r12
     80a:	df 92       	push	r13
     80c:	ef 92       	push	r14
     80e:	ff 92       	push	r15
     810:	0f 93       	push	r16
     812:	cf 93       	push	r28
     814:	df 93       	push	r29
     816:	cd b7       	in	r28, 0x3d	; 61
     818:	de b7       	in	r29, 0x3e	; 62
	// Initialize CAN with fixed baud rate, as defined in can_config.h
	can_init();
     81a:	0e 94 ae 02 	call	0x55c	; 0x55c <can_init>
	/* Wait for an open mailbox and bind msg_id to the mailbox when available*/
	//while(can_cmd(&can_receive_msg) != CAN_CMD_ACCEPTED);
	
	// Create the MCU status task, to blink the LED
	// Rate: 4Hz
    xTaskCreate(vMCUStatusTask, "STATUS", configMINIMAL_STACK_SIZE, 
     81e:	a1 2c       	mov	r10, r1
     820:	b1 2c       	mov	r11, r1
     822:	c1 2c       	mov	r12, r1
     824:	d1 2c       	mov	r13, r1
     826:	e1 2c       	mov	r14, r1
     828:	f1 2c       	mov	r15, r1
     82a:	01 e0       	ldi	r16, 0x01	; 1
     82c:	20 e0       	ldi	r18, 0x00	; 0
     82e:	30 e0       	ldi	r19, 0x00	; 0
     830:	44 e6       	ldi	r20, 0x64	; 100
     832:	50 e0       	ldi	r21, 0x00	; 0
     834:	6b e0       	ldi	r22, 0x0B	; 11
     836:	71 e0       	ldi	r23, 0x01	; 1
     838:	83 e7       	ldi	r24, 0x73	; 115
     83a:	9b e1       	ldi	r25, 0x1B	; 27
     83c:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <xTaskGenericCreate>
		NULL, mainMCU_STATUS_TASK_PRIORITY, NULL);
		
	// Create the heartbeat task, to transmit over CAN
	// Rate: 10Hz
	xTaskCreate(vHeartbeatTask, "HEART", configMINIMAL_STACK_SIZE,
     840:	a1 2c       	mov	r10, r1
     842:	b1 2c       	mov	r11, r1
     844:	c1 2c       	mov	r12, r1
     846:	d1 2c       	mov	r13, r1
     848:	e1 2c       	mov	r14, r1
     84a:	f1 2c       	mov	r15, r1
     84c:	02 e0       	ldi	r16, 0x02	; 2
     84e:	20 e0       	ldi	r18, 0x00	; 0
     850:	30 e0       	ldi	r19, 0x00	; 0
     852:	44 e6       	ldi	r20, 0x64	; 100
     854:	50 e0       	ldi	r21, 0x00	; 0
     856:	62 e1       	ldi	r22, 0x12	; 18
     858:	71 e0       	ldi	r23, 0x01	; 1
     85a:	8a ea       	ldi	r24, 0xAA	; 170
     85c:	9b e1       	ldi	r25, 0x1B	; 27
     85e:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <xTaskGenericCreate>
		NULL, mainHEARTBEAT_TASK_PRIORITY, NULL);
	
	// Start the scheduler
	vTaskStartScheduler();
     862:	0e 94 38 11 	call	0x2270	; 0x2270 <vTaskStartScheduler>
	
	// Return, the scheduler handles the rest
	return 0;
     866:	80 e0       	ldi	r24, 0x00	; 0
     868:	90 e0       	ldi	r25, 0x00	; 0
}
     86a:	df 91       	pop	r29
     86c:	cf 91       	pop	r28
     86e:	0f 91       	pop	r16
     870:	ff 90       	pop	r15
     872:	ef 90       	pop	r14
     874:	df 90       	pop	r13
     876:	cf 90       	pop	r12
     878:	bf 90       	pop	r11
     87a:	af 90       	pop	r10
     87c:	08 95       	ret

0000087e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     87e:	cf 93       	push	r28
     880:	df 93       	push	r29
     882:	00 d0       	rcall	.+0      	; 0x884 <vListInitialise+0x6>
     884:	cd b7       	in	r28, 0x3d	; 61
     886:	de b7       	in	r29, 0x3e	; 62
     888:	9a 83       	std	Y+2, r25	; 0x02
     88a:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     88c:	89 81       	ldd	r24, Y+1	; 0x01
     88e:	9a 81       	ldd	r25, Y+2	; 0x02
     890:	9c 01       	movw	r18, r24
     892:	2d 5f       	subi	r18, 0xFD	; 253
     894:	3f 4f       	sbci	r19, 0xFF	; 255
     896:	89 81       	ldd	r24, Y+1	; 0x01
     898:	9a 81       	ldd	r25, Y+2	; 0x02
     89a:	fc 01       	movw	r30, r24
     89c:	32 83       	std	Z+2, r19	; 0x02
     89e:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     8a0:	89 81       	ldd	r24, Y+1	; 0x01
     8a2:	9a 81       	ldd	r25, Y+2	; 0x02
     8a4:	2f ef       	ldi	r18, 0xFF	; 255
     8a6:	3f ef       	ldi	r19, 0xFF	; 255
     8a8:	fc 01       	movw	r30, r24
     8aa:	34 83       	std	Z+4, r19	; 0x04
     8ac:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8ae:	89 81       	ldd	r24, Y+1	; 0x01
     8b0:	9a 81       	ldd	r25, Y+2	; 0x02
     8b2:	9c 01       	movw	r18, r24
     8b4:	2d 5f       	subi	r18, 0xFD	; 253
     8b6:	3f 4f       	sbci	r19, 0xFF	; 255
     8b8:	89 81       	ldd	r24, Y+1	; 0x01
     8ba:	9a 81       	ldd	r25, Y+2	; 0x02
     8bc:	fc 01       	movw	r30, r24
     8be:	36 83       	std	Z+6, r19	; 0x06
     8c0:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8c2:	89 81       	ldd	r24, Y+1	; 0x01
     8c4:	9a 81       	ldd	r25, Y+2	; 0x02
     8c6:	9c 01       	movw	r18, r24
     8c8:	2d 5f       	subi	r18, 0xFD	; 253
     8ca:	3f 4f       	sbci	r19, 0xFF	; 255
     8cc:	89 81       	ldd	r24, Y+1	; 0x01
     8ce:	9a 81       	ldd	r25, Y+2	; 0x02
     8d0:	fc 01       	movw	r30, r24
     8d2:	30 87       	std	Z+8, r19	; 0x08
     8d4:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     8d6:	89 81       	ldd	r24, Y+1	; 0x01
     8d8:	9a 81       	ldd	r25, Y+2	; 0x02
     8da:	fc 01       	movw	r30, r24
     8dc:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     8de:	0f 90       	pop	r0
     8e0:	0f 90       	pop	r0
     8e2:	df 91       	pop	r29
     8e4:	cf 91       	pop	r28
     8e6:	08 95       	ret

000008e8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     8e8:	cf 93       	push	r28
     8ea:	df 93       	push	r29
     8ec:	00 d0       	rcall	.+0      	; 0x8ee <vListInitialiseItem+0x6>
     8ee:	cd b7       	in	r28, 0x3d	; 61
     8f0:	de b7       	in	r29, 0x3e	; 62
     8f2:	9a 83       	std	Y+2, r25	; 0x02
     8f4:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     8f6:	89 81       	ldd	r24, Y+1	; 0x01
     8f8:	9a 81       	ldd	r25, Y+2	; 0x02
     8fa:	fc 01       	movw	r30, r24
     8fc:	11 86       	std	Z+9, r1	; 0x09
     8fe:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     900:	0f 90       	pop	r0
     902:	0f 90       	pop	r0
     904:	df 91       	pop	r29
     906:	cf 91       	pop	r28
     908:	08 95       	ret

0000090a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     90a:	cf 93       	push	r28
     90c:	df 93       	push	r29
     90e:	00 d0       	rcall	.+0      	; 0x910 <vListInsertEnd+0x6>
     910:	00 d0       	rcall	.+0      	; 0x912 <vListInsertEnd+0x8>
     912:	00 d0       	rcall	.+0      	; 0x914 <vListInsertEnd+0xa>
     914:	cd b7       	in	r28, 0x3d	; 61
     916:	de b7       	in	r29, 0x3e	; 62
     918:	9c 83       	std	Y+4, r25	; 0x04
     91a:	8b 83       	std	Y+3, r24	; 0x03
     91c:	7e 83       	std	Y+6, r23	; 0x06
     91e:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     920:	8b 81       	ldd	r24, Y+3	; 0x03
     922:	9c 81       	ldd	r25, Y+4	; 0x04
     924:	fc 01       	movw	r30, r24
     926:	81 81       	ldd	r24, Z+1	; 0x01
     928:	92 81       	ldd	r25, Z+2	; 0x02
     92a:	9a 83       	std	Y+2, r25	; 0x02
     92c:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     92e:	8d 81       	ldd	r24, Y+5	; 0x05
     930:	9e 81       	ldd	r25, Y+6	; 0x06
     932:	29 81       	ldd	r18, Y+1	; 0x01
     934:	3a 81       	ldd	r19, Y+2	; 0x02
     936:	fc 01       	movw	r30, r24
     938:	33 83       	std	Z+3, r19	; 0x03
     93a:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     93c:	89 81       	ldd	r24, Y+1	; 0x01
     93e:	9a 81       	ldd	r25, Y+2	; 0x02
     940:	fc 01       	movw	r30, r24
     942:	24 81       	ldd	r18, Z+4	; 0x04
     944:	35 81       	ldd	r19, Z+5	; 0x05
     946:	8d 81       	ldd	r24, Y+5	; 0x05
     948:	9e 81       	ldd	r25, Y+6	; 0x06
     94a:	fc 01       	movw	r30, r24
     94c:	35 83       	std	Z+5, r19	; 0x05
     94e:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     950:	89 81       	ldd	r24, Y+1	; 0x01
     952:	9a 81       	ldd	r25, Y+2	; 0x02
     954:	fc 01       	movw	r30, r24
     956:	84 81       	ldd	r24, Z+4	; 0x04
     958:	95 81       	ldd	r25, Z+5	; 0x05
     95a:	2d 81       	ldd	r18, Y+5	; 0x05
     95c:	3e 81       	ldd	r19, Y+6	; 0x06
     95e:	fc 01       	movw	r30, r24
     960:	33 83       	std	Z+3, r19	; 0x03
     962:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     964:	89 81       	ldd	r24, Y+1	; 0x01
     966:	9a 81       	ldd	r25, Y+2	; 0x02
     968:	2d 81       	ldd	r18, Y+5	; 0x05
     96a:	3e 81       	ldd	r19, Y+6	; 0x06
     96c:	fc 01       	movw	r30, r24
     96e:	35 83       	std	Z+5, r19	; 0x05
     970:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     972:	8d 81       	ldd	r24, Y+5	; 0x05
     974:	9e 81       	ldd	r25, Y+6	; 0x06
     976:	2b 81       	ldd	r18, Y+3	; 0x03
     978:	3c 81       	ldd	r19, Y+4	; 0x04
     97a:	fc 01       	movw	r30, r24
     97c:	31 87       	std	Z+9, r19	; 0x09
     97e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     980:	8b 81       	ldd	r24, Y+3	; 0x03
     982:	9c 81       	ldd	r25, Y+4	; 0x04
     984:	fc 01       	movw	r30, r24
     986:	80 81       	ld	r24, Z
     988:	21 e0       	ldi	r18, 0x01	; 1
     98a:	28 0f       	add	r18, r24
     98c:	8b 81       	ldd	r24, Y+3	; 0x03
     98e:	9c 81       	ldd	r25, Y+4	; 0x04
     990:	fc 01       	movw	r30, r24
     992:	20 83       	st	Z, r18
}
     994:	26 96       	adiw	r28, 0x06	; 6
     996:	0f b6       	in	r0, 0x3f	; 63
     998:	f8 94       	cli
     99a:	de bf       	out	0x3e, r29	; 62
     99c:	0f be       	out	0x3f, r0	; 63
     99e:	cd bf       	out	0x3d, r28	; 61
     9a0:	df 91       	pop	r29
     9a2:	cf 91       	pop	r28
     9a4:	08 95       	ret

000009a6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     9a6:	cf 93       	push	r28
     9a8:	df 93       	push	r29
     9aa:	cd b7       	in	r28, 0x3d	; 61
     9ac:	de b7       	in	r29, 0x3e	; 62
     9ae:	28 97       	sbiw	r28, 0x08	; 8
     9b0:	0f b6       	in	r0, 0x3f	; 63
     9b2:	f8 94       	cli
     9b4:	de bf       	out	0x3e, r29	; 62
     9b6:	0f be       	out	0x3f, r0	; 63
     9b8:	cd bf       	out	0x3d, r28	; 61
     9ba:	9e 83       	std	Y+6, r25	; 0x06
     9bc:	8d 83       	std	Y+5, r24	; 0x05
     9be:	78 87       	std	Y+8, r23	; 0x08
     9c0:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     9c2:	8f 81       	ldd	r24, Y+7	; 0x07
     9c4:	98 85       	ldd	r25, Y+8	; 0x08
     9c6:	fc 01       	movw	r30, r24
     9c8:	80 81       	ld	r24, Z
     9ca:	91 81       	ldd	r25, Z+1	; 0x01
     9cc:	9c 83       	std	Y+4, r25	; 0x04
     9ce:	8b 83       	std	Y+3, r24	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     9d0:	8b 81       	ldd	r24, Y+3	; 0x03
     9d2:	9c 81       	ldd	r25, Y+4	; 0x04
     9d4:	01 96       	adiw	r24, 0x01	; 1
     9d6:	41 f4       	brne	.+16     	; 0x9e8 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     9d8:	8d 81       	ldd	r24, Y+5	; 0x05
     9da:	9e 81       	ldd	r25, Y+6	; 0x06
     9dc:	fc 01       	movw	r30, r24
     9de:	87 81       	ldd	r24, Z+7	; 0x07
     9e0:	90 85       	ldd	r25, Z+8	; 0x08
     9e2:	9a 83       	std	Y+2, r25	; 0x02
     9e4:	89 83       	std	Y+1, r24	; 0x01
     9e6:	1a c0       	rjmp	.+52     	; 0xa1c <vListInsert+0x76>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9e8:	8d 81       	ldd	r24, Y+5	; 0x05
     9ea:	9e 81       	ldd	r25, Y+6	; 0x06
     9ec:	03 96       	adiw	r24, 0x03	; 3
     9ee:	9a 83       	std	Y+2, r25	; 0x02
     9f0:	89 83       	std	Y+1, r24	; 0x01
     9f2:	07 c0       	rjmp	.+14     	; 0xa02 <vListInsert+0x5c>
     9f4:	89 81       	ldd	r24, Y+1	; 0x01
     9f6:	9a 81       	ldd	r25, Y+2	; 0x02
     9f8:	fc 01       	movw	r30, r24
     9fa:	82 81       	ldd	r24, Z+2	; 0x02
     9fc:	93 81       	ldd	r25, Z+3	; 0x03
     9fe:	9a 83       	std	Y+2, r25	; 0x02
     a00:	89 83       	std	Y+1, r24	; 0x01
     a02:	89 81       	ldd	r24, Y+1	; 0x01
     a04:	9a 81       	ldd	r25, Y+2	; 0x02
     a06:	fc 01       	movw	r30, r24
     a08:	82 81       	ldd	r24, Z+2	; 0x02
     a0a:	93 81       	ldd	r25, Z+3	; 0x03
     a0c:	fc 01       	movw	r30, r24
     a0e:	20 81       	ld	r18, Z
     a10:	31 81       	ldd	r19, Z+1	; 0x01
     a12:	8b 81       	ldd	r24, Y+3	; 0x03
     a14:	9c 81       	ldd	r25, Y+4	; 0x04
     a16:	82 17       	cp	r24, r18
     a18:	93 07       	cpc	r25, r19
     a1a:	60 f7       	brcc	.-40     	; 0x9f4 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a1c:	89 81       	ldd	r24, Y+1	; 0x01
     a1e:	9a 81       	ldd	r25, Y+2	; 0x02
     a20:	fc 01       	movw	r30, r24
     a22:	22 81       	ldd	r18, Z+2	; 0x02
     a24:	33 81       	ldd	r19, Z+3	; 0x03
     a26:	8f 81       	ldd	r24, Y+7	; 0x07
     a28:	98 85       	ldd	r25, Y+8	; 0x08
     a2a:	fc 01       	movw	r30, r24
     a2c:	33 83       	std	Z+3, r19	; 0x03
     a2e:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     a30:	8f 81       	ldd	r24, Y+7	; 0x07
     a32:	98 85       	ldd	r25, Y+8	; 0x08
     a34:	fc 01       	movw	r30, r24
     a36:	82 81       	ldd	r24, Z+2	; 0x02
     a38:	93 81       	ldd	r25, Z+3	; 0x03
     a3a:	2f 81       	ldd	r18, Y+7	; 0x07
     a3c:	38 85       	ldd	r19, Y+8	; 0x08
     a3e:	fc 01       	movw	r30, r24
     a40:	35 83       	std	Z+5, r19	; 0x05
     a42:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     a44:	8f 81       	ldd	r24, Y+7	; 0x07
     a46:	98 85       	ldd	r25, Y+8	; 0x08
     a48:	29 81       	ldd	r18, Y+1	; 0x01
     a4a:	3a 81       	ldd	r19, Y+2	; 0x02
     a4c:	fc 01       	movw	r30, r24
     a4e:	35 83       	std	Z+5, r19	; 0x05
     a50:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
     a52:	89 81       	ldd	r24, Y+1	; 0x01
     a54:	9a 81       	ldd	r25, Y+2	; 0x02
     a56:	2f 81       	ldd	r18, Y+7	; 0x07
     a58:	38 85       	ldd	r19, Y+8	; 0x08
     a5a:	fc 01       	movw	r30, r24
     a5c:	33 83       	std	Z+3, r19	; 0x03
     a5e:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a60:	8f 81       	ldd	r24, Y+7	; 0x07
     a62:	98 85       	ldd	r25, Y+8	; 0x08
     a64:	2d 81       	ldd	r18, Y+5	; 0x05
     a66:	3e 81       	ldd	r19, Y+6	; 0x06
     a68:	fc 01       	movw	r30, r24
     a6a:	31 87       	std	Z+9, r19	; 0x09
     a6c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     a6e:	8d 81       	ldd	r24, Y+5	; 0x05
     a70:	9e 81       	ldd	r25, Y+6	; 0x06
     a72:	fc 01       	movw	r30, r24
     a74:	80 81       	ld	r24, Z
     a76:	21 e0       	ldi	r18, 0x01	; 1
     a78:	28 0f       	add	r18, r24
     a7a:	8d 81       	ldd	r24, Y+5	; 0x05
     a7c:	9e 81       	ldd	r25, Y+6	; 0x06
     a7e:	fc 01       	movw	r30, r24
     a80:	20 83       	st	Z, r18
}
     a82:	28 96       	adiw	r28, 0x08	; 8
     a84:	0f b6       	in	r0, 0x3f	; 63
     a86:	f8 94       	cli
     a88:	de bf       	out	0x3e, r29	; 62
     a8a:	0f be       	out	0x3f, r0	; 63
     a8c:	cd bf       	out	0x3d, r28	; 61
     a8e:	df 91       	pop	r29
     a90:	cf 91       	pop	r28
     a92:	08 95       	ret

00000a94 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     a94:	cf 93       	push	r28
     a96:	df 93       	push	r29
     a98:	00 d0       	rcall	.+0      	; 0xa9a <uxListRemove+0x6>
     a9a:	00 d0       	rcall	.+0      	; 0xa9c <uxListRemove+0x8>
     a9c:	cd b7       	in	r28, 0x3d	; 61
     a9e:	de b7       	in	r29, 0x3e	; 62
     aa0:	9c 83       	std	Y+4, r25	; 0x04
     aa2:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     aa4:	8b 81       	ldd	r24, Y+3	; 0x03
     aa6:	9c 81       	ldd	r25, Y+4	; 0x04
     aa8:	fc 01       	movw	r30, r24
     aaa:	80 85       	ldd	r24, Z+8	; 0x08
     aac:	91 85       	ldd	r25, Z+9	; 0x09
     aae:	9a 83       	std	Y+2, r25	; 0x02
     ab0:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     ab2:	8b 81       	ldd	r24, Y+3	; 0x03
     ab4:	9c 81       	ldd	r25, Y+4	; 0x04
     ab6:	fc 01       	movw	r30, r24
     ab8:	82 81       	ldd	r24, Z+2	; 0x02
     aba:	93 81       	ldd	r25, Z+3	; 0x03
     abc:	2b 81       	ldd	r18, Y+3	; 0x03
     abe:	3c 81       	ldd	r19, Y+4	; 0x04
     ac0:	f9 01       	movw	r30, r18
     ac2:	24 81       	ldd	r18, Z+4	; 0x04
     ac4:	35 81       	ldd	r19, Z+5	; 0x05
     ac6:	fc 01       	movw	r30, r24
     ac8:	35 83       	std	Z+5, r19	; 0x05
     aca:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     acc:	8b 81       	ldd	r24, Y+3	; 0x03
     ace:	9c 81       	ldd	r25, Y+4	; 0x04
     ad0:	fc 01       	movw	r30, r24
     ad2:	84 81       	ldd	r24, Z+4	; 0x04
     ad4:	95 81       	ldd	r25, Z+5	; 0x05
     ad6:	2b 81       	ldd	r18, Y+3	; 0x03
     ad8:	3c 81       	ldd	r19, Y+4	; 0x04
     ada:	f9 01       	movw	r30, r18
     adc:	22 81       	ldd	r18, Z+2	; 0x02
     ade:	33 81       	ldd	r19, Z+3	; 0x03
     ae0:	fc 01       	movw	r30, r24
     ae2:	33 83       	std	Z+3, r19	; 0x03
     ae4:	22 83       	std	Z+2, r18	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     ae6:	89 81       	ldd	r24, Y+1	; 0x01
     ae8:	9a 81       	ldd	r25, Y+2	; 0x02
     aea:	fc 01       	movw	r30, r24
     aec:	21 81       	ldd	r18, Z+1	; 0x01
     aee:	32 81       	ldd	r19, Z+2	; 0x02
     af0:	8b 81       	ldd	r24, Y+3	; 0x03
     af2:	9c 81       	ldd	r25, Y+4	; 0x04
     af4:	28 17       	cp	r18, r24
     af6:	39 07       	cpc	r19, r25
     af8:	51 f4       	brne	.+20     	; 0xb0e <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     afa:	8b 81       	ldd	r24, Y+3	; 0x03
     afc:	9c 81       	ldd	r25, Y+4	; 0x04
     afe:	fc 01       	movw	r30, r24
     b00:	24 81       	ldd	r18, Z+4	; 0x04
     b02:	35 81       	ldd	r19, Z+5	; 0x05
     b04:	89 81       	ldd	r24, Y+1	; 0x01
     b06:	9a 81       	ldd	r25, Y+2	; 0x02
     b08:	fc 01       	movw	r30, r24
     b0a:	32 83       	std	Z+2, r19	; 0x02
     b0c:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     b0e:	8b 81       	ldd	r24, Y+3	; 0x03
     b10:	9c 81       	ldd	r25, Y+4	; 0x04
     b12:	fc 01       	movw	r30, r24
     b14:	11 86       	std	Z+9, r1	; 0x09
     b16:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     b18:	89 81       	ldd	r24, Y+1	; 0x01
     b1a:	9a 81       	ldd	r25, Y+2	; 0x02
     b1c:	fc 01       	movw	r30, r24
     b1e:	80 81       	ld	r24, Z
     b20:	2f ef       	ldi	r18, 0xFF	; 255
     b22:	28 0f       	add	r18, r24
     b24:	89 81       	ldd	r24, Y+1	; 0x01
     b26:	9a 81       	ldd	r25, Y+2	; 0x02
     b28:	fc 01       	movw	r30, r24
     b2a:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
     b2c:	89 81       	ldd	r24, Y+1	; 0x01
     b2e:	9a 81       	ldd	r25, Y+2	; 0x02
     b30:	fc 01       	movw	r30, r24
     b32:	80 81       	ld	r24, Z
}
     b34:	0f 90       	pop	r0
     b36:	0f 90       	pop	r0
     b38:	0f 90       	pop	r0
     b3a:	0f 90       	pop	r0
     b3c:	df 91       	pop	r29
     b3e:	cf 91       	pop	r28
     b40:	08 95       	ret

00000b42 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     b42:	cf 93       	push	r28
     b44:	df 93       	push	r29
     b46:	cd b7       	in	r28, 0x3d	; 61
     b48:	de b7       	in	r29, 0x3e	; 62
     b4a:	28 97       	sbiw	r28, 0x08	; 8
     b4c:	0f b6       	in	r0, 0x3f	; 63
     b4e:	f8 94       	cli
     b50:	de bf       	out	0x3e, r29	; 62
     b52:	0f be       	out	0x3f, r0	; 63
     b54:	cd bf       	out	0x3d, r28	; 61
     b56:	9c 83       	std	Y+4, r25	; 0x04
     b58:	8b 83       	std	Y+3, r24	; 0x03
     b5a:	7e 83       	std	Y+6, r23	; 0x06
     b5c:	6d 83       	std	Y+5, r22	; 0x05
     b5e:	58 87       	std	Y+8, r21	; 0x08
     b60:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     b62:	8b 81       	ldd	r24, Y+3	; 0x03
     b64:	9c 81       	ldd	r25, Y+4	; 0x04
     b66:	21 e1       	ldi	r18, 0x11	; 17
     b68:	fc 01       	movw	r30, r24
     b6a:	20 83       	st	Z, r18
	pxTopOfStack--;
     b6c:	8b 81       	ldd	r24, Y+3	; 0x03
     b6e:	9c 81       	ldd	r25, Y+4	; 0x04
     b70:	01 97       	sbiw	r24, 0x01	; 1
     b72:	9c 83       	std	Y+4, r25	; 0x04
     b74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     b76:	8b 81       	ldd	r24, Y+3	; 0x03
     b78:	9c 81       	ldd	r25, Y+4	; 0x04
     b7a:	22 e2       	ldi	r18, 0x22	; 34
     b7c:	fc 01       	movw	r30, r24
     b7e:	20 83       	st	Z, r18
	pxTopOfStack--;
     b80:	8b 81       	ldd	r24, Y+3	; 0x03
     b82:	9c 81       	ldd	r25, Y+4	; 0x04
     b84:	01 97       	sbiw	r24, 0x01	; 1
     b86:	9c 83       	std	Y+4, r25	; 0x04
     b88:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     b8a:	8b 81       	ldd	r24, Y+3	; 0x03
     b8c:	9c 81       	ldd	r25, Y+4	; 0x04
     b8e:	23 e3       	ldi	r18, 0x33	; 51
     b90:	fc 01       	movw	r30, r24
     b92:	20 83       	st	Z, r18
	pxTopOfStack--;
     b94:	8b 81       	ldd	r24, Y+3	; 0x03
     b96:	9c 81       	ldd	r25, Y+4	; 0x04
     b98:	01 97       	sbiw	r24, 0x01	; 1
     b9a:	9c 83       	std	Y+4, r25	; 0x04
     b9c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     b9e:	8d 81       	ldd	r24, Y+5	; 0x05
     ba0:	9e 81       	ldd	r25, Y+6	; 0x06
     ba2:	9a 83       	std	Y+2, r25	; 0x02
     ba4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     ba6:	29 81       	ldd	r18, Y+1	; 0x01
     ba8:	8b 81       	ldd	r24, Y+3	; 0x03
     baa:	9c 81       	ldd	r25, Y+4	; 0x04
     bac:	fc 01       	movw	r30, r24
     bae:	20 83       	st	Z, r18
	pxTopOfStack--;
     bb0:	8b 81       	ldd	r24, Y+3	; 0x03
     bb2:	9c 81       	ldd	r25, Y+4	; 0x04
     bb4:	01 97       	sbiw	r24, 0x01	; 1
     bb6:	9c 83       	std	Y+4, r25	; 0x04
     bb8:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     bba:	89 81       	ldd	r24, Y+1	; 0x01
     bbc:	9a 81       	ldd	r25, Y+2	; 0x02
     bbe:	89 2f       	mov	r24, r25
     bc0:	99 27       	eor	r25, r25
     bc2:	9a 83       	std	Y+2, r25	; 0x02
     bc4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     bc6:	29 81       	ldd	r18, Y+1	; 0x01
     bc8:	8b 81       	ldd	r24, Y+3	; 0x03
     bca:	9c 81       	ldd	r25, Y+4	; 0x04
     bcc:	fc 01       	movw	r30, r24
     bce:	20 83       	st	Z, r18
	pxTopOfStack--;
     bd0:	8b 81       	ldd	r24, Y+3	; 0x03
     bd2:	9c 81       	ldd	r25, Y+4	; 0x04
     bd4:	01 97       	sbiw	r24, 0x01	; 1
     bd6:	9c 83       	std	Y+4, r25	; 0x04
     bd8:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     bda:	8b 81       	ldd	r24, Y+3	; 0x03
     bdc:	9c 81       	ldd	r25, Y+4	; 0x04
     bde:	fc 01       	movw	r30, r24
     be0:	10 82       	st	Z, r1
	pxTopOfStack--;
     be2:	8b 81       	ldd	r24, Y+3	; 0x03
     be4:	9c 81       	ldd	r25, Y+4	; 0x04
     be6:	01 97       	sbiw	r24, 0x01	; 1
     be8:	9c 83       	std	Y+4, r25	; 0x04
     bea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     bec:	8b 81       	ldd	r24, Y+3	; 0x03
     bee:	9c 81       	ldd	r25, Y+4	; 0x04
     bf0:	20 e8       	ldi	r18, 0x80	; 128
     bf2:	fc 01       	movw	r30, r24
     bf4:	20 83       	st	Z, r18
	pxTopOfStack--;
     bf6:	8b 81       	ldd	r24, Y+3	; 0x03
     bf8:	9c 81       	ldd	r25, Y+4	; 0x04
     bfa:	01 97       	sbiw	r24, 0x01	; 1
     bfc:	9c 83       	std	Y+4, r25	; 0x04
     bfe:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     c00:	8b 81       	ldd	r24, Y+3	; 0x03
     c02:	9c 81       	ldd	r25, Y+4	; 0x04
     c04:	fc 01       	movw	r30, r24
     c06:	10 82       	st	Z, r1
	pxTopOfStack--;
     c08:	8b 81       	ldd	r24, Y+3	; 0x03
     c0a:	9c 81       	ldd	r25, Y+4	; 0x04
     c0c:	01 97       	sbiw	r24, 0x01	; 1
     c0e:	9c 83       	std	Y+4, r25	; 0x04
     c10:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     c12:	8b 81       	ldd	r24, Y+3	; 0x03
     c14:	9c 81       	ldd	r25, Y+4	; 0x04
     c16:	22 e0       	ldi	r18, 0x02	; 2
     c18:	fc 01       	movw	r30, r24
     c1a:	20 83       	st	Z, r18
	pxTopOfStack--;
     c1c:	8b 81       	ldd	r24, Y+3	; 0x03
     c1e:	9c 81       	ldd	r25, Y+4	; 0x04
     c20:	01 97       	sbiw	r24, 0x01	; 1
     c22:	9c 83       	std	Y+4, r25	; 0x04
     c24:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     c26:	8b 81       	ldd	r24, Y+3	; 0x03
     c28:	9c 81       	ldd	r25, Y+4	; 0x04
     c2a:	23 e0       	ldi	r18, 0x03	; 3
     c2c:	fc 01       	movw	r30, r24
     c2e:	20 83       	st	Z, r18
	pxTopOfStack--;
     c30:	8b 81       	ldd	r24, Y+3	; 0x03
     c32:	9c 81       	ldd	r25, Y+4	; 0x04
     c34:	01 97       	sbiw	r24, 0x01	; 1
     c36:	9c 83       	std	Y+4, r25	; 0x04
     c38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     c3a:	8b 81       	ldd	r24, Y+3	; 0x03
     c3c:	9c 81       	ldd	r25, Y+4	; 0x04
     c3e:	24 e0       	ldi	r18, 0x04	; 4
     c40:	fc 01       	movw	r30, r24
     c42:	20 83       	st	Z, r18
	pxTopOfStack--;
     c44:	8b 81       	ldd	r24, Y+3	; 0x03
     c46:	9c 81       	ldd	r25, Y+4	; 0x04
     c48:	01 97       	sbiw	r24, 0x01	; 1
     c4a:	9c 83       	std	Y+4, r25	; 0x04
     c4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     c4e:	8b 81       	ldd	r24, Y+3	; 0x03
     c50:	9c 81       	ldd	r25, Y+4	; 0x04
     c52:	25 e0       	ldi	r18, 0x05	; 5
     c54:	fc 01       	movw	r30, r24
     c56:	20 83       	st	Z, r18
	pxTopOfStack--;
     c58:	8b 81       	ldd	r24, Y+3	; 0x03
     c5a:	9c 81       	ldd	r25, Y+4	; 0x04
     c5c:	01 97       	sbiw	r24, 0x01	; 1
     c5e:	9c 83       	std	Y+4, r25	; 0x04
     c60:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     c62:	8b 81       	ldd	r24, Y+3	; 0x03
     c64:	9c 81       	ldd	r25, Y+4	; 0x04
     c66:	26 e0       	ldi	r18, 0x06	; 6
     c68:	fc 01       	movw	r30, r24
     c6a:	20 83       	st	Z, r18
	pxTopOfStack--;
     c6c:	8b 81       	ldd	r24, Y+3	; 0x03
     c6e:	9c 81       	ldd	r25, Y+4	; 0x04
     c70:	01 97       	sbiw	r24, 0x01	; 1
     c72:	9c 83       	std	Y+4, r25	; 0x04
     c74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     c76:	8b 81       	ldd	r24, Y+3	; 0x03
     c78:	9c 81       	ldd	r25, Y+4	; 0x04
     c7a:	27 e0       	ldi	r18, 0x07	; 7
     c7c:	fc 01       	movw	r30, r24
     c7e:	20 83       	st	Z, r18
	pxTopOfStack--;
     c80:	8b 81       	ldd	r24, Y+3	; 0x03
     c82:	9c 81       	ldd	r25, Y+4	; 0x04
     c84:	01 97       	sbiw	r24, 0x01	; 1
     c86:	9c 83       	std	Y+4, r25	; 0x04
     c88:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     c8a:	8b 81       	ldd	r24, Y+3	; 0x03
     c8c:	9c 81       	ldd	r25, Y+4	; 0x04
     c8e:	28 e0       	ldi	r18, 0x08	; 8
     c90:	fc 01       	movw	r30, r24
     c92:	20 83       	st	Z, r18
	pxTopOfStack--;
     c94:	8b 81       	ldd	r24, Y+3	; 0x03
     c96:	9c 81       	ldd	r25, Y+4	; 0x04
     c98:	01 97       	sbiw	r24, 0x01	; 1
     c9a:	9c 83       	std	Y+4, r25	; 0x04
     c9c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     c9e:	8b 81       	ldd	r24, Y+3	; 0x03
     ca0:	9c 81       	ldd	r25, Y+4	; 0x04
     ca2:	29 e0       	ldi	r18, 0x09	; 9
     ca4:	fc 01       	movw	r30, r24
     ca6:	20 83       	st	Z, r18
	pxTopOfStack--;
     ca8:	8b 81       	ldd	r24, Y+3	; 0x03
     caa:	9c 81       	ldd	r25, Y+4	; 0x04
     cac:	01 97       	sbiw	r24, 0x01	; 1
     cae:	9c 83       	std	Y+4, r25	; 0x04
     cb0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     cb2:	8b 81       	ldd	r24, Y+3	; 0x03
     cb4:	9c 81       	ldd	r25, Y+4	; 0x04
     cb6:	20 e1       	ldi	r18, 0x10	; 16
     cb8:	fc 01       	movw	r30, r24
     cba:	20 83       	st	Z, r18
	pxTopOfStack--;
     cbc:	8b 81       	ldd	r24, Y+3	; 0x03
     cbe:	9c 81       	ldd	r25, Y+4	; 0x04
     cc0:	01 97       	sbiw	r24, 0x01	; 1
     cc2:	9c 83       	std	Y+4, r25	; 0x04
     cc4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     cc6:	8b 81       	ldd	r24, Y+3	; 0x03
     cc8:	9c 81       	ldd	r25, Y+4	; 0x04
     cca:	21 e1       	ldi	r18, 0x11	; 17
     ccc:	fc 01       	movw	r30, r24
     cce:	20 83       	st	Z, r18
	pxTopOfStack--;
     cd0:	8b 81       	ldd	r24, Y+3	; 0x03
     cd2:	9c 81       	ldd	r25, Y+4	; 0x04
     cd4:	01 97       	sbiw	r24, 0x01	; 1
     cd6:	9c 83       	std	Y+4, r25	; 0x04
     cd8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     cda:	8b 81       	ldd	r24, Y+3	; 0x03
     cdc:	9c 81       	ldd	r25, Y+4	; 0x04
     cde:	22 e1       	ldi	r18, 0x12	; 18
     ce0:	fc 01       	movw	r30, r24
     ce2:	20 83       	st	Z, r18
	pxTopOfStack--;
     ce4:	8b 81       	ldd	r24, Y+3	; 0x03
     ce6:	9c 81       	ldd	r25, Y+4	; 0x04
     ce8:	01 97       	sbiw	r24, 0x01	; 1
     cea:	9c 83       	std	Y+4, r25	; 0x04
     cec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     cee:	8b 81       	ldd	r24, Y+3	; 0x03
     cf0:	9c 81       	ldd	r25, Y+4	; 0x04
     cf2:	23 e1       	ldi	r18, 0x13	; 19
     cf4:	fc 01       	movw	r30, r24
     cf6:	20 83       	st	Z, r18
	pxTopOfStack--;
     cf8:	8b 81       	ldd	r24, Y+3	; 0x03
     cfa:	9c 81       	ldd	r25, Y+4	; 0x04
     cfc:	01 97       	sbiw	r24, 0x01	; 1
     cfe:	9c 83       	std	Y+4, r25	; 0x04
     d00:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     d02:	8b 81       	ldd	r24, Y+3	; 0x03
     d04:	9c 81       	ldd	r25, Y+4	; 0x04
     d06:	24 e1       	ldi	r18, 0x14	; 20
     d08:	fc 01       	movw	r30, r24
     d0a:	20 83       	st	Z, r18
	pxTopOfStack--;
     d0c:	8b 81       	ldd	r24, Y+3	; 0x03
     d0e:	9c 81       	ldd	r25, Y+4	; 0x04
     d10:	01 97       	sbiw	r24, 0x01	; 1
     d12:	9c 83       	std	Y+4, r25	; 0x04
     d14:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     d16:	8b 81       	ldd	r24, Y+3	; 0x03
     d18:	9c 81       	ldd	r25, Y+4	; 0x04
     d1a:	25 e1       	ldi	r18, 0x15	; 21
     d1c:	fc 01       	movw	r30, r24
     d1e:	20 83       	st	Z, r18
	pxTopOfStack--;
     d20:	8b 81       	ldd	r24, Y+3	; 0x03
     d22:	9c 81       	ldd	r25, Y+4	; 0x04
     d24:	01 97       	sbiw	r24, 0x01	; 1
     d26:	9c 83       	std	Y+4, r25	; 0x04
     d28:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     d2a:	8b 81       	ldd	r24, Y+3	; 0x03
     d2c:	9c 81       	ldd	r25, Y+4	; 0x04
     d2e:	26 e1       	ldi	r18, 0x16	; 22
     d30:	fc 01       	movw	r30, r24
     d32:	20 83       	st	Z, r18
	pxTopOfStack--;
     d34:	8b 81       	ldd	r24, Y+3	; 0x03
     d36:	9c 81       	ldd	r25, Y+4	; 0x04
     d38:	01 97       	sbiw	r24, 0x01	; 1
     d3a:	9c 83       	std	Y+4, r25	; 0x04
     d3c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     d3e:	8b 81       	ldd	r24, Y+3	; 0x03
     d40:	9c 81       	ldd	r25, Y+4	; 0x04
     d42:	27 e1       	ldi	r18, 0x17	; 23
     d44:	fc 01       	movw	r30, r24
     d46:	20 83       	st	Z, r18
	pxTopOfStack--;
     d48:	8b 81       	ldd	r24, Y+3	; 0x03
     d4a:	9c 81       	ldd	r25, Y+4	; 0x04
     d4c:	01 97       	sbiw	r24, 0x01	; 1
     d4e:	9c 83       	std	Y+4, r25	; 0x04
     d50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     d52:	8b 81       	ldd	r24, Y+3	; 0x03
     d54:	9c 81       	ldd	r25, Y+4	; 0x04
     d56:	28 e1       	ldi	r18, 0x18	; 24
     d58:	fc 01       	movw	r30, r24
     d5a:	20 83       	st	Z, r18
	pxTopOfStack--;
     d5c:	8b 81       	ldd	r24, Y+3	; 0x03
     d5e:	9c 81       	ldd	r25, Y+4	; 0x04
     d60:	01 97       	sbiw	r24, 0x01	; 1
     d62:	9c 83       	std	Y+4, r25	; 0x04
     d64:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     d66:	8b 81       	ldd	r24, Y+3	; 0x03
     d68:	9c 81       	ldd	r25, Y+4	; 0x04
     d6a:	29 e1       	ldi	r18, 0x19	; 25
     d6c:	fc 01       	movw	r30, r24
     d6e:	20 83       	st	Z, r18
	pxTopOfStack--;
     d70:	8b 81       	ldd	r24, Y+3	; 0x03
     d72:	9c 81       	ldd	r25, Y+4	; 0x04
     d74:	01 97       	sbiw	r24, 0x01	; 1
     d76:	9c 83       	std	Y+4, r25	; 0x04
     d78:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     d7a:	8b 81       	ldd	r24, Y+3	; 0x03
     d7c:	9c 81       	ldd	r25, Y+4	; 0x04
     d7e:	20 e2       	ldi	r18, 0x20	; 32
     d80:	fc 01       	movw	r30, r24
     d82:	20 83       	st	Z, r18
	pxTopOfStack--;
     d84:	8b 81       	ldd	r24, Y+3	; 0x03
     d86:	9c 81       	ldd	r25, Y+4	; 0x04
     d88:	01 97       	sbiw	r24, 0x01	; 1
     d8a:	9c 83       	std	Y+4, r25	; 0x04
     d8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     d8e:	8b 81       	ldd	r24, Y+3	; 0x03
     d90:	9c 81       	ldd	r25, Y+4	; 0x04
     d92:	21 e2       	ldi	r18, 0x21	; 33
     d94:	fc 01       	movw	r30, r24
     d96:	20 83       	st	Z, r18
	pxTopOfStack--;
     d98:	8b 81       	ldd	r24, Y+3	; 0x03
     d9a:	9c 81       	ldd	r25, Y+4	; 0x04
     d9c:	01 97       	sbiw	r24, 0x01	; 1
     d9e:	9c 83       	std	Y+4, r25	; 0x04
     da0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     da2:	8b 81       	ldd	r24, Y+3	; 0x03
     da4:	9c 81       	ldd	r25, Y+4	; 0x04
     da6:	22 e2       	ldi	r18, 0x22	; 34
     da8:	fc 01       	movw	r30, r24
     daa:	20 83       	st	Z, r18
	pxTopOfStack--;
     dac:	8b 81       	ldd	r24, Y+3	; 0x03
     dae:	9c 81       	ldd	r25, Y+4	; 0x04
     db0:	01 97       	sbiw	r24, 0x01	; 1
     db2:	9c 83       	std	Y+4, r25	; 0x04
     db4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     db6:	8b 81       	ldd	r24, Y+3	; 0x03
     db8:	9c 81       	ldd	r25, Y+4	; 0x04
     dba:	23 e2       	ldi	r18, 0x23	; 35
     dbc:	fc 01       	movw	r30, r24
     dbe:	20 83       	st	Z, r18
	pxTopOfStack--;
     dc0:	8b 81       	ldd	r24, Y+3	; 0x03
     dc2:	9c 81       	ldd	r25, Y+4	; 0x04
     dc4:	01 97       	sbiw	r24, 0x01	; 1
     dc6:	9c 83       	std	Y+4, r25	; 0x04
     dc8:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     dca:	8f 81       	ldd	r24, Y+7	; 0x07
     dcc:	98 85       	ldd	r25, Y+8	; 0x08
     dce:	9a 83       	std	Y+2, r25	; 0x02
     dd0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     dd2:	29 81       	ldd	r18, Y+1	; 0x01
     dd4:	8b 81       	ldd	r24, Y+3	; 0x03
     dd6:	9c 81       	ldd	r25, Y+4	; 0x04
     dd8:	fc 01       	movw	r30, r24
     dda:	20 83       	st	Z, r18
	pxTopOfStack--;
     ddc:	8b 81       	ldd	r24, Y+3	; 0x03
     dde:	9c 81       	ldd	r25, Y+4	; 0x04
     de0:	01 97       	sbiw	r24, 0x01	; 1
     de2:	9c 83       	std	Y+4, r25	; 0x04
     de4:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     de6:	89 81       	ldd	r24, Y+1	; 0x01
     de8:	9a 81       	ldd	r25, Y+2	; 0x02
     dea:	89 2f       	mov	r24, r25
     dec:	99 27       	eor	r25, r25
     dee:	9a 83       	std	Y+2, r25	; 0x02
     df0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     df2:	29 81       	ldd	r18, Y+1	; 0x01
     df4:	8b 81       	ldd	r24, Y+3	; 0x03
     df6:	9c 81       	ldd	r25, Y+4	; 0x04
     df8:	fc 01       	movw	r30, r24
     dfa:	20 83       	st	Z, r18
	pxTopOfStack--;
     dfc:	8b 81       	ldd	r24, Y+3	; 0x03
     dfe:	9c 81       	ldd	r25, Y+4	; 0x04
     e00:	01 97       	sbiw	r24, 0x01	; 1
     e02:	9c 83       	std	Y+4, r25	; 0x04
     e04:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     e06:	8b 81       	ldd	r24, Y+3	; 0x03
     e08:	9c 81       	ldd	r25, Y+4	; 0x04
     e0a:	26 e2       	ldi	r18, 0x26	; 38
     e0c:	fc 01       	movw	r30, r24
     e0e:	20 83       	st	Z, r18
	pxTopOfStack--;
     e10:	8b 81       	ldd	r24, Y+3	; 0x03
     e12:	9c 81       	ldd	r25, Y+4	; 0x04
     e14:	01 97       	sbiw	r24, 0x01	; 1
     e16:	9c 83       	std	Y+4, r25	; 0x04
     e18:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     e1a:	8b 81       	ldd	r24, Y+3	; 0x03
     e1c:	9c 81       	ldd	r25, Y+4	; 0x04
     e1e:	27 e2       	ldi	r18, 0x27	; 39
     e20:	fc 01       	movw	r30, r24
     e22:	20 83       	st	Z, r18
	pxTopOfStack--;
     e24:	8b 81       	ldd	r24, Y+3	; 0x03
     e26:	9c 81       	ldd	r25, Y+4	; 0x04
     e28:	01 97       	sbiw	r24, 0x01	; 1
     e2a:	9c 83       	std	Y+4, r25	; 0x04
     e2c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     e2e:	8b 81       	ldd	r24, Y+3	; 0x03
     e30:	9c 81       	ldd	r25, Y+4	; 0x04
     e32:	28 e2       	ldi	r18, 0x28	; 40
     e34:	fc 01       	movw	r30, r24
     e36:	20 83       	st	Z, r18
	pxTopOfStack--;
     e38:	8b 81       	ldd	r24, Y+3	; 0x03
     e3a:	9c 81       	ldd	r25, Y+4	; 0x04
     e3c:	01 97       	sbiw	r24, 0x01	; 1
     e3e:	9c 83       	std	Y+4, r25	; 0x04
     e40:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     e42:	8b 81       	ldd	r24, Y+3	; 0x03
     e44:	9c 81       	ldd	r25, Y+4	; 0x04
     e46:	29 e2       	ldi	r18, 0x29	; 41
     e48:	fc 01       	movw	r30, r24
     e4a:	20 83       	st	Z, r18
	pxTopOfStack--;
     e4c:	8b 81       	ldd	r24, Y+3	; 0x03
     e4e:	9c 81       	ldd	r25, Y+4	; 0x04
     e50:	01 97       	sbiw	r24, 0x01	; 1
     e52:	9c 83       	std	Y+4, r25	; 0x04
     e54:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     e56:	8b 81       	ldd	r24, Y+3	; 0x03
     e58:	9c 81       	ldd	r25, Y+4	; 0x04
     e5a:	20 e3       	ldi	r18, 0x30	; 48
     e5c:	fc 01       	movw	r30, r24
     e5e:	20 83       	st	Z, r18
	pxTopOfStack--;
     e60:	8b 81       	ldd	r24, Y+3	; 0x03
     e62:	9c 81       	ldd	r25, Y+4	; 0x04
     e64:	01 97       	sbiw	r24, 0x01	; 1
     e66:	9c 83       	std	Y+4, r25	; 0x04
     e68:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     e6a:	8b 81       	ldd	r24, Y+3	; 0x03
     e6c:	9c 81       	ldd	r25, Y+4	; 0x04
     e6e:	21 e3       	ldi	r18, 0x31	; 49
     e70:	fc 01       	movw	r30, r24
     e72:	20 83       	st	Z, r18
	pxTopOfStack--;
     e74:	8b 81       	ldd	r24, Y+3	; 0x03
     e76:	9c 81       	ldd	r25, Y+4	; 0x04
     e78:	01 97       	sbiw	r24, 0x01	; 1
     e7a:	9c 83       	std	Y+4, r25	; 0x04
     e7c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     e7e:	8b 81       	ldd	r24, Y+3	; 0x03
     e80:	9c 81       	ldd	r25, Y+4	; 0x04
}
     e82:	28 96       	adiw	r28, 0x08	; 8
     e84:	0f b6       	in	r0, 0x3f	; 63
     e86:	f8 94       	cli
     e88:	de bf       	out	0x3e, r29	; 62
     e8a:	0f be       	out	0x3f, r0	; 63
     e8c:	cd bf       	out	0x3d, r28	; 61
     e8e:	df 91       	pop	r29
     e90:	cf 91       	pop	r28
     e92:	08 95       	ret

00000e94 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     e94:	cf 93       	push	r28
     e96:	df 93       	push	r29
     e98:	cd b7       	in	r28, 0x3d	; 61
     e9a:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     e9c:	0e 94 3c 08 	call	0x1078	; 0x1078 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     ea0:	a0 91 15 05 	lds	r26, 0x0515
     ea4:	b0 91 16 05 	lds	r27, 0x0516
     ea8:	cd 91       	ld	r28, X+
     eaa:	cd bf       	out	0x3d, r28	; 61
     eac:	dd 91       	ld	r29, X+
     eae:	de bf       	out	0x3e, r29	; 62
     eb0:	ff 91       	pop	r31
     eb2:	ef 91       	pop	r30
     eb4:	df 91       	pop	r29
     eb6:	cf 91       	pop	r28
     eb8:	bf 91       	pop	r27
     eba:	af 91       	pop	r26
     ebc:	9f 91       	pop	r25
     ebe:	8f 91       	pop	r24
     ec0:	7f 91       	pop	r23
     ec2:	6f 91       	pop	r22
     ec4:	5f 91       	pop	r21
     ec6:	4f 91       	pop	r20
     ec8:	3f 91       	pop	r19
     eca:	2f 91       	pop	r18
     ecc:	1f 91       	pop	r17
     ece:	0f 91       	pop	r16
     ed0:	ff 90       	pop	r15
     ed2:	ef 90       	pop	r14
     ed4:	df 90       	pop	r13
     ed6:	cf 90       	pop	r12
     ed8:	bf 90       	pop	r11
     eda:	af 90       	pop	r10
     edc:	9f 90       	pop	r9
     ede:	8f 90       	pop	r8
     ee0:	7f 90       	pop	r7
     ee2:	6f 90       	pop	r6
     ee4:	5f 90       	pop	r5
     ee6:	4f 90       	pop	r4
     ee8:	3f 90       	pop	r3
     eea:	2f 90       	pop	r2
     eec:	1f 90       	pop	r1
     eee:	0f 90       	pop	r0
     ef0:	0f be       	out	0x3f, r0	; 63
     ef2:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     ef4:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     ef6:	81 e0       	ldi	r24, 0x01	; 1
}
     ef8:	df 91       	pop	r29
     efa:	cf 91       	pop	r28
     efc:	08 95       	ret

00000efe <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     efe:	cf 93       	push	r28
     f00:	df 93       	push	r29
     f02:	cd b7       	in	r28, 0x3d	; 61
     f04:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     f06:	df 91       	pop	r29
     f08:	cf 91       	pop	r28
     f0a:	08 95       	ret

00000f0c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     f0c:	0f 92       	push	r0
     f0e:	0f b6       	in	r0, 0x3f	; 63
     f10:	f8 94       	cli
     f12:	0f 92       	push	r0
     f14:	1f 92       	push	r1
     f16:	11 24       	eor	r1, r1
     f18:	2f 92       	push	r2
     f1a:	3f 92       	push	r3
     f1c:	4f 92       	push	r4
     f1e:	5f 92       	push	r5
     f20:	6f 92       	push	r6
     f22:	7f 92       	push	r7
     f24:	8f 92       	push	r8
     f26:	9f 92       	push	r9
     f28:	af 92       	push	r10
     f2a:	bf 92       	push	r11
     f2c:	cf 92       	push	r12
     f2e:	df 92       	push	r13
     f30:	ef 92       	push	r14
     f32:	ff 92       	push	r15
     f34:	0f 93       	push	r16
     f36:	1f 93       	push	r17
     f38:	2f 93       	push	r18
     f3a:	3f 93       	push	r19
     f3c:	4f 93       	push	r20
     f3e:	5f 93       	push	r21
     f40:	6f 93       	push	r22
     f42:	7f 93       	push	r23
     f44:	8f 93       	push	r24
     f46:	9f 93       	push	r25
     f48:	af 93       	push	r26
     f4a:	bf 93       	push	r27
     f4c:	cf 93       	push	r28
     f4e:	df 93       	push	r29
     f50:	ef 93       	push	r30
     f52:	ff 93       	push	r31
     f54:	a0 91 15 05 	lds	r26, 0x0515
     f58:	b0 91 16 05 	lds	r27, 0x0516
     f5c:	0d b6       	in	r0, 0x3d	; 61
     f5e:	0d 92       	st	X+, r0
     f60:	0e b6       	in	r0, 0x3e	; 62
     f62:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     f64:	0e 94 3d 13 	call	0x267a	; 0x267a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     f68:	a0 91 15 05 	lds	r26, 0x0515
     f6c:	b0 91 16 05 	lds	r27, 0x0516
     f70:	cd 91       	ld	r28, X+
     f72:	cd bf       	out	0x3d, r28	; 61
     f74:	dd 91       	ld	r29, X+
     f76:	de bf       	out	0x3e, r29	; 62
     f78:	ff 91       	pop	r31
     f7a:	ef 91       	pop	r30
     f7c:	df 91       	pop	r29
     f7e:	cf 91       	pop	r28
     f80:	bf 91       	pop	r27
     f82:	af 91       	pop	r26
     f84:	9f 91       	pop	r25
     f86:	8f 91       	pop	r24
     f88:	7f 91       	pop	r23
     f8a:	6f 91       	pop	r22
     f8c:	5f 91       	pop	r21
     f8e:	4f 91       	pop	r20
     f90:	3f 91       	pop	r19
     f92:	2f 91       	pop	r18
     f94:	1f 91       	pop	r17
     f96:	0f 91       	pop	r16
     f98:	ff 90       	pop	r15
     f9a:	ef 90       	pop	r14
     f9c:	df 90       	pop	r13
     f9e:	cf 90       	pop	r12
     fa0:	bf 90       	pop	r11
     fa2:	af 90       	pop	r10
     fa4:	9f 90       	pop	r9
     fa6:	8f 90       	pop	r8
     fa8:	7f 90       	pop	r7
     faa:	6f 90       	pop	r6
     fac:	5f 90       	pop	r5
     fae:	4f 90       	pop	r4
     fb0:	3f 90       	pop	r3
     fb2:	2f 90       	pop	r2
     fb4:	1f 90       	pop	r1
     fb6:	0f 90       	pop	r0
     fb8:	0f be       	out	0x3f, r0	; 63
     fba:	0f 90       	pop	r0

	asm volatile ( "ret" );
     fbc:	08 95       	ret

00000fbe <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     fbe:	0f 92       	push	r0
     fc0:	0f b6       	in	r0, 0x3f	; 63
     fc2:	f8 94       	cli
     fc4:	0f 92       	push	r0
     fc6:	1f 92       	push	r1
     fc8:	11 24       	eor	r1, r1
     fca:	2f 92       	push	r2
     fcc:	3f 92       	push	r3
     fce:	4f 92       	push	r4
     fd0:	5f 92       	push	r5
     fd2:	6f 92       	push	r6
     fd4:	7f 92       	push	r7
     fd6:	8f 92       	push	r8
     fd8:	9f 92       	push	r9
     fda:	af 92       	push	r10
     fdc:	bf 92       	push	r11
     fde:	cf 92       	push	r12
     fe0:	df 92       	push	r13
     fe2:	ef 92       	push	r14
     fe4:	ff 92       	push	r15
     fe6:	0f 93       	push	r16
     fe8:	1f 93       	push	r17
     fea:	2f 93       	push	r18
     fec:	3f 93       	push	r19
     fee:	4f 93       	push	r20
     ff0:	5f 93       	push	r21
     ff2:	6f 93       	push	r22
     ff4:	7f 93       	push	r23
     ff6:	8f 93       	push	r24
     ff8:	9f 93       	push	r25
     ffa:	af 93       	push	r26
     ffc:	bf 93       	push	r27
     ffe:	cf 93       	push	r28
    1000:	df 93       	push	r29
    1002:	ef 93       	push	r30
    1004:	ff 93       	push	r31
    1006:	a0 91 15 05 	lds	r26, 0x0515
    100a:	b0 91 16 05 	lds	r27, 0x0516
    100e:	0d b6       	in	r0, 0x3d	; 61
    1010:	0d 92       	st	X+, r0
    1012:	0e b6       	in	r0, 0x3e	; 62
    1014:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1016:	0e 94 4f 12 	call	0x249e	; 0x249e <xTaskIncrementTick>
    101a:	88 23       	and	r24, r24
    101c:	11 f0       	breq	.+4      	; 0x1022 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    101e:	0e 94 3d 13 	call	0x267a	; 0x267a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1022:	a0 91 15 05 	lds	r26, 0x0515
    1026:	b0 91 16 05 	lds	r27, 0x0516
    102a:	cd 91       	ld	r28, X+
    102c:	cd bf       	out	0x3d, r28	; 61
    102e:	dd 91       	ld	r29, X+
    1030:	de bf       	out	0x3e, r29	; 62
    1032:	ff 91       	pop	r31
    1034:	ef 91       	pop	r30
    1036:	df 91       	pop	r29
    1038:	cf 91       	pop	r28
    103a:	bf 91       	pop	r27
    103c:	af 91       	pop	r26
    103e:	9f 91       	pop	r25
    1040:	8f 91       	pop	r24
    1042:	7f 91       	pop	r23
    1044:	6f 91       	pop	r22
    1046:	5f 91       	pop	r21
    1048:	4f 91       	pop	r20
    104a:	3f 91       	pop	r19
    104c:	2f 91       	pop	r18
    104e:	1f 91       	pop	r17
    1050:	0f 91       	pop	r16
    1052:	ff 90       	pop	r15
    1054:	ef 90       	pop	r14
    1056:	df 90       	pop	r13
    1058:	cf 90       	pop	r12
    105a:	bf 90       	pop	r11
    105c:	af 90       	pop	r10
    105e:	9f 90       	pop	r9
    1060:	8f 90       	pop	r8
    1062:	7f 90       	pop	r7
    1064:	6f 90       	pop	r6
    1066:	5f 90       	pop	r5
    1068:	4f 90       	pop	r4
    106a:	3f 90       	pop	r3
    106c:	2f 90       	pop	r2
    106e:	1f 90       	pop	r1
    1070:	0f 90       	pop	r0
    1072:	0f be       	out	0x3f, r0	; 63
    1074:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1076:	08 95       	ret

00001078 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1078:	cf 93       	push	r28
    107a:	df 93       	push	r29
    107c:	00 d0       	rcall	.+0      	; 0x107e <prvSetupTimerInterrupt+0x6>
    107e:	00 d0       	rcall	.+0      	; 0x1080 <prvSetupTimerInterrupt+0x8>
    1080:	00 d0       	rcall	.+0      	; 0x1082 <prvSetupTimerInterrupt+0xa>
    1082:	cd b7       	in	r28, 0x3d	; 61
    1084:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1086:	80 e8       	ldi	r24, 0x80	; 128
    1088:	9e e3       	ldi	r25, 0x3E	; 62
    108a:	a0 e0       	ldi	r26, 0x00	; 0
    108c:	b0 e0       	ldi	r27, 0x00	; 0
    108e:	89 83       	std	Y+1, r24	; 0x01
    1090:	9a 83       	std	Y+2, r25	; 0x02
    1092:	ab 83       	std	Y+3, r26	; 0x03
    1094:	bc 83       	std	Y+4, r27	; 0x04

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1096:	89 81       	ldd	r24, Y+1	; 0x01
    1098:	9a 81       	ldd	r25, Y+2	; 0x02
    109a:	ab 81       	ldd	r26, Y+3	; 0x03
    109c:	bc 81       	ldd	r27, Y+4	; 0x04
    109e:	68 94       	set
    10a0:	15 f8       	bld	r1, 5
    10a2:	b6 95       	lsr	r27
    10a4:	a7 95       	ror	r26
    10a6:	97 95       	ror	r25
    10a8:	87 95       	ror	r24
    10aa:	16 94       	lsr	r1
    10ac:	d1 f7       	brne	.-12     	; 0x10a2 <prvSetupTimerInterrupt+0x2a>
    10ae:	89 83       	std	Y+1, r24	; 0x01
    10b0:	9a 83       	std	Y+2, r25	; 0x02
    10b2:	ab 83       	std	Y+3, r26	; 0x03
    10b4:	bc 83       	std	Y+4, r27	; 0x04

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    10b6:	89 81       	ldd	r24, Y+1	; 0x01
    10b8:	9a 81       	ldd	r25, Y+2	; 0x02
    10ba:	ab 81       	ldd	r26, Y+3	; 0x03
    10bc:	bc 81       	ldd	r27, Y+4	; 0x04
    10be:	01 97       	sbiw	r24, 0x01	; 1
    10c0:	a1 09       	sbc	r26, r1
    10c2:	b1 09       	sbc	r27, r1
    10c4:	89 83       	std	Y+1, r24	; 0x01
    10c6:	9a 83       	std	Y+2, r25	; 0x02
    10c8:	ab 83       	std	Y+3, r26	; 0x03
    10ca:	bc 83       	std	Y+4, r27	; 0x04

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    10cc:	89 81       	ldd	r24, Y+1	; 0x01
    10ce:	8d 83       	std	Y+5, r24	; 0x05
	ulCompareMatch >>= 8;
    10d0:	89 81       	ldd	r24, Y+1	; 0x01
    10d2:	9a 81       	ldd	r25, Y+2	; 0x02
    10d4:	ab 81       	ldd	r26, Y+3	; 0x03
    10d6:	bc 81       	ldd	r27, Y+4	; 0x04
    10d8:	89 2f       	mov	r24, r25
    10da:	9a 2f       	mov	r25, r26
    10dc:	ab 2f       	mov	r26, r27
    10de:	bb 27       	eor	r27, r27
    10e0:	89 83       	std	Y+1, r24	; 0x01
    10e2:	9a 83       	std	Y+2, r25	; 0x02
    10e4:	ab 83       	std	Y+3, r26	; 0x03
    10e6:	bc 83       	std	Y+4, r27	; 0x04
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    10e8:	89 81       	ldd	r24, Y+1	; 0x01
    10ea:	8e 83       	std	Y+6, r24	; 0x06
	OCR1AH = ucHighByte;
    10ec:	89 e8       	ldi	r24, 0x89	; 137
    10ee:	90 e0       	ldi	r25, 0x00	; 0
    10f0:	2e 81       	ldd	r18, Y+6	; 0x06
    10f2:	fc 01       	movw	r30, r24
    10f4:	20 83       	st	Z, r18
	OCR1AL = ucLowByte;
    10f6:	88 e8       	ldi	r24, 0x88	; 136
    10f8:	90 e0       	ldi	r25, 0x00	; 0
    10fa:	2d 81       	ldd	r18, Y+5	; 0x05
    10fc:	fc 01       	movw	r30, r24
    10fe:	20 83       	st	Z, r18

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1100:	8b e0       	ldi	r24, 0x0B	; 11
    1102:	8d 83       	std	Y+5, r24	; 0x05
	TCCR1B = ucLowByte;
    1104:	81 e8       	ldi	r24, 0x81	; 129
    1106:	90 e0       	ldi	r25, 0x00	; 0
    1108:	2d 81       	ldd	r18, Y+5	; 0x05
    110a:	fc 01       	movw	r30, r24
    110c:	20 83       	st	Z, r18

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    110e:	8f e6       	ldi	r24, 0x6F	; 111
    1110:	90 e0       	ldi	r25, 0x00	; 0
    1112:	fc 01       	movw	r30, r24
    1114:	80 81       	ld	r24, Z
    1116:	8d 83       	std	Y+5, r24	; 0x05
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1118:	8d 81       	ldd	r24, Y+5	; 0x05
    111a:	82 60       	ori	r24, 0x02	; 2
    111c:	8d 83       	std	Y+5, r24	; 0x05
	TIMSK1 = ucLowByte;
    111e:	8f e6       	ldi	r24, 0x6F	; 111
    1120:	90 e0       	ldi	r25, 0x00	; 0
    1122:	2d 81       	ldd	r18, Y+5	; 0x05
    1124:	fc 01       	movw	r30, r24
    1126:	20 83       	st	Z, r18
	
	TCNT1 = 0;
    1128:	84 e8       	ldi	r24, 0x84	; 132
    112a:	90 e0       	ldi	r25, 0x00	; 0
    112c:	fc 01       	movw	r30, r24
    112e:	11 82       	std	Z+1, r1	; 0x01
    1130:	10 82       	st	Z, r1
}
    1132:	26 96       	adiw	r28, 0x06	; 6
    1134:	0f b6       	in	r0, 0x3f	; 63
    1136:	f8 94       	cli
    1138:	de bf       	out	0x3e, r29	; 62
    113a:	0f be       	out	0x3f, r0	; 63
    113c:	cd bf       	out	0x3d, r28	; 61
    113e:	df 91       	pop	r29
    1140:	cf 91       	pop	r28
    1142:	08 95       	ret

00001144 <__vector_12>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	ISR(TIMER1_COMPA_vect, ISR_NAKED)
	{
		vPortYieldFromTick();
    1144:	0e 94 df 07 	call	0xfbe	; 0xfbe <vPortYieldFromTick>
		asm volatile ( "reti" );
    1148:	18 95       	reti

0000114a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    114a:	cf 93       	push	r28
    114c:	df 93       	push	r29
    114e:	00 d0       	rcall	.+0      	; 0x1150 <pvPortMalloc+0x6>
    1150:	00 d0       	rcall	.+0      	; 0x1152 <pvPortMalloc+0x8>
    1152:	cd b7       	in	r28, 0x3d	; 61
    1154:	de b7       	in	r29, 0x3e	; 62
    1156:	9c 83       	std	Y+4, r25	; 0x04
    1158:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    115a:	1a 82       	std	Y+2, r1	; 0x02
    115c:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    115e:	0e 94 80 11 	call	0x2300	; 0x2300 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1162:	80 91 13 05 	lds	r24, 0x0513
    1166:	90 91 14 05 	lds	r25, 0x0514
    116a:	89 2b       	or	r24, r25
    116c:	31 f4       	brne	.+12     	; 0x117a <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    116e:	8a e2       	ldi	r24, 0x2A	; 42
    1170:	91 e0       	ldi	r25, 0x01	; 1
    1172:	90 93 14 05 	sts	0x0514, r25
    1176:	80 93 13 05 	sts	0x0513, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    117a:	20 91 11 05 	lds	r18, 0x0511
    117e:	30 91 12 05 	lds	r19, 0x0512
    1182:	8b 81       	ldd	r24, Y+3	; 0x03
    1184:	9c 81       	ldd	r25, Y+4	; 0x04
    1186:	82 0f       	add	r24, r18
    1188:	93 1f       	adc	r25, r19
    118a:	87 3e       	cpi	r24, 0xE7	; 231
    118c:	93 40       	sbci	r25, 0x03	; 3
    118e:	38 f5       	brcc	.+78     	; 0x11de <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    1190:	20 91 11 05 	lds	r18, 0x0511
    1194:	30 91 12 05 	lds	r19, 0x0512
    1198:	8b 81       	ldd	r24, Y+3	; 0x03
    119a:	9c 81       	ldd	r25, Y+4	; 0x04
    119c:	28 0f       	add	r18, r24
    119e:	39 1f       	adc	r19, r25
    11a0:	80 91 11 05 	lds	r24, 0x0511
    11a4:	90 91 12 05 	lds	r25, 0x0512
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    11a8:	82 17       	cp	r24, r18
    11aa:	93 07       	cpc	r25, r19
    11ac:	c0 f4       	brcc	.+48     	; 0x11de <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    11ae:	20 91 13 05 	lds	r18, 0x0513
    11b2:	30 91 14 05 	lds	r19, 0x0514
    11b6:	80 91 11 05 	lds	r24, 0x0511
    11ba:	90 91 12 05 	lds	r25, 0x0512
    11be:	82 0f       	add	r24, r18
    11c0:	93 1f       	adc	r25, r19
    11c2:	9a 83       	std	Y+2, r25	; 0x02
    11c4:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    11c6:	20 91 11 05 	lds	r18, 0x0511
    11ca:	30 91 12 05 	lds	r19, 0x0512
    11ce:	8b 81       	ldd	r24, Y+3	; 0x03
    11d0:	9c 81       	ldd	r25, Y+4	; 0x04
    11d2:	82 0f       	add	r24, r18
    11d4:	93 1f       	adc	r25, r19
    11d6:	90 93 12 05 	sts	0x0512, r25
    11da:	80 93 11 05 	sts	0x0511, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    11de:	0e 94 8c 11 	call	0x2318	; 0x2318 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    11e2:	89 81       	ldd	r24, Y+1	; 0x01
    11e4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    11e6:	0f 90       	pop	r0
    11e8:	0f 90       	pop	r0
    11ea:	0f 90       	pop	r0
    11ec:	0f 90       	pop	r0
    11ee:	df 91       	pop	r29
    11f0:	cf 91       	pop	r28
    11f2:	08 95       	ret

000011f4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    11f4:	cf 93       	push	r28
    11f6:	df 93       	push	r29
    11f8:	00 d0       	rcall	.+0      	; 0x11fa <vPortFree+0x6>
    11fa:	cd b7       	in	r28, 0x3d	; 61
    11fc:	de b7       	in	r29, 0x3e	; 62
    11fe:	9a 83       	std	Y+2, r25	; 0x02
    1200:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    1202:	0f 90       	pop	r0
    1204:	0f 90       	pop	r0
    1206:	df 91       	pop	r29
    1208:	cf 91       	pop	r28
    120a:	08 95       	ret

0000120c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    120c:	cf 93       	push	r28
    120e:	df 93       	push	r29
    1210:	cd b7       	in	r28, 0x3d	; 61
    1212:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1214:	10 92 12 05 	sts	0x0512, r1
    1218:	10 92 11 05 	sts	0x0511, r1
}
    121c:	df 91       	pop	r29
    121e:	cf 91       	pop	r28
    1220:	08 95       	ret

00001222 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1222:	cf 93       	push	r28
    1224:	df 93       	push	r29
    1226:	cd b7       	in	r28, 0x3d	; 61
    1228:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    122a:	80 91 11 05 	lds	r24, 0x0511
    122e:	90 91 12 05 	lds	r25, 0x0512
    1232:	27 ee       	ldi	r18, 0xE7	; 231
    1234:	33 e0       	ldi	r19, 0x03	; 3
    1236:	a9 01       	movw	r20, r18
    1238:	48 1b       	sub	r20, r24
    123a:	59 0b       	sbc	r21, r25
    123c:	ca 01       	movw	r24, r20
}
    123e:	df 91       	pop	r29
    1240:	cf 91       	pop	r28
    1242:	08 95       	ret

00001244 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1244:	cf 93       	push	r28
    1246:	df 93       	push	r29
    1248:	00 d0       	rcall	.+0      	; 0x124a <xQueueGenericReset+0x6>
    124a:	00 d0       	rcall	.+0      	; 0x124c <xQueueGenericReset+0x8>
    124c:	1f 92       	push	r1
    124e:	cd b7       	in	r28, 0x3d	; 61
    1250:	de b7       	in	r29, 0x3e	; 62
    1252:	9c 83       	std	Y+4, r25	; 0x04
    1254:	8b 83       	std	Y+3, r24	; 0x03
    1256:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1258:	8b 81       	ldd	r24, Y+3	; 0x03
    125a:	9c 81       	ldd	r25, Y+4	; 0x04
    125c:	9a 83       	std	Y+2, r25	; 0x02
    125e:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1260:	0f b6       	in	r0, 0x3f	; 63
    1262:	f8 94       	cli
    1264:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1266:	89 81       	ldd	r24, Y+1	; 0x01
    1268:	9a 81       	ldd	r25, Y+2	; 0x02
    126a:	fc 01       	movw	r30, r24
    126c:	80 81       	ld	r24, Z
    126e:	91 81       	ldd	r25, Z+1	; 0x01
    1270:	29 81       	ldd	r18, Y+1	; 0x01
    1272:	3a 81       	ldd	r19, Y+2	; 0x02
    1274:	f9 01       	movw	r30, r18
    1276:	23 8d       	ldd	r18, Z+27	; 0x1b
    1278:	42 2f       	mov	r20, r18
    127a:	50 e0       	ldi	r21, 0x00	; 0
    127c:	29 81       	ldd	r18, Y+1	; 0x01
    127e:	3a 81       	ldd	r19, Y+2	; 0x02
    1280:	f9 01       	movw	r30, r18
    1282:	24 8d       	ldd	r18, Z+28	; 0x1c
    1284:	22 2f       	mov	r18, r18
    1286:	30 e0       	ldi	r19, 0x00	; 0
    1288:	42 9f       	mul	r20, r18
    128a:	b0 01       	movw	r22, r0
    128c:	43 9f       	mul	r20, r19
    128e:	70 0d       	add	r23, r0
    1290:	52 9f       	mul	r21, r18
    1292:	70 0d       	add	r23, r0
    1294:	11 24       	eor	r1, r1
    1296:	9b 01       	movw	r18, r22
    1298:	28 0f       	add	r18, r24
    129a:	39 1f       	adc	r19, r25
    129c:	89 81       	ldd	r24, Y+1	; 0x01
    129e:	9a 81       	ldd	r25, Y+2	; 0x02
    12a0:	fc 01       	movw	r30, r24
    12a2:	33 83       	std	Z+3, r19	; 0x03
    12a4:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    12a6:	89 81       	ldd	r24, Y+1	; 0x01
    12a8:	9a 81       	ldd	r25, Y+2	; 0x02
    12aa:	fc 01       	movw	r30, r24
    12ac:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    12ae:	89 81       	ldd	r24, Y+1	; 0x01
    12b0:	9a 81       	ldd	r25, Y+2	; 0x02
    12b2:	fc 01       	movw	r30, r24
    12b4:	20 81       	ld	r18, Z
    12b6:	31 81       	ldd	r19, Z+1	; 0x01
    12b8:	89 81       	ldd	r24, Y+1	; 0x01
    12ba:	9a 81       	ldd	r25, Y+2	; 0x02
    12bc:	fc 01       	movw	r30, r24
    12be:	35 83       	std	Z+5, r19	; 0x05
    12c0:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    12c2:	89 81       	ldd	r24, Y+1	; 0x01
    12c4:	9a 81       	ldd	r25, Y+2	; 0x02
    12c6:	fc 01       	movw	r30, r24
    12c8:	80 81       	ld	r24, Z
    12ca:	91 81       	ldd	r25, Z+1	; 0x01
    12cc:	29 81       	ldd	r18, Y+1	; 0x01
    12ce:	3a 81       	ldd	r19, Y+2	; 0x02
    12d0:	f9 01       	movw	r30, r18
    12d2:	23 8d       	ldd	r18, Z+27	; 0x1b
    12d4:	22 2f       	mov	r18, r18
    12d6:	30 e0       	ldi	r19, 0x00	; 0
    12d8:	a9 01       	movw	r20, r18
    12da:	41 50       	subi	r20, 0x01	; 1
    12dc:	51 09       	sbc	r21, r1
    12de:	29 81       	ldd	r18, Y+1	; 0x01
    12e0:	3a 81       	ldd	r19, Y+2	; 0x02
    12e2:	f9 01       	movw	r30, r18
    12e4:	24 8d       	ldd	r18, Z+28	; 0x1c
    12e6:	22 2f       	mov	r18, r18
    12e8:	30 e0       	ldi	r19, 0x00	; 0
    12ea:	42 9f       	mul	r20, r18
    12ec:	b0 01       	movw	r22, r0
    12ee:	43 9f       	mul	r20, r19
    12f0:	70 0d       	add	r23, r0
    12f2:	52 9f       	mul	r21, r18
    12f4:	70 0d       	add	r23, r0
    12f6:	11 24       	eor	r1, r1
    12f8:	9b 01       	movw	r18, r22
    12fa:	28 0f       	add	r18, r24
    12fc:	39 1f       	adc	r19, r25
    12fe:	89 81       	ldd	r24, Y+1	; 0x01
    1300:	9a 81       	ldd	r25, Y+2	; 0x02
    1302:	fc 01       	movw	r30, r24
    1304:	37 83       	std	Z+7, r19	; 0x07
    1306:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1308:	89 81       	ldd	r24, Y+1	; 0x01
    130a:	9a 81       	ldd	r25, Y+2	; 0x02
    130c:	2f ef       	ldi	r18, 0xFF	; 255
    130e:	fc 01       	movw	r30, r24
    1310:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1312:	89 81       	ldd	r24, Y+1	; 0x01
    1314:	9a 81       	ldd	r25, Y+2	; 0x02
    1316:	2f ef       	ldi	r18, 0xFF	; 255
    1318:	fc 01       	movw	r30, r24
    131a:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    131c:	8d 81       	ldd	r24, Y+5	; 0x05
    131e:	88 23       	and	r24, r24
    1320:	81 f4       	brne	.+32     	; 0x1342 <xQueueGenericReset+0xfe>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1322:	89 81       	ldd	r24, Y+1	; 0x01
    1324:	9a 81       	ldd	r25, Y+2	; 0x02
    1326:	fc 01       	movw	r30, r24
    1328:	80 85       	ldd	r24, Z+8	; 0x08
    132a:	88 23       	and	r24, r24
    132c:	a1 f0       	breq	.+40     	; 0x1356 <xQueueGenericReset+0x112>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    132e:	89 81       	ldd	r24, Y+1	; 0x01
    1330:	9a 81       	ldd	r25, Y+2	; 0x02
    1332:	08 96       	adiw	r24, 0x08	; 8
    1334:	0e 94 25 14 	call	0x284a	; 0x284a <xTaskRemoveFromEventList>
    1338:	81 30       	cpi	r24, 0x01	; 1
    133a:	69 f4       	brne	.+26     	; 0x1356 <xQueueGenericReset+0x112>
				{
					queueYIELD_IF_USING_PREEMPTION();
    133c:	0e 94 86 07 	call	0xf0c	; 0xf0c <vPortYield>
    1340:	0a c0       	rjmp	.+20     	; 0x1356 <xQueueGenericReset+0x112>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1342:	89 81       	ldd	r24, Y+1	; 0x01
    1344:	9a 81       	ldd	r25, Y+2	; 0x02
    1346:	08 96       	adiw	r24, 0x08	; 8
    1348:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    134c:	89 81       	ldd	r24, Y+1	; 0x01
    134e:	9a 81       	ldd	r25, Y+2	; 0x02
    1350:	41 96       	adiw	r24, 0x11	; 17
    1352:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1356:	0f 90       	pop	r0
    1358:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    135a:	81 e0       	ldi	r24, 0x01	; 1
}
    135c:	0f 90       	pop	r0
    135e:	0f 90       	pop	r0
    1360:	0f 90       	pop	r0
    1362:	0f 90       	pop	r0
    1364:	0f 90       	pop	r0
    1366:	df 91       	pop	r29
    1368:	cf 91       	pop	r28
    136a:	08 95       	ret

0000136c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    136c:	cf 93       	push	r28
    136e:	df 93       	push	r29
    1370:	cd b7       	in	r28, 0x3d	; 61
    1372:	de b7       	in	r29, 0x3e	; 62
    1374:	29 97       	sbiw	r28, 0x09	; 9
    1376:	0f b6       	in	r0, 0x3f	; 63
    1378:	f8 94       	cli
    137a:	de bf       	out	0x3e, r29	; 62
    137c:	0f be       	out	0x3f, r0	; 63
    137e:	cd bf       	out	0x3d, r28	; 61
    1380:	8f 83       	std	Y+7, r24	; 0x07
    1382:	68 87       	std	Y+8, r22	; 0x08
    1384:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    1386:	1c 82       	std	Y+4, r1	; 0x04
    1388:	1b 82       	std	Y+3, r1	; 0x03
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
    138a:	88 85       	ldd	r24, Y+8	; 0x08
    138c:	88 23       	and	r24, r24
    138e:	19 f4       	brne	.+6      	; 0x1396 <xQueueGenericCreate+0x2a>
	{
		/* There is not going to be a queue storage area. */
		xQueueSizeInBytes = ( size_t ) 0;
    1390:	1a 82       	std	Y+2, r1	; 0x02
    1392:	19 82       	std	Y+1, r1	; 0x01
    1394:	11 c0       	rjmp	.+34     	; 0x13b8 <xQueueGenericCreate+0x4c>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1396:	8f 81       	ldd	r24, Y+7	; 0x07
    1398:	28 2f       	mov	r18, r24
    139a:	30 e0       	ldi	r19, 0x00	; 0
    139c:	88 85       	ldd	r24, Y+8	; 0x08
    139e:	88 2f       	mov	r24, r24
    13a0:	90 e0       	ldi	r25, 0x00	; 0
    13a2:	28 9f       	mul	r18, r24
    13a4:	a0 01       	movw	r20, r0
    13a6:	29 9f       	mul	r18, r25
    13a8:	50 0d       	add	r21, r0
    13aa:	38 9f       	mul	r19, r24
    13ac:	50 0d       	add	r21, r0
    13ae:	11 24       	eor	r1, r1
    13b0:	ca 01       	movw	r24, r20
    13b2:	01 96       	adiw	r24, 0x01	; 1
    13b4:	9a 83       	std	Y+2, r25	; 0x02
    13b6:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    13b8:	89 81       	ldd	r24, Y+1	; 0x01
    13ba:	9a 81       	ldd	r25, Y+2	; 0x02
    13bc:	4f 96       	adiw	r24, 0x1f	; 31
    13be:	0e 94 a5 08 	call	0x114a	; 0x114a <pvPortMalloc>
    13c2:	9e 83       	std	Y+6, r25	; 0x06
    13c4:	8d 83       	std	Y+5, r24	; 0x05

	if( pxNewQueue != NULL )
    13c6:	8d 81       	ldd	r24, Y+5	; 0x05
    13c8:	9e 81       	ldd	r25, Y+6	; 0x06
    13ca:	89 2b       	or	r24, r25
    13cc:	41 f1       	breq	.+80     	; 0x141e <xQueueGenericCreate+0xb2>
	{
		if( uxItemSize == ( UBaseType_t ) 0 )
    13ce:	88 85       	ldd	r24, Y+8	; 0x08
    13d0:	88 23       	and	r24, r24
    13d2:	41 f4       	brne	.+16     	; 0x13e4 <xQueueGenericCreate+0x78>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    13d4:	8d 81       	ldd	r24, Y+5	; 0x05
    13d6:	9e 81       	ldd	r25, Y+6	; 0x06
    13d8:	2d 81       	ldd	r18, Y+5	; 0x05
    13da:	3e 81       	ldd	r19, Y+6	; 0x06
    13dc:	fc 01       	movw	r30, r24
    13de:	31 83       	std	Z+1, r19	; 0x01
    13e0:	20 83       	st	Z, r18
    13e2:	0a c0       	rjmp	.+20     	; 0x13f8 <xQueueGenericCreate+0x8c>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
    13e4:	8d 81       	ldd	r24, Y+5	; 0x05
    13e6:	9e 81       	ldd	r25, Y+6	; 0x06
    13e8:	9c 01       	movw	r18, r24
    13ea:	21 5e       	subi	r18, 0xE1	; 225
    13ec:	3f 4f       	sbci	r19, 0xFF	; 255
    13ee:	8d 81       	ldd	r24, Y+5	; 0x05
    13f0:	9e 81       	ldd	r25, Y+6	; 0x06
    13f2:	fc 01       	movw	r30, r24
    13f4:	31 83       	std	Z+1, r19	; 0x01
    13f6:	20 83       	st	Z, r18
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
    13f8:	8d 81       	ldd	r24, Y+5	; 0x05
    13fa:	9e 81       	ldd	r25, Y+6	; 0x06
    13fc:	2f 81       	ldd	r18, Y+7	; 0x07
    13fe:	fc 01       	movw	r30, r24
    1400:	23 8f       	std	Z+27, r18	; 0x1b
		pxNewQueue->uxItemSize = uxItemSize;
    1402:	8d 81       	ldd	r24, Y+5	; 0x05
    1404:	9e 81       	ldd	r25, Y+6	; 0x06
    1406:	28 85       	ldd	r18, Y+8	; 0x08
    1408:	fc 01       	movw	r30, r24
    140a:	24 8f       	std	Z+28, r18	; 0x1c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    140c:	8d 81       	ldd	r24, Y+5	; 0x05
    140e:	9e 81       	ldd	r25, Y+6	; 0x06
    1410:	61 e0       	ldi	r22, 0x01	; 1
    1412:	0e 94 22 09 	call	0x1244	; 0x1244 <xQueueGenericReset>
			pxNewQueue->pxQueueSetContainer = NULL;
		}
		#endif /* configUSE_QUEUE_SETS */

		traceQUEUE_CREATE( pxNewQueue );
		xReturn = pxNewQueue;
    1416:	8d 81       	ldd	r24, Y+5	; 0x05
    1418:	9e 81       	ldd	r25, Y+6	; 0x06
    141a:	9c 83       	std	Y+4, r25	; 0x04
    141c:	8b 83       	std	Y+3, r24	; 0x03
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    141e:	8b 81       	ldd	r24, Y+3	; 0x03
    1420:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1422:	29 96       	adiw	r28, 0x09	; 9
    1424:	0f b6       	in	r0, 0x3f	; 63
    1426:	f8 94       	cli
    1428:	de bf       	out	0x3e, r29	; 62
    142a:	0f be       	out	0x3f, r0	; 63
    142c:	cd bf       	out	0x3d, r28	; 61
    142e:	df 91       	pop	r29
    1430:	cf 91       	pop	r28
    1432:	08 95       	ret

00001434 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1434:	cf 93       	push	r28
    1436:	df 93       	push	r29
    1438:	cd b7       	in	r28, 0x3d	; 61
    143a:	de b7       	in	r29, 0x3e	; 62
    143c:	2e 97       	sbiw	r28, 0x0e	; 14
    143e:	0f b6       	in	r0, 0x3f	; 63
    1440:	f8 94       	cli
    1442:	de bf       	out	0x3e, r29	; 62
    1444:	0f be       	out	0x3f, r0	; 63
    1446:	cd bf       	out	0x3d, r28	; 61
    1448:	99 87       	std	Y+9, r25	; 0x09
    144a:	88 87       	std	Y+8, r24	; 0x08
    144c:	7b 87       	std	Y+11, r23	; 0x0b
    144e:	6a 87       	std	Y+10, r22	; 0x0a
    1450:	5d 87       	std	Y+13, r21	; 0x0d
    1452:	4c 87       	std	Y+12, r20	; 0x0c
    1454:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1456:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1458:	88 85       	ldd	r24, Y+8	; 0x08
    145a:	99 85       	ldd	r25, Y+9	; 0x09
    145c:	9b 83       	std	Y+3, r25	; 0x03
    145e:	8a 83       	std	Y+2, r24	; 0x02
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1460:	0f b6       	in	r0, 0x3f	; 63
    1462:	f8 94       	cli
    1464:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1466:	8a 81       	ldd	r24, Y+2	; 0x02
    1468:	9b 81       	ldd	r25, Y+3	; 0x03
    146a:	fc 01       	movw	r30, r24
    146c:	22 8d       	ldd	r18, Z+26	; 0x1a
    146e:	8a 81       	ldd	r24, Y+2	; 0x02
    1470:	9b 81       	ldd	r25, Y+3	; 0x03
    1472:	fc 01       	movw	r30, r24
    1474:	83 8d       	ldd	r24, Z+27	; 0x1b
    1476:	28 17       	cp	r18, r24
    1478:	18 f0       	brcs	.+6      	; 0x1480 <xQueueGenericSend+0x4c>
    147a:	8e 85       	ldd	r24, Y+14	; 0x0e
    147c:	82 30       	cpi	r24, 0x02	; 2
    147e:	11 f5       	brne	.+68     	; 0x14c4 <xQueueGenericSend+0x90>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1480:	2a 85       	ldd	r18, Y+10	; 0x0a
    1482:	3b 85       	ldd	r19, Y+11	; 0x0b
    1484:	8a 81       	ldd	r24, Y+2	; 0x02
    1486:	9b 81       	ldd	r25, Y+3	; 0x03
    1488:	4e 85       	ldd	r20, Y+14	; 0x0e
    148a:	b9 01       	movw	r22, r18
    148c:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <prvCopyDataToQueue>
    1490:	8c 83       	std	Y+4, r24	; 0x04
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1492:	8a 81       	ldd	r24, Y+2	; 0x02
    1494:	9b 81       	ldd	r25, Y+3	; 0x03
    1496:	fc 01       	movw	r30, r24
    1498:	81 89       	ldd	r24, Z+17	; 0x11
    149a:	88 23       	and	r24, r24
    149c:	51 f0       	breq	.+20     	; 0x14b2 <xQueueGenericSend+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    149e:	8a 81       	ldd	r24, Y+2	; 0x02
    14a0:	9b 81       	ldd	r25, Y+3	; 0x03
    14a2:	41 96       	adiw	r24, 0x11	; 17
    14a4:	0e 94 25 14 	call	0x284a	; 0x284a <xTaskRemoveFromEventList>
    14a8:	81 30       	cpi	r24, 0x01	; 1
    14aa:	41 f4       	brne	.+16     	; 0x14bc <xQueueGenericSend+0x88>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    14ac:	0e 94 86 07 	call	0xf0c	; 0xf0c <vPortYield>
    14b0:	05 c0       	rjmp	.+10     	; 0x14bc <xQueueGenericSend+0x88>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    14b2:	8c 81       	ldd	r24, Y+4	; 0x04
    14b4:	88 23       	and	r24, r24
    14b6:	11 f0       	breq	.+4      	; 0x14bc <xQueueGenericSend+0x88>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    14b8:	0e 94 86 07 	call	0xf0c	; 0xf0c <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    14bc:	0f 90       	pop	r0
    14be:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    14c0:	81 e0       	ldi	r24, 0x01	; 1
    14c2:	61 c0       	rjmp	.+194    	; 0x1586 <xQueueGenericSend+0x152>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    14c4:	8c 85       	ldd	r24, Y+12	; 0x0c
    14c6:	9d 85       	ldd	r25, Y+13	; 0x0d
    14c8:	89 2b       	or	r24, r25
    14ca:	21 f4       	brne	.+8      	; 0x14d4 <xQueueGenericSend+0xa0>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    14cc:	0f 90       	pop	r0
    14ce:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    14d0:	80 e0       	ldi	r24, 0x00	; 0
    14d2:	59 c0       	rjmp	.+178    	; 0x1586 <xQueueGenericSend+0x152>
				}
				else if( xEntryTimeSet == pdFALSE )
    14d4:	89 81       	ldd	r24, Y+1	; 0x01
    14d6:	88 23       	and	r24, r24
    14d8:	31 f4       	brne	.+12     	; 0x14e6 <xQueueGenericSend+0xb2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    14da:	ce 01       	movw	r24, r28
    14dc:	05 96       	adiw	r24, 0x05	; 5
    14de:	0e 94 fd 14 	call	0x29fa	; 0x29fa <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    14e2:	81 e0       	ldi	r24, 0x01	; 1
    14e4:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    14e6:	0f 90       	pop	r0
    14e8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    14ea:	0e 94 80 11 	call	0x2300	; 0x2300 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    14ee:	0f b6       	in	r0, 0x3f	; 63
    14f0:	f8 94       	cli
    14f2:	0f 92       	push	r0
    14f4:	8a 81       	ldd	r24, Y+2	; 0x02
    14f6:	9b 81       	ldd	r25, Y+3	; 0x03
    14f8:	fc 01       	movw	r30, r24
    14fa:	85 8d       	ldd	r24, Z+29	; 0x1d
    14fc:	8f 3f       	cpi	r24, 0xFF	; 255
    14fe:	21 f4       	brne	.+8      	; 0x1508 <xQueueGenericSend+0xd4>
    1500:	8a 81       	ldd	r24, Y+2	; 0x02
    1502:	9b 81       	ldd	r25, Y+3	; 0x03
    1504:	fc 01       	movw	r30, r24
    1506:	15 8e       	std	Z+29, r1	; 0x1d
    1508:	8a 81       	ldd	r24, Y+2	; 0x02
    150a:	9b 81       	ldd	r25, Y+3	; 0x03
    150c:	fc 01       	movw	r30, r24
    150e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1510:	8f 3f       	cpi	r24, 0xFF	; 255
    1512:	21 f4       	brne	.+8      	; 0x151c <xQueueGenericSend+0xe8>
    1514:	8a 81       	ldd	r24, Y+2	; 0x02
    1516:	9b 81       	ldd	r25, Y+3	; 0x03
    1518:	fc 01       	movw	r30, r24
    151a:	16 8e       	std	Z+30, r1	; 0x1e
    151c:	0f 90       	pop	r0
    151e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1520:	9e 01       	movw	r18, r28
    1522:	24 5f       	subi	r18, 0xF4	; 244
    1524:	3f 4f       	sbci	r19, 0xFF	; 255
    1526:	ce 01       	movw	r24, r28
    1528:	05 96       	adiw	r24, 0x05	; 5
    152a:	b9 01       	movw	r22, r18
    152c:	0e 94 18 15 	call	0x2a30	; 0x2a30 <xTaskCheckForTimeOut>
    1530:	88 23       	and	r24, r24
    1532:	01 f5       	brne	.+64     	; 0x1574 <xQueueGenericSend+0x140>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1534:	8a 81       	ldd	r24, Y+2	; 0x02
    1536:	9b 81       	ldd	r25, Y+3	; 0x03
    1538:	0e 94 0a 0f 	call	0x1e14	; 0x1e14 <prvIsQueueFull>
    153c:	88 23       	and	r24, r24
    153e:	99 f0       	breq	.+38     	; 0x1566 <xQueueGenericSend+0x132>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1540:	2c 85       	ldd	r18, Y+12	; 0x0c
    1542:	3d 85       	ldd	r19, Y+13	; 0x0d
    1544:	8a 81       	ldd	r24, Y+2	; 0x02
    1546:	9b 81       	ldd	r25, Y+3	; 0x03
    1548:	08 96       	adiw	r24, 0x08	; 8
    154a:	b9 01       	movw	r22, r18
    154c:	0e 94 ac 13 	call	0x2758	; 0x2758 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1550:	8a 81       	ldd	r24, Y+2	; 0x02
    1552:	9b 81       	ldd	r25, Y+3	; 0x03
    1554:	0e 94 6f 0e 	call	0x1cde	; 0x1cde <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1558:	0e 94 8c 11 	call	0x2318	; 0x2318 <xTaskResumeAll>
    155c:	88 23       	and	r24, r24
    155e:	91 f4       	brne	.+36     	; 0x1584 <xQueueGenericSend+0x150>
				{
					portYIELD_WITHIN_API();
    1560:	0e 94 86 07 	call	0xf0c	; 0xf0c <vPortYield>
    1564:	0f c0       	rjmp	.+30     	; 0x1584 <xQueueGenericSend+0x150>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1566:	8a 81       	ldd	r24, Y+2	; 0x02
    1568:	9b 81       	ldd	r25, Y+3	; 0x03
    156a:	0e 94 6f 0e 	call	0x1cde	; 0x1cde <prvUnlockQueue>
				( void ) xTaskResumeAll();
    156e:	0e 94 8c 11 	call	0x2318	; 0x2318 <xTaskResumeAll>
    1572:	76 cf       	rjmp	.-276    	; 0x1460 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1574:	8a 81       	ldd	r24, Y+2	; 0x02
    1576:	9b 81       	ldd	r25, Y+3	; 0x03
    1578:	0e 94 6f 0e 	call	0x1cde	; 0x1cde <prvUnlockQueue>
			( void ) xTaskResumeAll();
    157c:	0e 94 8c 11 	call	0x2318	; 0x2318 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1580:	80 e0       	ldi	r24, 0x00	; 0
    1582:	01 c0       	rjmp	.+2      	; 0x1586 <xQueueGenericSend+0x152>
		}
	}
    1584:	6d cf       	rjmp	.-294    	; 0x1460 <xQueueGenericSend+0x2c>
}
    1586:	2e 96       	adiw	r28, 0x0e	; 14
    1588:	0f b6       	in	r0, 0x3f	; 63
    158a:	f8 94       	cli
    158c:	de bf       	out	0x3e, r29	; 62
    158e:	0f be       	out	0x3f, r0	; 63
    1590:	cd bf       	out	0x3d, r28	; 61
    1592:	df 91       	pop	r29
    1594:	cf 91       	pop	r28
    1596:	08 95       	ret

00001598 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1598:	cf 93       	push	r28
    159a:	df 93       	push	r29
    159c:	cd b7       	in	r28, 0x3d	; 61
    159e:	de b7       	in	r29, 0x3e	; 62
    15a0:	2b 97       	sbiw	r28, 0x0b	; 11
    15a2:	0f b6       	in	r0, 0x3f	; 63
    15a4:	f8 94       	cli
    15a6:	de bf       	out	0x3e, r29	; 62
    15a8:	0f be       	out	0x3f, r0	; 63
    15aa:	cd bf       	out	0x3d, r28	; 61
    15ac:	9e 83       	std	Y+6, r25	; 0x06
    15ae:	8d 83       	std	Y+5, r24	; 0x05
    15b0:	78 87       	std	Y+8, r23	; 0x08
    15b2:	6f 83       	std	Y+7, r22	; 0x07
    15b4:	5a 87       	std	Y+10, r21	; 0x0a
    15b6:	49 87       	std	Y+9, r20	; 0x09
    15b8:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    15ba:	8d 81       	ldd	r24, Y+5	; 0x05
    15bc:	9e 81       	ldd	r25, Y+6	; 0x06
    15be:	9b 83       	std	Y+3, r25	; 0x03
    15c0:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    15c2:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    15c4:	8a 81       	ldd	r24, Y+2	; 0x02
    15c6:	9b 81       	ldd	r25, Y+3	; 0x03
    15c8:	fc 01       	movw	r30, r24
    15ca:	22 8d       	ldd	r18, Z+26	; 0x1a
    15cc:	8a 81       	ldd	r24, Y+2	; 0x02
    15ce:	9b 81       	ldd	r25, Y+3	; 0x03
    15d0:	fc 01       	movw	r30, r24
    15d2:	83 8d       	ldd	r24, Z+27	; 0x1b
    15d4:	28 17       	cp	r18, r24
    15d6:	18 f0       	brcs	.+6      	; 0x15de <xQueueGenericSendFromISR+0x46>
    15d8:	8b 85       	ldd	r24, Y+11	; 0x0b
    15da:	82 30       	cpi	r24, 0x02	; 2
    15dc:	91 f5       	brne	.+100    	; 0x1642 <xQueueGenericSendFromISR+0xaa>
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    15de:	2f 81       	ldd	r18, Y+7	; 0x07
    15e0:	38 85       	ldd	r19, Y+8	; 0x08
    15e2:	8a 81       	ldd	r24, Y+2	; 0x02
    15e4:	9b 81       	ldd	r25, Y+3	; 0x03
    15e6:	4b 85       	ldd	r20, Y+11	; 0x0b
    15e8:	b9 01       	movw	r22, r18
    15ea:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    15ee:	8a 81       	ldd	r24, Y+2	; 0x02
    15f0:	9b 81       	ldd	r25, Y+3	; 0x03
    15f2:	fc 01       	movw	r30, r24
    15f4:	86 8d       	ldd	r24, Z+30	; 0x1e
    15f6:	8f 3f       	cpi	r24, 0xFF	; 255
    15f8:	b9 f4       	brne	.+46     	; 0x1628 <xQueueGenericSendFromISR+0x90>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    15fa:	8a 81       	ldd	r24, Y+2	; 0x02
    15fc:	9b 81       	ldd	r25, Y+3	; 0x03
    15fe:	fc 01       	movw	r30, r24
    1600:	81 89       	ldd	r24, Z+17	; 0x11
    1602:	88 23       	and	r24, r24
    1604:	d9 f0       	breq	.+54     	; 0x163c <xQueueGenericSendFromISR+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1606:	8a 81       	ldd	r24, Y+2	; 0x02
    1608:	9b 81       	ldd	r25, Y+3	; 0x03
    160a:	41 96       	adiw	r24, 0x11	; 17
    160c:	0e 94 25 14 	call	0x284a	; 0x284a <xTaskRemoveFromEventList>
    1610:	88 23       	and	r24, r24
    1612:	a1 f0       	breq	.+40     	; 0x163c <xQueueGenericSendFromISR+0xa4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1614:	89 85       	ldd	r24, Y+9	; 0x09
    1616:	9a 85       	ldd	r25, Y+10	; 0x0a
    1618:	89 2b       	or	r24, r25
    161a:	81 f0       	breq	.+32     	; 0x163c <xQueueGenericSendFromISR+0xa4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    161c:	89 85       	ldd	r24, Y+9	; 0x09
    161e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1620:	21 e0       	ldi	r18, 0x01	; 1
    1622:	fc 01       	movw	r30, r24
    1624:	20 83       	st	Z, r18
    1626:	0a c0       	rjmp	.+20     	; 0x163c <xQueueGenericSendFromISR+0xa4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1628:	8a 81       	ldd	r24, Y+2	; 0x02
    162a:	9b 81       	ldd	r25, Y+3	; 0x03
    162c:	fc 01       	movw	r30, r24
    162e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1630:	8f 5f       	subi	r24, 0xFF	; 255
    1632:	28 2f       	mov	r18, r24
    1634:	8a 81       	ldd	r24, Y+2	; 0x02
    1636:	9b 81       	ldd	r25, Y+3	; 0x03
    1638:	fc 01       	movw	r30, r24
    163a:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    163c:	81 e0       	ldi	r24, 0x01	; 1
    163e:	89 83       	std	Y+1, r24	; 0x01
    1640:	01 c0       	rjmp	.+2      	; 0x1644 <xQueueGenericSendFromISR+0xac>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1642:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1644:	89 81       	ldd	r24, Y+1	; 0x01
}
    1646:	2b 96       	adiw	r28, 0x0b	; 11
    1648:	0f b6       	in	r0, 0x3f	; 63
    164a:	f8 94       	cli
    164c:	de bf       	out	0x3e, r29	; 62
    164e:	0f be       	out	0x3f, r0	; 63
    1650:	cd bf       	out	0x3d, r28	; 61
    1652:	df 91       	pop	r29
    1654:	cf 91       	pop	r28
    1656:	08 95       	ret

00001658 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1658:	cf 93       	push	r28
    165a:	df 93       	push	r29
    165c:	cd b7       	in	r28, 0x3d	; 61
    165e:	de b7       	in	r29, 0x3e	; 62
    1660:	28 97       	sbiw	r28, 0x08	; 8
    1662:	0f b6       	in	r0, 0x3f	; 63
    1664:	f8 94       	cli
    1666:	de bf       	out	0x3e, r29	; 62
    1668:	0f be       	out	0x3f, r0	; 63
    166a:	cd bf       	out	0x3d, r28	; 61
    166c:	9e 83       	std	Y+6, r25	; 0x06
    166e:	8d 83       	std	Y+5, r24	; 0x05
    1670:	78 87       	std	Y+8, r23	; 0x08
    1672:	6f 83       	std	Y+7, r22	; 0x07
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1674:	8d 81       	ldd	r24, Y+5	; 0x05
    1676:	9e 81       	ldd	r25, Y+6	; 0x06
    1678:	9b 83       	std	Y+3, r25	; 0x03
    167a:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    167c:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    167e:	8a 81       	ldd	r24, Y+2	; 0x02
    1680:	9b 81       	ldd	r25, Y+3	; 0x03
    1682:	fc 01       	movw	r30, r24
    1684:	22 8d       	ldd	r18, Z+26	; 0x1a
    1686:	8a 81       	ldd	r24, Y+2	; 0x02
    1688:	9b 81       	ldd	r25, Y+3	; 0x03
    168a:	fc 01       	movw	r30, r24
    168c:	83 8d       	ldd	r24, Z+27	; 0x1b
    168e:	28 17       	cp	r18, r24
    1690:	a0 f5       	brcc	.+104    	; 0x16fa <xQueueGiveFromISR+0xa2>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    1692:	8a 81       	ldd	r24, Y+2	; 0x02
    1694:	9b 81       	ldd	r25, Y+3	; 0x03
    1696:	fc 01       	movw	r30, r24
    1698:	82 8d       	ldd	r24, Z+26	; 0x1a
    169a:	21 e0       	ldi	r18, 0x01	; 1
    169c:	28 0f       	add	r18, r24
    169e:	8a 81       	ldd	r24, Y+2	; 0x02
    16a0:	9b 81       	ldd	r25, Y+3	; 0x03
    16a2:	fc 01       	movw	r30, r24
    16a4:	22 8f       	std	Z+26, r18	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    16a6:	8a 81       	ldd	r24, Y+2	; 0x02
    16a8:	9b 81       	ldd	r25, Y+3	; 0x03
    16aa:	fc 01       	movw	r30, r24
    16ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    16ae:	8f 3f       	cpi	r24, 0xFF	; 255
    16b0:	b9 f4       	brne	.+46     	; 0x16e0 <xQueueGiveFromISR+0x88>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16b2:	8a 81       	ldd	r24, Y+2	; 0x02
    16b4:	9b 81       	ldd	r25, Y+3	; 0x03
    16b6:	fc 01       	movw	r30, r24
    16b8:	81 89       	ldd	r24, Z+17	; 0x11
    16ba:	88 23       	and	r24, r24
    16bc:	d9 f0       	breq	.+54     	; 0x16f4 <xQueueGiveFromISR+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    16be:	8a 81       	ldd	r24, Y+2	; 0x02
    16c0:	9b 81       	ldd	r25, Y+3	; 0x03
    16c2:	41 96       	adiw	r24, 0x11	; 17
    16c4:	0e 94 25 14 	call	0x284a	; 0x284a <xTaskRemoveFromEventList>
    16c8:	88 23       	and	r24, r24
    16ca:	a1 f0       	breq	.+40     	; 0x16f4 <xQueueGiveFromISR+0x9c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    16cc:	8f 81       	ldd	r24, Y+7	; 0x07
    16ce:	98 85       	ldd	r25, Y+8	; 0x08
    16d0:	89 2b       	or	r24, r25
    16d2:	81 f0       	breq	.+32     	; 0x16f4 <xQueueGiveFromISR+0x9c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    16d4:	8f 81       	ldd	r24, Y+7	; 0x07
    16d6:	98 85       	ldd	r25, Y+8	; 0x08
    16d8:	21 e0       	ldi	r18, 0x01	; 1
    16da:	fc 01       	movw	r30, r24
    16dc:	20 83       	st	Z, r18
    16de:	0a c0       	rjmp	.+20     	; 0x16f4 <xQueueGiveFromISR+0x9c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    16e0:	8a 81       	ldd	r24, Y+2	; 0x02
    16e2:	9b 81       	ldd	r25, Y+3	; 0x03
    16e4:	fc 01       	movw	r30, r24
    16e6:	86 8d       	ldd	r24, Z+30	; 0x1e
    16e8:	8f 5f       	subi	r24, 0xFF	; 255
    16ea:	28 2f       	mov	r18, r24
    16ec:	8a 81       	ldd	r24, Y+2	; 0x02
    16ee:	9b 81       	ldd	r25, Y+3	; 0x03
    16f0:	fc 01       	movw	r30, r24
    16f2:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    16f4:	81 e0       	ldi	r24, 0x01	; 1
    16f6:	89 83       	std	Y+1, r24	; 0x01
    16f8:	01 c0       	rjmp	.+2      	; 0x16fc <xQueueGiveFromISR+0xa4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    16fa:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    16fc:	89 81       	ldd	r24, Y+1	; 0x01
}
    16fe:	28 96       	adiw	r28, 0x08	; 8
    1700:	0f b6       	in	r0, 0x3f	; 63
    1702:	f8 94       	cli
    1704:	de bf       	out	0x3e, r29	; 62
    1706:	0f be       	out	0x3f, r0	; 63
    1708:	cd bf       	out	0x3d, r28	; 61
    170a:	df 91       	pop	r29
    170c:	cf 91       	pop	r28
    170e:	08 95       	ret

00001710 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1710:	cf 93       	push	r28
    1712:	df 93       	push	r29
    1714:	cd b7       	in	r28, 0x3d	; 61
    1716:	de b7       	in	r29, 0x3e	; 62
    1718:	2f 97       	sbiw	r28, 0x0f	; 15
    171a:	0f b6       	in	r0, 0x3f	; 63
    171c:	f8 94       	cli
    171e:	de bf       	out	0x3e, r29	; 62
    1720:	0f be       	out	0x3f, r0	; 63
    1722:	cd bf       	out	0x3d, r28	; 61
    1724:	9a 87       	std	Y+10, r25	; 0x0a
    1726:	89 87       	std	Y+9, r24	; 0x09
    1728:	7c 87       	std	Y+12, r23	; 0x0c
    172a:	6b 87       	std	Y+11, r22	; 0x0b
    172c:	5e 87       	std	Y+14, r21	; 0x0e
    172e:	4d 87       	std	Y+13, r20	; 0x0d
    1730:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    1732:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1734:	89 85       	ldd	r24, Y+9	; 0x09
    1736:	9a 85       	ldd	r25, Y+10	; 0x0a
    1738:	9b 83       	std	Y+3, r25	; 0x03
    173a:	8a 83       	std	Y+2, r24	; 0x02
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    173c:	0f b6       	in	r0, 0x3f	; 63
    173e:	f8 94       	cli
    1740:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1742:	8a 81       	ldd	r24, Y+2	; 0x02
    1744:	9b 81       	ldd	r25, Y+3	; 0x03
    1746:	fc 01       	movw	r30, r24
    1748:	82 8d       	ldd	r24, Z+26	; 0x1a
    174a:	88 23       	and	r24, r24
    174c:	09 f4       	brne	.+2      	; 0x1750 <xQueueGenericReceive+0x40>
    174e:	45 c0       	rjmp	.+138    	; 0x17da <xQueueGenericReceive+0xca>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1750:	8a 81       	ldd	r24, Y+2	; 0x02
    1752:	9b 81       	ldd	r25, Y+3	; 0x03
    1754:	fc 01       	movw	r30, r24
    1756:	86 81       	ldd	r24, Z+6	; 0x06
    1758:	97 81       	ldd	r25, Z+7	; 0x07
    175a:	9d 83       	std	Y+5, r25	; 0x05
    175c:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    175e:	2b 85       	ldd	r18, Y+11	; 0x0b
    1760:	3c 85       	ldd	r19, Y+12	; 0x0c
    1762:	8a 81       	ldd	r24, Y+2	; 0x02
    1764:	9b 81       	ldd	r25, Y+3	; 0x03
    1766:	b9 01       	movw	r22, r18
    1768:	0e 94 1f 0e 	call	0x1c3e	; 0x1c3e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    176c:	8f 85       	ldd	r24, Y+15	; 0x0f
    176e:	88 23       	and	r24, r24
    1770:	d1 f4       	brne	.+52     	; 0x17a6 <xQueueGenericReceive+0x96>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1772:	8a 81       	ldd	r24, Y+2	; 0x02
    1774:	9b 81       	ldd	r25, Y+3	; 0x03
    1776:	fc 01       	movw	r30, r24
    1778:	82 8d       	ldd	r24, Z+26	; 0x1a
    177a:	2f ef       	ldi	r18, 0xFF	; 255
    177c:	28 0f       	add	r18, r24
    177e:	8a 81       	ldd	r24, Y+2	; 0x02
    1780:	9b 81       	ldd	r25, Y+3	; 0x03
    1782:	fc 01       	movw	r30, r24
    1784:	22 8f       	std	Z+26, r18	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1786:	8a 81       	ldd	r24, Y+2	; 0x02
    1788:	9b 81       	ldd	r25, Y+3	; 0x03
    178a:	fc 01       	movw	r30, r24
    178c:	80 85       	ldd	r24, Z+8	; 0x08
    178e:	88 23       	and	r24, r24
    1790:	01 f1       	breq	.+64     	; 0x17d2 <xQueueGenericReceive+0xc2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1792:	8a 81       	ldd	r24, Y+2	; 0x02
    1794:	9b 81       	ldd	r25, Y+3	; 0x03
    1796:	08 96       	adiw	r24, 0x08	; 8
    1798:	0e 94 25 14 	call	0x284a	; 0x284a <xTaskRemoveFromEventList>
    179c:	81 30       	cpi	r24, 0x01	; 1
    179e:	c9 f4       	brne	.+50     	; 0x17d2 <xQueueGenericReceive+0xc2>
						{
							queueYIELD_IF_USING_PREEMPTION();
    17a0:	0e 94 86 07 	call	0xf0c	; 0xf0c <vPortYield>
    17a4:	16 c0       	rjmp	.+44     	; 0x17d2 <xQueueGenericReceive+0xc2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    17a6:	8a 81       	ldd	r24, Y+2	; 0x02
    17a8:	9b 81       	ldd	r25, Y+3	; 0x03
    17aa:	2c 81       	ldd	r18, Y+4	; 0x04
    17ac:	3d 81       	ldd	r19, Y+5	; 0x05
    17ae:	fc 01       	movw	r30, r24
    17b0:	37 83       	std	Z+7, r19	; 0x07
    17b2:	26 83       	std	Z+6, r18	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17b4:	8a 81       	ldd	r24, Y+2	; 0x02
    17b6:	9b 81       	ldd	r25, Y+3	; 0x03
    17b8:	fc 01       	movw	r30, r24
    17ba:	81 89       	ldd	r24, Z+17	; 0x11
    17bc:	88 23       	and	r24, r24
    17be:	49 f0       	breq	.+18     	; 0x17d2 <xQueueGenericReceive+0xc2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17c0:	8a 81       	ldd	r24, Y+2	; 0x02
    17c2:	9b 81       	ldd	r25, Y+3	; 0x03
    17c4:	41 96       	adiw	r24, 0x11	; 17
    17c6:	0e 94 25 14 	call	0x284a	; 0x284a <xTaskRemoveFromEventList>
    17ca:	88 23       	and	r24, r24
    17cc:	11 f0       	breq	.+4      	; 0x17d2 <xQueueGenericReceive+0xc2>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    17ce:	0e 94 86 07 	call	0xf0c	; 0xf0c <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    17d2:	0f 90       	pop	r0
    17d4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    17d6:	81 e0       	ldi	r24, 0x01	; 1
    17d8:	61 c0       	rjmp	.+194    	; 0x189c <xQueueGenericReceive+0x18c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    17da:	8d 85       	ldd	r24, Y+13	; 0x0d
    17dc:	9e 85       	ldd	r25, Y+14	; 0x0e
    17de:	89 2b       	or	r24, r25
    17e0:	21 f4       	brne	.+8      	; 0x17ea <xQueueGenericReceive+0xda>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    17e2:	0f 90       	pop	r0
    17e4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    17e6:	80 e0       	ldi	r24, 0x00	; 0
    17e8:	59 c0       	rjmp	.+178    	; 0x189c <xQueueGenericReceive+0x18c>
				}
				else if( xEntryTimeSet == pdFALSE )
    17ea:	89 81       	ldd	r24, Y+1	; 0x01
    17ec:	88 23       	and	r24, r24
    17ee:	31 f4       	brne	.+12     	; 0x17fc <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    17f0:	ce 01       	movw	r24, r28
    17f2:	06 96       	adiw	r24, 0x06	; 6
    17f4:	0e 94 fd 14 	call	0x29fa	; 0x29fa <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    17f8:	81 e0       	ldi	r24, 0x01	; 1
    17fa:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    17fc:	0f 90       	pop	r0
    17fe:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1800:	0e 94 80 11 	call	0x2300	; 0x2300 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1804:	0f b6       	in	r0, 0x3f	; 63
    1806:	f8 94       	cli
    1808:	0f 92       	push	r0
    180a:	8a 81       	ldd	r24, Y+2	; 0x02
    180c:	9b 81       	ldd	r25, Y+3	; 0x03
    180e:	fc 01       	movw	r30, r24
    1810:	85 8d       	ldd	r24, Z+29	; 0x1d
    1812:	8f 3f       	cpi	r24, 0xFF	; 255
    1814:	21 f4       	brne	.+8      	; 0x181e <xQueueGenericReceive+0x10e>
    1816:	8a 81       	ldd	r24, Y+2	; 0x02
    1818:	9b 81       	ldd	r25, Y+3	; 0x03
    181a:	fc 01       	movw	r30, r24
    181c:	15 8e       	std	Z+29, r1	; 0x1d
    181e:	8a 81       	ldd	r24, Y+2	; 0x02
    1820:	9b 81       	ldd	r25, Y+3	; 0x03
    1822:	fc 01       	movw	r30, r24
    1824:	86 8d       	ldd	r24, Z+30	; 0x1e
    1826:	8f 3f       	cpi	r24, 0xFF	; 255
    1828:	21 f4       	brne	.+8      	; 0x1832 <xQueueGenericReceive+0x122>
    182a:	8a 81       	ldd	r24, Y+2	; 0x02
    182c:	9b 81       	ldd	r25, Y+3	; 0x03
    182e:	fc 01       	movw	r30, r24
    1830:	16 8e       	std	Z+30, r1	; 0x1e
    1832:	0f 90       	pop	r0
    1834:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1836:	9e 01       	movw	r18, r28
    1838:	23 5f       	subi	r18, 0xF3	; 243
    183a:	3f 4f       	sbci	r19, 0xFF	; 255
    183c:	ce 01       	movw	r24, r28
    183e:	06 96       	adiw	r24, 0x06	; 6
    1840:	b9 01       	movw	r22, r18
    1842:	0e 94 18 15 	call	0x2a30	; 0x2a30 <xTaskCheckForTimeOut>
    1846:	88 23       	and	r24, r24
    1848:	01 f5       	brne	.+64     	; 0x188a <xQueueGenericReceive+0x17a>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    184a:	8a 81       	ldd	r24, Y+2	; 0x02
    184c:	9b 81       	ldd	r25, Y+3	; 0x03
    184e:	0e 94 d3 0e 	call	0x1da6	; 0x1da6 <prvIsQueueEmpty>
    1852:	88 23       	and	r24, r24
    1854:	99 f0       	breq	.+38     	; 0x187c <xQueueGenericReceive+0x16c>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1856:	2d 85       	ldd	r18, Y+13	; 0x0d
    1858:	3e 85       	ldd	r19, Y+14	; 0x0e
    185a:	8a 81       	ldd	r24, Y+2	; 0x02
    185c:	9b 81       	ldd	r25, Y+3	; 0x03
    185e:	41 96       	adiw	r24, 0x11	; 17
    1860:	b9 01       	movw	r22, r18
    1862:	0e 94 ac 13 	call	0x2758	; 0x2758 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1866:	8a 81       	ldd	r24, Y+2	; 0x02
    1868:	9b 81       	ldd	r25, Y+3	; 0x03
    186a:	0e 94 6f 0e 	call	0x1cde	; 0x1cde <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    186e:	0e 94 8c 11 	call	0x2318	; 0x2318 <xTaskResumeAll>
    1872:	88 23       	and	r24, r24
    1874:	91 f4       	brne	.+36     	; 0x189a <xQueueGenericReceive+0x18a>
				{
					portYIELD_WITHIN_API();
    1876:	0e 94 86 07 	call	0xf0c	; 0xf0c <vPortYield>
    187a:	0f c0       	rjmp	.+30     	; 0x189a <xQueueGenericReceive+0x18a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    187c:	8a 81       	ldd	r24, Y+2	; 0x02
    187e:	9b 81       	ldd	r25, Y+3	; 0x03
    1880:	0e 94 6f 0e 	call	0x1cde	; 0x1cde <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1884:	0e 94 8c 11 	call	0x2318	; 0x2318 <xTaskResumeAll>
    1888:	59 cf       	rjmp	.-334    	; 0x173c <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    188a:	8a 81       	ldd	r24, Y+2	; 0x02
    188c:	9b 81       	ldd	r25, Y+3	; 0x03
    188e:	0e 94 6f 0e 	call	0x1cde	; 0x1cde <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1892:	0e 94 8c 11 	call	0x2318	; 0x2318 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1896:	80 e0       	ldi	r24, 0x00	; 0
    1898:	01 c0       	rjmp	.+2      	; 0x189c <xQueueGenericReceive+0x18c>
		}
	}
    189a:	50 cf       	rjmp	.-352    	; 0x173c <xQueueGenericReceive+0x2c>
}
    189c:	2f 96       	adiw	r28, 0x0f	; 15
    189e:	0f b6       	in	r0, 0x3f	; 63
    18a0:	f8 94       	cli
    18a2:	de bf       	out	0x3e, r29	; 62
    18a4:	0f be       	out	0x3f, r0	; 63
    18a6:	cd bf       	out	0x3d, r28	; 61
    18a8:	df 91       	pop	r29
    18aa:	cf 91       	pop	r28
    18ac:	08 95       	ret

000018ae <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    18ae:	cf 93       	push	r28
    18b0:	df 93       	push	r29
    18b2:	cd b7       	in	r28, 0x3d	; 61
    18b4:	de b7       	in	r29, 0x3e	; 62
    18b6:	2a 97       	sbiw	r28, 0x0a	; 10
    18b8:	0f b6       	in	r0, 0x3f	; 63
    18ba:	f8 94       	cli
    18bc:	de bf       	out	0x3e, r29	; 62
    18be:	0f be       	out	0x3f, r0	; 63
    18c0:	cd bf       	out	0x3d, r28	; 61
    18c2:	9e 83       	std	Y+6, r25	; 0x06
    18c4:	8d 83       	std	Y+5, r24	; 0x05
    18c6:	78 87       	std	Y+8, r23	; 0x08
    18c8:	6f 83       	std	Y+7, r22	; 0x07
    18ca:	5a 87       	std	Y+10, r21	; 0x0a
    18cc:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    18ce:	8d 81       	ldd	r24, Y+5	; 0x05
    18d0:	9e 81       	ldd	r25, Y+6	; 0x06
    18d2:	9b 83       	std	Y+3, r25	; 0x03
    18d4:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    18d6:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    18d8:	8a 81       	ldd	r24, Y+2	; 0x02
    18da:	9b 81       	ldd	r25, Y+3	; 0x03
    18dc:	fc 01       	movw	r30, r24
    18de:	82 8d       	ldd	r24, Z+26	; 0x1a
    18e0:	88 23       	and	r24, r24
    18e2:	d9 f1       	breq	.+118    	; 0x195a <xQueueReceiveFromISR+0xac>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    18e4:	2f 81       	ldd	r18, Y+7	; 0x07
    18e6:	38 85       	ldd	r19, Y+8	; 0x08
    18e8:	8a 81       	ldd	r24, Y+2	; 0x02
    18ea:	9b 81       	ldd	r25, Y+3	; 0x03
    18ec:	b9 01       	movw	r22, r18
    18ee:	0e 94 1f 0e 	call	0x1c3e	; 0x1c3e <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    18f2:	8a 81       	ldd	r24, Y+2	; 0x02
    18f4:	9b 81       	ldd	r25, Y+3	; 0x03
    18f6:	fc 01       	movw	r30, r24
    18f8:	82 8d       	ldd	r24, Z+26	; 0x1a
    18fa:	2f ef       	ldi	r18, 0xFF	; 255
    18fc:	28 0f       	add	r18, r24
    18fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1900:	9b 81       	ldd	r25, Y+3	; 0x03
    1902:	fc 01       	movw	r30, r24
    1904:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1906:	8a 81       	ldd	r24, Y+2	; 0x02
    1908:	9b 81       	ldd	r25, Y+3	; 0x03
    190a:	fc 01       	movw	r30, r24
    190c:	85 8d       	ldd	r24, Z+29	; 0x1d
    190e:	8f 3f       	cpi	r24, 0xFF	; 255
    1910:	b9 f4       	brne	.+46     	; 0x1940 <xQueueReceiveFromISR+0x92>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1912:	8a 81       	ldd	r24, Y+2	; 0x02
    1914:	9b 81       	ldd	r25, Y+3	; 0x03
    1916:	fc 01       	movw	r30, r24
    1918:	80 85       	ldd	r24, Z+8	; 0x08
    191a:	88 23       	and	r24, r24
    191c:	d9 f0       	breq	.+54     	; 0x1954 <xQueueReceiveFromISR+0xa6>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    191e:	8a 81       	ldd	r24, Y+2	; 0x02
    1920:	9b 81       	ldd	r25, Y+3	; 0x03
    1922:	08 96       	adiw	r24, 0x08	; 8
    1924:	0e 94 25 14 	call	0x284a	; 0x284a <xTaskRemoveFromEventList>
    1928:	88 23       	and	r24, r24
    192a:	a1 f0       	breq	.+40     	; 0x1954 <xQueueReceiveFromISR+0xa6>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    192c:	89 85       	ldd	r24, Y+9	; 0x09
    192e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1930:	89 2b       	or	r24, r25
    1932:	81 f0       	breq	.+32     	; 0x1954 <xQueueReceiveFromISR+0xa6>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1934:	89 85       	ldd	r24, Y+9	; 0x09
    1936:	9a 85       	ldd	r25, Y+10	; 0x0a
    1938:	21 e0       	ldi	r18, 0x01	; 1
    193a:	fc 01       	movw	r30, r24
    193c:	20 83       	st	Z, r18
    193e:	0a c0       	rjmp	.+20     	; 0x1954 <xQueueReceiveFromISR+0xa6>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1940:	8a 81       	ldd	r24, Y+2	; 0x02
    1942:	9b 81       	ldd	r25, Y+3	; 0x03
    1944:	fc 01       	movw	r30, r24
    1946:	85 8d       	ldd	r24, Z+29	; 0x1d
    1948:	8f 5f       	subi	r24, 0xFF	; 255
    194a:	28 2f       	mov	r18, r24
    194c:	8a 81       	ldd	r24, Y+2	; 0x02
    194e:	9b 81       	ldd	r25, Y+3	; 0x03
    1950:	fc 01       	movw	r30, r24
    1952:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    1954:	81 e0       	ldi	r24, 0x01	; 1
    1956:	89 83       	std	Y+1, r24	; 0x01
    1958:	01 c0       	rjmp	.+2      	; 0x195c <xQueueReceiveFromISR+0xae>
		}
		else
		{
			xReturn = pdFAIL;
    195a:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    195c:	89 81       	ldd	r24, Y+1	; 0x01
}
    195e:	2a 96       	adiw	r28, 0x0a	; 10
    1960:	0f b6       	in	r0, 0x3f	; 63
    1962:	f8 94       	cli
    1964:	de bf       	out	0x3e, r29	; 62
    1966:	0f be       	out	0x3f, r0	; 63
    1968:	cd bf       	out	0x3d, r28	; 61
    196a:	df 91       	pop	r29
    196c:	cf 91       	pop	r28
    196e:	08 95       	ret

00001970 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1970:	cf 93       	push	r28
    1972:	df 93       	push	r29
    1974:	cd b7       	in	r28, 0x3d	; 61
    1976:	de b7       	in	r29, 0x3e	; 62
    1978:	2a 97       	sbiw	r28, 0x0a	; 10
    197a:	0f b6       	in	r0, 0x3f	; 63
    197c:	f8 94       	cli
    197e:	de bf       	out	0x3e, r29	; 62
    1980:	0f be       	out	0x3f, r0	; 63
    1982:	cd bf       	out	0x3d, r28	; 61
    1984:	98 87       	std	Y+8, r25	; 0x08
    1986:	8f 83       	std	Y+7, r24	; 0x07
    1988:	7a 87       	std	Y+10, r23	; 0x0a
    198a:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    198c:	8f 81       	ldd	r24, Y+7	; 0x07
    198e:	98 85       	ldd	r25, Y+8	; 0x08
    1990:	9b 83       	std	Y+3, r25	; 0x03
    1992:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1994:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1996:	8a 81       	ldd	r24, Y+2	; 0x02
    1998:	9b 81       	ldd	r25, Y+3	; 0x03
    199a:	fc 01       	movw	r30, r24
    199c:	82 8d       	ldd	r24, Z+26	; 0x1a
    199e:	88 23       	and	r24, r24
    19a0:	c1 f0       	breq	.+48     	; 0x19d2 <xQueuePeekFromISR+0x62>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    19a2:	8a 81       	ldd	r24, Y+2	; 0x02
    19a4:	9b 81       	ldd	r25, Y+3	; 0x03
    19a6:	fc 01       	movw	r30, r24
    19a8:	86 81       	ldd	r24, Z+6	; 0x06
    19aa:	97 81       	ldd	r25, Z+7	; 0x07
    19ac:	9e 83       	std	Y+6, r25	; 0x06
    19ae:	8d 83       	std	Y+5, r24	; 0x05
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    19b0:	29 85       	ldd	r18, Y+9	; 0x09
    19b2:	3a 85       	ldd	r19, Y+10	; 0x0a
    19b4:	8a 81       	ldd	r24, Y+2	; 0x02
    19b6:	9b 81       	ldd	r25, Y+3	; 0x03
    19b8:	b9 01       	movw	r22, r18
    19ba:	0e 94 1f 0e 	call	0x1c3e	; 0x1c3e <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    19be:	8a 81       	ldd	r24, Y+2	; 0x02
    19c0:	9b 81       	ldd	r25, Y+3	; 0x03
    19c2:	2d 81       	ldd	r18, Y+5	; 0x05
    19c4:	3e 81       	ldd	r19, Y+6	; 0x06
    19c6:	fc 01       	movw	r30, r24
    19c8:	37 83       	std	Z+7, r19	; 0x07
    19ca:	26 83       	std	Z+6, r18	; 0x06

			xReturn = pdPASS;
    19cc:	81 e0       	ldi	r24, 0x01	; 1
    19ce:	89 83       	std	Y+1, r24	; 0x01
    19d0:	01 c0       	rjmp	.+2      	; 0x19d4 <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
    19d2:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    19d4:	89 81       	ldd	r24, Y+1	; 0x01
}
    19d6:	2a 96       	adiw	r28, 0x0a	; 10
    19d8:	0f b6       	in	r0, 0x3f	; 63
    19da:	f8 94       	cli
    19dc:	de bf       	out	0x3e, r29	; 62
    19de:	0f be       	out	0x3f, r0	; 63
    19e0:	cd bf       	out	0x3d, r28	; 61
    19e2:	df 91       	pop	r29
    19e4:	cf 91       	pop	r28
    19e6:	08 95       	ret

000019e8 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    19e8:	cf 93       	push	r28
    19ea:	df 93       	push	r29
    19ec:	00 d0       	rcall	.+0      	; 0x19ee <uxQueueMessagesWaiting+0x6>
    19ee:	1f 92       	push	r1
    19f0:	cd b7       	in	r28, 0x3d	; 61
    19f2:	de b7       	in	r29, 0x3e	; 62
    19f4:	9b 83       	std	Y+3, r25	; 0x03
    19f6:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    19f8:	0f b6       	in	r0, 0x3f	; 63
    19fa:	f8 94       	cli
    19fc:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    19fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1a00:	9b 81       	ldd	r25, Y+3	; 0x03
    1a02:	fc 01       	movw	r30, r24
    1a04:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a06:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1a08:	0f 90       	pop	r0
    1a0a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1a0c:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1a0e:	0f 90       	pop	r0
    1a10:	0f 90       	pop	r0
    1a12:	0f 90       	pop	r0
    1a14:	df 91       	pop	r29
    1a16:	cf 91       	pop	r28
    1a18:	08 95       	ret

00001a1a <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1a1a:	cf 93       	push	r28
    1a1c:	df 93       	push	r29
    1a1e:	00 d0       	rcall	.+0      	; 0x1a20 <uxQueueSpacesAvailable+0x6>
    1a20:	00 d0       	rcall	.+0      	; 0x1a22 <uxQueueSpacesAvailable+0x8>
    1a22:	1f 92       	push	r1
    1a24:	cd b7       	in	r28, 0x3d	; 61
    1a26:	de b7       	in	r29, 0x3e	; 62
    1a28:	9d 83       	std	Y+5, r25	; 0x05
    1a2a:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    1a2c:	8c 81       	ldd	r24, Y+4	; 0x04
    1a2e:	9d 81       	ldd	r25, Y+5	; 0x05
    1a30:	9a 83       	std	Y+2, r25	; 0x02
    1a32:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1a34:	0f b6       	in	r0, 0x3f	; 63
    1a36:	f8 94       	cli
    1a38:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1a3a:	89 81       	ldd	r24, Y+1	; 0x01
    1a3c:	9a 81       	ldd	r25, Y+2	; 0x02
    1a3e:	fc 01       	movw	r30, r24
    1a40:	23 8d       	ldd	r18, Z+27	; 0x1b
    1a42:	89 81       	ldd	r24, Y+1	; 0x01
    1a44:	9a 81       	ldd	r25, Y+2	; 0x02
    1a46:	fc 01       	movw	r30, r24
    1a48:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a4a:	f2 2f       	mov	r31, r18
    1a4c:	f8 1b       	sub	r31, r24
    1a4e:	8f 2f       	mov	r24, r31
    1a50:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    1a52:	0f 90       	pop	r0
    1a54:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1a56:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1a58:	0f 90       	pop	r0
    1a5a:	0f 90       	pop	r0
    1a5c:	0f 90       	pop	r0
    1a5e:	0f 90       	pop	r0
    1a60:	0f 90       	pop	r0
    1a62:	df 91       	pop	r29
    1a64:	cf 91       	pop	r28
    1a66:	08 95       	ret

00001a68 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    1a68:	cf 93       	push	r28
    1a6a:	df 93       	push	r29
    1a6c:	00 d0       	rcall	.+0      	; 0x1a6e <uxQueueMessagesWaitingFromISR+0x6>
    1a6e:	1f 92       	push	r1
    1a70:	cd b7       	in	r28, 0x3d	; 61
    1a72:	de b7       	in	r29, 0x3e	; 62
    1a74:	9b 83       	std	Y+3, r25	; 0x03
    1a76:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1a78:	8a 81       	ldd	r24, Y+2	; 0x02
    1a7a:	9b 81       	ldd	r25, Y+3	; 0x03
    1a7c:	fc 01       	movw	r30, r24
    1a7e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a80:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1a82:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1a84:	0f 90       	pop	r0
    1a86:	0f 90       	pop	r0
    1a88:	0f 90       	pop	r0
    1a8a:	df 91       	pop	r29
    1a8c:	cf 91       	pop	r28
    1a8e:	08 95       	ret

00001a90 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    1a90:	cf 93       	push	r28
    1a92:	df 93       	push	r29
    1a94:	00 d0       	rcall	.+0      	; 0x1a96 <vQueueDelete+0x6>
    1a96:	00 d0       	rcall	.+0      	; 0x1a98 <vQueueDelete+0x8>
    1a98:	cd b7       	in	r28, 0x3d	; 61
    1a9a:	de b7       	in	r29, 0x3e	; 62
    1a9c:	9c 83       	std	Y+4, r25	; 0x04
    1a9e:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1aa0:	8b 81       	ldd	r24, Y+3	; 0x03
    1aa2:	9c 81       	ldd	r25, Y+4	; 0x04
    1aa4:	9a 83       	std	Y+2, r25	; 0x02
    1aa6:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue );
    1aa8:	89 81       	ldd	r24, Y+1	; 0x01
    1aaa:	9a 81       	ldd	r25, Y+2	; 0x02
    1aac:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <vPortFree>
}
    1ab0:	0f 90       	pop	r0
    1ab2:	0f 90       	pop	r0
    1ab4:	0f 90       	pop	r0
    1ab6:	0f 90       	pop	r0
    1ab8:	df 91       	pop	r29
    1aba:	cf 91       	pop	r28
    1abc:	08 95       	ret

00001abe <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1abe:	cf 93       	push	r28
    1ac0:	df 93       	push	r29
    1ac2:	00 d0       	rcall	.+0      	; 0x1ac4 <prvCopyDataToQueue+0x6>
    1ac4:	00 d0       	rcall	.+0      	; 0x1ac6 <prvCopyDataToQueue+0x8>
    1ac6:	00 d0       	rcall	.+0      	; 0x1ac8 <prvCopyDataToQueue+0xa>
    1ac8:	cd b7       	in	r28, 0x3d	; 61
    1aca:	de b7       	in	r29, 0x3e	; 62
    1acc:	9b 83       	std	Y+3, r25	; 0x03
    1ace:	8a 83       	std	Y+2, r24	; 0x02
    1ad0:	7d 83       	std	Y+5, r23	; 0x05
    1ad2:	6c 83       	std	Y+4, r22	; 0x04
    1ad4:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    1ad6:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1ad8:	8a 81       	ldd	r24, Y+2	; 0x02
    1ada:	9b 81       	ldd	r25, Y+3	; 0x03
    1adc:	fc 01       	movw	r30, r24
    1ade:	84 8d       	ldd	r24, Z+28	; 0x1c
    1ae0:	88 23       	and	r24, r24
    1ae2:	09 f4       	brne	.+2      	; 0x1ae6 <prvCopyDataToQueue+0x28>
    1ae4:	98 c0       	rjmp	.+304    	; 0x1c16 <prvCopyDataToQueue+0x158>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1ae6:	8e 81       	ldd	r24, Y+6	; 0x06
    1ae8:	88 23       	and	r24, r24
    1aea:	d9 f5       	brne	.+118    	; 0x1b62 <prvCopyDataToQueue+0xa4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    1aec:	8a 81       	ldd	r24, Y+2	; 0x02
    1aee:	9b 81       	ldd	r25, Y+3	; 0x03
    1af0:	fc 01       	movw	r30, r24
    1af2:	84 8d       	ldd	r24, Z+28	; 0x1c
    1af4:	48 2f       	mov	r20, r24
    1af6:	50 e0       	ldi	r21, 0x00	; 0
    1af8:	8a 81       	ldd	r24, Y+2	; 0x02
    1afa:	9b 81       	ldd	r25, Y+3	; 0x03
    1afc:	fc 01       	movw	r30, r24
    1afe:	84 81       	ldd	r24, Z+4	; 0x04
    1b00:	95 81       	ldd	r25, Z+5	; 0x05
    1b02:	2c 81       	ldd	r18, Y+4	; 0x04
    1b04:	3d 81       	ldd	r19, Y+5	; 0x05
    1b06:	b9 01       	movw	r22, r18
    1b08:	0e 94 81 1c 	call	0x3902	; 0x3902 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1b0c:	8a 81       	ldd	r24, Y+2	; 0x02
    1b0e:	9b 81       	ldd	r25, Y+3	; 0x03
    1b10:	fc 01       	movw	r30, r24
    1b12:	24 81       	ldd	r18, Z+4	; 0x04
    1b14:	35 81       	ldd	r19, Z+5	; 0x05
    1b16:	8a 81       	ldd	r24, Y+2	; 0x02
    1b18:	9b 81       	ldd	r25, Y+3	; 0x03
    1b1a:	fc 01       	movw	r30, r24
    1b1c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b1e:	88 2f       	mov	r24, r24
    1b20:	90 e0       	ldi	r25, 0x00	; 0
    1b22:	28 0f       	add	r18, r24
    1b24:	39 1f       	adc	r19, r25
    1b26:	8a 81       	ldd	r24, Y+2	; 0x02
    1b28:	9b 81       	ldd	r25, Y+3	; 0x03
    1b2a:	fc 01       	movw	r30, r24
    1b2c:	35 83       	std	Z+5, r19	; 0x05
    1b2e:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1b30:	8a 81       	ldd	r24, Y+2	; 0x02
    1b32:	9b 81       	ldd	r25, Y+3	; 0x03
    1b34:	fc 01       	movw	r30, r24
    1b36:	24 81       	ldd	r18, Z+4	; 0x04
    1b38:	35 81       	ldd	r19, Z+5	; 0x05
    1b3a:	8a 81       	ldd	r24, Y+2	; 0x02
    1b3c:	9b 81       	ldd	r25, Y+3	; 0x03
    1b3e:	fc 01       	movw	r30, r24
    1b40:	82 81       	ldd	r24, Z+2	; 0x02
    1b42:	93 81       	ldd	r25, Z+3	; 0x03
    1b44:	28 17       	cp	r18, r24
    1b46:	39 07       	cpc	r19, r25
    1b48:	08 f4       	brcc	.+2      	; 0x1b4c <prvCopyDataToQueue+0x8e>
    1b4a:	65 c0       	rjmp	.+202    	; 0x1c16 <prvCopyDataToQueue+0x158>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1b4c:	8a 81       	ldd	r24, Y+2	; 0x02
    1b4e:	9b 81       	ldd	r25, Y+3	; 0x03
    1b50:	fc 01       	movw	r30, r24
    1b52:	20 81       	ld	r18, Z
    1b54:	31 81       	ldd	r19, Z+1	; 0x01
    1b56:	8a 81       	ldd	r24, Y+2	; 0x02
    1b58:	9b 81       	ldd	r25, Y+3	; 0x03
    1b5a:	fc 01       	movw	r30, r24
    1b5c:	35 83       	std	Z+5, r19	; 0x05
    1b5e:	24 83       	std	Z+4, r18	; 0x04
    1b60:	5a c0       	rjmp	.+180    	; 0x1c16 <prvCopyDataToQueue+0x158>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1b62:	8a 81       	ldd	r24, Y+2	; 0x02
    1b64:	9b 81       	ldd	r25, Y+3	; 0x03
    1b66:	fc 01       	movw	r30, r24
    1b68:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b6a:	48 2f       	mov	r20, r24
    1b6c:	50 e0       	ldi	r21, 0x00	; 0
    1b6e:	8a 81       	ldd	r24, Y+2	; 0x02
    1b70:	9b 81       	ldd	r25, Y+3	; 0x03
    1b72:	fc 01       	movw	r30, r24
    1b74:	86 81       	ldd	r24, Z+6	; 0x06
    1b76:	97 81       	ldd	r25, Z+7	; 0x07
    1b78:	2c 81       	ldd	r18, Y+4	; 0x04
    1b7a:	3d 81       	ldd	r19, Y+5	; 0x05
    1b7c:	b9 01       	movw	r22, r18
    1b7e:	0e 94 81 1c 	call	0x3902	; 0x3902 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    1b82:	8a 81       	ldd	r24, Y+2	; 0x02
    1b84:	9b 81       	ldd	r25, Y+3	; 0x03
    1b86:	fc 01       	movw	r30, r24
    1b88:	26 81       	ldd	r18, Z+6	; 0x06
    1b8a:	37 81       	ldd	r19, Z+7	; 0x07
    1b8c:	8a 81       	ldd	r24, Y+2	; 0x02
    1b8e:	9b 81       	ldd	r25, Y+3	; 0x03
    1b90:	fc 01       	movw	r30, r24
    1b92:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b94:	88 2f       	mov	r24, r24
    1b96:	90 e0       	ldi	r25, 0x00	; 0
    1b98:	91 95       	neg	r25
    1b9a:	81 95       	neg	r24
    1b9c:	91 09       	sbc	r25, r1
    1b9e:	28 0f       	add	r18, r24
    1ba0:	39 1f       	adc	r19, r25
    1ba2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ba4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ba6:	fc 01       	movw	r30, r24
    1ba8:	37 83       	std	Z+7, r19	; 0x07
    1baa:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1bac:	8a 81       	ldd	r24, Y+2	; 0x02
    1bae:	9b 81       	ldd	r25, Y+3	; 0x03
    1bb0:	fc 01       	movw	r30, r24
    1bb2:	26 81       	ldd	r18, Z+6	; 0x06
    1bb4:	37 81       	ldd	r19, Z+7	; 0x07
    1bb6:	8a 81       	ldd	r24, Y+2	; 0x02
    1bb8:	9b 81       	ldd	r25, Y+3	; 0x03
    1bba:	fc 01       	movw	r30, r24
    1bbc:	80 81       	ld	r24, Z
    1bbe:	91 81       	ldd	r25, Z+1	; 0x01
    1bc0:	28 17       	cp	r18, r24
    1bc2:	39 07       	cpc	r19, r25
    1bc4:	a8 f4       	brcc	.+42     	; 0x1bf0 <prvCopyDataToQueue+0x132>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1bc6:	8a 81       	ldd	r24, Y+2	; 0x02
    1bc8:	9b 81       	ldd	r25, Y+3	; 0x03
    1bca:	fc 01       	movw	r30, r24
    1bcc:	22 81       	ldd	r18, Z+2	; 0x02
    1bce:	33 81       	ldd	r19, Z+3	; 0x03
    1bd0:	8a 81       	ldd	r24, Y+2	; 0x02
    1bd2:	9b 81       	ldd	r25, Y+3	; 0x03
    1bd4:	fc 01       	movw	r30, r24
    1bd6:	84 8d       	ldd	r24, Z+28	; 0x1c
    1bd8:	88 2f       	mov	r24, r24
    1bda:	90 e0       	ldi	r25, 0x00	; 0
    1bdc:	91 95       	neg	r25
    1bde:	81 95       	neg	r24
    1be0:	91 09       	sbc	r25, r1
    1be2:	28 0f       	add	r18, r24
    1be4:	39 1f       	adc	r19, r25
    1be6:	8a 81       	ldd	r24, Y+2	; 0x02
    1be8:	9b 81       	ldd	r25, Y+3	; 0x03
    1bea:	fc 01       	movw	r30, r24
    1bec:	37 83       	std	Z+7, r19	; 0x07
    1bee:	26 83       	std	Z+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1bf0:	8e 81       	ldd	r24, Y+6	; 0x06
    1bf2:	82 30       	cpi	r24, 0x02	; 2
    1bf4:	81 f4       	brne	.+32     	; 0x1c16 <prvCopyDataToQueue+0x158>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1bf6:	8a 81       	ldd	r24, Y+2	; 0x02
    1bf8:	9b 81       	ldd	r25, Y+3	; 0x03
    1bfa:	fc 01       	movw	r30, r24
    1bfc:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bfe:	88 23       	and	r24, r24
    1c00:	51 f0       	breq	.+20     	; 0x1c16 <prvCopyDataToQueue+0x158>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    1c02:	8a 81       	ldd	r24, Y+2	; 0x02
    1c04:	9b 81       	ldd	r25, Y+3	; 0x03
    1c06:	fc 01       	movw	r30, r24
    1c08:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c0a:	2f ef       	ldi	r18, 0xFF	; 255
    1c0c:	28 0f       	add	r18, r24
    1c0e:	8a 81       	ldd	r24, Y+2	; 0x02
    1c10:	9b 81       	ldd	r25, Y+3	; 0x03
    1c12:	fc 01       	movw	r30, r24
    1c14:	22 8f       	std	Z+26, r18	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1c16:	8a 81       	ldd	r24, Y+2	; 0x02
    1c18:	9b 81       	ldd	r25, Y+3	; 0x03
    1c1a:	fc 01       	movw	r30, r24
    1c1c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c1e:	21 e0       	ldi	r18, 0x01	; 1
    1c20:	28 0f       	add	r18, r24
    1c22:	8a 81       	ldd	r24, Y+2	; 0x02
    1c24:	9b 81       	ldd	r25, Y+3	; 0x03
    1c26:	fc 01       	movw	r30, r24
    1c28:	22 8f       	std	Z+26, r18	; 0x1a

	return xReturn;
    1c2a:	89 81       	ldd	r24, Y+1	; 0x01
}
    1c2c:	26 96       	adiw	r28, 0x06	; 6
    1c2e:	0f b6       	in	r0, 0x3f	; 63
    1c30:	f8 94       	cli
    1c32:	de bf       	out	0x3e, r29	; 62
    1c34:	0f be       	out	0x3f, r0	; 63
    1c36:	cd bf       	out	0x3d, r28	; 61
    1c38:	df 91       	pop	r29
    1c3a:	cf 91       	pop	r28
    1c3c:	08 95       	ret

00001c3e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1c3e:	cf 93       	push	r28
    1c40:	df 93       	push	r29
    1c42:	00 d0       	rcall	.+0      	; 0x1c44 <prvCopyDataFromQueue+0x6>
    1c44:	00 d0       	rcall	.+0      	; 0x1c46 <prvCopyDataFromQueue+0x8>
    1c46:	cd b7       	in	r28, 0x3d	; 61
    1c48:	de b7       	in	r29, 0x3e	; 62
    1c4a:	9a 83       	std	Y+2, r25	; 0x02
    1c4c:	89 83       	std	Y+1, r24	; 0x01
    1c4e:	7c 83       	std	Y+4, r23	; 0x04
    1c50:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1c52:	89 81       	ldd	r24, Y+1	; 0x01
    1c54:	9a 81       	ldd	r25, Y+2	; 0x02
    1c56:	fc 01       	movw	r30, r24
    1c58:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c5a:	88 23       	and	r24, r24
    1c5c:	c9 f1       	breq	.+114    	; 0x1cd0 <prvCopyDataFromQueue+0x92>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1c5e:	89 81       	ldd	r24, Y+1	; 0x01
    1c60:	9a 81       	ldd	r25, Y+2	; 0x02
    1c62:	fc 01       	movw	r30, r24
    1c64:	26 81       	ldd	r18, Z+6	; 0x06
    1c66:	37 81       	ldd	r19, Z+7	; 0x07
    1c68:	89 81       	ldd	r24, Y+1	; 0x01
    1c6a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c6c:	fc 01       	movw	r30, r24
    1c6e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c70:	88 2f       	mov	r24, r24
    1c72:	90 e0       	ldi	r25, 0x00	; 0
    1c74:	28 0f       	add	r18, r24
    1c76:	39 1f       	adc	r19, r25
    1c78:	89 81       	ldd	r24, Y+1	; 0x01
    1c7a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c7c:	fc 01       	movw	r30, r24
    1c7e:	37 83       	std	Z+7, r19	; 0x07
    1c80:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1c82:	89 81       	ldd	r24, Y+1	; 0x01
    1c84:	9a 81       	ldd	r25, Y+2	; 0x02
    1c86:	fc 01       	movw	r30, r24
    1c88:	26 81       	ldd	r18, Z+6	; 0x06
    1c8a:	37 81       	ldd	r19, Z+7	; 0x07
    1c8c:	89 81       	ldd	r24, Y+1	; 0x01
    1c8e:	9a 81       	ldd	r25, Y+2	; 0x02
    1c90:	fc 01       	movw	r30, r24
    1c92:	82 81       	ldd	r24, Z+2	; 0x02
    1c94:	93 81       	ldd	r25, Z+3	; 0x03
    1c96:	28 17       	cp	r18, r24
    1c98:	39 07       	cpc	r19, r25
    1c9a:	50 f0       	brcs	.+20     	; 0x1cb0 <prvCopyDataFromQueue+0x72>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1c9c:	89 81       	ldd	r24, Y+1	; 0x01
    1c9e:	9a 81       	ldd	r25, Y+2	; 0x02
    1ca0:	fc 01       	movw	r30, r24
    1ca2:	20 81       	ld	r18, Z
    1ca4:	31 81       	ldd	r19, Z+1	; 0x01
    1ca6:	89 81       	ldd	r24, Y+1	; 0x01
    1ca8:	9a 81       	ldd	r25, Y+2	; 0x02
    1caa:	fc 01       	movw	r30, r24
    1cac:	37 83       	std	Z+7, r19	; 0x07
    1cae:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1cb0:	89 81       	ldd	r24, Y+1	; 0x01
    1cb2:	9a 81       	ldd	r25, Y+2	; 0x02
    1cb4:	fc 01       	movw	r30, r24
    1cb6:	84 8d       	ldd	r24, Z+28	; 0x1c
    1cb8:	48 2f       	mov	r20, r24
    1cba:	50 e0       	ldi	r21, 0x00	; 0
    1cbc:	89 81       	ldd	r24, Y+1	; 0x01
    1cbe:	9a 81       	ldd	r25, Y+2	; 0x02
    1cc0:	fc 01       	movw	r30, r24
    1cc2:	26 81       	ldd	r18, Z+6	; 0x06
    1cc4:	37 81       	ldd	r19, Z+7	; 0x07
    1cc6:	8b 81       	ldd	r24, Y+3	; 0x03
    1cc8:	9c 81       	ldd	r25, Y+4	; 0x04
    1cca:	b9 01       	movw	r22, r18
    1ccc:	0e 94 81 1c 	call	0x3902	; 0x3902 <memcpy>
	}
}
    1cd0:	0f 90       	pop	r0
    1cd2:	0f 90       	pop	r0
    1cd4:	0f 90       	pop	r0
    1cd6:	0f 90       	pop	r0
    1cd8:	df 91       	pop	r29
    1cda:	cf 91       	pop	r28
    1cdc:	08 95       	ret

00001cde <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1cde:	cf 93       	push	r28
    1ce0:	df 93       	push	r29
    1ce2:	00 d0       	rcall	.+0      	; 0x1ce4 <prvUnlockQueue+0x6>
    1ce4:	cd b7       	in	r28, 0x3d	; 61
    1ce6:	de b7       	in	r29, 0x3e	; 62
    1ce8:	9a 83       	std	Y+2, r25	; 0x02
    1cea:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1cec:	0f b6       	in	r0, 0x3f	; 63
    1cee:	f8 94       	cli
    1cf0:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1cf2:	1b c0       	rjmp	.+54     	; 0x1d2a <prvUnlockQueue+0x4c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1cf4:	89 81       	ldd	r24, Y+1	; 0x01
    1cf6:	9a 81       	ldd	r25, Y+2	; 0x02
    1cf8:	fc 01       	movw	r30, r24
    1cfa:	81 89       	ldd	r24, Z+17	; 0x11
    1cfc:	88 23       	and	r24, r24
    1cfe:	51 f0       	breq	.+20     	; 0x1d14 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1d00:	89 81       	ldd	r24, Y+1	; 0x01
    1d02:	9a 81       	ldd	r25, Y+2	; 0x02
    1d04:	41 96       	adiw	r24, 0x11	; 17
    1d06:	0e 94 25 14 	call	0x284a	; 0x284a <xTaskRemoveFromEventList>
    1d0a:	88 23       	and	r24, r24
    1d0c:	21 f0       	breq	.+8      	; 0x1d16 <prvUnlockQueue+0x38>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    1d0e:	0e 94 80 15 	call	0x2b00	; 0x2b00 <vTaskMissedYield>
    1d12:	01 c0       	rjmp	.+2      	; 0x1d16 <prvUnlockQueue+0x38>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
    1d14:	10 c0       	rjmp	.+32     	; 0x1d36 <prvUnlockQueue+0x58>
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    1d16:	89 81       	ldd	r24, Y+1	; 0x01
    1d18:	9a 81       	ldd	r25, Y+2	; 0x02
    1d1a:	fc 01       	movw	r30, r24
    1d1c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d1e:	81 50       	subi	r24, 0x01	; 1
    1d20:	28 2f       	mov	r18, r24
    1d22:	89 81       	ldd	r24, Y+1	; 0x01
    1d24:	9a 81       	ldd	r25, Y+2	; 0x02
    1d26:	fc 01       	movw	r30, r24
    1d28:	26 8f       	std	Z+30, r18	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1d2a:	89 81       	ldd	r24, Y+1	; 0x01
    1d2c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d2e:	fc 01       	movw	r30, r24
    1d30:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d32:	18 16       	cp	r1, r24
    1d34:	fc f2       	brlt	.-66     	; 0x1cf4 <prvUnlockQueue+0x16>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1d36:	89 81       	ldd	r24, Y+1	; 0x01
    1d38:	9a 81       	ldd	r25, Y+2	; 0x02
    1d3a:	2f ef       	ldi	r18, 0xFF	; 255
    1d3c:	fc 01       	movw	r30, r24
    1d3e:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    1d40:	0f 90       	pop	r0
    1d42:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1d44:	0f b6       	in	r0, 0x3f	; 63
    1d46:	f8 94       	cli
    1d48:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1d4a:	1b c0       	rjmp	.+54     	; 0x1d82 <prvUnlockQueue+0xa4>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d4c:	89 81       	ldd	r24, Y+1	; 0x01
    1d4e:	9a 81       	ldd	r25, Y+2	; 0x02
    1d50:	fc 01       	movw	r30, r24
    1d52:	80 85       	ldd	r24, Z+8	; 0x08
    1d54:	88 23       	and	r24, r24
    1d56:	a1 f0       	breq	.+40     	; 0x1d80 <prvUnlockQueue+0xa2>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d58:	89 81       	ldd	r24, Y+1	; 0x01
    1d5a:	9a 81       	ldd	r25, Y+2	; 0x02
    1d5c:	08 96       	adiw	r24, 0x08	; 8
    1d5e:	0e 94 25 14 	call	0x284a	; 0x284a <xTaskRemoveFromEventList>
    1d62:	88 23       	and	r24, r24
    1d64:	11 f0       	breq	.+4      	; 0x1d6a <prvUnlockQueue+0x8c>
				{
					vTaskMissedYield();
    1d66:	0e 94 80 15 	call	0x2b00	; 0x2b00 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    1d6a:	89 81       	ldd	r24, Y+1	; 0x01
    1d6c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d6e:	fc 01       	movw	r30, r24
    1d70:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d72:	81 50       	subi	r24, 0x01	; 1
    1d74:	28 2f       	mov	r18, r24
    1d76:	89 81       	ldd	r24, Y+1	; 0x01
    1d78:	9a 81       	ldd	r25, Y+2	; 0x02
    1d7a:	fc 01       	movw	r30, r24
    1d7c:	25 8f       	std	Z+29, r18	; 0x1d
    1d7e:	01 c0       	rjmp	.+2      	; 0x1d82 <prvUnlockQueue+0xa4>
			}
			else
			{
				break;
    1d80:	06 c0       	rjmp	.+12     	; 0x1d8e <prvUnlockQueue+0xb0>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1d82:	89 81       	ldd	r24, Y+1	; 0x01
    1d84:	9a 81       	ldd	r25, Y+2	; 0x02
    1d86:	fc 01       	movw	r30, r24
    1d88:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d8a:	18 16       	cp	r1, r24
    1d8c:	fc f2       	brlt	.-66     	; 0x1d4c <prvUnlockQueue+0x6e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1d8e:	89 81       	ldd	r24, Y+1	; 0x01
    1d90:	9a 81       	ldd	r25, Y+2	; 0x02
    1d92:	2f ef       	ldi	r18, 0xFF	; 255
    1d94:	fc 01       	movw	r30, r24
    1d96:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    1d98:	0f 90       	pop	r0
    1d9a:	0f be       	out	0x3f, r0	; 63
}
    1d9c:	0f 90       	pop	r0
    1d9e:	0f 90       	pop	r0
    1da0:	df 91       	pop	r29
    1da2:	cf 91       	pop	r28
    1da4:	08 95       	ret

00001da6 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    1da6:	cf 93       	push	r28
    1da8:	df 93       	push	r29
    1daa:	00 d0       	rcall	.+0      	; 0x1dac <prvIsQueueEmpty+0x6>
    1dac:	1f 92       	push	r1
    1dae:	cd b7       	in	r28, 0x3d	; 61
    1db0:	de b7       	in	r29, 0x3e	; 62
    1db2:	9b 83       	std	Y+3, r25	; 0x03
    1db4:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1db6:	0f b6       	in	r0, 0x3f	; 63
    1db8:	f8 94       	cli
    1dba:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1dbc:	8a 81       	ldd	r24, Y+2	; 0x02
    1dbe:	9b 81       	ldd	r25, Y+3	; 0x03
    1dc0:	fc 01       	movw	r30, r24
    1dc2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1dc4:	88 23       	and	r24, r24
    1dc6:	19 f4       	brne	.+6      	; 0x1dce <prvIsQueueEmpty+0x28>
		{
			xReturn = pdTRUE;
    1dc8:	81 e0       	ldi	r24, 0x01	; 1
    1dca:	89 83       	std	Y+1, r24	; 0x01
    1dcc:	01 c0       	rjmp	.+2      	; 0x1dd0 <prvIsQueueEmpty+0x2a>
		}
		else
		{
			xReturn = pdFALSE;
    1dce:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1dd0:	0f 90       	pop	r0
    1dd2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1dd4:	89 81       	ldd	r24, Y+1	; 0x01
}
    1dd6:	0f 90       	pop	r0
    1dd8:	0f 90       	pop	r0
    1dda:	0f 90       	pop	r0
    1ddc:	df 91       	pop	r29
    1dde:	cf 91       	pop	r28
    1de0:	08 95       	ret

00001de2 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    1de2:	cf 93       	push	r28
    1de4:	df 93       	push	r29
    1de6:	00 d0       	rcall	.+0      	; 0x1de8 <xQueueIsQueueEmptyFromISR+0x6>
    1de8:	1f 92       	push	r1
    1dea:	cd b7       	in	r28, 0x3d	; 61
    1dec:	de b7       	in	r29, 0x3e	; 62
    1dee:	9b 83       	std	Y+3, r25	; 0x03
    1df0:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1df2:	8a 81       	ldd	r24, Y+2	; 0x02
    1df4:	9b 81       	ldd	r25, Y+3	; 0x03
    1df6:	fc 01       	movw	r30, r24
    1df8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1dfa:	88 23       	and	r24, r24
    1dfc:	19 f4       	brne	.+6      	; 0x1e04 <xQueueIsQueueEmptyFromISR+0x22>
	{
		xReturn = pdTRUE;
    1dfe:	81 e0       	ldi	r24, 0x01	; 1
    1e00:	89 83       	std	Y+1, r24	; 0x01
    1e02:	01 c0       	rjmp	.+2      	; 0x1e06 <xQueueIsQueueEmptyFromISR+0x24>
	}
	else
	{
		xReturn = pdFALSE;
    1e04:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    1e06:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1e08:	0f 90       	pop	r0
    1e0a:	0f 90       	pop	r0
    1e0c:	0f 90       	pop	r0
    1e0e:	df 91       	pop	r29
    1e10:	cf 91       	pop	r28
    1e12:	08 95       	ret

00001e14 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    1e14:	cf 93       	push	r28
    1e16:	df 93       	push	r29
    1e18:	00 d0       	rcall	.+0      	; 0x1e1a <prvIsQueueFull+0x6>
    1e1a:	1f 92       	push	r1
    1e1c:	cd b7       	in	r28, 0x3d	; 61
    1e1e:	de b7       	in	r29, 0x3e	; 62
    1e20:	9b 83       	std	Y+3, r25	; 0x03
    1e22:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1e24:	0f b6       	in	r0, 0x3f	; 63
    1e26:	f8 94       	cli
    1e28:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1e2a:	8a 81       	ldd	r24, Y+2	; 0x02
    1e2c:	9b 81       	ldd	r25, Y+3	; 0x03
    1e2e:	fc 01       	movw	r30, r24
    1e30:	22 8d       	ldd	r18, Z+26	; 0x1a
    1e32:	8a 81       	ldd	r24, Y+2	; 0x02
    1e34:	9b 81       	ldd	r25, Y+3	; 0x03
    1e36:	fc 01       	movw	r30, r24
    1e38:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e3a:	28 17       	cp	r18, r24
    1e3c:	19 f4       	brne	.+6      	; 0x1e44 <prvIsQueueFull+0x30>
		{
			xReturn = pdTRUE;
    1e3e:	81 e0       	ldi	r24, 0x01	; 1
    1e40:	89 83       	std	Y+1, r24	; 0x01
    1e42:	01 c0       	rjmp	.+2      	; 0x1e46 <prvIsQueueFull+0x32>
		}
		else
		{
			xReturn = pdFALSE;
    1e44:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1e46:	0f 90       	pop	r0
    1e48:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1e4a:	89 81       	ldd	r24, Y+1	; 0x01
}
    1e4c:	0f 90       	pop	r0
    1e4e:	0f 90       	pop	r0
    1e50:	0f 90       	pop	r0
    1e52:	df 91       	pop	r29
    1e54:	cf 91       	pop	r28
    1e56:	08 95       	ret

00001e58 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1e58:	cf 93       	push	r28
    1e5a:	df 93       	push	r29
    1e5c:	00 d0       	rcall	.+0      	; 0x1e5e <xQueueIsQueueFullFromISR+0x6>
    1e5e:	1f 92       	push	r1
    1e60:	cd b7       	in	r28, 0x3d	; 61
    1e62:	de b7       	in	r29, 0x3e	; 62
    1e64:	9b 83       	std	Y+3, r25	; 0x03
    1e66:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    1e68:	8a 81       	ldd	r24, Y+2	; 0x02
    1e6a:	9b 81       	ldd	r25, Y+3	; 0x03
    1e6c:	fc 01       	movw	r30, r24
    1e6e:	22 8d       	ldd	r18, Z+26	; 0x1a
    1e70:	8a 81       	ldd	r24, Y+2	; 0x02
    1e72:	9b 81       	ldd	r25, Y+3	; 0x03
    1e74:	fc 01       	movw	r30, r24
    1e76:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e78:	28 17       	cp	r18, r24
    1e7a:	19 f4       	brne	.+6      	; 0x1e82 <xQueueIsQueueFullFromISR+0x2a>
	{
		xReturn = pdTRUE;
    1e7c:	81 e0       	ldi	r24, 0x01	; 1
    1e7e:	89 83       	std	Y+1, r24	; 0x01
    1e80:	01 c0       	rjmp	.+2      	; 0x1e84 <xQueueIsQueueFullFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    1e82:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    1e84:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1e86:	0f 90       	pop	r0
    1e88:	0f 90       	pop	r0
    1e8a:	0f 90       	pop	r0
    1e8c:	df 91       	pop	r29
    1e8e:	cf 91       	pop	r28
    1e90:	08 95       	ret

00001e92 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    1e92:	af 92       	push	r10
    1e94:	bf 92       	push	r11
    1e96:	cf 92       	push	r12
    1e98:	df 92       	push	r13
    1e9a:	ef 92       	push	r14
    1e9c:	ff 92       	push	r15
    1e9e:	0f 93       	push	r16
    1ea0:	1f 93       	push	r17
    1ea2:	cf 93       	push	r28
    1ea4:	df 93       	push	r29
    1ea6:	cd b7       	in	r28, 0x3d	; 61
    1ea8:	de b7       	in	r29, 0x3e	; 62
    1eaa:	64 97       	sbiw	r28, 0x14	; 20
    1eac:	0f b6       	in	r0, 0x3f	; 63
    1eae:	f8 94       	cli
    1eb0:	de bf       	out	0x3e, r29	; 62
    1eb2:	0f be       	out	0x3f, r0	; 63
    1eb4:	cd bf       	out	0x3d, r28	; 61
    1eb6:	9f 83       	std	Y+7, r25	; 0x07
    1eb8:	8e 83       	std	Y+6, r24	; 0x06
    1eba:	79 87       	std	Y+9, r23	; 0x09
    1ebc:	68 87       	std	Y+8, r22	; 0x08
    1ebe:	5b 87       	std	Y+11, r21	; 0x0b
    1ec0:	4a 87       	std	Y+10, r20	; 0x0a
    1ec2:	3d 87       	std	Y+13, r19	; 0x0d
    1ec4:	2c 87       	std	Y+12, r18	; 0x0c
    1ec6:	0e 87       	std	Y+14, r16	; 0x0e
    1ec8:	f8 8a       	std	Y+16, r15	; 0x10
    1eca:	ef 86       	std	Y+15, r14	; 0x0f
    1ecc:	da 8a       	std	Y+18, r13	; 0x12
    1ece:	c9 8a       	std	Y+17, r12	; 0x11
    1ed0:	bc 8a       	std	Y+20, r11	; 0x14
    1ed2:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    1ed4:	29 89       	ldd	r18, Y+17	; 0x11
    1ed6:	3a 89       	ldd	r19, Y+18	; 0x12
    1ed8:	8a 85       	ldd	r24, Y+10	; 0x0a
    1eda:	9b 85       	ldd	r25, Y+11	; 0x0b
    1edc:	b9 01       	movw	r22, r18
    1ede:	0e 94 e5 16 	call	0x2dca	; 0x2dca <prvAllocateTCBAndStack>
    1ee2:	9b 83       	std	Y+3, r25	; 0x03
    1ee4:	8a 83       	std	Y+2, r24	; 0x02

	if( pxNewTCB != NULL )
    1ee6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ee8:	9b 81       	ldd	r25, Y+3	; 0x03
    1eea:	89 2b       	or	r24, r25
    1eec:	09 f4       	brne	.+2      	; 0x1ef0 <xTaskGenericCreate+0x5e>
    1eee:	91 c0       	rjmp	.+290    	; 0x2012 <xTaskGenericCreate+0x180>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    1ef0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ef2:	9b 81       	ldd	r25, Y+3	; 0x03
    1ef4:	fc 01       	movw	r30, r24
    1ef6:	27 89       	ldd	r18, Z+23	; 0x17
    1ef8:	30 8d       	ldd	r19, Z+24	; 0x18
    1efa:	8a 85       	ldd	r24, Y+10	; 0x0a
    1efc:	9b 85       	ldd	r25, Y+11	; 0x0b
    1efe:	01 97       	sbiw	r24, 0x01	; 1
    1f00:	82 0f       	add	r24, r18
    1f02:	93 1f       	adc	r25, r19
    1f04:	9d 83       	std	Y+5, r25	; 0x05
    1f06:	8c 83       	std	Y+4, r24	; 0x04
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    1f08:	4a 85       	ldd	r20, Y+10	; 0x0a
    1f0a:	5b 85       	ldd	r21, Y+11	; 0x0b
    1f0c:	2b 89       	ldd	r18, Y+19	; 0x13
    1f0e:	3c 89       	ldd	r19, Y+20	; 0x14
    1f10:	68 85       	ldd	r22, Y+8	; 0x08
    1f12:	79 85       	ldd	r23, Y+9	; 0x09
    1f14:	8a 81       	ldd	r24, Y+2	; 0x02
    1f16:	9b 81       	ldd	r25, Y+3	; 0x03
    1f18:	8a 01       	movw	r16, r20
    1f1a:	4e 85       	ldd	r20, Y+14	; 0x0e
    1f1c:	0e 94 9a 15 	call	0x2b34	; 0x2b34 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1f20:	4c 85       	ldd	r20, Y+12	; 0x0c
    1f22:	5d 85       	ldd	r21, Y+13	; 0x0d
    1f24:	2e 81       	ldd	r18, Y+6	; 0x06
    1f26:	3f 81       	ldd	r19, Y+7	; 0x07
    1f28:	8c 81       	ldd	r24, Y+4	; 0x04
    1f2a:	9d 81       	ldd	r25, Y+5	; 0x05
    1f2c:	b9 01       	movw	r22, r18
    1f2e:	0e 94 a1 05 	call	0xb42	; 0xb42 <pxPortInitialiseStack>
    1f32:	9c 01       	movw	r18, r24
    1f34:	8a 81       	ldd	r24, Y+2	; 0x02
    1f36:	9b 81       	ldd	r25, Y+3	; 0x03
    1f38:	fc 01       	movw	r30, r24
    1f3a:	31 83       	std	Z+1, r19	; 0x01
    1f3c:	20 83       	st	Z, r18
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    1f3e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f40:	98 89       	ldd	r25, Y+16	; 0x10
    1f42:	89 2b       	or	r24, r25
    1f44:	39 f0       	breq	.+14     	; 0x1f54 <xTaskGenericCreate+0xc2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1f46:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f48:	98 89       	ldd	r25, Y+16	; 0x10
    1f4a:	2a 81       	ldd	r18, Y+2	; 0x02
    1f4c:	3b 81       	ldd	r19, Y+3	; 0x03
    1f4e:	fc 01       	movw	r30, r24
    1f50:	31 83       	std	Z+1, r19	; 0x01
    1f52:	20 83       	st	Z, r18
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    1f54:	0f b6       	in	r0, 0x3f	; 63
    1f56:	f8 94       	cli
    1f58:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1f5a:	80 91 64 05 	lds	r24, 0x0564
    1f5e:	8f 5f       	subi	r24, 0xFF	; 255
    1f60:	80 93 64 05 	sts	0x0564, r24
			if( pxCurrentTCB == NULL )
    1f64:	80 91 15 05 	lds	r24, 0x0515
    1f68:	90 91 16 05 	lds	r25, 0x0516
    1f6c:	89 2b       	or	r24, r25
    1f6e:	69 f4       	brne	.+26     	; 0x1f8a <xTaskGenericCreate+0xf8>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1f70:	8a 81       	ldd	r24, Y+2	; 0x02
    1f72:	9b 81       	ldd	r25, Y+3	; 0x03
    1f74:	90 93 16 05 	sts	0x0516, r25
    1f78:	80 93 15 05 	sts	0x0515, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1f7c:	80 91 64 05 	lds	r24, 0x0564
    1f80:	81 30       	cpi	r24, 0x01	; 1
    1f82:	b1 f4       	brne	.+44     	; 0x1fb0 <xTaskGenericCreate+0x11e>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    1f84:	0e 94 1e 16 	call	0x2c3c	; 0x2c3c <prvInitialiseTaskLists>
    1f88:	13 c0       	rjmp	.+38     	; 0x1fb0 <xTaskGenericCreate+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1f8a:	80 91 68 05 	lds	r24, 0x0568
    1f8e:	88 23       	and	r24, r24
    1f90:	79 f4       	brne	.+30     	; 0x1fb0 <xTaskGenericCreate+0x11e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1f92:	80 91 15 05 	lds	r24, 0x0515
    1f96:	90 91 16 05 	lds	r25, 0x0516
    1f9a:	fc 01       	movw	r30, r24
    1f9c:	96 89       	ldd	r25, Z+22	; 0x16
    1f9e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1fa0:	89 17       	cp	r24, r25
    1fa2:	30 f0       	brcs	.+12     	; 0x1fb0 <xTaskGenericCreate+0x11e>
					{
						pxCurrentTCB = pxNewTCB;
    1fa4:	8a 81       	ldd	r24, Y+2	; 0x02
    1fa6:	9b 81       	ldd	r25, Y+3	; 0x03
    1fa8:	90 93 16 05 	sts	0x0516, r25
    1fac:	80 93 15 05 	sts	0x0515, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    1fb0:	80 91 6c 05 	lds	r24, 0x056C
    1fb4:	8f 5f       	subi	r24, 0xFF	; 255
    1fb6:	80 93 6c 05 	sts	0x056C, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    1fba:	8a 81       	ldd	r24, Y+2	; 0x02
    1fbc:	9b 81       	ldd	r25, Y+3	; 0x03
    1fbe:	fc 01       	movw	r30, r24
    1fc0:	96 89       	ldd	r25, Z+22	; 0x16
    1fc2:	80 91 67 05 	lds	r24, 0x0567
    1fc6:	89 17       	cp	r24, r25
    1fc8:	30 f4       	brcc	.+12     	; 0x1fd6 <xTaskGenericCreate+0x144>
    1fca:	8a 81       	ldd	r24, Y+2	; 0x02
    1fcc:	9b 81       	ldd	r25, Y+3	; 0x03
    1fce:	fc 01       	movw	r30, r24
    1fd0:	86 89       	ldd	r24, Z+22	; 0x16
    1fd2:	80 93 67 05 	sts	0x0567, r24
    1fd6:	8a 81       	ldd	r24, Y+2	; 0x02
    1fd8:	9b 81       	ldd	r25, Y+3	; 0x03
    1fda:	ac 01       	movw	r20, r24
    1fdc:	4e 5f       	subi	r20, 0xFE	; 254
    1fde:	5f 4f       	sbci	r21, 0xFF	; 255
    1fe0:	8a 81       	ldd	r24, Y+2	; 0x02
    1fe2:	9b 81       	ldd	r25, Y+3	; 0x03
    1fe4:	fc 01       	movw	r30, r24
    1fe6:	86 89       	ldd	r24, Z+22	; 0x16
    1fe8:	28 2f       	mov	r18, r24
    1fea:	30 e0       	ldi	r19, 0x00	; 0
    1fec:	c9 01       	movw	r24, r18
    1fee:	88 0f       	add	r24, r24
    1ff0:	99 1f       	adc	r25, r25
    1ff2:	88 0f       	add	r24, r24
    1ff4:	99 1f       	adc	r25, r25
    1ff6:	88 0f       	add	r24, r24
    1ff8:	99 1f       	adc	r25, r25
    1ffa:	82 0f       	add	r24, r18
    1ffc:	93 1f       	adc	r25, r19
    1ffe:	89 5e       	subi	r24, 0xE9	; 233
    2000:	9a 4f       	sbci	r25, 0xFA	; 250
    2002:	ba 01       	movw	r22, r20
    2004:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsertEnd>

			xReturn = pdPASS;
    2008:	81 e0       	ldi	r24, 0x01	; 1
    200a:	89 83       	std	Y+1, r24	; 0x01
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    200c:	0f 90       	pop	r0
    200e:	0f be       	out	0x3f, r0	; 63
    2010:	02 c0       	rjmp	.+4      	; 0x2016 <xTaskGenericCreate+0x184>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2012:	8f ef       	ldi	r24, 0xFF	; 255
    2014:	89 83       	std	Y+1, r24	; 0x01
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    2016:	89 81       	ldd	r24, Y+1	; 0x01
    2018:	81 30       	cpi	r24, 0x01	; 1
    201a:	79 f4       	brne	.+30     	; 0x203a <xTaskGenericCreate+0x1a8>
	{
		if( xSchedulerRunning != pdFALSE )
    201c:	80 91 68 05 	lds	r24, 0x0568
    2020:	88 23       	and	r24, r24
    2022:	59 f0       	breq	.+22     	; 0x203a <xTaskGenericCreate+0x1a8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2024:	80 91 15 05 	lds	r24, 0x0515
    2028:	90 91 16 05 	lds	r25, 0x0516
    202c:	fc 01       	movw	r30, r24
    202e:	96 89       	ldd	r25, Z+22	; 0x16
    2030:	8e 85       	ldd	r24, Y+14	; 0x0e
    2032:	98 17       	cp	r25, r24
    2034:	10 f4       	brcc	.+4      	; 0x203a <xTaskGenericCreate+0x1a8>
			{
				taskYIELD_IF_USING_PREEMPTION();
    2036:	0e 94 86 07 	call	0xf0c	; 0xf0c <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    203a:	89 81       	ldd	r24, Y+1	; 0x01
}
    203c:	64 96       	adiw	r28, 0x14	; 20
    203e:	0f b6       	in	r0, 0x3f	; 63
    2040:	f8 94       	cli
    2042:	de bf       	out	0x3e, r29	; 62
    2044:	0f be       	out	0x3f, r0	; 63
    2046:	cd bf       	out	0x3d, r28	; 61
    2048:	df 91       	pop	r29
    204a:	cf 91       	pop	r28
    204c:	1f 91       	pop	r17
    204e:	0f 91       	pop	r16
    2050:	ff 90       	pop	r15
    2052:	ef 90       	pop	r14
    2054:	df 90       	pop	r13
    2056:	cf 90       	pop	r12
    2058:	bf 90       	pop	r11
    205a:	af 90       	pop	r10
    205c:	08 95       	ret

0000205e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    205e:	cf 93       	push	r28
    2060:	df 93       	push	r29
    2062:	00 d0       	rcall	.+0      	; 0x2064 <vTaskDelete+0x6>
    2064:	00 d0       	rcall	.+0      	; 0x2066 <vTaskDelete+0x8>
    2066:	cd b7       	in	r28, 0x3d	; 61
    2068:	de b7       	in	r29, 0x3e	; 62
    206a:	9c 83       	std	Y+4, r25	; 0x04
    206c:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    206e:	0f b6       	in	r0, 0x3f	; 63
    2070:	f8 94       	cli
    2072:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    2074:	8b 81       	ldd	r24, Y+3	; 0x03
    2076:	9c 81       	ldd	r25, Y+4	; 0x04
    2078:	89 2b       	or	r24, r25
    207a:	29 f4       	brne	.+10     	; 0x2086 <vTaskDelete+0x28>
    207c:	80 91 15 05 	lds	r24, 0x0515
    2080:	90 91 16 05 	lds	r25, 0x0516
    2084:	02 c0       	rjmp	.+4      	; 0x208a <vTaskDelete+0x2c>
    2086:	8b 81       	ldd	r24, Y+3	; 0x03
    2088:	9c 81       	ldd	r25, Y+4	; 0x04
    208a:	9a 83       	std	Y+2, r25	; 0x02
    208c:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    208e:	89 81       	ldd	r24, Y+1	; 0x01
    2090:	9a 81       	ldd	r25, Y+2	; 0x02
    2092:	02 96       	adiw	r24, 0x02	; 2
    2094:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2098:	89 81       	ldd	r24, Y+1	; 0x01
    209a:	9a 81       	ldd	r25, Y+2	; 0x02
    209c:	fc 01       	movw	r30, r24
    209e:	84 89       	ldd	r24, Z+20	; 0x14
    20a0:	95 89       	ldd	r25, Z+21	; 0x15
    20a2:	89 2b       	or	r24, r25
    20a4:	29 f0       	breq	.+10     	; 0x20b0 <vTaskDelete+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    20a6:	89 81       	ldd	r24, Y+1	; 0x01
    20a8:	9a 81       	ldd	r25, Y+2	; 0x02
    20aa:	0c 96       	adiw	r24, 0x0c	; 12
    20ac:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    20b0:	89 81       	ldd	r24, Y+1	; 0x01
    20b2:	9a 81       	ldd	r25, Y+2	; 0x02
    20b4:	02 96       	adiw	r24, 0x02	; 2
    20b6:	bc 01       	movw	r22, r24
    20b8:	8a e5       	ldi	r24, 0x5A	; 90
    20ba:	95 e0       	ldi	r25, 0x05	; 5
    20bc:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    20c0:	80 91 63 05 	lds	r24, 0x0563
    20c4:	8f 5f       	subi	r24, 0xFF	; 255
    20c6:	80 93 63 05 	sts	0x0563, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    20ca:	80 91 6c 05 	lds	r24, 0x056C
    20ce:	8f 5f       	subi	r24, 0xFF	; 255
    20d0:	80 93 6c 05 	sts	0x056C, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    20d4:	0f 90       	pop	r0
    20d6:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    20d8:	80 91 68 05 	lds	r24, 0x0568
    20dc:	88 23       	and	r24, r24
    20de:	99 f0       	breq	.+38     	; 0x2106 <vTaskDelete+0xa8>
		{
			if( pxTCB == pxCurrentTCB )
    20e0:	80 91 15 05 	lds	r24, 0x0515
    20e4:	90 91 16 05 	lds	r25, 0x0516
    20e8:	29 81       	ldd	r18, Y+1	; 0x01
    20ea:	3a 81       	ldd	r19, Y+2	; 0x02
    20ec:	28 17       	cp	r18, r24
    20ee:	39 07       	cpc	r19, r25
    20f0:	19 f4       	brne	.+6      	; 0x20f8 <vTaskDelete+0x9a>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    20f2:	0e 94 86 07 	call	0xf0c	; 0xf0c <vPortYield>
    20f6:	07 c0       	rjmp	.+14     	; 0x2106 <vTaskDelete+0xa8>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    20f8:	0f b6       	in	r0, 0x3f	; 63
    20fa:	f8 94       	cli
    20fc:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    20fe:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    2102:	0f 90       	pop	r0
    2104:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    2106:	0f 90       	pop	r0
    2108:	0f 90       	pop	r0
    210a:	0f 90       	pop	r0
    210c:	0f 90       	pop	r0
    210e:	df 91       	pop	r29
    2110:	cf 91       	pop	r28
    2112:	08 95       	ret

00002114 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    2114:	cf 93       	push	r28
    2116:	df 93       	push	r29
    2118:	cd b7       	in	r28, 0x3d	; 61
    211a:	de b7       	in	r29, 0x3e	; 62
    211c:	2a 97       	sbiw	r28, 0x0a	; 10
    211e:	0f b6       	in	r0, 0x3f	; 63
    2120:	f8 94       	cli
    2122:	de bf       	out	0x3e, r29	; 62
    2124:	0f be       	out	0x3f, r0	; 63
    2126:	cd bf       	out	0x3d, r28	; 61
    2128:	98 87       	std	Y+8, r25	; 0x08
    212a:	8f 83       	std	Y+7, r24	; 0x07
    212c:	7a 87       	std	Y+10, r23	; 0x0a
    212e:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    2130:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    2132:	0e 94 80 11 	call	0x2300	; 0x2300 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2136:	80 91 65 05 	lds	r24, 0x0565
    213a:	90 91 66 05 	lds	r25, 0x0566
    213e:	9b 83       	std	Y+3, r25	; 0x03
    2140:	8a 83       	std	Y+2, r24	; 0x02

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2142:	8f 81       	ldd	r24, Y+7	; 0x07
    2144:	98 85       	ldd	r25, Y+8	; 0x08
    2146:	fc 01       	movw	r30, r24
    2148:	20 81       	ld	r18, Z
    214a:	31 81       	ldd	r19, Z+1	; 0x01
    214c:	89 85       	ldd	r24, Y+9	; 0x09
    214e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2150:	82 0f       	add	r24, r18
    2152:	93 1f       	adc	r25, r19
    2154:	9d 83       	std	Y+5, r25	; 0x05
    2156:	8c 83       	std	Y+4, r24	; 0x04

			if( xConstTickCount < *pxPreviousWakeTime )
    2158:	8f 81       	ldd	r24, Y+7	; 0x07
    215a:	98 85       	ldd	r25, Y+8	; 0x08
    215c:	fc 01       	movw	r30, r24
    215e:	20 81       	ld	r18, Z
    2160:	31 81       	ldd	r19, Z+1	; 0x01
    2162:	8a 81       	ldd	r24, Y+2	; 0x02
    2164:	9b 81       	ldd	r25, Y+3	; 0x03
    2166:	82 17       	cp	r24, r18
    2168:	93 07       	cpc	r25, r19
    216a:	a0 f4       	brcc	.+40     	; 0x2194 <vTaskDelayUntil+0x80>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    216c:	8f 81       	ldd	r24, Y+7	; 0x07
    216e:	98 85       	ldd	r25, Y+8	; 0x08
    2170:	fc 01       	movw	r30, r24
    2172:	20 81       	ld	r18, Z
    2174:	31 81       	ldd	r19, Z+1	; 0x01
    2176:	8c 81       	ldd	r24, Y+4	; 0x04
    2178:	9d 81       	ldd	r25, Y+5	; 0x05
    217a:	82 17       	cp	r24, r18
    217c:	93 07       	cpc	r25, r19
    217e:	e8 f4       	brcc	.+58     	; 0x21ba <vTaskDelayUntil+0xa6>
    2180:	2c 81       	ldd	r18, Y+4	; 0x04
    2182:	3d 81       	ldd	r19, Y+5	; 0x05
    2184:	8a 81       	ldd	r24, Y+2	; 0x02
    2186:	9b 81       	ldd	r25, Y+3	; 0x03
    2188:	82 17       	cp	r24, r18
    218a:	93 07       	cpc	r25, r19
    218c:	b0 f4       	brcc	.+44     	; 0x21ba <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    218e:	81 e0       	ldi	r24, 0x01	; 1
    2190:	89 83       	std	Y+1, r24	; 0x01
    2192:	13 c0       	rjmp	.+38     	; 0x21ba <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    2194:	8f 81       	ldd	r24, Y+7	; 0x07
    2196:	98 85       	ldd	r25, Y+8	; 0x08
    2198:	fc 01       	movw	r30, r24
    219a:	20 81       	ld	r18, Z
    219c:	31 81       	ldd	r19, Z+1	; 0x01
    219e:	8c 81       	ldd	r24, Y+4	; 0x04
    21a0:	9d 81       	ldd	r25, Y+5	; 0x05
    21a2:	82 17       	cp	r24, r18
    21a4:	93 07       	cpc	r25, r19
    21a6:	38 f0       	brcs	.+14     	; 0x21b6 <vTaskDelayUntil+0xa2>
    21a8:	2c 81       	ldd	r18, Y+4	; 0x04
    21aa:	3d 81       	ldd	r19, Y+5	; 0x05
    21ac:	8a 81       	ldd	r24, Y+2	; 0x02
    21ae:	9b 81       	ldd	r25, Y+3	; 0x03
    21b0:	82 17       	cp	r24, r18
    21b2:	93 07       	cpc	r25, r19
    21b4:	10 f4       	brcc	.+4      	; 0x21ba <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    21b6:	81 e0       	ldi	r24, 0x01	; 1
    21b8:	89 83       	std	Y+1, r24	; 0x01
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    21ba:	8f 81       	ldd	r24, Y+7	; 0x07
    21bc:	98 85       	ldd	r25, Y+8	; 0x08
    21be:	2c 81       	ldd	r18, Y+4	; 0x04
    21c0:	3d 81       	ldd	r19, Y+5	; 0x05
    21c2:	fc 01       	movw	r30, r24
    21c4:	31 83       	std	Z+1, r19	; 0x01
    21c6:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
    21c8:	89 81       	ldd	r24, Y+1	; 0x01
    21ca:	88 23       	and	r24, r24
    21cc:	59 f0       	breq	.+22     	; 0x21e4 <vTaskDelayUntil+0xd0>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    21ce:	80 91 15 05 	lds	r24, 0x0515
    21d2:	90 91 16 05 	lds	r25, 0x0516
    21d6:	02 96       	adiw	r24, 0x02	; 2
    21d8:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    21dc:	8c 81       	ldd	r24, Y+4	; 0x04
    21de:	9d 81       	ldd	r25, Y+5	; 0x05
    21e0:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    21e4:	0e 94 8c 11 	call	0x2318	; 0x2318 <xTaskResumeAll>
    21e8:	8e 83       	std	Y+6, r24	; 0x06

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    21ea:	8e 81       	ldd	r24, Y+6	; 0x06
    21ec:	88 23       	and	r24, r24
    21ee:	11 f4       	brne	.+4      	; 0x21f4 <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
    21f0:	0e 94 86 07 	call	0xf0c	; 0xf0c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    21f4:	2a 96       	adiw	r28, 0x0a	; 10
    21f6:	0f b6       	in	r0, 0x3f	; 63
    21f8:	f8 94       	cli
    21fa:	de bf       	out	0x3e, r29	; 62
    21fc:	0f be       	out	0x3f, r0	; 63
    21fe:	cd bf       	out	0x3d, r28	; 61
    2200:	df 91       	pop	r29
    2202:	cf 91       	pop	r28
    2204:	08 95       	ret

00002206 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2206:	cf 93       	push	r28
    2208:	df 93       	push	r29
    220a:	00 d0       	rcall	.+0      	; 0x220c <vTaskDelay+0x6>
    220c:	00 d0       	rcall	.+0      	; 0x220e <vTaskDelay+0x8>
    220e:	1f 92       	push	r1
    2210:	cd b7       	in	r28, 0x3d	; 61
    2212:	de b7       	in	r29, 0x3e	; 62
    2214:	9d 83       	std	Y+5, r25	; 0x05
    2216:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    2218:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    221a:	8c 81       	ldd	r24, Y+4	; 0x04
    221c:	9d 81       	ldd	r25, Y+5	; 0x05
    221e:	89 2b       	or	r24, r25
    2220:	d1 f0       	breq	.+52     	; 0x2256 <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2222:	0e 94 80 11 	call	0x2300	; 0x2300 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2226:	20 91 65 05 	lds	r18, 0x0565
    222a:	30 91 66 05 	lds	r19, 0x0566
    222e:	8c 81       	ldd	r24, Y+4	; 0x04
    2230:	9d 81       	ldd	r25, Y+5	; 0x05
    2232:	82 0f       	add	r24, r18
    2234:	93 1f       	adc	r25, r19
    2236:	9b 83       	std	Y+3, r25	; 0x03
    2238:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    223a:	80 91 15 05 	lds	r24, 0x0515
    223e:	90 91 16 05 	lds	r25, 0x0516
    2242:	02 96       	adiw	r24, 0x02	; 2
    2244:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2248:	8a 81       	ldd	r24, Y+2	; 0x02
    224a:	9b 81       	ldd	r25, Y+3	; 0x03
    224c:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2250:	0e 94 8c 11 	call	0x2318	; 0x2318 <xTaskResumeAll>
    2254:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2256:	89 81       	ldd	r24, Y+1	; 0x01
    2258:	88 23       	and	r24, r24
    225a:	11 f4       	brne	.+4      	; 0x2260 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    225c:	0e 94 86 07 	call	0xf0c	; 0xf0c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2260:	0f 90       	pop	r0
    2262:	0f 90       	pop	r0
    2264:	0f 90       	pop	r0
    2266:	0f 90       	pop	r0
    2268:	0f 90       	pop	r0
    226a:	df 91       	pop	r29
    226c:	cf 91       	pop	r28
    226e:	08 95       	ret

00002270 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    2270:	af 92       	push	r10
    2272:	bf 92       	push	r11
    2274:	cf 92       	push	r12
    2276:	df 92       	push	r13
    2278:	ef 92       	push	r14
    227a:	ff 92       	push	r15
    227c:	0f 93       	push	r16
    227e:	cf 93       	push	r28
    2280:	df 93       	push	r29
    2282:	1f 92       	push	r1
    2284:	cd b7       	in	r28, 0x3d	; 61
    2286:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    2288:	a1 2c       	mov	r10, r1
    228a:	b1 2c       	mov	r11, r1
    228c:	c1 2c       	mov	r12, r1
    228e:	d1 2c       	mov	r13, r1
    2290:	e1 2c       	mov	r14, r1
    2292:	f1 2c       	mov	r15, r1
    2294:	00 e0       	ldi	r16, 0x00	; 0
    2296:	20 e0       	ldi	r18, 0x00	; 0
    2298:	30 e0       	ldi	r19, 0x00	; 0
    229a:	44 e6       	ldi	r20, 0x64	; 100
    229c:	50 e0       	ldi	r21, 0x00	; 0
    229e:	68 e1       	ldi	r22, 0x18	; 24
    22a0:	71 e0       	ldi	r23, 0x01	; 1
    22a2:	8a e8       	ldi	r24, 0x8A	; 138
    22a4:	95 e1       	ldi	r25, 0x15	; 21
    22a6:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <xTaskGenericCreate>
    22aa:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    22ac:	89 81       	ldd	r24, Y+1	; 0x01
    22ae:	81 30       	cpi	r24, 0x01	; 1
    22b0:	81 f4       	brne	.+32     	; 0x22d2 <vTaskStartScheduler+0x62>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    22b2:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    22b4:	8f ef       	ldi	r24, 0xFF	; 255
    22b6:	9f ef       	ldi	r25, 0xFF	; 255
    22b8:	90 93 6e 05 	sts	0x056E, r25
    22bc:	80 93 6d 05 	sts	0x056D, r24
		xSchedulerRunning = pdTRUE;
    22c0:	81 e0       	ldi	r24, 0x01	; 1
    22c2:	80 93 68 05 	sts	0x0568, r24
		xTickCount = ( TickType_t ) 0U;
    22c6:	10 92 66 05 	sts	0x0566, r1
    22ca:	10 92 65 05 	sts	0x0565, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    22ce:	0e 94 4a 07 	call	0xe94	; 0xe94 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    22d2:	0f 90       	pop	r0
    22d4:	df 91       	pop	r29
    22d6:	cf 91       	pop	r28
    22d8:	0f 91       	pop	r16
    22da:	ff 90       	pop	r15
    22dc:	ef 90       	pop	r14
    22de:	df 90       	pop	r13
    22e0:	cf 90       	pop	r12
    22e2:	bf 90       	pop	r11
    22e4:	af 90       	pop	r10
    22e6:	08 95       	ret

000022e8 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    22e8:	cf 93       	push	r28
    22ea:	df 93       	push	r29
    22ec:	cd b7       	in	r28, 0x3d	; 61
    22ee:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    22f0:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    22f2:	10 92 68 05 	sts	0x0568, r1
	vPortEndScheduler();
    22f6:	0e 94 7f 07 	call	0xefe	; 0xefe <vPortEndScheduler>
}
    22fa:	df 91       	pop	r29
    22fc:	cf 91       	pop	r28
    22fe:	08 95       	ret

00002300 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2300:	cf 93       	push	r28
    2302:	df 93       	push	r29
    2304:	cd b7       	in	r28, 0x3d	; 61
    2306:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    2308:	80 91 6f 05 	lds	r24, 0x056F
    230c:	8f 5f       	subi	r24, 0xFF	; 255
    230e:	80 93 6f 05 	sts	0x056F, r24
}
    2312:	df 91       	pop	r29
    2314:	cf 91       	pop	r28
    2316:	08 95       	ret

00002318 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    2318:	cf 93       	push	r28
    231a:	df 93       	push	r29
    231c:	00 d0       	rcall	.+0      	; 0x231e <xTaskResumeAll+0x6>
    231e:	1f 92       	push	r1
    2320:	cd b7       	in	r28, 0x3d	; 61
    2322:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    2324:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2326:	0f b6       	in	r0, 0x3f	; 63
    2328:	f8 94       	cli
    232a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    232c:	80 91 6f 05 	lds	r24, 0x056F
    2330:	81 50       	subi	r24, 0x01	; 1
    2332:	80 93 6f 05 	sts	0x056F, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2336:	80 91 6f 05 	lds	r24, 0x056F
    233a:	88 23       	and	r24, r24
    233c:	09 f0       	breq	.+2      	; 0x2340 <xTaskResumeAll+0x28>
    233e:	71 c0       	rjmp	.+226    	; 0x2422 <xTaskResumeAll+0x10a>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    2340:	80 91 64 05 	lds	r24, 0x0564
    2344:	88 23       	and	r24, r24
    2346:	09 f4       	brne	.+2      	; 0x234a <xTaskResumeAll+0x32>
    2348:	6c c0       	rjmp	.+216    	; 0x2422 <xTaskResumeAll+0x10a>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    234a:	49 c0       	rjmp	.+146    	; 0x23de <xTaskResumeAll+0xc6>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    234c:	80 91 56 05 	lds	r24, 0x0556
    2350:	90 91 57 05 	lds	r25, 0x0557
    2354:	fc 01       	movw	r30, r24
    2356:	86 81       	ldd	r24, Z+6	; 0x06
    2358:	97 81       	ldd	r25, Z+7	; 0x07
    235a:	9b 83       	std	Y+3, r25	; 0x03
    235c:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    235e:	8a 81       	ldd	r24, Y+2	; 0x02
    2360:	9b 81       	ldd	r25, Y+3	; 0x03
    2362:	0c 96       	adiw	r24, 0x0c	; 12
    2364:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    2368:	8a 81       	ldd	r24, Y+2	; 0x02
    236a:	9b 81       	ldd	r25, Y+3	; 0x03
    236c:	02 96       	adiw	r24, 0x02	; 2
    236e:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2372:	8a 81       	ldd	r24, Y+2	; 0x02
    2374:	9b 81       	ldd	r25, Y+3	; 0x03
    2376:	fc 01       	movw	r30, r24
    2378:	96 89       	ldd	r25, Z+22	; 0x16
    237a:	80 91 67 05 	lds	r24, 0x0567
    237e:	89 17       	cp	r24, r25
    2380:	30 f4       	brcc	.+12     	; 0x238e <xTaskResumeAll+0x76>
    2382:	8a 81       	ldd	r24, Y+2	; 0x02
    2384:	9b 81       	ldd	r25, Y+3	; 0x03
    2386:	fc 01       	movw	r30, r24
    2388:	86 89       	ldd	r24, Z+22	; 0x16
    238a:	80 93 67 05 	sts	0x0567, r24
    238e:	8a 81       	ldd	r24, Y+2	; 0x02
    2390:	9b 81       	ldd	r25, Y+3	; 0x03
    2392:	ac 01       	movw	r20, r24
    2394:	4e 5f       	subi	r20, 0xFE	; 254
    2396:	5f 4f       	sbci	r21, 0xFF	; 255
    2398:	8a 81       	ldd	r24, Y+2	; 0x02
    239a:	9b 81       	ldd	r25, Y+3	; 0x03
    239c:	fc 01       	movw	r30, r24
    239e:	86 89       	ldd	r24, Z+22	; 0x16
    23a0:	28 2f       	mov	r18, r24
    23a2:	30 e0       	ldi	r19, 0x00	; 0
    23a4:	c9 01       	movw	r24, r18
    23a6:	88 0f       	add	r24, r24
    23a8:	99 1f       	adc	r25, r25
    23aa:	88 0f       	add	r24, r24
    23ac:	99 1f       	adc	r25, r25
    23ae:	88 0f       	add	r24, r24
    23b0:	99 1f       	adc	r25, r25
    23b2:	82 0f       	add	r24, r18
    23b4:	93 1f       	adc	r25, r19
    23b6:	89 5e       	subi	r24, 0xE9	; 233
    23b8:	9a 4f       	sbci	r25, 0xFA	; 250
    23ba:	ba 01       	movw	r22, r20
    23bc:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    23c0:	8a 81       	ldd	r24, Y+2	; 0x02
    23c2:	9b 81       	ldd	r25, Y+3	; 0x03
    23c4:	fc 01       	movw	r30, r24
    23c6:	26 89       	ldd	r18, Z+22	; 0x16
    23c8:	80 91 15 05 	lds	r24, 0x0515
    23cc:	90 91 16 05 	lds	r25, 0x0516
    23d0:	fc 01       	movw	r30, r24
    23d2:	86 89       	ldd	r24, Z+22	; 0x16
    23d4:	28 17       	cp	r18, r24
    23d6:	18 f0       	brcs	.+6      	; 0x23de <xTaskResumeAll+0xc6>
					{
						xYieldPending = pdTRUE;
    23d8:	81 e0       	ldi	r24, 0x01	; 1
    23da:	80 93 6a 05 	sts	0x056A, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    23de:	80 91 51 05 	lds	r24, 0x0551
    23e2:	88 23       	and	r24, r24
    23e4:	09 f0       	breq	.+2      	; 0x23e8 <xTaskResumeAll+0xd0>
    23e6:	b2 cf       	rjmp	.-156    	; 0x234c <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    23e8:	80 91 69 05 	lds	r24, 0x0569
    23ec:	88 23       	and	r24, r24
    23ee:	89 f0       	breq	.+34     	; 0x2412 <xTaskResumeAll+0xfa>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    23f0:	0c c0       	rjmp	.+24     	; 0x240a <xTaskResumeAll+0xf2>
					{
						if( xTaskIncrementTick() != pdFALSE )
    23f2:	0e 94 4f 12 	call	0x249e	; 0x249e <xTaskIncrementTick>
    23f6:	88 23       	and	r24, r24
    23f8:	19 f0       	breq	.+6      	; 0x2400 <xTaskResumeAll+0xe8>
						{
							xYieldPending = pdTRUE;
    23fa:	81 e0       	ldi	r24, 0x01	; 1
    23fc:	80 93 6a 05 	sts	0x056A, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    2400:	80 91 69 05 	lds	r24, 0x0569
    2404:	81 50       	subi	r24, 0x01	; 1
    2406:	80 93 69 05 	sts	0x0569, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    240a:	80 91 69 05 	lds	r24, 0x0569
    240e:	88 23       	and	r24, r24
    2410:	81 f7       	brne	.-32     	; 0x23f2 <xTaskResumeAll+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    2412:	80 91 6a 05 	lds	r24, 0x056A
    2416:	81 30       	cpi	r24, 0x01	; 1
    2418:	21 f4       	brne	.+8      	; 0x2422 <xTaskResumeAll+0x10a>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    241a:	81 e0       	ldi	r24, 0x01	; 1
    241c:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    241e:	0e 94 86 07 	call	0xf0c	; 0xf0c <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2422:	0f 90       	pop	r0
    2424:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2426:	89 81       	ldd	r24, Y+1	; 0x01
}
    2428:	0f 90       	pop	r0
    242a:	0f 90       	pop	r0
    242c:	0f 90       	pop	r0
    242e:	df 91       	pop	r29
    2430:	cf 91       	pop	r28
    2432:	08 95       	ret

00002434 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    2434:	cf 93       	push	r28
    2436:	df 93       	push	r29
    2438:	00 d0       	rcall	.+0      	; 0x243a <xTaskGetTickCount+0x6>
    243a:	cd b7       	in	r28, 0x3d	; 61
    243c:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    243e:	0f b6       	in	r0, 0x3f	; 63
    2440:	f8 94       	cli
    2442:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2444:	80 91 65 05 	lds	r24, 0x0565
    2448:	90 91 66 05 	lds	r25, 0x0566
    244c:	9a 83       	std	Y+2, r25	; 0x02
    244e:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    2450:	0f 90       	pop	r0
    2452:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2454:	89 81       	ldd	r24, Y+1	; 0x01
    2456:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2458:	0f 90       	pop	r0
    245a:	0f 90       	pop	r0
    245c:	df 91       	pop	r29
    245e:	cf 91       	pop	r28
    2460:	08 95       	ret

00002462 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    2462:	cf 93       	push	r28
    2464:	df 93       	push	r29
    2466:	00 d0       	rcall	.+0      	; 0x2468 <xTaskGetTickCountFromISR+0x6>
    2468:	1f 92       	push	r1
    246a:	cd b7       	in	r28, 0x3d	; 61
    246c:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    246e:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    2470:	80 91 65 05 	lds	r24, 0x0565
    2474:	90 91 66 05 	lds	r25, 0x0566
    2478:	9b 83       	std	Y+3, r25	; 0x03
    247a:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    247c:	8a 81       	ldd	r24, Y+2	; 0x02
    247e:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2480:	0f 90       	pop	r0
    2482:	0f 90       	pop	r0
    2484:	0f 90       	pop	r0
    2486:	df 91       	pop	r29
    2488:	cf 91       	pop	r28
    248a:	08 95       	ret

0000248c <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    248c:	cf 93       	push	r28
    248e:	df 93       	push	r29
    2490:	cd b7       	in	r28, 0x3d	; 61
    2492:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    2494:	80 91 64 05 	lds	r24, 0x0564
}
    2498:	df 91       	pop	r29
    249a:	cf 91       	pop	r28
    249c:	08 95       	ret

0000249e <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    249e:	cf 93       	push	r28
    24a0:	df 93       	push	r29
    24a2:	cd b7       	in	r28, 0x3d	; 61
    24a4:	de b7       	in	r29, 0x3e	; 62
    24a6:	29 97       	sbiw	r28, 0x09	; 9
    24a8:	0f b6       	in	r0, 0x3f	; 63
    24aa:	f8 94       	cli
    24ac:	de bf       	out	0x3e, r29	; 62
    24ae:	0f be       	out	0x3f, r0	; 63
    24b0:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    24b2:	19 82       	std	Y+1, r1	; 0x01

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    24b4:	80 91 6f 05 	lds	r24, 0x056F
    24b8:	88 23       	and	r24, r24
    24ba:	09 f0       	breq	.+2      	; 0x24be <xTaskIncrementTick+0x20>
    24bc:	c9 c0       	rjmp	.+402    	; 0x2650 <xTaskIncrementTick+0x1b2>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    24be:	80 91 65 05 	lds	r24, 0x0565
    24c2:	90 91 66 05 	lds	r25, 0x0566
    24c6:	01 96       	adiw	r24, 0x01	; 1
    24c8:	90 93 66 05 	sts	0x0566, r25
    24cc:	80 93 65 05 	sts	0x0565, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    24d0:	80 91 65 05 	lds	r24, 0x0565
    24d4:	90 91 66 05 	lds	r25, 0x0566
    24d8:	9b 83       	std	Y+3, r25	; 0x03
    24da:	8a 83       	std	Y+2, r24	; 0x02

			if( xConstTickCount == ( TickType_t ) 0U )
    24dc:	8a 81       	ldd	r24, Y+2	; 0x02
    24de:	9b 81       	ldd	r25, Y+3	; 0x03
    24e0:	89 2b       	or	r24, r25
    24e2:	d9 f4       	brne	.+54     	; 0x251a <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    24e4:	80 91 4d 05 	lds	r24, 0x054D
    24e8:	90 91 4e 05 	lds	r25, 0x054E
    24ec:	9d 83       	std	Y+5, r25	; 0x05
    24ee:	8c 83       	std	Y+4, r24	; 0x04
    24f0:	80 91 4f 05 	lds	r24, 0x054F
    24f4:	90 91 50 05 	lds	r25, 0x0550
    24f8:	90 93 4e 05 	sts	0x054E, r25
    24fc:	80 93 4d 05 	sts	0x054D, r24
    2500:	8c 81       	ldd	r24, Y+4	; 0x04
    2502:	9d 81       	ldd	r25, Y+5	; 0x05
    2504:	90 93 50 05 	sts	0x0550, r25
    2508:	80 93 4f 05 	sts	0x054F, r24
    250c:	80 91 6b 05 	lds	r24, 0x056B
    2510:	8f 5f       	subi	r24, 0xFF	; 255
    2512:	80 93 6b 05 	sts	0x056B, r24
    2516:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    251a:	80 91 6d 05 	lds	r24, 0x056D
    251e:	90 91 6e 05 	lds	r25, 0x056E
    2522:	2a 81       	ldd	r18, Y+2	; 0x02
    2524:	3b 81       	ldd	r19, Y+3	; 0x03
    2526:	28 17       	cp	r18, r24
    2528:	39 07       	cpc	r19, r25
    252a:	08 f4       	brcc	.+2      	; 0x252e <xTaskIncrementTick+0x90>
    252c:	77 c0       	rjmp	.+238    	; 0x261c <xTaskIncrementTick+0x17e>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    252e:	80 91 4d 05 	lds	r24, 0x054D
    2532:	90 91 4e 05 	lds	r25, 0x054E
    2536:	fc 01       	movw	r30, r24
    2538:	80 81       	ld	r24, Z
    253a:	88 23       	and	r24, r24
    253c:	39 f4       	brne	.+14     	; 0x254c <xTaskIncrementTick+0xae>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    253e:	8f ef       	ldi	r24, 0xFF	; 255
    2540:	9f ef       	ldi	r25, 0xFF	; 255
    2542:	90 93 6e 05 	sts	0x056E, r25
    2546:	80 93 6d 05 	sts	0x056D, r24
						break;
    254a:	68 c0       	rjmp	.+208    	; 0x261c <xTaskIncrementTick+0x17e>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    254c:	80 91 4d 05 	lds	r24, 0x054D
    2550:	90 91 4e 05 	lds	r25, 0x054E
    2554:	fc 01       	movw	r30, r24
    2556:	85 81       	ldd	r24, Z+5	; 0x05
    2558:	96 81       	ldd	r25, Z+6	; 0x06
    255a:	fc 01       	movw	r30, r24
    255c:	86 81       	ldd	r24, Z+6	; 0x06
    255e:	97 81       	ldd	r25, Z+7	; 0x07
    2560:	9f 83       	std	Y+7, r25	; 0x07
    2562:	8e 83       	std	Y+6, r24	; 0x06
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2564:	8e 81       	ldd	r24, Y+6	; 0x06
    2566:	9f 81       	ldd	r25, Y+7	; 0x07
    2568:	fc 01       	movw	r30, r24
    256a:	82 81       	ldd	r24, Z+2	; 0x02
    256c:	93 81       	ldd	r25, Z+3	; 0x03
    256e:	99 87       	std	Y+9, r25	; 0x09
    2570:	88 87       	std	Y+8, r24	; 0x08

						if( xConstTickCount < xItemValue )
    2572:	2a 81       	ldd	r18, Y+2	; 0x02
    2574:	3b 81       	ldd	r19, Y+3	; 0x03
    2576:	88 85       	ldd	r24, Y+8	; 0x08
    2578:	99 85       	ldd	r25, Y+9	; 0x09
    257a:	28 17       	cp	r18, r24
    257c:	39 07       	cpc	r19, r25
    257e:	38 f4       	brcc	.+14     	; 0x258e <xTaskIncrementTick+0xf0>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    2580:	88 85       	ldd	r24, Y+8	; 0x08
    2582:	99 85       	ldd	r25, Y+9	; 0x09
    2584:	90 93 6e 05 	sts	0x056E, r25
    2588:	80 93 6d 05 	sts	0x056D, r24
							break;
    258c:	47 c0       	rjmp	.+142    	; 0x261c <xTaskIncrementTick+0x17e>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    258e:	8e 81       	ldd	r24, Y+6	; 0x06
    2590:	9f 81       	ldd	r25, Y+7	; 0x07
    2592:	02 96       	adiw	r24, 0x02	; 2
    2594:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2598:	8e 81       	ldd	r24, Y+6	; 0x06
    259a:	9f 81       	ldd	r25, Y+7	; 0x07
    259c:	fc 01       	movw	r30, r24
    259e:	84 89       	ldd	r24, Z+20	; 0x14
    25a0:	95 89       	ldd	r25, Z+21	; 0x15
    25a2:	89 2b       	or	r24, r25
    25a4:	29 f0       	breq	.+10     	; 0x25b0 <xTaskIncrementTick+0x112>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    25a6:	8e 81       	ldd	r24, Y+6	; 0x06
    25a8:	9f 81       	ldd	r25, Y+7	; 0x07
    25aa:	0c 96       	adiw	r24, 0x0c	; 12
    25ac:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    25b0:	8e 81       	ldd	r24, Y+6	; 0x06
    25b2:	9f 81       	ldd	r25, Y+7	; 0x07
    25b4:	fc 01       	movw	r30, r24
    25b6:	96 89       	ldd	r25, Z+22	; 0x16
    25b8:	80 91 67 05 	lds	r24, 0x0567
    25bc:	89 17       	cp	r24, r25
    25be:	30 f4       	brcc	.+12     	; 0x25cc <xTaskIncrementTick+0x12e>
    25c0:	8e 81       	ldd	r24, Y+6	; 0x06
    25c2:	9f 81       	ldd	r25, Y+7	; 0x07
    25c4:	fc 01       	movw	r30, r24
    25c6:	86 89       	ldd	r24, Z+22	; 0x16
    25c8:	80 93 67 05 	sts	0x0567, r24
    25cc:	8e 81       	ldd	r24, Y+6	; 0x06
    25ce:	9f 81       	ldd	r25, Y+7	; 0x07
    25d0:	ac 01       	movw	r20, r24
    25d2:	4e 5f       	subi	r20, 0xFE	; 254
    25d4:	5f 4f       	sbci	r21, 0xFF	; 255
    25d6:	8e 81       	ldd	r24, Y+6	; 0x06
    25d8:	9f 81       	ldd	r25, Y+7	; 0x07
    25da:	fc 01       	movw	r30, r24
    25dc:	86 89       	ldd	r24, Z+22	; 0x16
    25de:	28 2f       	mov	r18, r24
    25e0:	30 e0       	ldi	r19, 0x00	; 0
    25e2:	c9 01       	movw	r24, r18
    25e4:	88 0f       	add	r24, r24
    25e6:	99 1f       	adc	r25, r25
    25e8:	88 0f       	add	r24, r24
    25ea:	99 1f       	adc	r25, r25
    25ec:	88 0f       	add	r24, r24
    25ee:	99 1f       	adc	r25, r25
    25f0:	82 0f       	add	r24, r18
    25f2:	93 1f       	adc	r25, r19
    25f4:	89 5e       	subi	r24, 0xE9	; 233
    25f6:	9a 4f       	sbci	r25, 0xFA	; 250
    25f8:	ba 01       	movw	r22, r20
    25fa:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    25fe:	8e 81       	ldd	r24, Y+6	; 0x06
    2600:	9f 81       	ldd	r25, Y+7	; 0x07
    2602:	fc 01       	movw	r30, r24
    2604:	26 89       	ldd	r18, Z+22	; 0x16
    2606:	80 91 15 05 	lds	r24, 0x0515
    260a:	90 91 16 05 	lds	r25, 0x0516
    260e:	fc 01       	movw	r30, r24
    2610:	86 89       	ldd	r24, Z+22	; 0x16
    2612:	28 17       	cp	r18, r24
    2614:	10 f0       	brcs	.+4      	; 0x261a <xTaskIncrementTick+0x17c>
							{
								xSwitchRequired = pdTRUE;
    2616:	81 e0       	ldi	r24, 0x01	; 1
    2618:	89 83       	std	Y+1, r24	; 0x01
								mtCOVERAGE_TEST_MARKER();
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
    261a:	89 cf       	rjmp	.-238    	; 0x252e <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    261c:	80 91 15 05 	lds	r24, 0x0515
    2620:	90 91 16 05 	lds	r25, 0x0516
    2624:	fc 01       	movw	r30, r24
    2626:	86 89       	ldd	r24, Z+22	; 0x16
    2628:	28 2f       	mov	r18, r24
    262a:	30 e0       	ldi	r19, 0x00	; 0
    262c:	c9 01       	movw	r24, r18
    262e:	88 0f       	add	r24, r24
    2630:	99 1f       	adc	r25, r25
    2632:	88 0f       	add	r24, r24
    2634:	99 1f       	adc	r25, r25
    2636:	88 0f       	add	r24, r24
    2638:	99 1f       	adc	r25, r25
    263a:	82 0f       	add	r24, r18
    263c:	93 1f       	adc	r25, r19
    263e:	89 5e       	subi	r24, 0xE9	; 233
    2640:	9a 4f       	sbci	r25, 0xFA	; 250
    2642:	fc 01       	movw	r30, r24
    2644:	80 81       	ld	r24, Z
    2646:	82 30       	cpi	r24, 0x02	; 2
    2648:	40 f0       	brcs	.+16     	; 0x265a <xTaskIncrementTick+0x1bc>
			{
				xSwitchRequired = pdTRUE;
    264a:	81 e0       	ldi	r24, 0x01	; 1
    264c:	89 83       	std	Y+1, r24	; 0x01
    264e:	05 c0       	rjmp	.+10     	; 0x265a <xTaskIncrementTick+0x1bc>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    2650:	80 91 69 05 	lds	r24, 0x0569
    2654:	8f 5f       	subi	r24, 0xFF	; 255
    2656:	80 93 69 05 	sts	0x0569, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    265a:	80 91 6a 05 	lds	r24, 0x056A
    265e:	88 23       	and	r24, r24
    2660:	11 f0       	breq	.+4      	; 0x2666 <xTaskIncrementTick+0x1c8>
		{
			xSwitchRequired = pdTRUE;
    2662:	81 e0       	ldi	r24, 0x01	; 1
    2664:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    2666:	89 81       	ldd	r24, Y+1	; 0x01
}
    2668:	29 96       	adiw	r28, 0x09	; 9
    266a:	0f b6       	in	r0, 0x3f	; 63
    266c:	f8 94       	cli
    266e:	de bf       	out	0x3e, r29	; 62
    2670:	0f be       	out	0x3f, r0	; 63
    2672:	cd bf       	out	0x3d, r28	; 61
    2674:	df 91       	pop	r29
    2676:	cf 91       	pop	r28
    2678:	08 95       	ret

0000267a <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    267a:	cf 93       	push	r28
    267c:	df 93       	push	r29
    267e:	00 d0       	rcall	.+0      	; 0x2680 <vTaskSwitchContext+0x6>
    2680:	cd b7       	in	r28, 0x3d	; 61
    2682:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2684:	80 91 6f 05 	lds	r24, 0x056F
    2688:	88 23       	and	r24, r24
    268a:	21 f0       	breq	.+8      	; 0x2694 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    268c:	81 e0       	ldi	r24, 0x01	; 1
    268e:	80 93 6a 05 	sts	0x056A, r24
    2692:	5d c0       	rjmp	.+186    	; 0x274e <vTaskSwitchContext+0xd4>
	}
	else
	{
		xYieldPending = pdFALSE;
    2694:	10 92 6a 05 	sts	0x056A, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    2698:	05 c0       	rjmp	.+10     	; 0x26a4 <vTaskSwitchContext+0x2a>
    269a:	80 91 67 05 	lds	r24, 0x0567
    269e:	81 50       	subi	r24, 0x01	; 1
    26a0:	80 93 67 05 	sts	0x0567, r24
    26a4:	80 91 67 05 	lds	r24, 0x0567
    26a8:	28 2f       	mov	r18, r24
    26aa:	30 e0       	ldi	r19, 0x00	; 0
    26ac:	c9 01       	movw	r24, r18
    26ae:	88 0f       	add	r24, r24
    26b0:	99 1f       	adc	r25, r25
    26b2:	88 0f       	add	r24, r24
    26b4:	99 1f       	adc	r25, r25
    26b6:	88 0f       	add	r24, r24
    26b8:	99 1f       	adc	r25, r25
    26ba:	82 0f       	add	r24, r18
    26bc:	93 1f       	adc	r25, r19
    26be:	89 5e       	subi	r24, 0xE9	; 233
    26c0:	9a 4f       	sbci	r25, 0xFA	; 250
    26c2:	fc 01       	movw	r30, r24
    26c4:	80 81       	ld	r24, Z
    26c6:	88 23       	and	r24, r24
    26c8:	41 f3       	breq	.-48     	; 0x269a <vTaskSwitchContext+0x20>
    26ca:	80 91 67 05 	lds	r24, 0x0567
    26ce:	28 2f       	mov	r18, r24
    26d0:	30 e0       	ldi	r19, 0x00	; 0
    26d2:	c9 01       	movw	r24, r18
    26d4:	88 0f       	add	r24, r24
    26d6:	99 1f       	adc	r25, r25
    26d8:	88 0f       	add	r24, r24
    26da:	99 1f       	adc	r25, r25
    26dc:	88 0f       	add	r24, r24
    26de:	99 1f       	adc	r25, r25
    26e0:	82 0f       	add	r24, r18
    26e2:	93 1f       	adc	r25, r19
    26e4:	89 5e       	subi	r24, 0xE9	; 233
    26e6:	9a 4f       	sbci	r25, 0xFA	; 250
    26e8:	9a 83       	std	Y+2, r25	; 0x02
    26ea:	89 83       	std	Y+1, r24	; 0x01
    26ec:	89 81       	ldd	r24, Y+1	; 0x01
    26ee:	9a 81       	ldd	r25, Y+2	; 0x02
    26f0:	fc 01       	movw	r30, r24
    26f2:	81 81       	ldd	r24, Z+1	; 0x01
    26f4:	92 81       	ldd	r25, Z+2	; 0x02
    26f6:	fc 01       	movw	r30, r24
    26f8:	22 81       	ldd	r18, Z+2	; 0x02
    26fa:	33 81       	ldd	r19, Z+3	; 0x03
    26fc:	89 81       	ldd	r24, Y+1	; 0x01
    26fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2700:	fc 01       	movw	r30, r24
    2702:	32 83       	std	Z+2, r19	; 0x02
    2704:	21 83       	std	Z+1, r18	; 0x01
    2706:	89 81       	ldd	r24, Y+1	; 0x01
    2708:	9a 81       	ldd	r25, Y+2	; 0x02
    270a:	fc 01       	movw	r30, r24
    270c:	21 81       	ldd	r18, Z+1	; 0x01
    270e:	32 81       	ldd	r19, Z+2	; 0x02
    2710:	89 81       	ldd	r24, Y+1	; 0x01
    2712:	9a 81       	ldd	r25, Y+2	; 0x02
    2714:	03 96       	adiw	r24, 0x03	; 3
    2716:	28 17       	cp	r18, r24
    2718:	39 07       	cpc	r19, r25
    271a:	69 f4       	brne	.+26     	; 0x2736 <vTaskSwitchContext+0xbc>
    271c:	89 81       	ldd	r24, Y+1	; 0x01
    271e:	9a 81       	ldd	r25, Y+2	; 0x02
    2720:	fc 01       	movw	r30, r24
    2722:	81 81       	ldd	r24, Z+1	; 0x01
    2724:	92 81       	ldd	r25, Z+2	; 0x02
    2726:	fc 01       	movw	r30, r24
    2728:	22 81       	ldd	r18, Z+2	; 0x02
    272a:	33 81       	ldd	r19, Z+3	; 0x03
    272c:	89 81       	ldd	r24, Y+1	; 0x01
    272e:	9a 81       	ldd	r25, Y+2	; 0x02
    2730:	fc 01       	movw	r30, r24
    2732:	32 83       	std	Z+2, r19	; 0x02
    2734:	21 83       	std	Z+1, r18	; 0x01
    2736:	89 81       	ldd	r24, Y+1	; 0x01
    2738:	9a 81       	ldd	r25, Y+2	; 0x02
    273a:	fc 01       	movw	r30, r24
    273c:	81 81       	ldd	r24, Z+1	; 0x01
    273e:	92 81       	ldd	r25, Z+2	; 0x02
    2740:	fc 01       	movw	r30, r24
    2742:	86 81       	ldd	r24, Z+6	; 0x06
    2744:	97 81       	ldd	r25, Z+7	; 0x07
    2746:	90 93 16 05 	sts	0x0516, r25
    274a:	80 93 15 05 	sts	0x0515, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    274e:	0f 90       	pop	r0
    2750:	0f 90       	pop	r0
    2752:	df 91       	pop	r29
    2754:	cf 91       	pop	r28
    2756:	08 95       	ret

00002758 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    2758:	cf 93       	push	r28
    275a:	df 93       	push	r29
    275c:	00 d0       	rcall	.+0      	; 0x275e <vTaskPlaceOnEventList+0x6>
    275e:	00 d0       	rcall	.+0      	; 0x2760 <vTaskPlaceOnEventList+0x8>
    2760:	00 d0       	rcall	.+0      	; 0x2762 <vTaskPlaceOnEventList+0xa>
    2762:	cd b7       	in	r28, 0x3d	; 61
    2764:	de b7       	in	r29, 0x3e	; 62
    2766:	9c 83       	std	Y+4, r25	; 0x04
    2768:	8b 83       	std	Y+3, r24	; 0x03
    276a:	7e 83       	std	Y+6, r23	; 0x06
    276c:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    276e:	80 91 15 05 	lds	r24, 0x0515
    2772:	90 91 16 05 	lds	r25, 0x0516
    2776:	9c 01       	movw	r18, r24
    2778:	24 5f       	subi	r18, 0xF4	; 244
    277a:	3f 4f       	sbci	r19, 0xFF	; 255
    277c:	8b 81       	ldd	r24, Y+3	; 0x03
    277e:	9c 81       	ldd	r25, Y+4	; 0x04
    2780:	b9 01       	movw	r22, r18
    2782:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2786:	80 91 15 05 	lds	r24, 0x0515
    278a:	90 91 16 05 	lds	r25, 0x0516
    278e:	02 96       	adiw	r24, 0x02	; 2
    2790:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    2794:	20 91 65 05 	lds	r18, 0x0565
    2798:	30 91 66 05 	lds	r19, 0x0566
    279c:	8d 81       	ldd	r24, Y+5	; 0x05
    279e:	9e 81       	ldd	r25, Y+6	; 0x06
    27a0:	82 0f       	add	r24, r18
    27a2:	93 1f       	adc	r25, r19
    27a4:	9a 83       	std	Y+2, r25	; 0x02
    27a6:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    27a8:	89 81       	ldd	r24, Y+1	; 0x01
    27aa:	9a 81       	ldd	r25, Y+2	; 0x02
    27ac:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    27b0:	26 96       	adiw	r28, 0x06	; 6
    27b2:	0f b6       	in	r0, 0x3f	; 63
    27b4:	f8 94       	cli
    27b6:	de bf       	out	0x3e, r29	; 62
    27b8:	0f be       	out	0x3f, r0	; 63
    27ba:	cd bf       	out	0x3d, r28	; 61
    27bc:	df 91       	pop	r29
    27be:	cf 91       	pop	r28
    27c0:	08 95       	ret

000027c2 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    27c2:	cf 93       	push	r28
    27c4:	df 93       	push	r29
    27c6:	cd b7       	in	r28, 0x3d	; 61
    27c8:	de b7       	in	r29, 0x3e	; 62
    27ca:	28 97       	sbiw	r28, 0x08	; 8
    27cc:	0f b6       	in	r0, 0x3f	; 63
    27ce:	f8 94       	cli
    27d0:	de bf       	out	0x3e, r29	; 62
    27d2:	0f be       	out	0x3f, r0	; 63
    27d4:	cd bf       	out	0x3d, r28	; 61
    27d6:	9c 83       	std	Y+4, r25	; 0x04
    27d8:	8b 83       	std	Y+3, r24	; 0x03
    27da:	7e 83       	std	Y+6, r23	; 0x06
    27dc:	6d 83       	std	Y+5, r22	; 0x05
    27de:	58 87       	std	Y+8, r21	; 0x08
    27e0:	4f 83       	std	Y+7, r20	; 0x07
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    27e2:	80 91 15 05 	lds	r24, 0x0515
    27e6:	90 91 16 05 	lds	r25, 0x0516
    27ea:	2d 81       	ldd	r18, Y+5	; 0x05
    27ec:	3e 81       	ldd	r19, Y+6	; 0x06
    27ee:	30 68       	ori	r19, 0x80	; 128
    27f0:	fc 01       	movw	r30, r24
    27f2:	35 87       	std	Z+13, r19	; 0x0d
    27f4:	24 87       	std	Z+12, r18	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    27f6:	80 91 15 05 	lds	r24, 0x0515
    27fa:	90 91 16 05 	lds	r25, 0x0516
    27fe:	9c 01       	movw	r18, r24
    2800:	24 5f       	subi	r18, 0xF4	; 244
    2802:	3f 4f       	sbci	r19, 0xFF	; 255
    2804:	8b 81       	ldd	r24, Y+3	; 0x03
    2806:	9c 81       	ldd	r25, Y+4	; 0x04
    2808:	b9 01       	movw	r22, r18
    280a:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    280e:	80 91 15 05 	lds	r24, 0x0515
    2812:	90 91 16 05 	lds	r25, 0x0516
    2816:	02 96       	adiw	r24, 0x02	; 2
    2818:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    281c:	20 91 65 05 	lds	r18, 0x0565
    2820:	30 91 66 05 	lds	r19, 0x0566
    2824:	8f 81       	ldd	r24, Y+7	; 0x07
    2826:	98 85       	ldd	r25, Y+8	; 0x08
    2828:	82 0f       	add	r24, r18
    282a:	93 1f       	adc	r25, r19
    282c:	9a 83       	std	Y+2, r25	; 0x02
    282e:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2830:	89 81       	ldd	r24, Y+1	; 0x01
    2832:	9a 81       	ldd	r25, Y+2	; 0x02
    2834:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    2838:	28 96       	adiw	r28, 0x08	; 8
    283a:	0f b6       	in	r0, 0x3f	; 63
    283c:	f8 94       	cli
    283e:	de bf       	out	0x3e, r29	; 62
    2840:	0f be       	out	0x3f, r0	; 63
    2842:	cd bf       	out	0x3d, r28	; 61
    2844:	df 91       	pop	r29
    2846:	cf 91       	pop	r28
    2848:	08 95       	ret

0000284a <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    284a:	cf 93       	push	r28
    284c:	df 93       	push	r29
    284e:	00 d0       	rcall	.+0      	; 0x2850 <xTaskRemoveFromEventList+0x6>
    2850:	00 d0       	rcall	.+0      	; 0x2852 <xTaskRemoveFromEventList+0x8>
    2852:	1f 92       	push	r1
    2854:	cd b7       	in	r28, 0x3d	; 61
    2856:	de b7       	in	r29, 0x3e	; 62
    2858:	9d 83       	std	Y+5, r25	; 0x05
    285a:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    285c:	8c 81       	ldd	r24, Y+4	; 0x04
    285e:	9d 81       	ldd	r25, Y+5	; 0x05
    2860:	fc 01       	movw	r30, r24
    2862:	85 81       	ldd	r24, Z+5	; 0x05
    2864:	96 81       	ldd	r25, Z+6	; 0x06
    2866:	fc 01       	movw	r30, r24
    2868:	86 81       	ldd	r24, Z+6	; 0x06
    286a:	97 81       	ldd	r25, Z+7	; 0x07
    286c:	9b 83       	std	Y+3, r25	; 0x03
    286e:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2870:	8a 81       	ldd	r24, Y+2	; 0x02
    2872:	9b 81       	ldd	r25, Y+3	; 0x03
    2874:	0c 96       	adiw	r24, 0x0c	; 12
    2876:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    287a:	80 91 6f 05 	lds	r24, 0x056F
    287e:	88 23       	and	r24, r24
    2880:	69 f5       	brne	.+90     	; 0x28dc <xTaskRemoveFromEventList+0x92>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2882:	8a 81       	ldd	r24, Y+2	; 0x02
    2884:	9b 81       	ldd	r25, Y+3	; 0x03
    2886:	02 96       	adiw	r24, 0x02	; 2
    2888:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    288c:	8a 81       	ldd	r24, Y+2	; 0x02
    288e:	9b 81       	ldd	r25, Y+3	; 0x03
    2890:	fc 01       	movw	r30, r24
    2892:	96 89       	ldd	r25, Z+22	; 0x16
    2894:	80 91 67 05 	lds	r24, 0x0567
    2898:	89 17       	cp	r24, r25
    289a:	30 f4       	brcc	.+12     	; 0x28a8 <xTaskRemoveFromEventList+0x5e>
    289c:	8a 81       	ldd	r24, Y+2	; 0x02
    289e:	9b 81       	ldd	r25, Y+3	; 0x03
    28a0:	fc 01       	movw	r30, r24
    28a2:	86 89       	ldd	r24, Z+22	; 0x16
    28a4:	80 93 67 05 	sts	0x0567, r24
    28a8:	8a 81       	ldd	r24, Y+2	; 0x02
    28aa:	9b 81       	ldd	r25, Y+3	; 0x03
    28ac:	ac 01       	movw	r20, r24
    28ae:	4e 5f       	subi	r20, 0xFE	; 254
    28b0:	5f 4f       	sbci	r21, 0xFF	; 255
    28b2:	8a 81       	ldd	r24, Y+2	; 0x02
    28b4:	9b 81       	ldd	r25, Y+3	; 0x03
    28b6:	fc 01       	movw	r30, r24
    28b8:	86 89       	ldd	r24, Z+22	; 0x16
    28ba:	28 2f       	mov	r18, r24
    28bc:	30 e0       	ldi	r19, 0x00	; 0
    28be:	c9 01       	movw	r24, r18
    28c0:	88 0f       	add	r24, r24
    28c2:	99 1f       	adc	r25, r25
    28c4:	88 0f       	add	r24, r24
    28c6:	99 1f       	adc	r25, r25
    28c8:	88 0f       	add	r24, r24
    28ca:	99 1f       	adc	r25, r25
    28cc:	82 0f       	add	r24, r18
    28ce:	93 1f       	adc	r25, r19
    28d0:	89 5e       	subi	r24, 0xE9	; 233
    28d2:	9a 4f       	sbci	r25, 0xFA	; 250
    28d4:	ba 01       	movw	r22, r20
    28d6:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsertEnd>
    28da:	08 c0       	rjmp	.+16     	; 0x28ec <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    28dc:	8a 81       	ldd	r24, Y+2	; 0x02
    28de:	9b 81       	ldd	r25, Y+3	; 0x03
    28e0:	0c 96       	adiw	r24, 0x0c	; 12
    28e2:	bc 01       	movw	r22, r24
    28e4:	81 e5       	ldi	r24, 0x51	; 81
    28e6:	95 e0       	ldi	r25, 0x05	; 5
    28e8:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    28ec:	8a 81       	ldd	r24, Y+2	; 0x02
    28ee:	9b 81       	ldd	r25, Y+3	; 0x03
    28f0:	fc 01       	movw	r30, r24
    28f2:	26 89       	ldd	r18, Z+22	; 0x16
    28f4:	80 91 15 05 	lds	r24, 0x0515
    28f8:	90 91 16 05 	lds	r25, 0x0516
    28fc:	fc 01       	movw	r30, r24
    28fe:	86 89       	ldd	r24, Z+22	; 0x16
    2900:	82 17       	cp	r24, r18
    2902:	30 f4       	brcc	.+12     	; 0x2910 <xTaskRemoveFromEventList+0xc6>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    2904:	81 e0       	ldi	r24, 0x01	; 1
    2906:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2908:	81 e0       	ldi	r24, 0x01	; 1
    290a:	80 93 6a 05 	sts	0x056A, r24
    290e:	01 c0       	rjmp	.+2      	; 0x2912 <xTaskRemoveFromEventList+0xc8>
	}
	else
	{
		xReturn = pdFALSE;
    2910:	19 82       	std	Y+1, r1	; 0x01
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    2912:	89 81       	ldd	r24, Y+1	; 0x01
}
    2914:	0f 90       	pop	r0
    2916:	0f 90       	pop	r0
    2918:	0f 90       	pop	r0
    291a:	0f 90       	pop	r0
    291c:	0f 90       	pop	r0
    291e:	df 91       	pop	r29
    2920:	cf 91       	pop	r28
    2922:	08 95       	ret

00002924 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    2924:	cf 93       	push	r28
    2926:	df 93       	push	r29
    2928:	cd b7       	in	r28, 0x3d	; 61
    292a:	de b7       	in	r29, 0x3e	; 62
    292c:	27 97       	sbiw	r28, 0x07	; 7
    292e:	0f b6       	in	r0, 0x3f	; 63
    2930:	f8 94       	cli
    2932:	de bf       	out	0x3e, r29	; 62
    2934:	0f be       	out	0x3f, r0	; 63
    2936:	cd bf       	out	0x3d, r28	; 61
    2938:	9d 83       	std	Y+5, r25	; 0x05
    293a:	8c 83       	std	Y+4, r24	; 0x04
    293c:	7f 83       	std	Y+7, r23	; 0x07
    293e:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2940:	8e 81       	ldd	r24, Y+6	; 0x06
    2942:	9f 81       	ldd	r25, Y+7	; 0x07
    2944:	9c 01       	movw	r18, r24
    2946:	30 68       	ori	r19, 0x80	; 128
    2948:	8c 81       	ldd	r24, Y+4	; 0x04
    294a:	9d 81       	ldd	r25, Y+5	; 0x05
    294c:	fc 01       	movw	r30, r24
    294e:	31 83       	std	Z+1, r19	; 0x01
    2950:	20 83       	st	Z, r18

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    2952:	8c 81       	ldd	r24, Y+4	; 0x04
    2954:	9d 81       	ldd	r25, Y+5	; 0x05
    2956:	fc 01       	movw	r30, r24
    2958:	86 81       	ldd	r24, Z+6	; 0x06
    295a:	97 81       	ldd	r25, Z+7	; 0x07
    295c:	9b 83       	std	Y+3, r25	; 0x03
    295e:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    2960:	8c 81       	ldd	r24, Y+4	; 0x04
    2962:	9d 81       	ldd	r25, Y+5	; 0x05
    2964:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2968:	8a 81       	ldd	r24, Y+2	; 0x02
    296a:	9b 81       	ldd	r25, Y+3	; 0x03
    296c:	02 96       	adiw	r24, 0x02	; 2
    296e:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    2972:	8a 81       	ldd	r24, Y+2	; 0x02
    2974:	9b 81       	ldd	r25, Y+3	; 0x03
    2976:	fc 01       	movw	r30, r24
    2978:	96 89       	ldd	r25, Z+22	; 0x16
    297a:	80 91 67 05 	lds	r24, 0x0567
    297e:	89 17       	cp	r24, r25
    2980:	30 f4       	brcc	.+12     	; 0x298e <xTaskRemoveFromUnorderedEventList+0x6a>
    2982:	8a 81       	ldd	r24, Y+2	; 0x02
    2984:	9b 81       	ldd	r25, Y+3	; 0x03
    2986:	fc 01       	movw	r30, r24
    2988:	86 89       	ldd	r24, Z+22	; 0x16
    298a:	80 93 67 05 	sts	0x0567, r24
    298e:	8a 81       	ldd	r24, Y+2	; 0x02
    2990:	9b 81       	ldd	r25, Y+3	; 0x03
    2992:	ac 01       	movw	r20, r24
    2994:	4e 5f       	subi	r20, 0xFE	; 254
    2996:	5f 4f       	sbci	r21, 0xFF	; 255
    2998:	8a 81       	ldd	r24, Y+2	; 0x02
    299a:	9b 81       	ldd	r25, Y+3	; 0x03
    299c:	fc 01       	movw	r30, r24
    299e:	86 89       	ldd	r24, Z+22	; 0x16
    29a0:	28 2f       	mov	r18, r24
    29a2:	30 e0       	ldi	r19, 0x00	; 0
    29a4:	c9 01       	movw	r24, r18
    29a6:	88 0f       	add	r24, r24
    29a8:	99 1f       	adc	r25, r25
    29aa:	88 0f       	add	r24, r24
    29ac:	99 1f       	adc	r25, r25
    29ae:	88 0f       	add	r24, r24
    29b0:	99 1f       	adc	r25, r25
    29b2:	82 0f       	add	r24, r18
    29b4:	93 1f       	adc	r25, r19
    29b6:	89 5e       	subi	r24, 0xE9	; 233
    29b8:	9a 4f       	sbci	r25, 0xFA	; 250
    29ba:	ba 01       	movw	r22, r20
    29bc:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    29c0:	8a 81       	ldd	r24, Y+2	; 0x02
    29c2:	9b 81       	ldd	r25, Y+3	; 0x03
    29c4:	fc 01       	movw	r30, r24
    29c6:	26 89       	ldd	r18, Z+22	; 0x16
    29c8:	80 91 15 05 	lds	r24, 0x0515
    29cc:	90 91 16 05 	lds	r25, 0x0516
    29d0:	fc 01       	movw	r30, r24
    29d2:	86 89       	ldd	r24, Z+22	; 0x16
    29d4:	82 17       	cp	r24, r18
    29d6:	30 f4       	brcc	.+12     	; 0x29e4 <xTaskRemoveFromUnorderedEventList+0xc0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    29d8:	81 e0       	ldi	r24, 0x01	; 1
    29da:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    29dc:	81 e0       	ldi	r24, 0x01	; 1
    29de:	80 93 6a 05 	sts	0x056A, r24
    29e2:	01 c0       	rjmp	.+2      	; 0x29e6 <xTaskRemoveFromUnorderedEventList+0xc2>
	}
	else
	{
		xReturn = pdFALSE;
    29e4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    29e6:	89 81       	ldd	r24, Y+1	; 0x01
}
    29e8:	27 96       	adiw	r28, 0x07	; 7
    29ea:	0f b6       	in	r0, 0x3f	; 63
    29ec:	f8 94       	cli
    29ee:	de bf       	out	0x3e, r29	; 62
    29f0:	0f be       	out	0x3f, r0	; 63
    29f2:	cd bf       	out	0x3d, r28	; 61
    29f4:	df 91       	pop	r29
    29f6:	cf 91       	pop	r28
    29f8:	08 95       	ret

000029fa <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    29fa:	cf 93       	push	r28
    29fc:	df 93       	push	r29
    29fe:	00 d0       	rcall	.+0      	; 0x2a00 <vTaskSetTimeOutState+0x6>
    2a00:	cd b7       	in	r28, 0x3d	; 61
    2a02:	de b7       	in	r29, 0x3e	; 62
    2a04:	9a 83       	std	Y+2, r25	; 0x02
    2a06:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2a08:	20 91 6b 05 	lds	r18, 0x056B
    2a0c:	89 81       	ldd	r24, Y+1	; 0x01
    2a0e:	9a 81       	ldd	r25, Y+2	; 0x02
    2a10:	fc 01       	movw	r30, r24
    2a12:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2a14:	20 91 65 05 	lds	r18, 0x0565
    2a18:	30 91 66 05 	lds	r19, 0x0566
    2a1c:	89 81       	ldd	r24, Y+1	; 0x01
    2a1e:	9a 81       	ldd	r25, Y+2	; 0x02
    2a20:	fc 01       	movw	r30, r24
    2a22:	32 83       	std	Z+2, r19	; 0x02
    2a24:	21 83       	std	Z+1, r18	; 0x01
}
    2a26:	0f 90       	pop	r0
    2a28:	0f 90       	pop	r0
    2a2a:	df 91       	pop	r29
    2a2c:	cf 91       	pop	r28
    2a2e:	08 95       	ret

00002a30 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2a30:	cf 93       	push	r28
    2a32:	df 93       	push	r29
    2a34:	cd b7       	in	r28, 0x3d	; 61
    2a36:	de b7       	in	r29, 0x3e	; 62
    2a38:	27 97       	sbiw	r28, 0x07	; 7
    2a3a:	0f b6       	in	r0, 0x3f	; 63
    2a3c:	f8 94       	cli
    2a3e:	de bf       	out	0x3e, r29	; 62
    2a40:	0f be       	out	0x3f, r0	; 63
    2a42:	cd bf       	out	0x3d, r28	; 61
    2a44:	9d 83       	std	Y+5, r25	; 0x05
    2a46:	8c 83       	std	Y+4, r24	; 0x04
    2a48:	7f 83       	std	Y+7, r23	; 0x07
    2a4a:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2a4c:	0f b6       	in	r0, 0x3f	; 63
    2a4e:	f8 94       	cli
    2a50:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2a52:	80 91 65 05 	lds	r24, 0x0565
    2a56:	90 91 66 05 	lds	r25, 0x0566
    2a5a:	9b 83       	std	Y+3, r25	; 0x03
    2a5c:	8a 83       	std	Y+2, r24	; 0x02
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2a5e:	8c 81       	ldd	r24, Y+4	; 0x04
    2a60:	9d 81       	ldd	r25, Y+5	; 0x05
    2a62:	fc 01       	movw	r30, r24
    2a64:	90 81       	ld	r25, Z
    2a66:	80 91 6b 05 	lds	r24, 0x056B
    2a6a:	98 17       	cp	r25, r24
    2a6c:	69 f0       	breq	.+26     	; 0x2a88 <xTaskCheckForTimeOut+0x58>
    2a6e:	8c 81       	ldd	r24, Y+4	; 0x04
    2a70:	9d 81       	ldd	r25, Y+5	; 0x05
    2a72:	fc 01       	movw	r30, r24
    2a74:	21 81       	ldd	r18, Z+1	; 0x01
    2a76:	32 81       	ldd	r19, Z+2	; 0x02
    2a78:	8a 81       	ldd	r24, Y+2	; 0x02
    2a7a:	9b 81       	ldd	r25, Y+3	; 0x03
    2a7c:	82 17       	cp	r24, r18
    2a7e:	93 07       	cpc	r25, r19
    2a80:	18 f0       	brcs	.+6      	; 0x2a88 <xTaskCheckForTimeOut+0x58>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2a82:	81 e0       	ldi	r24, 0x01	; 1
    2a84:	89 83       	std	Y+1, r24	; 0x01
    2a86:	30 c0       	rjmp	.+96     	; 0x2ae8 <xTaskCheckForTimeOut+0xb8>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    2a88:	8c 81       	ldd	r24, Y+4	; 0x04
    2a8a:	9d 81       	ldd	r25, Y+5	; 0x05
    2a8c:	fc 01       	movw	r30, r24
    2a8e:	81 81       	ldd	r24, Z+1	; 0x01
    2a90:	92 81       	ldd	r25, Z+2	; 0x02
    2a92:	2a 81       	ldd	r18, Y+2	; 0x02
    2a94:	3b 81       	ldd	r19, Y+3	; 0x03
    2a96:	28 1b       	sub	r18, r24
    2a98:	39 0b       	sbc	r19, r25
    2a9a:	8e 81       	ldd	r24, Y+6	; 0x06
    2a9c:	9f 81       	ldd	r25, Y+7	; 0x07
    2a9e:	fc 01       	movw	r30, r24
    2aa0:	80 81       	ld	r24, Z
    2aa2:	91 81       	ldd	r25, Z+1	; 0x01
    2aa4:	28 17       	cp	r18, r24
    2aa6:	39 07       	cpc	r19, r25
    2aa8:	e8 f4       	brcc	.+58     	; 0x2ae4 <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    2aaa:	8e 81       	ldd	r24, Y+6	; 0x06
    2aac:	9f 81       	ldd	r25, Y+7	; 0x07
    2aae:	fc 01       	movw	r30, r24
    2ab0:	20 81       	ld	r18, Z
    2ab2:	31 81       	ldd	r19, Z+1	; 0x01
    2ab4:	8c 81       	ldd	r24, Y+4	; 0x04
    2ab6:	9d 81       	ldd	r25, Y+5	; 0x05
    2ab8:	fc 01       	movw	r30, r24
    2aba:	41 81       	ldd	r20, Z+1	; 0x01
    2abc:	52 81       	ldd	r21, Z+2	; 0x02
    2abe:	8a 81       	ldd	r24, Y+2	; 0x02
    2ac0:	9b 81       	ldd	r25, Y+3	; 0x03
    2ac2:	ba 01       	movw	r22, r20
    2ac4:	68 1b       	sub	r22, r24
    2ac6:	79 0b       	sbc	r23, r25
    2ac8:	cb 01       	movw	r24, r22
    2aca:	28 0f       	add	r18, r24
    2acc:	39 1f       	adc	r19, r25
    2ace:	8e 81       	ldd	r24, Y+6	; 0x06
    2ad0:	9f 81       	ldd	r25, Y+7	; 0x07
    2ad2:	fc 01       	movw	r30, r24
    2ad4:	31 83       	std	Z+1, r19	; 0x01
    2ad6:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    2ad8:	8c 81       	ldd	r24, Y+4	; 0x04
    2ada:	9d 81       	ldd	r25, Y+5	; 0x05
    2adc:	0e 94 fd 14 	call	0x29fa	; 0x29fa <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2ae0:	19 82       	std	Y+1, r1	; 0x01
    2ae2:	02 c0       	rjmp	.+4      	; 0x2ae8 <xTaskCheckForTimeOut+0xb8>
		}
		else
		{
			xReturn = pdTRUE;
    2ae4:	81 e0       	ldi	r24, 0x01	; 1
    2ae6:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2ae8:	0f 90       	pop	r0
    2aea:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2aec:	89 81       	ldd	r24, Y+1	; 0x01
}
    2aee:	27 96       	adiw	r28, 0x07	; 7
    2af0:	0f b6       	in	r0, 0x3f	; 63
    2af2:	f8 94       	cli
    2af4:	de bf       	out	0x3e, r29	; 62
    2af6:	0f be       	out	0x3f, r0	; 63
    2af8:	cd bf       	out	0x3d, r28	; 61
    2afa:	df 91       	pop	r29
    2afc:	cf 91       	pop	r28
    2afe:	08 95       	ret

00002b00 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2b00:	cf 93       	push	r28
    2b02:	df 93       	push	r29
    2b04:	cd b7       	in	r28, 0x3d	; 61
    2b06:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    2b08:	81 e0       	ldi	r24, 0x01	; 1
    2b0a:	80 93 6a 05 	sts	0x056A, r24
}
    2b0e:	df 91       	pop	r29
    2b10:	cf 91       	pop	r28
    2b12:	08 95       	ret

00002b14 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2b14:	cf 93       	push	r28
    2b16:	df 93       	push	r29
    2b18:	00 d0       	rcall	.+0      	; 0x2b1a <prvIdleTask+0x6>
    2b1a:	cd b7       	in	r28, 0x3d	; 61
    2b1c:	de b7       	in	r29, 0x3e	; 62
    2b1e:	9a 83       	std	Y+2, r25	; 0x02
    2b20:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    2b22:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    2b26:	80 91 17 05 	lds	r24, 0x0517
    2b2a:	82 30       	cpi	r24, 0x02	; 2
    2b2c:	10 f0       	brcs	.+4      	; 0x2b32 <prvIdleTask+0x1e>
			{
				taskYIELD();
    2b2e:	0e 94 86 07 	call	0xf0c	; 0xf0c <vPortYield>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    2b32:	f7 cf       	rjmp	.-18     	; 0x2b22 <prvIdleTask+0xe>

00002b34 <prvInitialiseTCBVariables>:

#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    2b34:	0f 93       	push	r16
    2b36:	1f 93       	push	r17
    2b38:	cf 93       	push	r28
    2b3a:	df 93       	push	r29
    2b3c:	cd b7       	in	r28, 0x3d	; 61
    2b3e:	de b7       	in	r29, 0x3e	; 62
    2b40:	2a 97       	sbiw	r28, 0x0a	; 10
    2b42:	0f b6       	in	r0, 0x3f	; 63
    2b44:	f8 94       	cli
    2b46:	de bf       	out	0x3e, r29	; 62
    2b48:	0f be       	out	0x3f, r0	; 63
    2b4a:	cd bf       	out	0x3d, r28	; 61
    2b4c:	9b 83       	std	Y+3, r25	; 0x03
    2b4e:	8a 83       	std	Y+2, r24	; 0x02
    2b50:	7d 83       	std	Y+5, r23	; 0x05
    2b52:	6c 83       	std	Y+4, r22	; 0x04
    2b54:	4e 83       	std	Y+6, r20	; 0x06
    2b56:	38 87       	std	Y+8, r19	; 0x08
    2b58:	2f 83       	std	Y+7, r18	; 0x07
    2b5a:	1a 87       	std	Y+10, r17	; 0x0a
    2b5c:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2b5e:	19 82       	std	Y+1, r1	; 0x01
    2b60:	22 c0       	rjmp	.+68     	; 0x2ba6 <prvInitialiseTCBVariables+0x72>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    2b62:	89 81       	ldd	r24, Y+1	; 0x01
    2b64:	88 2f       	mov	r24, r24
    2b66:	90 e0       	ldi	r25, 0x00	; 0
    2b68:	29 81       	ldd	r18, Y+1	; 0x01
    2b6a:	22 2f       	mov	r18, r18
    2b6c:	30 e0       	ldi	r19, 0x00	; 0
    2b6e:	4c 81       	ldd	r20, Y+4	; 0x04
    2b70:	5d 81       	ldd	r21, Y+5	; 0x05
    2b72:	24 0f       	add	r18, r20
    2b74:	35 1f       	adc	r19, r21
    2b76:	f9 01       	movw	r30, r18
    2b78:	40 81       	ld	r20, Z
    2b7a:	2a 81       	ldd	r18, Y+2	; 0x02
    2b7c:	3b 81       	ldd	r19, Y+3	; 0x03
    2b7e:	82 0f       	add	r24, r18
    2b80:	93 1f       	adc	r25, r19
    2b82:	49 96       	adiw	r24, 0x19	; 25
    2b84:	fc 01       	movw	r30, r24
    2b86:	40 83       	st	Z, r20

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    2b88:	89 81       	ldd	r24, Y+1	; 0x01
    2b8a:	88 2f       	mov	r24, r24
    2b8c:	90 e0       	ldi	r25, 0x00	; 0
    2b8e:	2c 81       	ldd	r18, Y+4	; 0x04
    2b90:	3d 81       	ldd	r19, Y+5	; 0x05
    2b92:	82 0f       	add	r24, r18
    2b94:	93 1f       	adc	r25, r19
    2b96:	fc 01       	movw	r30, r24
    2b98:	80 81       	ld	r24, Z
    2b9a:	88 23       	and	r24, r24
    2b9c:	09 f4       	brne	.+2      	; 0x2ba0 <prvInitialiseTCBVariables+0x6c>
		{
			break;
    2b9e:	06 c0       	rjmp	.+12     	; 0x2bac <prvInitialiseTCBVariables+0x78>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2ba0:	89 81       	ldd	r24, Y+1	; 0x01
    2ba2:	8f 5f       	subi	r24, 0xFF	; 255
    2ba4:	89 83       	std	Y+1, r24	; 0x01
    2ba6:	89 81       	ldd	r24, Y+1	; 0x01
    2ba8:	88 30       	cpi	r24, 0x08	; 8
    2baa:	d8 f2       	brcs	.-74     	; 0x2b62 <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    2bac:	8a 81       	ldd	r24, Y+2	; 0x02
    2bae:	9b 81       	ldd	r25, Y+3	; 0x03
    2bb0:	fc 01       	movw	r30, r24
    2bb2:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2bb4:	8e 81       	ldd	r24, Y+6	; 0x06
    2bb6:	84 30       	cpi	r24, 0x04	; 4
    2bb8:	10 f0       	brcs	.+4      	; 0x2bbe <prvInitialiseTCBVariables+0x8a>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    2bba:	83 e0       	ldi	r24, 0x03	; 3
    2bbc:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    2bbe:	8a 81       	ldd	r24, Y+2	; 0x02
    2bc0:	9b 81       	ldd	r25, Y+3	; 0x03
    2bc2:	2e 81       	ldd	r18, Y+6	; 0x06
    2bc4:	fc 01       	movw	r30, r24
    2bc6:	26 8b       	std	Z+22, r18	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2bc8:	8a 81       	ldd	r24, Y+2	; 0x02
    2bca:	9b 81       	ldd	r25, Y+3	; 0x03
    2bcc:	02 96       	adiw	r24, 0x02	; 2
    2bce:	0e 94 74 04 	call	0x8e8	; 0x8e8 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2bd2:	8a 81       	ldd	r24, Y+2	; 0x02
    2bd4:	9b 81       	ldd	r25, Y+3	; 0x03
    2bd6:	0c 96       	adiw	r24, 0x0c	; 12
    2bd8:	0e 94 74 04 	call	0x8e8	; 0x8e8 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2bdc:	8a 81       	ldd	r24, Y+2	; 0x02
    2bde:	9b 81       	ldd	r25, Y+3	; 0x03
    2be0:	2a 81       	ldd	r18, Y+2	; 0x02
    2be2:	3b 81       	ldd	r19, Y+3	; 0x03
    2be4:	fc 01       	movw	r30, r24
    2be6:	31 87       	std	Z+9, r19	; 0x09
    2be8:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2bea:	8e 81       	ldd	r24, Y+6	; 0x06
    2bec:	88 2f       	mov	r24, r24
    2bee:	90 e0       	ldi	r25, 0x00	; 0
    2bf0:	24 e0       	ldi	r18, 0x04	; 4
    2bf2:	30 e0       	ldi	r19, 0x00	; 0
    2bf4:	28 1b       	sub	r18, r24
    2bf6:	39 0b       	sbc	r19, r25
    2bf8:	8a 81       	ldd	r24, Y+2	; 0x02
    2bfa:	9b 81       	ldd	r25, Y+3	; 0x03
    2bfc:	fc 01       	movw	r30, r24
    2bfe:	35 87       	std	Z+13, r19	; 0x0d
    2c00:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2c02:	8a 81       	ldd	r24, Y+2	; 0x02
    2c04:	9b 81       	ldd	r25, Y+3	; 0x03
    2c06:	2a 81       	ldd	r18, Y+2	; 0x02
    2c08:	3b 81       	ldd	r19, Y+3	; 0x03
    2c0a:	fc 01       	movw	r30, r24
    2c0c:	33 8b       	std	Z+19, r19	; 0x13
    2c0e:	22 8b       	std	Z+18, r18	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    2c10:	8a 81       	ldd	r24, Y+2	; 0x02
    2c12:	9b 81       	ldd	r25, Y+3	; 0x03
    2c14:	fc 01       	movw	r30, r24
    2c16:	11 a2       	std	Z+33, r1	; 0x21
    2c18:	12 a2       	std	Z+34, r1	; 0x22
    2c1a:	13 a2       	std	Z+35, r1	; 0x23
    2c1c:	14 a2       	std	Z+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
    2c1e:	8a 81       	ldd	r24, Y+2	; 0x02
    2c20:	9b 81       	ldd	r25, Y+3	; 0x03
    2c22:	fc 01       	movw	r30, r24
    2c24:	15 a2       	std	Z+37, r1	; 0x25
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    2c26:	2a 96       	adiw	r28, 0x0a	; 10
    2c28:	0f b6       	in	r0, 0x3f	; 63
    2c2a:	f8 94       	cli
    2c2c:	de bf       	out	0x3e, r29	; 62
    2c2e:	0f be       	out	0x3f, r0	; 63
    2c30:	cd bf       	out	0x3d, r28	; 61
    2c32:	df 91       	pop	r29
    2c34:	cf 91       	pop	r28
    2c36:	1f 91       	pop	r17
    2c38:	0f 91       	pop	r16
    2c3a:	08 95       	ret

00002c3c <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    2c3c:	cf 93       	push	r28
    2c3e:	df 93       	push	r29
    2c40:	1f 92       	push	r1
    2c42:	cd b7       	in	r28, 0x3d	; 61
    2c44:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2c46:	19 82       	std	Y+1, r1	; 0x01
    2c48:	13 c0       	rjmp	.+38     	; 0x2c70 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    2c4a:	89 81       	ldd	r24, Y+1	; 0x01
    2c4c:	28 2f       	mov	r18, r24
    2c4e:	30 e0       	ldi	r19, 0x00	; 0
    2c50:	c9 01       	movw	r24, r18
    2c52:	88 0f       	add	r24, r24
    2c54:	99 1f       	adc	r25, r25
    2c56:	88 0f       	add	r24, r24
    2c58:	99 1f       	adc	r25, r25
    2c5a:	88 0f       	add	r24, r24
    2c5c:	99 1f       	adc	r25, r25
    2c5e:	82 0f       	add	r24, r18
    2c60:	93 1f       	adc	r25, r19
    2c62:	89 5e       	subi	r24, 0xE9	; 233
    2c64:	9a 4f       	sbci	r25, 0xFA	; 250
    2c66:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2c6a:	89 81       	ldd	r24, Y+1	; 0x01
    2c6c:	8f 5f       	subi	r24, 0xFF	; 255
    2c6e:	89 83       	std	Y+1, r24	; 0x01
    2c70:	89 81       	ldd	r24, Y+1	; 0x01
    2c72:	84 30       	cpi	r24, 0x04	; 4
    2c74:	50 f3       	brcs	.-44     	; 0x2c4a <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    2c76:	8b e3       	ldi	r24, 0x3B	; 59
    2c78:	95 e0       	ldi	r25, 0x05	; 5
    2c7a:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    2c7e:	84 e4       	ldi	r24, 0x44	; 68
    2c80:	95 e0       	ldi	r25, 0x05	; 5
    2c82:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
	vListInitialise( &xPendingReadyList );
    2c86:	81 e5       	ldi	r24, 0x51	; 81
    2c88:	95 e0       	ldi	r25, 0x05	; 5
    2c8a:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    2c8e:	8a e5       	ldi	r24, 0x5A	; 90
    2c90:	95 e0       	ldi	r25, 0x05	; 5
    2c92:	0e 94 3f 04 	call	0x87e	; 0x87e <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2c96:	8b e3       	ldi	r24, 0x3B	; 59
    2c98:	95 e0       	ldi	r25, 0x05	; 5
    2c9a:	90 93 4e 05 	sts	0x054E, r25
    2c9e:	80 93 4d 05 	sts	0x054D, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2ca2:	84 e4       	ldi	r24, 0x44	; 68
    2ca4:	95 e0       	ldi	r25, 0x05	; 5
    2ca6:	90 93 50 05 	sts	0x0550, r25
    2caa:	80 93 4f 05 	sts	0x054F, r24
}
    2cae:	0f 90       	pop	r0
    2cb0:	df 91       	pop	r29
    2cb2:	cf 91       	pop	r28
    2cb4:	08 95       	ret

00002cb6 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2cb6:	cf 93       	push	r28
    2cb8:	df 93       	push	r29
    2cba:	00 d0       	rcall	.+0      	; 0x2cbc <prvCheckTasksWaitingTermination+0x6>
    2cbc:	1f 92       	push	r1
    2cbe:	cd b7       	in	r28, 0x3d	; 61
    2cc0:	de b7       	in	r29, 0x3e	; 62
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    2cc2:	2f c0       	rjmp	.+94     	; 0x2d22 <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
    2cc4:	0e 94 80 11 	call	0x2300	; 0x2300 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2cc8:	90 91 5a 05 	lds	r25, 0x055A
    2ccc:	81 e0       	ldi	r24, 0x01	; 1
    2cce:	99 23       	and	r25, r25
    2cd0:	09 f0       	breq	.+2      	; 0x2cd4 <prvCheckTasksWaitingTermination+0x1e>
    2cd2:	80 e0       	ldi	r24, 0x00	; 0
    2cd4:	89 83       	std	Y+1, r24	; 0x01
			}
			( void ) xTaskResumeAll();
    2cd6:	0e 94 8c 11 	call	0x2318	; 0x2318 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2cda:	89 81       	ldd	r24, Y+1	; 0x01
    2cdc:	88 23       	and	r24, r24
    2cde:	09 f5       	brne	.+66     	; 0x2d22 <prvCheckTasksWaitingTermination+0x6c>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    2ce0:	0f b6       	in	r0, 0x3f	; 63
    2ce2:	f8 94       	cli
    2ce4:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    2ce6:	80 91 5f 05 	lds	r24, 0x055F
    2cea:	90 91 60 05 	lds	r25, 0x0560
    2cee:	fc 01       	movw	r30, r24
    2cf0:	86 81       	ldd	r24, Z+6	; 0x06
    2cf2:	97 81       	ldd	r25, Z+7	; 0x07
    2cf4:	9b 83       	std	Y+3, r25	; 0x03
    2cf6:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    2cf8:	8a 81       	ldd	r24, Y+2	; 0x02
    2cfa:	9b 81       	ldd	r25, Y+3	; 0x03
    2cfc:	02 96       	adiw	r24, 0x02	; 2
    2cfe:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
					--uxCurrentNumberOfTasks;
    2d02:	80 91 64 05 	lds	r24, 0x0564
    2d06:	81 50       	subi	r24, 0x01	; 1
    2d08:	80 93 64 05 	sts	0x0564, r24
					--uxTasksDeleted;
    2d0c:	80 91 63 05 	lds	r24, 0x0563
    2d10:	81 50       	subi	r24, 0x01	; 1
    2d12:	80 93 63 05 	sts	0x0563, r24
				}
				taskEXIT_CRITICAL();
    2d16:	0f 90       	pop	r0
    2d18:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2d1a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d1c:	9b 81       	ldd	r25, Y+3	; 0x03
    2d1e:	0e 94 28 17 	call	0x2e50	; 0x2e50 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    2d22:	80 91 63 05 	lds	r24, 0x0563
    2d26:	88 23       	and	r24, r24
    2d28:	69 f6       	brne	.-102    	; 0x2cc4 <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    2d2a:	0f 90       	pop	r0
    2d2c:	0f 90       	pop	r0
    2d2e:	0f 90       	pop	r0
    2d30:	df 91       	pop	r29
    2d32:	cf 91       	pop	r28
    2d34:	08 95       	ret

00002d36 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    2d36:	cf 93       	push	r28
    2d38:	df 93       	push	r29
    2d3a:	00 d0       	rcall	.+0      	; 0x2d3c <prvAddCurrentTaskToDelayedList+0x6>
    2d3c:	cd b7       	in	r28, 0x3d	; 61
    2d3e:	de b7       	in	r29, 0x3e	; 62
    2d40:	9a 83       	std	Y+2, r25	; 0x02
    2d42:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2d44:	80 91 15 05 	lds	r24, 0x0515
    2d48:	90 91 16 05 	lds	r25, 0x0516
    2d4c:	29 81       	ldd	r18, Y+1	; 0x01
    2d4e:	3a 81       	ldd	r19, Y+2	; 0x02
    2d50:	fc 01       	movw	r30, r24
    2d52:	33 83       	std	Z+3, r19	; 0x03
    2d54:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    2d56:	80 91 65 05 	lds	r24, 0x0565
    2d5a:	90 91 66 05 	lds	r25, 0x0566
    2d5e:	29 81       	ldd	r18, Y+1	; 0x01
    2d60:	3a 81       	ldd	r19, Y+2	; 0x02
    2d62:	28 17       	cp	r18, r24
    2d64:	39 07       	cpc	r19, r25
    2d66:	78 f4       	brcc	.+30     	; 0x2d86 <prvAddCurrentTaskToDelayedList+0x50>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    2d68:	80 91 15 05 	lds	r24, 0x0515
    2d6c:	90 91 16 05 	lds	r25, 0x0516
    2d70:	9c 01       	movw	r18, r24
    2d72:	2e 5f       	subi	r18, 0xFE	; 254
    2d74:	3f 4f       	sbci	r19, 0xFF	; 255
    2d76:	80 91 4f 05 	lds	r24, 0x054F
    2d7a:	90 91 50 05 	lds	r25, 0x0550
    2d7e:	b9 01       	movw	r22, r18
    2d80:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <vListInsert>
    2d84:	1d c0       	rjmp	.+58     	; 0x2dc0 <prvAddCurrentTaskToDelayedList+0x8a>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    2d86:	80 91 15 05 	lds	r24, 0x0515
    2d8a:	90 91 16 05 	lds	r25, 0x0516
    2d8e:	9c 01       	movw	r18, r24
    2d90:	2e 5f       	subi	r18, 0xFE	; 254
    2d92:	3f 4f       	sbci	r19, 0xFF	; 255
    2d94:	80 91 4d 05 	lds	r24, 0x054D
    2d98:	90 91 4e 05 	lds	r25, 0x054E
    2d9c:	b9 01       	movw	r22, r18
    2d9e:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    2da2:	80 91 6d 05 	lds	r24, 0x056D
    2da6:	90 91 6e 05 	lds	r25, 0x056E
    2daa:	29 81       	ldd	r18, Y+1	; 0x01
    2dac:	3a 81       	ldd	r19, Y+2	; 0x02
    2dae:	28 17       	cp	r18, r24
    2db0:	39 07       	cpc	r19, r25
    2db2:	30 f4       	brcc	.+12     	; 0x2dc0 <prvAddCurrentTaskToDelayedList+0x8a>
		{
			xNextTaskUnblockTime = xTimeToWake;
    2db4:	89 81       	ldd	r24, Y+1	; 0x01
    2db6:	9a 81       	ldd	r25, Y+2	; 0x02
    2db8:	90 93 6e 05 	sts	0x056E, r25
    2dbc:	80 93 6d 05 	sts	0x056D, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    2dc0:	0f 90       	pop	r0
    2dc2:	0f 90       	pop	r0
    2dc4:	df 91       	pop	r29
    2dc6:	cf 91       	pop	r28
    2dc8:	08 95       	ret

00002dca <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    2dca:	cf 93       	push	r28
    2dcc:	df 93       	push	r29
    2dce:	cd b7       	in	r28, 0x3d	; 61
    2dd0:	de b7       	in	r29, 0x3e	; 62
    2dd2:	28 97       	sbiw	r28, 0x08	; 8
    2dd4:	0f b6       	in	r0, 0x3f	; 63
    2dd6:	f8 94       	cli
    2dd8:	de bf       	out	0x3e, r29	; 62
    2dda:	0f be       	out	0x3f, r0	; 63
    2ddc:	cd bf       	out	0x3d, r28	; 61
    2dde:	9e 83       	std	Y+6, r25	; 0x06
    2de0:	8d 83       	std	Y+5, r24	; 0x05
    2de2:	78 87       	std	Y+8, r23	; 0x08
    2de4:	6f 83       	std	Y+7, r22	; 0x07
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2de6:	8f 81       	ldd	r24, Y+7	; 0x07
    2de8:	98 85       	ldd	r25, Y+8	; 0x08
    2dea:	89 2b       	or	r24, r25
    2dec:	29 f4       	brne	.+10     	; 0x2df8 <prvAllocateTCBAndStack+0x2e>
    2dee:	8d 81       	ldd	r24, Y+5	; 0x05
    2df0:	9e 81       	ldd	r25, Y+6	; 0x06
    2df2:	0e 94 a5 08 	call	0x114a	; 0x114a <pvPortMalloc>
    2df6:	02 c0       	rjmp	.+4      	; 0x2dfc <prvAllocateTCBAndStack+0x32>
    2df8:	8f 81       	ldd	r24, Y+7	; 0x07
    2dfa:	98 85       	ldd	r25, Y+8	; 0x08
    2dfc:	9c 83       	std	Y+4, r25	; 0x04
    2dfe:	8b 83       	std	Y+3, r24	; 0x03

		if( pxStack != NULL )
    2e00:	8b 81       	ldd	r24, Y+3	; 0x03
    2e02:	9c 81       	ldd	r25, Y+4	; 0x04
    2e04:	89 2b       	or	r24, r25
    2e06:	b9 f0       	breq	.+46     	; 0x2e36 <prvAllocateTCBAndStack+0x6c>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    2e08:	86 e2       	ldi	r24, 0x26	; 38
    2e0a:	90 e0       	ldi	r25, 0x00	; 0
    2e0c:	0e 94 a5 08 	call	0x114a	; 0x114a <pvPortMalloc>
    2e10:	9a 83       	std	Y+2, r25	; 0x02
    2e12:	89 83       	std	Y+1, r24	; 0x01

			if( pxNewTCB != NULL )
    2e14:	89 81       	ldd	r24, Y+1	; 0x01
    2e16:	9a 81       	ldd	r25, Y+2	; 0x02
    2e18:	89 2b       	or	r24, r25
    2e1a:	41 f0       	breq	.+16     	; 0x2e2c <prvAllocateTCBAndStack+0x62>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    2e1c:	89 81       	ldd	r24, Y+1	; 0x01
    2e1e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e20:	2b 81       	ldd	r18, Y+3	; 0x03
    2e22:	3c 81       	ldd	r19, Y+4	; 0x04
    2e24:	fc 01       	movw	r30, r24
    2e26:	30 8f       	std	Z+24, r19	; 0x18
    2e28:	27 8b       	std	Z+23, r18	; 0x17
    2e2a:	07 c0       	rjmp	.+14     	; 0x2e3a <prvAllocateTCBAndStack+0x70>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    2e2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e2e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e30:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <vPortFree>
    2e34:	02 c0       	rjmp	.+4      	; 0x2e3a <prvAllocateTCBAndStack+0x70>
			}
		}
		else
		{
			pxNewTCB = NULL;
    2e36:	1a 82       	std	Y+2, r1	; 0x02
    2e38:	19 82       	std	Y+1, r1	; 0x01
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
		}
		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
	}

	return pxNewTCB;
    2e3a:	89 81       	ldd	r24, Y+1	; 0x01
    2e3c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2e3e:	28 96       	adiw	r28, 0x08	; 8
    2e40:	0f b6       	in	r0, 0x3f	; 63
    2e42:	f8 94       	cli
    2e44:	de bf       	out	0x3e, r29	; 62
    2e46:	0f be       	out	0x3f, r0	; 63
    2e48:	cd bf       	out	0x3d, r28	; 61
    2e4a:	df 91       	pop	r29
    2e4c:	cf 91       	pop	r28
    2e4e:	08 95       	ret

00002e50 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    2e50:	cf 93       	push	r28
    2e52:	df 93       	push	r29
    2e54:	00 d0       	rcall	.+0      	; 0x2e56 <prvDeleteTCB+0x6>
    2e56:	cd b7       	in	r28, 0x3d	; 61
    2e58:	de b7       	in	r29, 0x3e	; 62
    2e5a:	9a 83       	std	Y+2, r25	; 0x02
    2e5c:	89 83       	std	Y+1, r24	; 0x01
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
    2e5e:	89 81       	ldd	r24, Y+1	; 0x01
    2e60:	9a 81       	ldd	r25, Y+2	; 0x02
    2e62:	fc 01       	movw	r30, r24
    2e64:	87 89       	ldd	r24, Z+23	; 0x17
    2e66:	90 8d       	ldd	r25, Z+24	; 0x18
    2e68:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
    2e6c:	89 81       	ldd	r24, Y+1	; 0x01
    2e6e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e70:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <vPortFree>
	}
    2e74:	0f 90       	pop	r0
    2e76:	0f 90       	pop	r0
    2e78:	df 91       	pop	r29
    2e7a:	cf 91       	pop	r28
    2e7c:	08 95       	ret

00002e7e <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    2e7e:	cf 93       	push	r28
    2e80:	df 93       	push	r29
    2e82:	00 d0       	rcall	.+0      	; 0x2e84 <prvResetNextTaskUnblockTime+0x6>
    2e84:	cd b7       	in	r28, 0x3d	; 61
    2e86:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2e88:	80 91 4d 05 	lds	r24, 0x054D
    2e8c:	90 91 4e 05 	lds	r25, 0x054E
    2e90:	fc 01       	movw	r30, r24
    2e92:	80 81       	ld	r24, Z
    2e94:	88 23       	and	r24, r24
    2e96:	39 f4       	brne	.+14     	; 0x2ea6 <prvResetNextTaskUnblockTime+0x28>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    2e98:	8f ef       	ldi	r24, 0xFF	; 255
    2e9a:	9f ef       	ldi	r25, 0xFF	; 255
    2e9c:	90 93 6e 05 	sts	0x056E, r25
    2ea0:	80 93 6d 05 	sts	0x056D, r24
    2ea4:	15 c0       	rjmp	.+42     	; 0x2ed0 <prvResetNextTaskUnblockTime+0x52>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2ea6:	80 91 4d 05 	lds	r24, 0x054D
    2eaa:	90 91 4e 05 	lds	r25, 0x054E
    2eae:	fc 01       	movw	r30, r24
    2eb0:	85 81       	ldd	r24, Z+5	; 0x05
    2eb2:	96 81       	ldd	r25, Z+6	; 0x06
    2eb4:	fc 01       	movw	r30, r24
    2eb6:	86 81       	ldd	r24, Z+6	; 0x06
    2eb8:	97 81       	ldd	r25, Z+7	; 0x07
    2eba:	9a 83       	std	Y+2, r25	; 0x02
    2ebc:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    2ebe:	89 81       	ldd	r24, Y+1	; 0x01
    2ec0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ec2:	fc 01       	movw	r30, r24
    2ec4:	82 81       	ldd	r24, Z+2	; 0x02
    2ec6:	93 81       	ldd	r25, Z+3	; 0x03
    2ec8:	90 93 6e 05 	sts	0x056E, r25
    2ecc:	80 93 6d 05 	sts	0x056D, r24
	}
}
    2ed0:	0f 90       	pop	r0
    2ed2:	0f 90       	pop	r0
    2ed4:	df 91       	pop	r29
    2ed6:	cf 91       	pop	r28
    2ed8:	08 95       	ret

00002eda <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    2eda:	cf 93       	push	r28
    2edc:	df 93       	push	r29
    2ede:	00 d0       	rcall	.+0      	; 0x2ee0 <uxTaskResetEventItemValue+0x6>
    2ee0:	cd b7       	in	r28, 0x3d	; 61
    2ee2:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    2ee4:	80 91 15 05 	lds	r24, 0x0515
    2ee8:	90 91 16 05 	lds	r25, 0x0516
    2eec:	fc 01       	movw	r30, r24
    2eee:	84 85       	ldd	r24, Z+12	; 0x0c
    2ef0:	95 85       	ldd	r25, Z+13	; 0x0d
    2ef2:	9a 83       	std	Y+2, r25	; 0x02
    2ef4:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2ef6:	80 91 15 05 	lds	r24, 0x0515
    2efa:	90 91 16 05 	lds	r25, 0x0516
    2efe:	20 91 15 05 	lds	r18, 0x0515
    2f02:	30 91 16 05 	lds	r19, 0x0516
    2f06:	f9 01       	movw	r30, r18
    2f08:	26 89       	ldd	r18, Z+22	; 0x16
    2f0a:	22 2f       	mov	r18, r18
    2f0c:	30 e0       	ldi	r19, 0x00	; 0
    2f0e:	44 e0       	ldi	r20, 0x04	; 4
    2f10:	50 e0       	ldi	r21, 0x00	; 0
    2f12:	ba 01       	movw	r22, r20
    2f14:	62 1b       	sub	r22, r18
    2f16:	73 0b       	sbc	r23, r19
    2f18:	9b 01       	movw	r18, r22
    2f1a:	fc 01       	movw	r30, r24
    2f1c:	35 87       	std	Z+13, r19	; 0x0d
    2f1e:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
    2f20:	89 81       	ldd	r24, Y+1	; 0x01
    2f22:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2f24:	0f 90       	pop	r0
    2f26:	0f 90       	pop	r0
    2f28:	df 91       	pop	r29
    2f2a:	cf 91       	pop	r28
    2f2c:	08 95       	ret

00002f2e <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    2f2e:	cf 93       	push	r28
    2f30:	df 93       	push	r29
    2f32:	cd b7       	in	r28, 0x3d	; 61
    2f34:	de b7       	in	r29, 0x3e	; 62
    2f36:	29 97       	sbiw	r28, 0x09	; 9
    2f38:	0f b6       	in	r0, 0x3f	; 63
    2f3a:	f8 94       	cli
    2f3c:	de bf       	out	0x3e, r29	; 62
    2f3e:	0f be       	out	0x3f, r0	; 63
    2f40:	cd bf       	out	0x3d, r28	; 61
    2f42:	8f 83       	std	Y+7, r24	; 0x07
    2f44:	79 87       	std	Y+9, r23	; 0x09
    2f46:	68 87       	std	Y+8, r22	; 0x08
	TickType_t xTimeToWake;
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    2f48:	0f b6       	in	r0, 0x3f	; 63
    2f4a:	f8 94       	cli
    2f4c:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    2f4e:	80 91 15 05 	lds	r24, 0x0515
    2f52:	90 91 16 05 	lds	r25, 0x0516
    2f56:	fc 01       	movw	r30, r24
    2f58:	81 a1       	ldd	r24, Z+33	; 0x21
    2f5a:	92 a1       	ldd	r25, Z+34	; 0x22
    2f5c:	a3 a1       	ldd	r26, Z+35	; 0x23
    2f5e:	b4 a1       	ldd	r27, Z+36	; 0x24
    2f60:	89 2b       	or	r24, r25
    2f62:	8a 2b       	or	r24, r26
    2f64:	8b 2b       	or	r24, r27
    2f66:	11 f5       	brne	.+68     	; 0x2fac <ulTaskNotifyTake+0x7e>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    2f68:	80 91 15 05 	lds	r24, 0x0515
    2f6c:	90 91 16 05 	lds	r25, 0x0516
    2f70:	21 e0       	ldi	r18, 0x01	; 1
    2f72:	fc 01       	movw	r30, r24
    2f74:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    2f76:	88 85       	ldd	r24, Y+8	; 0x08
    2f78:	99 85       	ldd	r25, Y+9	; 0x09
    2f7a:	89 2b       	or	r24, r25
    2f7c:	b9 f0       	breq	.+46     	; 0x2fac <ulTaskNotifyTake+0x7e>
				{
					/* The task is going to block.  First it must be removed
					from the ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2f7e:	80 91 15 05 	lds	r24, 0x0515
    2f82:	90 91 16 05 	lds	r25, 0x0516
    2f86:	02 96       	adiw	r24, 0x02	; 2
    2f88:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
					{
							/* Calculate the time at which the task should be
							woken if the event does not occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    2f8c:	20 91 65 05 	lds	r18, 0x0565
    2f90:	30 91 66 05 	lds	r19, 0x0566
    2f94:	88 85       	ldd	r24, Y+8	; 0x08
    2f96:	99 85       	ldd	r25, Y+9	; 0x09
    2f98:	82 0f       	add	r24, r18
    2f9a:	93 1f       	adc	r25, r19
    2f9c:	9a 83       	std	Y+2, r25	; 0x02
    2f9e:	89 83       	std	Y+1, r24	; 0x01
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    2fa0:	89 81       	ldd	r24, Y+1	; 0x01
    2fa2:	9a 81       	ldd	r25, Y+2	; 0x02
    2fa4:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2fa8:	0e 94 86 07 	call	0xf0c	; 0xf0c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2fac:	0f 90       	pop	r0
    2fae:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    2fb0:	0f b6       	in	r0, 0x3f	; 63
    2fb2:	f8 94       	cli
    2fb4:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    2fb6:	80 91 15 05 	lds	r24, 0x0515
    2fba:	90 91 16 05 	lds	r25, 0x0516
    2fbe:	fc 01       	movw	r30, r24
    2fc0:	81 a1       	ldd	r24, Z+33	; 0x21
    2fc2:	92 a1       	ldd	r25, Z+34	; 0x22
    2fc4:	a3 a1       	ldd	r26, Z+35	; 0x23
    2fc6:	b4 a1       	ldd	r27, Z+36	; 0x24
    2fc8:	8b 83       	std	Y+3, r24	; 0x03
    2fca:	9c 83       	std	Y+4, r25	; 0x04
    2fcc:	ad 83       	std	Y+5, r26	; 0x05
    2fce:	be 83       	std	Y+6, r27	; 0x06

			if( ulReturn != 0UL )
    2fd0:	8b 81       	ldd	r24, Y+3	; 0x03
    2fd2:	9c 81       	ldd	r25, Y+4	; 0x04
    2fd4:	ad 81       	ldd	r26, Y+5	; 0x05
    2fd6:	be 81       	ldd	r27, Y+6	; 0x06
    2fd8:	89 2b       	or	r24, r25
    2fda:	8a 2b       	or	r24, r26
    2fdc:	8b 2b       	or	r24, r27
    2fde:	f1 f0       	breq	.+60     	; 0x301c <ulTaskNotifyTake+0xee>
			{
				if( xClearCountOnExit != pdFALSE )
    2fe0:	8f 81       	ldd	r24, Y+7	; 0x07
    2fe2:	88 23       	and	r24, r24
    2fe4:	51 f0       	breq	.+20     	; 0x2ffa <ulTaskNotifyTake+0xcc>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    2fe6:	80 91 15 05 	lds	r24, 0x0515
    2fea:	90 91 16 05 	lds	r25, 0x0516
    2fee:	fc 01       	movw	r30, r24
    2ff0:	11 a2       	std	Z+33, r1	; 0x21
    2ff2:	12 a2       	std	Z+34, r1	; 0x22
    2ff4:	13 a2       	std	Z+35, r1	; 0x23
    2ff6:	14 a2       	std	Z+36, r1	; 0x24
    2ff8:	11 c0       	rjmp	.+34     	; 0x301c <ulTaskNotifyTake+0xee>
				}
				else
				{
					( pxCurrentTCB->ulNotifiedValue )--;
    2ffa:	20 91 15 05 	lds	r18, 0x0515
    2ffe:	30 91 16 05 	lds	r19, 0x0516
    3002:	f9 01       	movw	r30, r18
    3004:	81 a1       	ldd	r24, Z+33	; 0x21
    3006:	92 a1       	ldd	r25, Z+34	; 0x22
    3008:	a3 a1       	ldd	r26, Z+35	; 0x23
    300a:	b4 a1       	ldd	r27, Z+36	; 0x24
    300c:	01 97       	sbiw	r24, 0x01	; 1
    300e:	a1 09       	sbc	r26, r1
    3010:	b1 09       	sbc	r27, r1
    3012:	f9 01       	movw	r30, r18
    3014:	81 a3       	std	Z+33, r24	; 0x21
    3016:	92 a3       	std	Z+34, r25	; 0x22
    3018:	a3 a3       	std	Z+35, r26	; 0x23
    301a:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    301c:	80 91 15 05 	lds	r24, 0x0515
    3020:	90 91 16 05 	lds	r25, 0x0516
    3024:	fc 01       	movw	r30, r24
    3026:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    3028:	0f 90       	pop	r0
    302a:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    302c:	8b 81       	ldd	r24, Y+3	; 0x03
    302e:	9c 81       	ldd	r25, Y+4	; 0x04
    3030:	ad 81       	ldd	r26, Y+5	; 0x05
    3032:	be 81       	ldd	r27, Y+6	; 0x06
	}
    3034:	bc 01       	movw	r22, r24
    3036:	cd 01       	movw	r24, r26
    3038:	29 96       	adiw	r28, 0x09	; 9
    303a:	0f b6       	in	r0, 0x3f	; 63
    303c:	f8 94       	cli
    303e:	de bf       	out	0x3e, r29	; 62
    3040:	0f be       	out	0x3f, r0	; 63
    3042:	cd bf       	out	0x3d, r28	; 61
    3044:	df 91       	pop	r29
    3046:	cf 91       	pop	r28
    3048:	08 95       	ret

0000304a <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    304a:	ef 92       	push	r14
    304c:	ff 92       	push	r15
    304e:	0f 93       	push	r16
    3050:	1f 93       	push	r17
    3052:	cf 93       	push	r28
    3054:	df 93       	push	r29
    3056:	cd b7       	in	r28, 0x3d	; 61
    3058:	de b7       	in	r29, 0x3e	; 62
    305a:	2f 97       	sbiw	r28, 0x0f	; 15
    305c:	0f b6       	in	r0, 0x3f	; 63
    305e:	f8 94       	cli
    3060:	de bf       	out	0x3e, r29	; 62
    3062:	0f be       	out	0x3f, r0	; 63
    3064:	cd bf       	out	0x3d, r28	; 61
    3066:	6c 83       	std	Y+4, r22	; 0x04
    3068:	7d 83       	std	Y+5, r23	; 0x05
    306a:	8e 83       	std	Y+6, r24	; 0x06
    306c:	9f 83       	std	Y+7, r25	; 0x07
    306e:	28 87       	std	Y+8, r18	; 0x08
    3070:	39 87       	std	Y+9, r19	; 0x09
    3072:	4a 87       	std	Y+10, r20	; 0x0a
    3074:	5b 87       	std	Y+11, r21	; 0x0b
    3076:	1d 87       	std	Y+13, r17	; 0x0d
    3078:	0c 87       	std	Y+12, r16	; 0x0c
    307a:	ff 86       	std	Y+15, r15	; 0x0f
    307c:	ee 86       	std	Y+14, r14	; 0x0e
	TickType_t xTimeToWake;
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    307e:	0f b6       	in	r0, 0x3f	; 63
    3080:	f8 94       	cli
    3082:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->eNotifyState != eNotified )
    3084:	80 91 15 05 	lds	r24, 0x0515
    3088:	90 91 16 05 	lds	r25, 0x0516
    308c:	fc 01       	movw	r30, r24
    308e:	85 a1       	ldd	r24, Z+37	; 0x25
    3090:	82 30       	cpi	r24, 0x02	; 2
    3092:	e1 f1       	breq	.+120    	; 0x310c <xTaskNotifyWait+0xc2>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    3094:	60 91 15 05 	lds	r22, 0x0515
    3098:	70 91 16 05 	lds	r23, 0x0516
    309c:	fb 01       	movw	r30, r22
    309e:	21 a1       	ldd	r18, Z+33	; 0x21
    30a0:	32 a1       	ldd	r19, Z+34	; 0x22
    30a2:	43 a1       	ldd	r20, Z+35	; 0x23
    30a4:	54 a1       	ldd	r21, Z+36	; 0x24
    30a6:	8c 81       	ldd	r24, Y+4	; 0x04
    30a8:	9d 81       	ldd	r25, Y+5	; 0x05
    30aa:	ae 81       	ldd	r26, Y+6	; 0x06
    30ac:	bf 81       	ldd	r27, Y+7	; 0x07
    30ae:	80 95       	com	r24
    30b0:	90 95       	com	r25
    30b2:	a0 95       	com	r26
    30b4:	b0 95       	com	r27
    30b6:	82 23       	and	r24, r18
    30b8:	93 23       	and	r25, r19
    30ba:	a4 23       	and	r26, r20
    30bc:	b5 23       	and	r27, r21
    30be:	fb 01       	movw	r30, r22
    30c0:	81 a3       	std	Z+33, r24	; 0x21
    30c2:	92 a3       	std	Z+34, r25	; 0x22
    30c4:	a3 a3       	std	Z+35, r26	; 0x23
    30c6:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    30c8:	80 91 15 05 	lds	r24, 0x0515
    30cc:	90 91 16 05 	lds	r25, 0x0516
    30d0:	21 e0       	ldi	r18, 0x01	; 1
    30d2:	fc 01       	movw	r30, r24
    30d4:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    30d6:	8e 85       	ldd	r24, Y+14	; 0x0e
    30d8:	9f 85       	ldd	r25, Y+15	; 0x0f
    30da:	89 2b       	or	r24, r25
    30dc:	b9 f0       	breq	.+46     	; 0x310c <xTaskNotifyWait+0xc2>
				{
					/* The task is going to block.  First it must be removed
					from the	ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    30de:	80 91 15 05 	lds	r24, 0x0515
    30e2:	90 91 16 05 	lds	r25, 0x0516
    30e6:	02 96       	adiw	r24, 0x02	; 2
    30e8:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
					{
							/* Calculate the time at which the task should be
							woken if the event does not occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    30ec:	20 91 65 05 	lds	r18, 0x0565
    30f0:	30 91 66 05 	lds	r19, 0x0566
    30f4:	8e 85       	ldd	r24, Y+14	; 0x0e
    30f6:	9f 85       	ldd	r25, Y+15	; 0x0f
    30f8:	82 0f       	add	r24, r18
    30fa:	93 1f       	adc	r25, r19
    30fc:	9b 83       	std	Y+3, r25	; 0x03
    30fe:	8a 83       	std	Y+2, r24	; 0x02
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    3100:	8a 81       	ldd	r24, Y+2	; 0x02
    3102:	9b 81       	ldd	r25, Y+3	; 0x03
    3104:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    3108:	0e 94 86 07 	call	0xf0c	; 0xf0c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    310c:	0f 90       	pop	r0
    310e:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    3110:	0f b6       	in	r0, 0x3f	; 63
    3112:	f8 94       	cli
    3114:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    3116:	8c 85       	ldd	r24, Y+12	; 0x0c
    3118:	9d 85       	ldd	r25, Y+13	; 0x0d
    311a:	89 2b       	or	r24, r25
    311c:	81 f0       	breq	.+32     	; 0x313e <xTaskNotifyWait+0xf4>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    311e:	80 91 15 05 	lds	r24, 0x0515
    3122:	90 91 16 05 	lds	r25, 0x0516
    3126:	fc 01       	movw	r30, r24
    3128:	81 a1       	ldd	r24, Z+33	; 0x21
    312a:	92 a1       	ldd	r25, Z+34	; 0x22
    312c:	a3 a1       	ldd	r26, Z+35	; 0x23
    312e:	b4 a1       	ldd	r27, Z+36	; 0x24
    3130:	2c 85       	ldd	r18, Y+12	; 0x0c
    3132:	3d 85       	ldd	r19, Y+13	; 0x0d
    3134:	f9 01       	movw	r30, r18
    3136:	80 83       	st	Z, r24
    3138:	91 83       	std	Z+1, r25	; 0x01
    313a:	a2 83       	std	Z+2, r26	; 0x02
    313c:	b3 83       	std	Z+3, r27	; 0x03

			/* If eNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
    313e:	80 91 15 05 	lds	r24, 0x0515
    3142:	90 91 16 05 	lds	r25, 0x0516
    3146:	fc 01       	movw	r30, r24
    3148:	85 a1       	ldd	r24, Z+37	; 0x25
    314a:	81 30       	cpi	r24, 0x01	; 1
    314c:	11 f4       	brne	.+4      	; 0x3152 <xTaskNotifyWait+0x108>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    314e:	19 82       	std	Y+1, r1	; 0x01
    3150:	1c c0       	rjmp	.+56     	; 0x318a <xTaskNotifyWait+0x140>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    3152:	60 91 15 05 	lds	r22, 0x0515
    3156:	70 91 16 05 	lds	r23, 0x0516
    315a:	fb 01       	movw	r30, r22
    315c:	21 a1       	ldd	r18, Z+33	; 0x21
    315e:	32 a1       	ldd	r19, Z+34	; 0x22
    3160:	43 a1       	ldd	r20, Z+35	; 0x23
    3162:	54 a1       	ldd	r21, Z+36	; 0x24
    3164:	88 85       	ldd	r24, Y+8	; 0x08
    3166:	99 85       	ldd	r25, Y+9	; 0x09
    3168:	aa 85       	ldd	r26, Y+10	; 0x0a
    316a:	bb 85       	ldd	r27, Y+11	; 0x0b
    316c:	80 95       	com	r24
    316e:	90 95       	com	r25
    3170:	a0 95       	com	r26
    3172:	b0 95       	com	r27
    3174:	82 23       	and	r24, r18
    3176:	93 23       	and	r25, r19
    3178:	a4 23       	and	r26, r20
    317a:	b5 23       	and	r27, r21
    317c:	fb 01       	movw	r30, r22
    317e:	81 a3       	std	Z+33, r24	; 0x21
    3180:	92 a3       	std	Z+34, r25	; 0x22
    3182:	a3 a3       	std	Z+35, r26	; 0x23
    3184:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    3186:	81 e0       	ldi	r24, 0x01	; 1
    3188:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    318a:	80 91 15 05 	lds	r24, 0x0515
    318e:	90 91 16 05 	lds	r25, 0x0516
    3192:	fc 01       	movw	r30, r24
    3194:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    3196:	0f 90       	pop	r0
    3198:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    319a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    319c:	2f 96       	adiw	r28, 0x0f	; 15
    319e:	0f b6       	in	r0, 0x3f	; 63
    31a0:	f8 94       	cli
    31a2:	de bf       	out	0x3e, r29	; 62
    31a4:	0f be       	out	0x3f, r0	; 63
    31a6:	cd bf       	out	0x3d, r28	; 61
    31a8:	df 91       	pop	r29
    31aa:	cf 91       	pop	r28
    31ac:	1f 91       	pop	r17
    31ae:	0f 91       	pop	r16
    31b0:	ff 90       	pop	r15
    31b2:	ef 90       	pop	r14
    31b4:	08 95       	ret

000031b6 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    31b6:	0f 93       	push	r16
    31b8:	1f 93       	push	r17
    31ba:	cf 93       	push	r28
    31bc:	df 93       	push	r29
    31be:	cd b7       	in	r28, 0x3d	; 61
    31c0:	de b7       	in	r29, 0x3e	; 62
    31c2:	2d 97       	sbiw	r28, 0x0d	; 13
    31c4:	0f b6       	in	r0, 0x3f	; 63
    31c6:	f8 94       	cli
    31c8:	de bf       	out	0x3e, r29	; 62
    31ca:	0f be       	out	0x3f, r0	; 63
    31cc:	cd bf       	out	0x3d, r28	; 61
    31ce:	9e 83       	std	Y+6, r25	; 0x06
    31d0:	8d 83       	std	Y+5, r24	; 0x05
    31d2:	4f 83       	std	Y+7, r20	; 0x07
    31d4:	58 87       	std	Y+8, r21	; 0x08
    31d6:	69 87       	std	Y+9, r22	; 0x09
    31d8:	7a 87       	std	Y+10, r23	; 0x0a
    31da:	2b 87       	std	Y+11, r18	; 0x0b
    31dc:	1d 87       	std	Y+13, r17	; 0x0d
    31de:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    31e0:	81 e0       	ldi	r24, 0x01	; 1
    31e2:	89 83       	std	Y+1, r24	; 0x01

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
    31e4:	8d 81       	ldd	r24, Y+5	; 0x05
    31e6:	9e 81       	ldd	r25, Y+6	; 0x06
    31e8:	9b 83       	std	Y+3, r25	; 0x03
    31ea:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    31ec:	0f b6       	in	r0, 0x3f	; 63
    31ee:	f8 94       	cli
    31f0:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    31f2:	8c 85       	ldd	r24, Y+12	; 0x0c
    31f4:	9d 85       	ldd	r25, Y+13	; 0x0d
    31f6:	89 2b       	or	r24, r25
    31f8:	71 f0       	breq	.+28     	; 0x3216 <xTaskGenericNotify+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    31fa:	8a 81       	ldd	r24, Y+2	; 0x02
    31fc:	9b 81       	ldd	r25, Y+3	; 0x03
    31fe:	fc 01       	movw	r30, r24
    3200:	81 a1       	ldd	r24, Z+33	; 0x21
    3202:	92 a1       	ldd	r25, Z+34	; 0x22
    3204:	a3 a1       	ldd	r26, Z+35	; 0x23
    3206:	b4 a1       	ldd	r27, Z+36	; 0x24
    3208:	2c 85       	ldd	r18, Y+12	; 0x0c
    320a:	3d 85       	ldd	r19, Y+13	; 0x0d
    320c:	f9 01       	movw	r30, r18
    320e:	80 83       	st	Z, r24
    3210:	91 83       	std	Z+1, r25	; 0x01
    3212:	a2 83       	std	Z+2, r26	; 0x02
    3214:	b3 83       	std	Z+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    3216:	8a 81       	ldd	r24, Y+2	; 0x02
    3218:	9b 81       	ldd	r25, Y+3	; 0x03
    321a:	fc 01       	movw	r30, r24
    321c:	85 a1       	ldd	r24, Z+37	; 0x25
    321e:	8c 83       	std	Y+4, r24	; 0x04

			pxTCB->eNotifyState = eNotified;
    3220:	8a 81       	ldd	r24, Y+2	; 0x02
    3222:	9b 81       	ldd	r25, Y+3	; 0x03
    3224:	22 e0       	ldi	r18, 0x02	; 2
    3226:	fc 01       	movw	r30, r24
    3228:	25 a3       	std	Z+37, r18	; 0x25

			switch( eAction )
    322a:	8b 85       	ldd	r24, Y+11	; 0x0b
    322c:	88 2f       	mov	r24, r24
    322e:	90 e0       	ldi	r25, 0x00	; 0
    3230:	82 30       	cpi	r24, 0x02	; 2
    3232:	91 05       	cpc	r25, r1
    3234:	31 f1       	breq	.+76     	; 0x3282 <xTaskGenericNotify+0xcc>
    3236:	83 30       	cpi	r24, 0x03	; 3
    3238:	91 05       	cpc	r25, r1
    323a:	34 f4       	brge	.+12     	; 0x3248 <xTaskGenericNotify+0x92>
    323c:	00 97       	sbiw	r24, 0x00	; 0
    323e:	09 f4       	brne	.+2      	; 0x3242 <xTaskGenericNotify+0x8c>
    3240:	4f c0       	rjmp	.+158    	; 0x32e0 <xTaskGenericNotify+0x12a>
    3242:	01 97       	sbiw	r24, 0x01	; 1
    3244:	39 f0       	breq	.+14     	; 0x3254 <xTaskGenericNotify+0x9e>
    3246:	4d c0       	rjmp	.+154    	; 0x32e2 <xTaskGenericNotify+0x12c>
    3248:	83 30       	cpi	r24, 0x03	; 3
    324a:	91 05       	cpc	r25, r1
    324c:	61 f1       	breq	.+88     	; 0x32a6 <xTaskGenericNotify+0xf0>
    324e:	04 97       	sbiw	r24, 0x04	; 4
    3250:	b1 f1       	breq	.+108    	; 0x32be <xTaskGenericNotify+0x108>
    3252:	47 c0       	rjmp	.+142    	; 0x32e2 <xTaskGenericNotify+0x12c>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    3254:	8a 81       	ldd	r24, Y+2	; 0x02
    3256:	9b 81       	ldd	r25, Y+3	; 0x03
    3258:	fc 01       	movw	r30, r24
    325a:	21 a1       	ldd	r18, Z+33	; 0x21
    325c:	32 a1       	ldd	r19, Z+34	; 0x22
    325e:	43 a1       	ldd	r20, Z+35	; 0x23
    3260:	54 a1       	ldd	r21, Z+36	; 0x24
    3262:	8f 81       	ldd	r24, Y+7	; 0x07
    3264:	98 85       	ldd	r25, Y+8	; 0x08
    3266:	a9 85       	ldd	r26, Y+9	; 0x09
    3268:	ba 85       	ldd	r27, Y+10	; 0x0a
    326a:	82 2b       	or	r24, r18
    326c:	93 2b       	or	r25, r19
    326e:	a4 2b       	or	r26, r20
    3270:	b5 2b       	or	r27, r21
    3272:	2a 81       	ldd	r18, Y+2	; 0x02
    3274:	3b 81       	ldd	r19, Y+3	; 0x03
    3276:	f9 01       	movw	r30, r18
    3278:	81 a3       	std	Z+33, r24	; 0x21
    327a:	92 a3       	std	Z+34, r25	; 0x22
    327c:	a3 a3       	std	Z+35, r26	; 0x23
    327e:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    3280:	30 c0       	rjmp	.+96     	; 0x32e2 <xTaskGenericNotify+0x12c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    3282:	8a 81       	ldd	r24, Y+2	; 0x02
    3284:	9b 81       	ldd	r25, Y+3	; 0x03
    3286:	fc 01       	movw	r30, r24
    3288:	81 a1       	ldd	r24, Z+33	; 0x21
    328a:	92 a1       	ldd	r25, Z+34	; 0x22
    328c:	a3 a1       	ldd	r26, Z+35	; 0x23
    328e:	b4 a1       	ldd	r27, Z+36	; 0x24
    3290:	01 96       	adiw	r24, 0x01	; 1
    3292:	a1 1d       	adc	r26, r1
    3294:	b1 1d       	adc	r27, r1
    3296:	2a 81       	ldd	r18, Y+2	; 0x02
    3298:	3b 81       	ldd	r19, Y+3	; 0x03
    329a:	f9 01       	movw	r30, r18
    329c:	81 a3       	std	Z+33, r24	; 0x21
    329e:	92 a3       	std	Z+34, r25	; 0x22
    32a0:	a3 a3       	std	Z+35, r26	; 0x23
    32a2:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    32a4:	1e c0       	rjmp	.+60     	; 0x32e2 <xTaskGenericNotify+0x12c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    32a6:	2a 81       	ldd	r18, Y+2	; 0x02
    32a8:	3b 81       	ldd	r19, Y+3	; 0x03
    32aa:	8f 81       	ldd	r24, Y+7	; 0x07
    32ac:	98 85       	ldd	r25, Y+8	; 0x08
    32ae:	a9 85       	ldd	r26, Y+9	; 0x09
    32b0:	ba 85       	ldd	r27, Y+10	; 0x0a
    32b2:	f9 01       	movw	r30, r18
    32b4:	81 a3       	std	Z+33, r24	; 0x21
    32b6:	92 a3       	std	Z+34, r25	; 0x22
    32b8:	a3 a3       	std	Z+35, r26	; 0x23
    32ba:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    32bc:	12 c0       	rjmp	.+36     	; 0x32e2 <xTaskGenericNotify+0x12c>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    32be:	8c 81       	ldd	r24, Y+4	; 0x04
    32c0:	82 30       	cpi	r24, 0x02	; 2
    32c2:	61 f0       	breq	.+24     	; 0x32dc <xTaskGenericNotify+0x126>
					{
						pxTCB->ulNotifiedValue = ulValue;
    32c4:	2a 81       	ldd	r18, Y+2	; 0x02
    32c6:	3b 81       	ldd	r19, Y+3	; 0x03
    32c8:	8f 81       	ldd	r24, Y+7	; 0x07
    32ca:	98 85       	ldd	r25, Y+8	; 0x08
    32cc:	a9 85       	ldd	r26, Y+9	; 0x09
    32ce:	ba 85       	ldd	r27, Y+10	; 0x0a
    32d0:	f9 01       	movw	r30, r18
    32d2:	81 a3       	std	Z+33, r24	; 0x21
    32d4:	92 a3       	std	Z+34, r25	; 0x22
    32d6:	a3 a3       	std	Z+35, r26	; 0x23
    32d8:	b4 a3       	std	Z+36, r27	; 0x24
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    32da:	03 c0       	rjmp	.+6      	; 0x32e2 <xTaskGenericNotify+0x12c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    32dc:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    32de:	01 c0       	rjmp	.+2      	; 0x32e2 <xTaskGenericNotify+0x12c>

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
    32e0:	00 00       	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    32e2:	8c 81       	ldd	r24, Y+4	; 0x04
    32e4:	81 30       	cpi	r24, 0x01	; 1
    32e6:	d1 f5       	brne	.+116    	; 0x335c <xTaskGenericNotify+0x1a6>
			{
				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    32e8:	8a 81       	ldd	r24, Y+2	; 0x02
    32ea:	9b 81       	ldd	r25, Y+3	; 0x03
    32ec:	02 96       	adiw	r24, 0x02	; 2
    32ee:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    32f2:	8a 81       	ldd	r24, Y+2	; 0x02
    32f4:	9b 81       	ldd	r25, Y+3	; 0x03
    32f6:	fc 01       	movw	r30, r24
    32f8:	96 89       	ldd	r25, Z+22	; 0x16
    32fa:	80 91 67 05 	lds	r24, 0x0567
    32fe:	89 17       	cp	r24, r25
    3300:	30 f4       	brcc	.+12     	; 0x330e <xTaskGenericNotify+0x158>
    3302:	8a 81       	ldd	r24, Y+2	; 0x02
    3304:	9b 81       	ldd	r25, Y+3	; 0x03
    3306:	fc 01       	movw	r30, r24
    3308:	86 89       	ldd	r24, Z+22	; 0x16
    330a:	80 93 67 05 	sts	0x0567, r24
    330e:	8a 81       	ldd	r24, Y+2	; 0x02
    3310:	9b 81       	ldd	r25, Y+3	; 0x03
    3312:	ac 01       	movw	r20, r24
    3314:	4e 5f       	subi	r20, 0xFE	; 254
    3316:	5f 4f       	sbci	r21, 0xFF	; 255
    3318:	8a 81       	ldd	r24, Y+2	; 0x02
    331a:	9b 81       	ldd	r25, Y+3	; 0x03
    331c:	fc 01       	movw	r30, r24
    331e:	86 89       	ldd	r24, Z+22	; 0x16
    3320:	28 2f       	mov	r18, r24
    3322:	30 e0       	ldi	r19, 0x00	; 0
    3324:	c9 01       	movw	r24, r18
    3326:	88 0f       	add	r24, r24
    3328:	99 1f       	adc	r25, r25
    332a:	88 0f       	add	r24, r24
    332c:	99 1f       	adc	r25, r25
    332e:	88 0f       	add	r24, r24
    3330:	99 1f       	adc	r25, r25
    3332:	82 0f       	add	r24, r18
    3334:	93 1f       	adc	r25, r19
    3336:	89 5e       	subi	r24, 0xE9	; 233
    3338:	9a 4f       	sbci	r25, 0xFA	; 250
    333a:	ba 01       	movw	r22, r20
    333c:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3340:	8a 81       	ldd	r24, Y+2	; 0x02
    3342:	9b 81       	ldd	r25, Y+3	; 0x03
    3344:	fc 01       	movw	r30, r24
    3346:	26 89       	ldd	r18, Z+22	; 0x16
    3348:	80 91 15 05 	lds	r24, 0x0515
    334c:	90 91 16 05 	lds	r25, 0x0516
    3350:	fc 01       	movw	r30, r24
    3352:	86 89       	ldd	r24, Z+22	; 0x16
    3354:	82 17       	cp	r24, r18
    3356:	10 f4       	brcc	.+4      	; 0x335c <xTaskGenericNotify+0x1a6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    3358:	0e 94 86 07 	call	0xf0c	; 0xf0c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    335c:	0f 90       	pop	r0
    335e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3360:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3362:	2d 96       	adiw	r28, 0x0d	; 13
    3364:	0f b6       	in	r0, 0x3f	; 63
    3366:	f8 94       	cli
    3368:	de bf       	out	0x3e, r29	; 62
    336a:	0f be       	out	0x3f, r0	; 63
    336c:	cd bf       	out	0x3d, r28	; 61
    336e:	df 91       	pop	r29
    3370:	cf 91       	pop	r28
    3372:	1f 91       	pop	r17
    3374:	0f 91       	pop	r16
    3376:	08 95       	ret

00003378 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    3378:	ef 92       	push	r14
    337a:	ff 92       	push	r15
    337c:	0f 93       	push	r16
    337e:	1f 93       	push	r17
    3380:	cf 93       	push	r28
    3382:	df 93       	push	r29
    3384:	cd b7       	in	r28, 0x3d	; 61
    3386:	de b7       	in	r29, 0x3e	; 62
    3388:	60 97       	sbiw	r28, 0x10	; 16
    338a:	0f b6       	in	r0, 0x3f	; 63
    338c:	f8 94       	cli
    338e:	de bf       	out	0x3e, r29	; 62
    3390:	0f be       	out	0x3f, r0	; 63
    3392:	cd bf       	out	0x3d, r28	; 61
    3394:	9f 83       	std	Y+7, r25	; 0x07
    3396:	8e 83       	std	Y+6, r24	; 0x06
    3398:	48 87       	std	Y+8, r20	; 0x08
    339a:	59 87       	std	Y+9, r21	; 0x09
    339c:	6a 87       	std	Y+10, r22	; 0x0a
    339e:	7b 87       	std	Y+11, r23	; 0x0b
    33a0:	2c 87       	std	Y+12, r18	; 0x0c
    33a2:	1e 87       	std	Y+14, r17	; 0x0e
    33a4:	0d 87       	std	Y+13, r16	; 0x0d
    33a6:	f8 8a       	std	Y+16, r15	; 0x10
    33a8:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    33aa:	81 e0       	ldi	r24, 0x01	; 1
    33ac:	89 83       	std	Y+1, r24	; 0x01
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    33ae:	8e 81       	ldd	r24, Y+6	; 0x06
    33b0:	9f 81       	ldd	r25, Y+7	; 0x07
    33b2:	9b 83       	std	Y+3, r25	; 0x03
    33b4:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    33b6:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( pulPreviousNotificationValue != NULL )
    33b8:	8d 85       	ldd	r24, Y+13	; 0x0d
    33ba:	9e 85       	ldd	r25, Y+14	; 0x0e
    33bc:	89 2b       	or	r24, r25
    33be:	71 f0       	breq	.+28     	; 0x33dc <xTaskGenericNotifyFromISR+0x64>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    33c0:	8a 81       	ldd	r24, Y+2	; 0x02
    33c2:	9b 81       	ldd	r25, Y+3	; 0x03
    33c4:	fc 01       	movw	r30, r24
    33c6:	81 a1       	ldd	r24, Z+33	; 0x21
    33c8:	92 a1       	ldd	r25, Z+34	; 0x22
    33ca:	a3 a1       	ldd	r26, Z+35	; 0x23
    33cc:	b4 a1       	ldd	r27, Z+36	; 0x24
    33ce:	2d 85       	ldd	r18, Y+13	; 0x0d
    33d0:	3e 85       	ldd	r19, Y+14	; 0x0e
    33d2:	f9 01       	movw	r30, r18
    33d4:	80 83       	st	Z, r24
    33d6:	91 83       	std	Z+1, r25	; 0x01
    33d8:	a2 83       	std	Z+2, r26	; 0x02
    33da:	b3 83       	std	Z+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    33dc:	8a 81       	ldd	r24, Y+2	; 0x02
    33de:	9b 81       	ldd	r25, Y+3	; 0x03
    33e0:	fc 01       	movw	r30, r24
    33e2:	85 a1       	ldd	r24, Z+37	; 0x25
    33e4:	8d 83       	std	Y+5, r24	; 0x05
			pxTCB->eNotifyState = eNotified;
    33e6:	8a 81       	ldd	r24, Y+2	; 0x02
    33e8:	9b 81       	ldd	r25, Y+3	; 0x03
    33ea:	22 e0       	ldi	r18, 0x02	; 2
    33ec:	fc 01       	movw	r30, r24
    33ee:	25 a3       	std	Z+37, r18	; 0x25

			switch( eAction )
    33f0:	8c 85       	ldd	r24, Y+12	; 0x0c
    33f2:	88 2f       	mov	r24, r24
    33f4:	90 e0       	ldi	r25, 0x00	; 0
    33f6:	82 30       	cpi	r24, 0x02	; 2
    33f8:	91 05       	cpc	r25, r1
    33fa:	31 f1       	breq	.+76     	; 0x3448 <xTaskGenericNotifyFromISR+0xd0>
    33fc:	83 30       	cpi	r24, 0x03	; 3
    33fe:	91 05       	cpc	r25, r1
    3400:	34 f4       	brge	.+12     	; 0x340e <xTaskGenericNotifyFromISR+0x96>
    3402:	00 97       	sbiw	r24, 0x00	; 0
    3404:	09 f4       	brne	.+2      	; 0x3408 <xTaskGenericNotifyFromISR+0x90>
    3406:	4f c0       	rjmp	.+158    	; 0x34a6 <xTaskGenericNotifyFromISR+0x12e>
    3408:	01 97       	sbiw	r24, 0x01	; 1
    340a:	39 f0       	breq	.+14     	; 0x341a <xTaskGenericNotifyFromISR+0xa2>
    340c:	4d c0       	rjmp	.+154    	; 0x34a8 <xTaskGenericNotifyFromISR+0x130>
    340e:	83 30       	cpi	r24, 0x03	; 3
    3410:	91 05       	cpc	r25, r1
    3412:	61 f1       	breq	.+88     	; 0x346c <xTaskGenericNotifyFromISR+0xf4>
    3414:	04 97       	sbiw	r24, 0x04	; 4
    3416:	b1 f1       	breq	.+108    	; 0x3484 <xTaskGenericNotifyFromISR+0x10c>
    3418:	47 c0       	rjmp	.+142    	; 0x34a8 <xTaskGenericNotifyFromISR+0x130>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    341a:	8a 81       	ldd	r24, Y+2	; 0x02
    341c:	9b 81       	ldd	r25, Y+3	; 0x03
    341e:	fc 01       	movw	r30, r24
    3420:	21 a1       	ldd	r18, Z+33	; 0x21
    3422:	32 a1       	ldd	r19, Z+34	; 0x22
    3424:	43 a1       	ldd	r20, Z+35	; 0x23
    3426:	54 a1       	ldd	r21, Z+36	; 0x24
    3428:	88 85       	ldd	r24, Y+8	; 0x08
    342a:	99 85       	ldd	r25, Y+9	; 0x09
    342c:	aa 85       	ldd	r26, Y+10	; 0x0a
    342e:	bb 85       	ldd	r27, Y+11	; 0x0b
    3430:	82 2b       	or	r24, r18
    3432:	93 2b       	or	r25, r19
    3434:	a4 2b       	or	r26, r20
    3436:	b5 2b       	or	r27, r21
    3438:	2a 81       	ldd	r18, Y+2	; 0x02
    343a:	3b 81       	ldd	r19, Y+3	; 0x03
    343c:	f9 01       	movw	r30, r18
    343e:	81 a3       	std	Z+33, r24	; 0x21
    3440:	92 a3       	std	Z+34, r25	; 0x22
    3442:	a3 a3       	std	Z+35, r26	; 0x23
    3444:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    3446:	30 c0       	rjmp	.+96     	; 0x34a8 <xTaskGenericNotifyFromISR+0x130>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    3448:	8a 81       	ldd	r24, Y+2	; 0x02
    344a:	9b 81       	ldd	r25, Y+3	; 0x03
    344c:	fc 01       	movw	r30, r24
    344e:	81 a1       	ldd	r24, Z+33	; 0x21
    3450:	92 a1       	ldd	r25, Z+34	; 0x22
    3452:	a3 a1       	ldd	r26, Z+35	; 0x23
    3454:	b4 a1       	ldd	r27, Z+36	; 0x24
    3456:	01 96       	adiw	r24, 0x01	; 1
    3458:	a1 1d       	adc	r26, r1
    345a:	b1 1d       	adc	r27, r1
    345c:	2a 81       	ldd	r18, Y+2	; 0x02
    345e:	3b 81       	ldd	r19, Y+3	; 0x03
    3460:	f9 01       	movw	r30, r18
    3462:	81 a3       	std	Z+33, r24	; 0x21
    3464:	92 a3       	std	Z+34, r25	; 0x22
    3466:	a3 a3       	std	Z+35, r26	; 0x23
    3468:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    346a:	1e c0       	rjmp	.+60     	; 0x34a8 <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    346c:	2a 81       	ldd	r18, Y+2	; 0x02
    346e:	3b 81       	ldd	r19, Y+3	; 0x03
    3470:	88 85       	ldd	r24, Y+8	; 0x08
    3472:	99 85       	ldd	r25, Y+9	; 0x09
    3474:	aa 85       	ldd	r26, Y+10	; 0x0a
    3476:	bb 85       	ldd	r27, Y+11	; 0x0b
    3478:	f9 01       	movw	r30, r18
    347a:	81 a3       	std	Z+33, r24	; 0x21
    347c:	92 a3       	std	Z+34, r25	; 0x22
    347e:	a3 a3       	std	Z+35, r26	; 0x23
    3480:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    3482:	12 c0       	rjmp	.+36     	; 0x34a8 <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    3484:	8d 81       	ldd	r24, Y+5	; 0x05
    3486:	82 30       	cpi	r24, 0x02	; 2
    3488:	61 f0       	breq	.+24     	; 0x34a2 <xTaskGenericNotifyFromISR+0x12a>
					{
						pxTCB->ulNotifiedValue = ulValue;
    348a:	2a 81       	ldd	r18, Y+2	; 0x02
    348c:	3b 81       	ldd	r19, Y+3	; 0x03
    348e:	88 85       	ldd	r24, Y+8	; 0x08
    3490:	99 85       	ldd	r25, Y+9	; 0x09
    3492:	aa 85       	ldd	r26, Y+10	; 0x0a
    3494:	bb 85       	ldd	r27, Y+11	; 0x0b
    3496:	f9 01       	movw	r30, r18
    3498:	81 a3       	std	Z+33, r24	; 0x21
    349a:	92 a3       	std	Z+34, r25	; 0x22
    349c:	a3 a3       	std	Z+35, r26	; 0x23
    349e:	b4 a3       	std	Z+36, r27	; 0x24
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    34a0:	03 c0       	rjmp	.+6      	; 0x34a8 <xTaskGenericNotifyFromISR+0x130>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    34a2:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    34a4:	01 c0       	rjmp	.+2      	; 0x34a8 <xTaskGenericNotifyFromISR+0x130>

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
    34a6:	00 00       	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    34a8:	8d 81       	ldd	r24, Y+5	; 0x05
    34aa:	81 30       	cpi	r24, 0x01	; 1
    34ac:	09 f0       	breq	.+2      	; 0x34b0 <xTaskGenericNotifyFromISR+0x138>
    34ae:	4e c0       	rjmp	.+156    	; 0x354c <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    34b0:	80 91 6f 05 	lds	r24, 0x056F
    34b4:	88 23       	and	r24, r24
    34b6:	69 f5       	brne	.+90     	; 0x3512 <xTaskGenericNotifyFromISR+0x19a>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    34b8:	8a 81       	ldd	r24, Y+2	; 0x02
    34ba:	9b 81       	ldd	r25, Y+3	; 0x03
    34bc:	02 96       	adiw	r24, 0x02	; 2
    34be:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    34c2:	8a 81       	ldd	r24, Y+2	; 0x02
    34c4:	9b 81       	ldd	r25, Y+3	; 0x03
    34c6:	fc 01       	movw	r30, r24
    34c8:	96 89       	ldd	r25, Z+22	; 0x16
    34ca:	80 91 67 05 	lds	r24, 0x0567
    34ce:	89 17       	cp	r24, r25
    34d0:	30 f4       	brcc	.+12     	; 0x34de <xTaskGenericNotifyFromISR+0x166>
    34d2:	8a 81       	ldd	r24, Y+2	; 0x02
    34d4:	9b 81       	ldd	r25, Y+3	; 0x03
    34d6:	fc 01       	movw	r30, r24
    34d8:	86 89       	ldd	r24, Z+22	; 0x16
    34da:	80 93 67 05 	sts	0x0567, r24
    34de:	8a 81       	ldd	r24, Y+2	; 0x02
    34e0:	9b 81       	ldd	r25, Y+3	; 0x03
    34e2:	ac 01       	movw	r20, r24
    34e4:	4e 5f       	subi	r20, 0xFE	; 254
    34e6:	5f 4f       	sbci	r21, 0xFF	; 255
    34e8:	8a 81       	ldd	r24, Y+2	; 0x02
    34ea:	9b 81       	ldd	r25, Y+3	; 0x03
    34ec:	fc 01       	movw	r30, r24
    34ee:	86 89       	ldd	r24, Z+22	; 0x16
    34f0:	28 2f       	mov	r18, r24
    34f2:	30 e0       	ldi	r19, 0x00	; 0
    34f4:	c9 01       	movw	r24, r18
    34f6:	88 0f       	add	r24, r24
    34f8:	99 1f       	adc	r25, r25
    34fa:	88 0f       	add	r24, r24
    34fc:	99 1f       	adc	r25, r25
    34fe:	88 0f       	add	r24, r24
    3500:	99 1f       	adc	r25, r25
    3502:	82 0f       	add	r24, r18
    3504:	93 1f       	adc	r25, r19
    3506:	89 5e       	subi	r24, 0xE9	; 233
    3508:	9a 4f       	sbci	r25, 0xFA	; 250
    350a:	ba 01       	movw	r22, r20
    350c:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsertEnd>
    3510:	08 c0       	rjmp	.+16     	; 0x3522 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3512:	8a 81       	ldd	r24, Y+2	; 0x02
    3514:	9b 81       	ldd	r25, Y+3	; 0x03
    3516:	0c 96       	adiw	r24, 0x0c	; 12
    3518:	bc 01       	movw	r22, r24
    351a:	81 e5       	ldi	r24, 0x51	; 81
    351c:	95 e0       	ldi	r25, 0x05	; 5
    351e:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3522:	8a 81       	ldd	r24, Y+2	; 0x02
    3524:	9b 81       	ldd	r25, Y+3	; 0x03
    3526:	fc 01       	movw	r30, r24
    3528:	26 89       	ldd	r18, Z+22	; 0x16
    352a:	80 91 15 05 	lds	r24, 0x0515
    352e:	90 91 16 05 	lds	r25, 0x0516
    3532:	fc 01       	movw	r30, r24
    3534:	86 89       	ldd	r24, Z+22	; 0x16
    3536:	82 17       	cp	r24, r18
    3538:	48 f4       	brcc	.+18     	; 0x354c <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    353a:	8f 85       	ldd	r24, Y+15	; 0x0f
    353c:	98 89       	ldd	r25, Y+16	; 0x10
    353e:	89 2b       	or	r24, r25
    3540:	29 f0       	breq	.+10     	; 0x354c <xTaskGenericNotifyFromISR+0x1d4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    3542:	8f 85       	ldd	r24, Y+15	; 0x0f
    3544:	98 89       	ldd	r25, Y+16	; 0x10
    3546:	21 e0       	ldi	r18, 0x01	; 1
    3548:	fc 01       	movw	r30, r24
    354a:	20 83       	st	Z, r18
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    354c:	89 81       	ldd	r24, Y+1	; 0x01
	}
    354e:	60 96       	adiw	r28, 0x10	; 16
    3550:	0f b6       	in	r0, 0x3f	; 63
    3552:	f8 94       	cli
    3554:	de bf       	out	0x3e, r29	; 62
    3556:	0f be       	out	0x3f, r0	; 63
    3558:	cd bf       	out	0x3d, r28	; 61
    355a:	df 91       	pop	r29
    355c:	cf 91       	pop	r28
    355e:	1f 91       	pop	r17
    3560:	0f 91       	pop	r16
    3562:	ff 90       	pop	r15
    3564:	ef 90       	pop	r14
    3566:	08 95       	ret

00003568 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    3568:	cf 93       	push	r28
    356a:	df 93       	push	r29
    356c:	cd b7       	in	r28, 0x3d	; 61
    356e:	de b7       	in	r29, 0x3e	; 62
    3570:	28 97       	sbiw	r28, 0x08	; 8
    3572:	0f b6       	in	r0, 0x3f	; 63
    3574:	f8 94       	cli
    3576:	de bf       	out	0x3e, r29	; 62
    3578:	0f be       	out	0x3f, r0	; 63
    357a:	cd bf       	out	0x3d, r28	; 61
    357c:	9e 83       	std	Y+6, r25	; 0x06
    357e:	8d 83       	std	Y+5, r24	; 0x05
    3580:	78 87       	std	Y+8, r23	; 0x08
    3582:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    3584:	8d 81       	ldd	r24, Y+5	; 0x05
    3586:	9e 81       	ldd	r25, Y+6	; 0x06
    3588:	9a 83       	std	Y+2, r25	; 0x02
    358a:	89 83       	std	Y+1, r24	; 0x01

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    358c:	1b 82       	std	Y+3, r1	; 0x03
		{
			eOriginalNotifyState = pxTCB->eNotifyState;
    358e:	89 81       	ldd	r24, Y+1	; 0x01
    3590:	9a 81       	ldd	r25, Y+2	; 0x02
    3592:	fc 01       	movw	r30, r24
    3594:	85 a1       	ldd	r24, Z+37	; 0x25
    3596:	8c 83       	std	Y+4, r24	; 0x04
			pxTCB->eNotifyState = eNotified;
    3598:	89 81       	ldd	r24, Y+1	; 0x01
    359a:	9a 81       	ldd	r25, Y+2	; 0x02
    359c:	22 e0       	ldi	r18, 0x02	; 2
    359e:	fc 01       	movw	r30, r24
    35a0:	25 a3       	std	Z+37, r18	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    35a2:	89 81       	ldd	r24, Y+1	; 0x01
    35a4:	9a 81       	ldd	r25, Y+2	; 0x02
    35a6:	fc 01       	movw	r30, r24
    35a8:	81 a1       	ldd	r24, Z+33	; 0x21
    35aa:	92 a1       	ldd	r25, Z+34	; 0x22
    35ac:	a3 a1       	ldd	r26, Z+35	; 0x23
    35ae:	b4 a1       	ldd	r27, Z+36	; 0x24
    35b0:	01 96       	adiw	r24, 0x01	; 1
    35b2:	a1 1d       	adc	r26, r1
    35b4:	b1 1d       	adc	r27, r1
    35b6:	29 81       	ldd	r18, Y+1	; 0x01
    35b8:	3a 81       	ldd	r19, Y+2	; 0x02
    35ba:	f9 01       	movw	r30, r18
    35bc:	81 a3       	std	Z+33, r24	; 0x21
    35be:	92 a3       	std	Z+34, r25	; 0x22
    35c0:	a3 a3       	std	Z+35, r26	; 0x23
    35c2:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    35c4:	8c 81       	ldd	r24, Y+4	; 0x04
    35c6:	81 30       	cpi	r24, 0x01	; 1
    35c8:	09 f0       	breq	.+2      	; 0x35cc <vTaskNotifyGiveFromISR+0x64>
    35ca:	4e c0       	rjmp	.+156    	; 0x3668 <vTaskNotifyGiveFromISR+0x100>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    35cc:	80 91 6f 05 	lds	r24, 0x056F
    35d0:	88 23       	and	r24, r24
    35d2:	69 f5       	brne	.+90     	; 0x362e <vTaskNotifyGiveFromISR+0xc6>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    35d4:	89 81       	ldd	r24, Y+1	; 0x01
    35d6:	9a 81       	ldd	r25, Y+2	; 0x02
    35d8:	02 96       	adiw	r24, 0x02	; 2
    35da:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    35de:	89 81       	ldd	r24, Y+1	; 0x01
    35e0:	9a 81       	ldd	r25, Y+2	; 0x02
    35e2:	fc 01       	movw	r30, r24
    35e4:	96 89       	ldd	r25, Z+22	; 0x16
    35e6:	80 91 67 05 	lds	r24, 0x0567
    35ea:	89 17       	cp	r24, r25
    35ec:	30 f4       	brcc	.+12     	; 0x35fa <vTaskNotifyGiveFromISR+0x92>
    35ee:	89 81       	ldd	r24, Y+1	; 0x01
    35f0:	9a 81       	ldd	r25, Y+2	; 0x02
    35f2:	fc 01       	movw	r30, r24
    35f4:	86 89       	ldd	r24, Z+22	; 0x16
    35f6:	80 93 67 05 	sts	0x0567, r24
    35fa:	89 81       	ldd	r24, Y+1	; 0x01
    35fc:	9a 81       	ldd	r25, Y+2	; 0x02
    35fe:	ac 01       	movw	r20, r24
    3600:	4e 5f       	subi	r20, 0xFE	; 254
    3602:	5f 4f       	sbci	r21, 0xFF	; 255
    3604:	89 81       	ldd	r24, Y+1	; 0x01
    3606:	9a 81       	ldd	r25, Y+2	; 0x02
    3608:	fc 01       	movw	r30, r24
    360a:	86 89       	ldd	r24, Z+22	; 0x16
    360c:	28 2f       	mov	r18, r24
    360e:	30 e0       	ldi	r19, 0x00	; 0
    3610:	c9 01       	movw	r24, r18
    3612:	88 0f       	add	r24, r24
    3614:	99 1f       	adc	r25, r25
    3616:	88 0f       	add	r24, r24
    3618:	99 1f       	adc	r25, r25
    361a:	88 0f       	add	r24, r24
    361c:	99 1f       	adc	r25, r25
    361e:	82 0f       	add	r24, r18
    3620:	93 1f       	adc	r25, r19
    3622:	89 5e       	subi	r24, 0xE9	; 233
    3624:	9a 4f       	sbci	r25, 0xFA	; 250
    3626:	ba 01       	movw	r22, r20
    3628:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsertEnd>
    362c:	08 c0       	rjmp	.+16     	; 0x363e <vTaskNotifyGiveFromISR+0xd6>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    362e:	89 81       	ldd	r24, Y+1	; 0x01
    3630:	9a 81       	ldd	r25, Y+2	; 0x02
    3632:	0c 96       	adiw	r24, 0x0c	; 12
    3634:	bc 01       	movw	r22, r24
    3636:	81 e5       	ldi	r24, 0x51	; 81
    3638:	95 e0       	ldi	r25, 0x05	; 5
    363a:	0e 94 85 04 	call	0x90a	; 0x90a <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    363e:	89 81       	ldd	r24, Y+1	; 0x01
    3640:	9a 81       	ldd	r25, Y+2	; 0x02
    3642:	fc 01       	movw	r30, r24
    3644:	26 89       	ldd	r18, Z+22	; 0x16
    3646:	80 91 15 05 	lds	r24, 0x0515
    364a:	90 91 16 05 	lds	r25, 0x0516
    364e:	fc 01       	movw	r30, r24
    3650:	86 89       	ldd	r24, Z+22	; 0x16
    3652:	82 17       	cp	r24, r18
    3654:	48 f4       	brcc	.+18     	; 0x3668 <vTaskNotifyGiveFromISR+0x100>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    3656:	8f 81       	ldd	r24, Y+7	; 0x07
    3658:	98 85       	ldd	r25, Y+8	; 0x08
    365a:	89 2b       	or	r24, r25
    365c:	29 f0       	breq	.+10     	; 0x3668 <vTaskNotifyGiveFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    365e:	8f 81       	ldd	r24, Y+7	; 0x07
    3660:	98 85       	ldd	r25, Y+8	; 0x08
    3662:	21 e0       	ldi	r18, 0x01	; 1
    3664:	fc 01       	movw	r30, r24
    3666:	20 83       	st	Z, r18
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    3668:	28 96       	adiw	r28, 0x08	; 8
    366a:	0f b6       	in	r0, 0x3f	; 63
    366c:	f8 94       	cli
    366e:	de bf       	out	0x3e, r29	; 62
    3670:	0f be       	out	0x3f, r0	; 63
    3672:	cd bf       	out	0x3d, r28	; 61
    3674:	df 91       	pop	r29
    3676:	cf 91       	pop	r28
    3678:	08 95       	ret

0000367a <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    367a:	cf 93       	push	r28
    367c:	df 93       	push	r29
    367e:	00 d0       	rcall	.+0      	; 0x3680 <xTaskNotifyStateClear+0x6>
    3680:	00 d0       	rcall	.+0      	; 0x3682 <xTaskNotifyStateClear+0x8>
    3682:	1f 92       	push	r1
    3684:	cd b7       	in	r28, 0x3d	; 61
    3686:	de b7       	in	r29, 0x3e	; 62
    3688:	9d 83       	std	Y+5, r25	; 0x05
    368a:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		pxTCB = ( TCB_t * ) xTask;
    368c:	8c 81       	ldd	r24, Y+4	; 0x04
    368e:	9d 81       	ldd	r25, Y+5	; 0x05
    3690:	9b 83       	std	Y+3, r25	; 0x03
    3692:	8a 83       	std	Y+2, r24	; 0x02

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( pxTCB );
    3694:	8a 81       	ldd	r24, Y+2	; 0x02
    3696:	9b 81       	ldd	r25, Y+3	; 0x03
    3698:	89 2b       	or	r24, r25
    369a:	29 f4       	brne	.+10     	; 0x36a6 <xTaskNotifyStateClear+0x2c>
    369c:	80 91 15 05 	lds	r24, 0x0515
    36a0:	90 91 16 05 	lds	r25, 0x0516
    36a4:	02 c0       	rjmp	.+4      	; 0x36aa <xTaskNotifyStateClear+0x30>
    36a6:	8a 81       	ldd	r24, Y+2	; 0x02
    36a8:	9b 81       	ldd	r25, Y+3	; 0x03
    36aa:	9b 83       	std	Y+3, r25	; 0x03
    36ac:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    36ae:	0f b6       	in	r0, 0x3f	; 63
    36b0:	f8 94       	cli
    36b2:	0f 92       	push	r0
		{
			if( pxTCB->eNotifyState == eNotified )
    36b4:	8a 81       	ldd	r24, Y+2	; 0x02
    36b6:	9b 81       	ldd	r25, Y+3	; 0x03
    36b8:	fc 01       	movw	r30, r24
    36ba:	85 a1       	ldd	r24, Z+37	; 0x25
    36bc:	82 30       	cpi	r24, 0x02	; 2
    36be:	39 f4       	brne	.+14     	; 0x36ce <xTaskNotifyStateClear+0x54>
			{
				pxTCB->eNotifyState = eNotWaitingNotification;
    36c0:	8a 81       	ldd	r24, Y+2	; 0x02
    36c2:	9b 81       	ldd	r25, Y+3	; 0x03
    36c4:	fc 01       	movw	r30, r24
    36c6:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    36c8:	81 e0       	ldi	r24, 0x01	; 1
    36ca:	89 83       	std	Y+1, r24	; 0x01
    36cc:	01 c0       	rjmp	.+2      	; 0x36d0 <xTaskNotifyStateClear+0x56>
			}
			else
			{
				xReturn = pdFAIL;
    36ce:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    36d0:	0f 90       	pop	r0
    36d2:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    36d4:	89 81       	ldd	r24, Y+1	; 0x01
	}
    36d6:	0f 90       	pop	r0
    36d8:	0f 90       	pop	r0
    36da:	0f 90       	pop	r0
    36dc:	0f 90       	pop	r0
    36de:	0f 90       	pop	r0
    36e0:	df 91       	pop	r29
    36e2:	cf 91       	pop	r28
    36e4:	08 95       	ret

000036e6 <vMCUStatusTask>:
/* MCU Status task
 * Toggles the MCU status LED, to blink at 2Hz
 * Rate: 4Hz
 * Priority: 1 (lowest)
 */
void vMCUStatusTask(void *pvParameters) {
    36e6:	cf 93       	push	r28
    36e8:	df 93       	push	r29
    36ea:	cd b7       	in	r28, 0x3d	; 61
    36ec:	de b7       	in	r29, 0x3e	; 62
    36ee:	27 97       	sbiw	r28, 0x07	; 7
    36f0:	0f b6       	in	r0, 0x3f	; 63
    36f2:	f8 94       	cli
    36f4:	de bf       	out	0x3e, r29	; 62
    36f6:	0f be       	out	0x3f, r0	; 63
    36f8:	cd bf       	out	0x3d, r28	; 61
    36fa:	9f 83       	std	Y+7, r25	; 0x07
    36fc:	8e 83       	std	Y+6, r24	; 0x06
	// Make compiler happy
	(void) pvParameters;
	
	// Previous wake time pointer
	TickType_t xLastWakeTime = xTaskGetTickCount();
    36fe:	0e 94 1a 12 	call	0x2434	; 0x2434 <xTaskGetTickCount>
    3702:	9d 83       	std	Y+5, r25	; 0x05
    3704:	8c 83       	std	Y+4, r24	; 0x04
	// Period
	const TickType_t xPeriod = 250;		// In ticks (ms)
    3706:	8a ef       	ldi	r24, 0xFA	; 250
    3708:	90 e0       	ldi	r25, 0x00	; 0
    370a:	9b 83       	std	Y+3, r25	; 0x03
    370c:	8a 83       	std	Y+2, r24	; 0x02
	
	// Task variables
	bool currentValue = 0;	// false
    370e:	19 82       	std	Y+1, r1	; 0x01
	// Setup MCU status pin as output
	config_io_pin(MCU_STATUS_PORT, MCU_STATUS_CH, IO_DIR_OUTPUT);
    3710:	41 e0       	ldi	r20, 0x01	; 1
    3712:	60 e0       	ldi	r22, 0x00	; 0
    3714:	81 e0       	ldi	r24, 0x01	; 1
    3716:	0e 94 03 1c 	call	0x3806	; 0x3806 <config_io_pin>
	
	for(;;) {
		// Flip value
		currentValue = !currentValue;
    371a:	89 81       	ldd	r24, Y+1	; 0x01
    371c:	88 2f       	mov	r24, r24
    371e:	90 e0       	ldi	r25, 0x00	; 0
    3720:	21 e0       	ldi	r18, 0x01	; 1
    3722:	89 2b       	or	r24, r25
    3724:	09 f4       	brne	.+2      	; 0x3728 <vMCUStatusTask+0x42>
    3726:	20 e0       	ldi	r18, 0x00	; 0
    3728:	81 e0       	ldi	r24, 0x01	; 1
    372a:	82 27       	eor	r24, r18
    372c:	88 2f       	mov	r24, r24
    372e:	90 e0       	ldi	r25, 0x00	; 0
    3730:	89 83       	std	Y+1, r24	; 0x01
    3732:	89 81       	ldd	r24, Y+1	; 0x01
    3734:	81 70       	andi	r24, 0x01	; 1
    3736:	89 83       	std	Y+1, r24	; 0x01
		// Write out value
		set_io_pin(MCU_STATUS_PORT, MCU_STATUS_CH, currentValue);
    3738:	89 81       	ldd	r24, Y+1	; 0x01
    373a:	48 2f       	mov	r20, r24
    373c:	60 e0       	ldi	r22, 0x00	; 0
    373e:	81 e0       	ldi	r24, 0x01	; 1
    3740:	0e 94 42 1c 	call	0x3884	; 0x3884 <set_io_pin>
		// Delay until next period
		vTaskDelayUntil(&xLastWakeTime, xPeriod); 
    3744:	2a 81       	ldd	r18, Y+2	; 0x02
    3746:	3b 81       	ldd	r19, Y+3	; 0x03
    3748:	ce 01       	movw	r24, r28
    374a:	04 96       	adiw	r24, 0x04	; 4
    374c:	b9 01       	movw	r22, r18
    374e:	0e 94 8a 10 	call	0x2114	; 0x2114 <vTaskDelayUntil>
	}
    3752:	e3 cf       	rjmp	.-58     	; 0x371a <vMCUStatusTask+0x34>

00003754 <vHeartbeatTask>:
/* Heartbeat task
 * Sends a node heartbeat out on the CANBus
 * Rate: 10Hz
 * Priority: 3
 */
void vHeartbeatTask(void *pvParameters) {
    3754:	cf 93       	push	r28
    3756:	df 93       	push	r29
    3758:	cd b7       	in	r28, 0x3d	; 61
    375a:	de b7       	in	r29, 0x3e	; 62
    375c:	28 97       	sbiw	r28, 0x08	; 8
    375e:	0f b6       	in	r0, 0x3f	; 63
    3760:	f8 94       	cli
    3762:	de bf       	out	0x3e, r29	; 62
    3764:	0f be       	out	0x3f, r0	; 63
    3766:	cd bf       	out	0x3d, r28	; 61
    3768:	98 87       	std	Y+8, r25	; 0x08
    376a:	8f 83       	std	Y+7, r24	; 0x07
	// Make compiler happy
	(void) pvParameters;
	
	// Previous wake time pointer
	TickType_t xLastWakeTime = xTaskGetTickCount();
    376c:	0e 94 1a 12 	call	0x2434	; 0x2434 <xTaskGetTickCount>
    3770:	9c 83       	std	Y+4, r25	; 0x04
    3772:	8b 83       	std	Y+3, r24	; 0x03
	// Period
	const TickType_t xPeriod = 1000;		// In ticks (ms)
    3774:	88 ee       	ldi	r24, 0xE8	; 232
    3776:	93 e0       	ldi	r25, 0x03	; 3
    3778:	9a 83       	std	Y+2, r25	; 0x02
    377a:	89 83       	std	Y+1, r24	; 0x01
	
	static CAN_packet packet = {0x204, 2, "fa"};
	
	
	// Setup values
	data.currentState = RTD;
    377c:	82 e0       	ldi	r24, 0x02	; 2
    377e:	8d 83       	std	Y+5, r24	; 0x05
	data.someData = 10;
    3780:	8a e0       	ldi	r24, 0x0A	; 10
    3782:	8e 83       	std	Y+6, r24	; 0x06
	
	for(;;) {
		// Transmit the data
		//can_tx(FSM_HEARTBEAT_ID, (uint8_t *)&data, sizeof(HeartbeatFSM));
		can_send(&packet, 1, 100);
    3784:	44 e6       	ldi	r20, 0x64	; 100
    3786:	50 e0       	ldi	r21, 0x00	; 0
    3788:	61 e0       	ldi	r22, 0x01	; 1
    378a:	70 e0       	ldi	r23, 0x00	; 0
    378c:	80 e0       	ldi	r24, 0x00	; 0
    378e:	91 e0       	ldi	r25, 0x01	; 1
    3790:	0e 94 a7 03 	call	0x74e	; 0x74e <can_send>
		
		
		// Delay 100ms
		vTaskDelayUntil(&xLastWakeTime, xPeriod);  
    3794:	29 81       	ldd	r18, Y+1	; 0x01
    3796:	3a 81       	ldd	r19, Y+2	; 0x02
    3798:	ce 01       	movw	r24, r28
    379a:	03 96       	adiw	r24, 0x03	; 3
    379c:	b9 01       	movw	r22, r18
    379e:	0e 94 8a 10 	call	0x2114	; 0x2114 <vTaskDelayUntil>
	}
    37a2:	f0 cf       	rjmp	.-32     	; 0x3784 <vHeartbeatTask+0x30>

000037a4 <vCANSendTask>:
/* Send over CAN
 * 
 * 
 * 
 */
void vCANSendTask(void *pvParameters) {
    37a4:	cf 93       	push	r28
    37a6:	df 93       	push	r29
    37a8:	00 d0       	rcall	.+0      	; 0x37aa <vCANSendTask+0x6>
    37aa:	cd b7       	in	r28, 0x3d	; 61
    37ac:	de b7       	in	r29, 0x3e	; 62
    37ae:	9a 83       	std	Y+2, r25	; 0x02
    37b0:	89 83       	std	Y+1, r24	; 0x01
	// Make compiler happy
	(void) pvParameters;
}
    37b2:	0f 90       	pop	r0
    37b4:	0f 90       	pop	r0
    37b6:	df 91       	pop	r29
    37b8:	cf 91       	pop	r28
    37ba:	08 95       	ret

000037bc <vCANReceiveTask>:
/* Receive from CAN
 * 
 * 
 * 
 */
void vCANReceiveTask(void *pvParameters) {
    37bc:	cf 93       	push	r28
    37be:	df 93       	push	r29
    37c0:	00 d0       	rcall	.+0      	; 0x37c2 <vCANReceiveTask+0x6>
    37c2:	cd b7       	in	r28, 0x3d	; 61
    37c4:	de b7       	in	r29, 0x3e	; 62
    37c6:	9a 83       	std	Y+2, r25	; 0x02
    37c8:	89 83       	std	Y+1, r24	; 0x01
	// Make compiler happy
	(void) pvParameters;
    37ca:	0f 90       	pop	r0
    37cc:	0f 90       	pop	r0
    37ce:	df 91       	pop	r29
    37d0:	cf 91       	pop	r28
    37d2:	08 95       	ret

000037d4 <adc_read>:
    37d4:	90 91 7c 00 	lds	r25, 0x007C
    37d8:	90 7e       	andi	r25, 0xE0	; 224
    37da:	90 93 7c 00 	sts	0x007C, r25
    37de:	8d 30       	cpi	r24, 0x0D	; 13
    37e0:	08 f0       	brcs	.+2      	; 0x37e4 <adc_read+0x10>
    37e2:	82 e1       	ldi	r24, 0x12	; 18
    37e4:	90 91 7c 00 	lds	r25, 0x007C
    37e8:	89 2b       	or	r24, r25
    37ea:	80 93 7c 00 	sts	0x007C, r24
    37ee:	80 91 7a 00 	lds	r24, 0x007A
    37f2:	80 64       	ori	r24, 0x40	; 64
    37f4:	80 93 7a 00 	sts	0x007A, r24
    37f8:	80 91 7a 00 	lds	r24, 0x007A
    37fc:	86 fd       	sbrc	r24, 6
    37fe:	fc cf       	rjmp	.-8      	; 0x37f8 <adc_read+0x24>
    3800:	80 91 79 00 	lds	r24, 0x0079
    3804:	08 95       	ret

00003806 <config_io_pin>:
    3806:	81 30       	cpi	r24, 0x01	; 1
    3808:	b9 f0       	breq	.+46     	; 0x3838 <config_io_pin+0x32>
    380a:	18 f0       	brcs	.+6      	; 0x3812 <config_io_pin+0xc>
    380c:	82 30       	cpi	r24, 0x02	; 2
    380e:	39 f1       	breq	.+78     	; 0x385e <config_io_pin+0x58>
    3810:	08 95       	ret
    3812:	84 b1       	in	r24, 0x04	; 4
    3814:	24 b1       	in	r18, 0x04	; 4
    3816:	50 e0       	ldi	r21, 0x00	; 0
    3818:	51 95       	neg	r21
    381a:	41 95       	neg	r20
    381c:	51 09       	sbc	r21, r1
    381e:	48 27       	eor	r20, r24
    3820:	81 e0       	ldi	r24, 0x01	; 1
    3822:	90 e0       	ldi	r25, 0x00	; 0
    3824:	02 c0       	rjmp	.+4      	; 0x382a <config_io_pin+0x24>
    3826:	88 0f       	add	r24, r24
    3828:	99 1f       	adc	r25, r25
    382a:	6a 95       	dec	r22
    382c:	e2 f7       	brpl	.-8      	; 0x3826 <config_io_pin+0x20>
    382e:	48 23       	and	r20, r24
    3830:	59 23       	and	r21, r25
    3832:	42 27       	eor	r20, r18
    3834:	44 b9       	out	0x04, r20	; 4
    3836:	08 95       	ret
    3838:	87 b1       	in	r24, 0x07	; 7
    383a:	27 b1       	in	r18, 0x07	; 7
    383c:	50 e0       	ldi	r21, 0x00	; 0
    383e:	51 95       	neg	r21
    3840:	41 95       	neg	r20
    3842:	51 09       	sbc	r21, r1
    3844:	48 27       	eor	r20, r24
    3846:	81 e0       	ldi	r24, 0x01	; 1
    3848:	90 e0       	ldi	r25, 0x00	; 0
    384a:	02 c0       	rjmp	.+4      	; 0x3850 <config_io_pin+0x4a>
    384c:	88 0f       	add	r24, r24
    384e:	99 1f       	adc	r25, r25
    3850:	6a 95       	dec	r22
    3852:	e2 f7       	brpl	.-8      	; 0x384c <config_io_pin+0x46>
    3854:	48 23       	and	r20, r24
    3856:	59 23       	and	r21, r25
    3858:	42 27       	eor	r20, r18
    385a:	47 b9       	out	0x07, r20	; 7
    385c:	08 95       	ret
    385e:	8a b1       	in	r24, 0x0a	; 10
    3860:	2a b1       	in	r18, 0x0a	; 10
    3862:	50 e0       	ldi	r21, 0x00	; 0
    3864:	51 95       	neg	r21
    3866:	41 95       	neg	r20
    3868:	51 09       	sbc	r21, r1
    386a:	48 27       	eor	r20, r24
    386c:	81 e0       	ldi	r24, 0x01	; 1
    386e:	90 e0       	ldi	r25, 0x00	; 0
    3870:	02 c0       	rjmp	.+4      	; 0x3876 <config_io_pin+0x70>
    3872:	88 0f       	add	r24, r24
    3874:	99 1f       	adc	r25, r25
    3876:	6a 95       	dec	r22
    3878:	e2 f7       	brpl	.-8      	; 0x3872 <config_io_pin+0x6c>
    387a:	48 23       	and	r20, r24
    387c:	59 23       	and	r21, r25
    387e:	42 27       	eor	r20, r18
    3880:	4a b9       	out	0x0a, r20	; 10
    3882:	08 95       	ret

00003884 <set_io_pin>:
    3884:	81 30       	cpi	r24, 0x01	; 1
    3886:	b9 f0       	breq	.+46     	; 0x38b6 <set_io_pin+0x32>
    3888:	18 f0       	brcs	.+6      	; 0x3890 <set_io_pin+0xc>
    388a:	82 30       	cpi	r24, 0x02	; 2
    388c:	39 f1       	breq	.+78     	; 0x38dc <set_io_pin+0x58>
    388e:	08 95       	ret
    3890:	85 b1       	in	r24, 0x05	; 5
    3892:	25 b1       	in	r18, 0x05	; 5
    3894:	50 e0       	ldi	r21, 0x00	; 0
    3896:	51 95       	neg	r21
    3898:	41 95       	neg	r20
    389a:	51 09       	sbc	r21, r1
    389c:	48 27       	eor	r20, r24
    389e:	81 e0       	ldi	r24, 0x01	; 1
    38a0:	90 e0       	ldi	r25, 0x00	; 0
    38a2:	02 c0       	rjmp	.+4      	; 0x38a8 <set_io_pin+0x24>
    38a4:	88 0f       	add	r24, r24
    38a6:	99 1f       	adc	r25, r25
    38a8:	6a 95       	dec	r22
    38aa:	e2 f7       	brpl	.-8      	; 0x38a4 <set_io_pin+0x20>
    38ac:	48 23       	and	r20, r24
    38ae:	59 23       	and	r21, r25
    38b0:	42 27       	eor	r20, r18
    38b2:	45 b9       	out	0x05, r20	; 5
    38b4:	08 95       	ret
    38b6:	88 b1       	in	r24, 0x08	; 8
    38b8:	28 b1       	in	r18, 0x08	; 8
    38ba:	50 e0       	ldi	r21, 0x00	; 0
    38bc:	51 95       	neg	r21
    38be:	41 95       	neg	r20
    38c0:	51 09       	sbc	r21, r1
    38c2:	48 27       	eor	r20, r24
    38c4:	81 e0       	ldi	r24, 0x01	; 1
    38c6:	90 e0       	ldi	r25, 0x00	; 0
    38c8:	02 c0       	rjmp	.+4      	; 0x38ce <set_io_pin+0x4a>
    38ca:	88 0f       	add	r24, r24
    38cc:	99 1f       	adc	r25, r25
    38ce:	6a 95       	dec	r22
    38d0:	e2 f7       	brpl	.-8      	; 0x38ca <set_io_pin+0x46>
    38d2:	48 23       	and	r20, r24
    38d4:	59 23       	and	r21, r25
    38d6:	42 27       	eor	r20, r18
    38d8:	48 b9       	out	0x08, r20	; 8
    38da:	08 95       	ret
    38dc:	8b b1       	in	r24, 0x0b	; 11
    38de:	2b b1       	in	r18, 0x0b	; 11
    38e0:	50 e0       	ldi	r21, 0x00	; 0
    38e2:	51 95       	neg	r21
    38e4:	41 95       	neg	r20
    38e6:	51 09       	sbc	r21, r1
    38e8:	48 27       	eor	r20, r24
    38ea:	81 e0       	ldi	r24, 0x01	; 1
    38ec:	90 e0       	ldi	r25, 0x00	; 0
    38ee:	02 c0       	rjmp	.+4      	; 0x38f4 <set_io_pin+0x70>
    38f0:	88 0f       	add	r24, r24
    38f2:	99 1f       	adc	r25, r25
    38f4:	6a 95       	dec	r22
    38f6:	e2 f7       	brpl	.-8      	; 0x38f0 <set_io_pin+0x6c>
    38f8:	48 23       	and	r20, r24
    38fa:	59 23       	and	r21, r25
    38fc:	42 27       	eor	r20, r18
    38fe:	4b b9       	out	0x0b, r20	; 11
    3900:	08 95       	ret

00003902 <memcpy>:
    3902:	fb 01       	movw	r30, r22
    3904:	dc 01       	movw	r26, r24
    3906:	02 c0       	rjmp	.+4      	; 0x390c <memcpy+0xa>
    3908:	01 90       	ld	r0, Z+
    390a:	0d 92       	st	X+, r0
    390c:	41 50       	subi	r20, 0x01	; 1
    390e:	50 40       	sbci	r21, 0x00	; 0
    3910:	d8 f7       	brcc	.-10     	; 0x3908 <memcpy+0x6>
    3912:	08 95       	ret

00003914 <_exit>:
    3914:	f8 94       	cli

00003916 <__stop_program>:
    3916:	ff cf       	rjmp	.-2      	; 0x3916 <__stop_program>
