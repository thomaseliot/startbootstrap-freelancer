
FrontSensorModule.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00800100  000050ae  00005142  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000050ae  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000045b  0080010e  0080010e  00005150  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00005150  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00005180  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000120  00000000  00000000  000051c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002933  00000000  00000000  000052e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000009d3  00000000  00000000  00007c13  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000024bb  00000000  00000000  000085e6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000bd0  00000000  00000000  0000aaa4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000ff7b  00000000  00000000  0000b674  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000183b  00000000  00000000  0001b5ef  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000018  00000000  00000000  0001ce2a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000526e  00000000  00000000  0001ce42  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 49 00 	jmp	0x92	; 0x92 <__ctors_end>
       4:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
       8:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
       c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      10:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      14:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      18:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      1c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      20:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      24:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      28:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      2c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      30:	0c 94 44 14 	jmp	0x2888	; 0x2888 <__vector_12>
      34:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      38:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      3c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      40:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      44:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      48:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      4c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      50:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      54:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      58:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      5c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      60:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      64:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      68:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      6c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      70:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      74:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      78:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      7c:	57 04       	cpc	r5, r7
      7e:	4d 05       	cpc	r20, r13
      80:	37 06       	cpc	r3, r23
      82:	05 07       	cpc	r16, r21
      84:	88 07       	cpc	r24, r24
      86:	18 08       	sbc	r1, r8
      88:	b2 08       	sbc	r11, r2
      8a:	d8 09       	sbc	r29, r8
      8c:	0b 0b       	sbc	r16, r27
      8e:	48 0c       	add	r4, r8
      90:	fe 0c       	add	r15, r14

00000092 <__ctors_end>:
      92:	11 24       	eor	r1, r1
      94:	1f be       	out	0x3f, r1	; 63
      96:	cf ef       	ldi	r28, 0xFF	; 255
      98:	d0 e1       	ldi	r29, 0x10	; 16
      9a:	de bf       	out	0x3e, r29	; 62
      9c:	cd bf       	out	0x3d, r28	; 61

0000009e <__do_copy_data>:
      9e:	11 e0       	ldi	r17, 0x01	; 1
      a0:	a0 e0       	ldi	r26, 0x00	; 0
      a2:	b1 e0       	ldi	r27, 0x01	; 1
      a4:	ee ea       	ldi	r30, 0xAE	; 174
      a6:	f0 e5       	ldi	r31, 0x50	; 80
      a8:	02 c0       	rjmp	.+4      	; 0xae <__do_copy_data+0x10>
      aa:	05 90       	lpm	r0, Z+
      ac:	0d 92       	st	X+, r0
      ae:	ae 30       	cpi	r26, 0x0E	; 14
      b0:	b1 07       	cpc	r27, r17
      b2:	d9 f7       	brne	.-10     	; 0xaa <__do_copy_data+0xc>

000000b4 <__do_clear_bss>:
      b4:	25 e0       	ldi	r18, 0x05	; 5
      b6:	ae e0       	ldi	r26, 0x0E	; 14
      b8:	b1 e0       	ldi	r27, 0x01	; 1
      ba:	01 c0       	rjmp	.+2      	; 0xbe <.do_clear_bss_start>

000000bc <.do_clear_bss_loop>:
      bc:	1d 92       	st	X+, r1

000000be <.do_clear_bss_start>:
      be:	a9 36       	cpi	r26, 0x69	; 105
      c0:	b2 07       	cpc	r27, r18
      c2:	e1 f7       	brne	.-8      	; 0xbc <.do_clear_bss_loop>
      c4:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <main>
      c8:	0c 94 55 28 	jmp	0x50aa	; 0x50aa <_exit>

000000cc <__bad_interrupt>:
      cc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d0 <can_clear_all_mob>:
//! @param none
//!
//! @return none
//------------------------------------------------------------------------------
void can_clear_all_mob(void)
{
      d0:	cf 93       	push	r28
      d2:	df 93       	push	r29
      d4:	00 d0       	rcall	.+0      	; 0xd6 <can_clear_all_mob+0x6>
      d6:	1f 92       	push	r1
      d8:	cd b7       	in	r28, 0x3d	; 61
      da:	de b7       	in	r29, 0x3e	; 62
uint8_t  mob_number;
/*
    uint8_t  data_index;
*/

    for (mob_number = 0; mob_number < NB_MOB; mob_number++)
      dc:	19 82       	std	Y+1, r1	; 0x01
      de:	1d c0       	rjmp	.+58     	; 0x11a <can_clear_all_mob+0x4a>
    {
        CANPAGE = (mob_number << 4);    //! Page index
      e0:	8d ee       	ldi	r24, 0xED	; 237
      e2:	90 e0       	ldi	r25, 0x00	; 0
      e4:	29 81       	ldd	r18, Y+1	; 0x01
      e6:	22 95       	swap	r18
      e8:	20 7f       	andi	r18, 0xF0	; 240
      ea:	fc 01       	movw	r30, r24
      ec:	20 83       	st	Z, r18
        Can_clear_mob();                //! All MOb Registers=0
      ee:	8e ee       	ldi	r24, 0xEE	; 238
      f0:	90 e0       	ldi	r25, 0x00	; 0
      f2:	9b 83       	std	Y+3, r25	; 0x03
      f4:	8a 83       	std	Y+2, r24	; 0x02
      f6:	09 c0       	rjmp	.+18     	; 0x10a <can_clear_all_mob+0x3a>
      f8:	8a 81       	ldd	r24, Y+2	; 0x02
      fa:	9b 81       	ldd	r25, Y+3	; 0x03
      fc:	fc 01       	movw	r30, r24
      fe:	10 82       	st	Z, r1
     100:	8a 81       	ldd	r24, Y+2	; 0x02
     102:	9b 81       	ldd	r25, Y+3	; 0x03
     104:	01 96       	adiw	r24, 0x01	; 1
     106:	9b 83       	std	Y+3, r25	; 0x03
     108:	8a 83       	std	Y+2, r24	; 0x02
     10a:	8a 81       	ldd	r24, Y+2	; 0x02
     10c:	9b 81       	ldd	r25, Y+3	; 0x03
     10e:	88 3f       	cpi	r24, 0xF8	; 248
     110:	91 05       	cpc	r25, r1
     112:	90 f3       	brcs	.-28     	; 0xf8 <can_clear_all_mob+0x28>
uint8_t  mob_number;
/*
    uint8_t  data_index;
*/

    for (mob_number = 0; mob_number < NB_MOB; mob_number++)
     114:	89 81       	ldd	r24, Y+1	; 0x01
     116:	8f 5f       	subi	r24, 0xFF	; 255
     118:	89 83       	std	Y+1, r24	; 0x01
     11a:	89 81       	ldd	r24, Y+1	; 0x01
     11c:	86 30       	cpi	r24, 0x06	; 6
     11e:	00 f3       	brcs	.-64     	; 0xe0 <can_clear_all_mob+0x10>
        {
            CANMSG = 0;                 //! MOb data FIFO
        }
*/
    }
}
     120:	0f 90       	pop	r0
     122:	0f 90       	pop	r0
     124:	0f 90       	pop	r0
     126:	df 91       	pop	r29
     128:	cf 91       	pop	r28
     12a:	08 95       	ret

0000012c <can_get_mob_free>:
//! @return Handle of MOb.
//!          - MOb[0] upto MOb[LAST_MOB_NB]
//!          - 0xFF if no MOb
//------------------------------------------------------------------------------
uint8_t can_get_mob_free(void)
{
     12c:	cf 93       	push	r28
     12e:	df 93       	push	r29
     130:	00 d0       	rcall	.+0      	; 0x132 <can_get_mob_free+0x6>
     132:	cd b7       	in	r28, 0x3d	; 61
     134:	de b7       	in	r29, 0x3e	; 62
    uint8_t mob_number, page_saved;

    page_saved = CANPAGE;
     136:	8d ee       	ldi	r24, 0xED	; 237
     138:	90 e0       	ldi	r25, 0x00	; 0
     13a:	fc 01       	movw	r30, r24
     13c:	80 81       	ld	r24, Z
     13e:	8a 83       	std	Y+2, r24	; 0x02
    for (mob_number = 0; mob_number < NB_MOB; mob_number++)
     140:	19 82       	std	Y+1, r1	; 0x01
     142:	1b c0       	rjmp	.+54     	; 0x17a <can_get_mob_free+0x4e>
    {
        Can_set_mob(mob_number);
     144:	8d ee       	ldi	r24, 0xED	; 237
     146:	90 e0       	ldi	r25, 0x00	; 0
     148:	29 81       	ldd	r18, Y+1	; 0x01
     14a:	22 95       	swap	r18
     14c:	20 7f       	andi	r18, 0xF0	; 240
     14e:	fc 01       	movw	r30, r24
     150:	20 83       	st	Z, r18
        if ((CANCDMOB & 0xC0) == 0x00) //! Disable configuration
     152:	8f ee       	ldi	r24, 0xEF	; 239
     154:	90 e0       	ldi	r25, 0x00	; 0
     156:	fc 01       	movw	r30, r24
     158:	80 81       	ld	r24, Z
     15a:	88 2f       	mov	r24, r24
     15c:	90 e0       	ldi	r25, 0x00	; 0
     15e:	80 7c       	andi	r24, 0xC0	; 192
     160:	99 27       	eor	r25, r25
     162:	89 2b       	or	r24, r25
     164:	39 f4       	brne	.+14     	; 0x174 <can_get_mob_free+0x48>
        {
            CANPAGE = page_saved;
     166:	8d ee       	ldi	r24, 0xED	; 237
     168:	90 e0       	ldi	r25, 0x00	; 0
     16a:	2a 81       	ldd	r18, Y+2	; 0x02
     16c:	fc 01       	movw	r30, r24
     16e:	20 83       	st	Z, r18
            return (mob_number);
     170:	89 81       	ldd	r24, Y+1	; 0x01
     172:	0c c0       	rjmp	.+24     	; 0x18c <can_get_mob_free+0x60>
uint8_t can_get_mob_free(void)
{
    uint8_t mob_number, page_saved;

    page_saved = CANPAGE;
    for (mob_number = 0; mob_number < NB_MOB; mob_number++)
     174:	89 81       	ldd	r24, Y+1	; 0x01
     176:	8f 5f       	subi	r24, 0xFF	; 255
     178:	89 83       	std	Y+1, r24	; 0x01
     17a:	89 81       	ldd	r24, Y+1	; 0x01
     17c:	86 30       	cpi	r24, 0x06	; 6
     17e:	10 f3       	brcs	.-60     	; 0x144 <can_get_mob_free+0x18>
        {
            CANPAGE = page_saved;
            return (mob_number);
        }
    }
    CANPAGE = page_saved;
     180:	8d ee       	ldi	r24, 0xED	; 237
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	2a 81       	ldd	r18, Y+2	; 0x02
     186:	fc 01       	movw	r30, r24
     188:	20 83       	st	Z, r18
    return (NO_MOB);
     18a:	8f ef       	ldi	r24, 0xFF	; 255
}
     18c:	0f 90       	pop	r0
     18e:	0f 90       	pop	r0
     190:	df 91       	pop	r29
     192:	cf 91       	pop	r28
     194:	08 95       	ret

00000196 <can_get_mob_status>:
//!          -  MOB_CRC_ERROR
//!          -  MOB_STUFF_ERROR
//!          -  MOB_BIT_ERROR
//------------------------------------------------------------------------------
uint8_t can_get_mob_status(void)
{
     196:	cf 93       	push	r28
     198:	df 93       	push	r29
     19a:	00 d0       	rcall	.+0      	; 0x19c <can_get_mob_status+0x6>
     19c:	cd b7       	in	r28, 0x3d	; 61
     19e:	de b7       	in	r29, 0x3e	; 62
    uint8_t mob_status, canstmob_copy;

    // Test if MOb ENABLE or DISABLE
    if ((CANCDMOB & 0xC0) == 0x00) {return(MOB_DISABLE);}
     1a0:	8f ee       	ldi	r24, 0xEF	; 239
     1a2:	90 e0       	ldi	r25, 0x00	; 0
     1a4:	fc 01       	movw	r30, r24
     1a6:	80 81       	ld	r24, Z
     1a8:	88 2f       	mov	r24, r24
     1aa:	90 e0       	ldi	r25, 0x00	; 0
     1ac:	80 7c       	andi	r24, 0xC0	; 192
     1ae:	99 27       	eor	r25, r25
     1b0:	89 2b       	or	r24, r25
     1b2:	11 f4       	brne	.+4      	; 0x1b8 <can_get_mob_status+0x22>
     1b4:	8f ef       	ldi	r24, 0xFF	; 255
     1b6:	1c c0       	rjmp	.+56     	; 0x1f0 <can_get_mob_status+0x5a>

    canstmob_copy = CANSTMOB; // Copy for test integrity
     1b8:	8e ee       	ldi	r24, 0xEE	; 238
     1ba:	90 e0       	ldi	r25, 0x00	; 0
     1bc:	fc 01       	movw	r30, r24
     1be:	80 81       	ld	r24, Z
     1c0:	89 83       	std	Y+1, r24	; 0x01

    // If MOb is ENABLE, test if MOb is COMPLETED
    // - MOb Status = 0x20 then MOB_RX_COMPLETED
    // - MOb Status = 0x40 then MOB_TX_COMPLETED
    // - MOb Status = 0xA0 then MOB_RX_COMPLETED_DLCW
    mob_status = canstmob_copy & ((1<<DLCW)|(1<<TXOK)|(1<<RXOK));
     1c2:	89 81       	ldd	r24, Y+1	; 0x01
     1c4:	80 7e       	andi	r24, 0xE0	; 224
     1c6:	8a 83       	std	Y+2, r24	; 0x02
    if ( (mob_status==MOB_RX_COMPLETED) ||   \
     1c8:	8a 81       	ldd	r24, Y+2	; 0x02
     1ca:	80 32       	cpi	r24, 0x20	; 32
     1cc:	31 f0       	breq	.+12     	; 0x1da <can_get_mob_status+0x44>
     1ce:	8a 81       	ldd	r24, Y+2	; 0x02
     1d0:	80 34       	cpi	r24, 0x40	; 64
     1d2:	19 f0       	breq	.+6      	; 0x1da <can_get_mob_status+0x44>
         (mob_status==MOB_TX_COMPLETED) ||   \
     1d4:	8a 81       	ldd	r24, Y+2	; 0x02
     1d6:	80 3a       	cpi	r24, 0xA0	; 160
     1d8:	11 f4       	brne	.+4      	; 0x1de <can_get_mob_status+0x48>
         (mob_status==MOB_RX_COMPLETED_DLCW) ) { return(mob_status); }
     1da:	8a 81       	ldd	r24, Y+2	; 0x02
     1dc:	09 c0       	rjmp	.+18     	; 0x1f0 <can_get_mob_status+0x5a>
    // - MOb Status bit_0 = MOB_ACK_ERROR
    // - MOb Status bit_1 = MOB_FORM_ERROR
    // - MOb Status bit_2 = MOB_CRC_ERROR
    // - MOb Status bit_3 = MOB_STUFF_ERROR
    // - MOb Status bit_4 = MOB_BIT_ERROR
    mob_status = canstmob_copy & ERR_MOB_MSK;
     1de:	89 81       	ldd	r24, Y+1	; 0x01
     1e0:	8f 71       	andi	r24, 0x1F	; 31
     1e2:	8a 83       	std	Y+2, r24	; 0x02
    if (mob_status != 0) { return(mob_status); }
     1e4:	8a 81       	ldd	r24, Y+2	; 0x02
     1e6:	88 23       	and	r24, r24
     1e8:	11 f0       	breq	.+4      	; 0x1ee <can_get_mob_status+0x58>
     1ea:	8a 81       	ldd	r24, Y+2	; 0x02
     1ec:	01 c0       	rjmp	.+2      	; 0x1f0 <can_get_mob_status+0x5a>

    // If CANSTMOB = 0 then MOB_NOT_COMPLETED
    return(MOB_NOT_COMPLETED);
     1ee:	80 e0       	ldi	r24, 0x00	; 0
}
     1f0:	0f 90       	pop	r0
     1f2:	0f 90       	pop	r0
     1f4:	df 91       	pop	r29
     1f6:	cf 91       	pop	r28
     1f8:	08 95       	ret

000001fa <can_get_data>:
//! @param CAN message data address.
//!
//! @return none.
//------------------------------------------------------------------------------
void can_get_data(uint8_t* p_can_message_data)
{
     1fa:	cf 93       	push	r28
     1fc:	df 93       	push	r29
     1fe:	00 d0       	rcall	.+0      	; 0x200 <can_get_data+0x6>
     200:	1f 92       	push	r1
     202:	cd b7       	in	r28, 0x3d	; 61
     204:	de b7       	in	r29, 0x3e	; 62
     206:	9b 83       	std	Y+3, r25	; 0x03
     208:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data_index;

    for (data_index = 0; data_index < (Can_get_dlc()); data_index++)
     20a:	19 82       	std	Y+1, r1	; 0x01
     20c:	10 c0       	rjmp	.+32     	; 0x22e <can_get_data+0x34>
    {
        *(p_can_message_data + data_index) = CANMSG;
     20e:	89 81       	ldd	r24, Y+1	; 0x01
     210:	88 2f       	mov	r24, r24
     212:	90 e0       	ldi	r25, 0x00	; 0
     214:	2a 81       	ldd	r18, Y+2	; 0x02
     216:	3b 81       	ldd	r19, Y+3	; 0x03
     218:	82 0f       	add	r24, r18
     21a:	93 1f       	adc	r25, r19
     21c:	2a ef       	ldi	r18, 0xFA	; 250
     21e:	30 e0       	ldi	r19, 0x00	; 0
     220:	f9 01       	movw	r30, r18
     222:	20 81       	ld	r18, Z
     224:	fc 01       	movw	r30, r24
     226:	20 83       	st	Z, r18
//------------------------------------------------------------------------------
void can_get_data(uint8_t* p_can_message_data)
{
    uint8_t data_index;

    for (data_index = 0; data_index < (Can_get_dlc()); data_index++)
     228:	89 81       	ldd	r24, Y+1	; 0x01
     22a:	8f 5f       	subi	r24, 0xFF	; 255
     22c:	89 83       	std	Y+1, r24	; 0x01
     22e:	89 81       	ldd	r24, Y+1	; 0x01
     230:	28 2f       	mov	r18, r24
     232:	30 e0       	ldi	r19, 0x00	; 0
     234:	8f ee       	ldi	r24, 0xEF	; 239
     236:	90 e0       	ldi	r25, 0x00	; 0
     238:	fc 01       	movw	r30, r24
     23a:	80 81       	ld	r24, Z
     23c:	88 2f       	mov	r24, r24
     23e:	90 e0       	ldi	r25, 0x00	; 0
     240:	8f 70       	andi	r24, 0x0F	; 15
     242:	99 27       	eor	r25, r25
     244:	28 17       	cp	r18, r24
     246:	39 07       	cpc	r19, r25
     248:	14 f3       	brlt	.-60     	; 0x20e <can_get_data+0x14>
    {
        *(p_can_message_data + data_index) = CANMSG;
    }
}
     24a:	0f 90       	pop	r0
     24c:	0f 90       	pop	r0
     24e:	0f 90       	pop	r0
     250:	df 91       	pop	r29
     252:	cf 91       	pop	r28
     254:	08 95       	ret

00000256 <can_auto_baudrate>:
//! @return Baudrate Status
//!         ==0: research of bit timing configuration failed
//!         ==1: baudrate performed
//------------------------------------------------------------------------------
uint8_t can_auto_baudrate (uint8_t mode)
{
     256:	cf 93       	push	r28
     258:	df 93       	push	r29
     25a:	cd b7       	in	r28, 0x3d	; 61
     25c:	de b7       	in	r29, 0x3e	; 62
     25e:	62 97       	sbiw	r28, 0x12	; 18
     260:	0f b6       	in	r0, 0x3f	; 63
     262:	f8 94       	cli
     264:	de bf       	out	0x3e, r29	; 62
     266:	0f be       	out	0x3f, r0	; 63
     268:	cd bf       	out	0x3d, r28	; 61
     26a:	8a 8b       	std	Y+18, r24	; 0x12
    uint8_t  u8_temp0;                               //! Temporary variable
    uint8_t  brp, prs, ntq, phs1, phs2;              //! Bit timing segment variables
    uint8_t  phs1_inc;                               //! Computing needed
    uint8_t  bt_not_found, wait_for_rx, evaluate;    //! Keys for "while()" loops
    uint8_t  try_conf;                               //! Key for configurate CAN
    uint8_t  ovrtim_flag=0;                          //! Timer overflow count
     26c:	1c 86       	std	Y+12, r1	; 0x0c
    uint16_t conf_index;                             //! Count of bit timing configuration tried
    uint8_t  bt_performed;                           //! Return flag

    //! --- Default setting
    phs1_inc = evaluate = 0;
     26e:	1a 86       	std	Y+10, r1	; 0x0a
     270:	8a 85       	ldd	r24, Y+10	; 0x0a
     272:	8f 83       	std	Y+7, r24	; 0x07
    bt_performed = 0;
     274:	1f 86       	std	Y+15, r1	; 0x0f
    conf_index = 0;
     276:	1e 86       	std	Y+14, r1	; 0x0e
     278:	1d 86       	std	Y+13, r1	; 0x0d
    bt_not_found = 1;
     27a:	81 e0       	ldi	r24, 0x01	; 1
     27c:	88 87       	std	Y+8, r24	; 0x08

    //! --- Init segment variables with MIN values if mode=0
    //!     or init segment variables with CANBTx if mode=1
    if (mode==0)
     27e:	8a 89       	ldd	r24, Y+18	; 0x12
     280:	88 23       	and	r24, r24
     282:	b1 f4       	brne	.+44     	; 0x2b0 <can_auto_baudrate+0x5a>
    {
        brp  = BRP_MIN;
     284:	81 e0       	ldi	r24, 0x01	; 1
     286:	8a 83       	std	Y+2, r24	; 0x02
        ntq  = NTQ_MIN;
     288:	88 e0       	ldi	r24, 0x08	; 8
     28a:	8c 83       	std	Y+4, r24	; 0x04
        phs1 = PHS1_MIN;
     28c:	82 e0       	ldi	r24, 0x02	; 2
     28e:	8d 83       	std	Y+5, r24	; 0x05
        phs2 = PHS2_MIN;
     290:	82 e0       	ldi	r24, 0x02	; 2
     292:	8e 83       	std	Y+6, r24	; 0x06
        prs  = ntq - ( phs1 + phs2 + 1 );
     294:	9d 81       	ldd	r25, Y+5	; 0x05
     296:	8e 81       	ldd	r24, Y+6	; 0x06
     298:	89 0f       	add	r24, r25
     29a:	9c 81       	ldd	r25, Y+4	; 0x04
     29c:	29 2f       	mov	r18, r25
     29e:	28 1b       	sub	r18, r24
     2a0:	82 2f       	mov	r24, r18
     2a2:	81 50       	subi	r24, 0x01	; 1
     2a4:	8b 83       	std	Y+3, r24	; 0x03
        try_conf = 1;       //! Try this configuration
     2a6:	81 e0       	ldi	r24, 0x01	; 1
     2a8:	8b 87       	std	Y+11, r24	; 0x0b
        wait_for_rx = 1;    //! Enable "while (wait_for_rx ..." loop
     2aa:	81 e0       	ldi	r24, 0x01	; 1
     2ac:	89 87       	std	Y+9, r24	; 0x09
     2ae:	92 c0       	rjmp	.+292    	; 0x3d4 <can_auto_baudrate+0x17e>
    }
    else //! mode = 1
    {
        brp  = Max ((((CANBT1 &  BRP_MSK) >> 1) +1) , BRP_MIN );
     2b0:	82 ee       	ldi	r24, 0xE2	; 226
     2b2:	90 e0       	ldi	r25, 0x00	; 0
     2b4:	fc 01       	movw	r30, r24
     2b6:	80 81       	ld	r24, Z
     2b8:	88 2f       	mov	r24, r24
     2ba:	90 e0       	ldi	r25, 0x00	; 0
     2bc:	8e 77       	andi	r24, 0x7E	; 126
     2be:	99 27       	eor	r25, r25
     2c0:	95 95       	asr	r25
     2c2:	87 95       	ror	r24
     2c4:	01 96       	adiw	r24, 0x01	; 1
     2c6:	02 97       	sbiw	r24, 0x02	; 2
     2c8:	64 f0       	brlt	.+24     	; 0x2e2 <can_auto_baudrate+0x8c>
     2ca:	82 ee       	ldi	r24, 0xE2	; 226
     2cc:	90 e0       	ldi	r25, 0x00	; 0
     2ce:	fc 01       	movw	r30, r24
     2d0:	80 81       	ld	r24, Z
     2d2:	88 2f       	mov	r24, r24
     2d4:	90 e0       	ldi	r25, 0x00	; 0
     2d6:	8e 77       	andi	r24, 0x7E	; 126
     2d8:	99 27       	eor	r25, r25
     2da:	95 95       	asr	r25
     2dc:	87 95       	ror	r24
     2de:	8f 5f       	subi	r24, 0xFF	; 255
     2e0:	01 c0       	rjmp	.+2      	; 0x2e4 <can_auto_baudrate+0x8e>
     2e2:	81 e0       	ldi	r24, 0x01	; 1
     2e4:	8a 83       	std	Y+2, r24	; 0x02
        prs  = Max ((((CANBT2 &  PRS_MSK) >> 1) +1) , PRS_MIN );
     2e6:	83 ee       	ldi	r24, 0xE3	; 227
     2e8:	90 e0       	ldi	r25, 0x00	; 0
     2ea:	fc 01       	movw	r30, r24
     2ec:	80 81       	ld	r24, Z
     2ee:	88 2f       	mov	r24, r24
     2f0:	90 e0       	ldi	r25, 0x00	; 0
     2f2:	8e 70       	andi	r24, 0x0E	; 14
     2f4:	99 27       	eor	r25, r25
     2f6:	95 95       	asr	r25
     2f8:	87 95       	ror	r24
     2fa:	01 96       	adiw	r24, 0x01	; 1
     2fc:	02 97       	sbiw	r24, 0x02	; 2
     2fe:	64 f0       	brlt	.+24     	; 0x318 <can_auto_baudrate+0xc2>
     300:	83 ee       	ldi	r24, 0xE3	; 227
     302:	90 e0       	ldi	r25, 0x00	; 0
     304:	fc 01       	movw	r30, r24
     306:	80 81       	ld	r24, Z
     308:	88 2f       	mov	r24, r24
     30a:	90 e0       	ldi	r25, 0x00	; 0
     30c:	8e 70       	andi	r24, 0x0E	; 14
     30e:	99 27       	eor	r25, r25
     310:	95 95       	asr	r25
     312:	87 95       	ror	r24
     314:	8f 5f       	subi	r24, 0xFF	; 255
     316:	01 c0       	rjmp	.+2      	; 0x31a <can_auto_baudrate+0xc4>
     318:	81 e0       	ldi	r24, 0x01	; 1
     31a:	8b 83       	std	Y+3, r24	; 0x03
        phs1 = Max ((((CANBT3 & PHS1_MSK) >> 1) +1) , PHS1_MIN);
     31c:	84 ee       	ldi	r24, 0xE4	; 228
     31e:	90 e0       	ldi	r25, 0x00	; 0
     320:	fc 01       	movw	r30, r24
     322:	80 81       	ld	r24, Z
     324:	88 2f       	mov	r24, r24
     326:	90 e0       	ldi	r25, 0x00	; 0
     328:	8e 70       	andi	r24, 0x0E	; 14
     32a:	99 27       	eor	r25, r25
     32c:	95 95       	asr	r25
     32e:	87 95       	ror	r24
     330:	01 96       	adiw	r24, 0x01	; 1
     332:	03 97       	sbiw	r24, 0x03	; 3
     334:	64 f0       	brlt	.+24     	; 0x34e <can_auto_baudrate+0xf8>
     336:	84 ee       	ldi	r24, 0xE4	; 228
     338:	90 e0       	ldi	r25, 0x00	; 0
     33a:	fc 01       	movw	r30, r24
     33c:	80 81       	ld	r24, Z
     33e:	88 2f       	mov	r24, r24
     340:	90 e0       	ldi	r25, 0x00	; 0
     342:	8e 70       	andi	r24, 0x0E	; 14
     344:	99 27       	eor	r25, r25
     346:	95 95       	asr	r25
     348:	87 95       	ror	r24
     34a:	8f 5f       	subi	r24, 0xFF	; 255
     34c:	01 c0       	rjmp	.+2      	; 0x350 <can_auto_baudrate+0xfa>
     34e:	82 e0       	ldi	r24, 0x02	; 2
     350:	8d 83       	std	Y+5, r24	; 0x05
        phs2 = Max ((((CANBT3 & PHS2_MSK) >> 4) +1) , PHS2_MIN);
     352:	84 ee       	ldi	r24, 0xE4	; 228
     354:	90 e0       	ldi	r25, 0x00	; 0
     356:	fc 01       	movw	r30, r24
     358:	80 81       	ld	r24, Z
     35a:	88 2f       	mov	r24, r24
     35c:	90 e0       	ldi	r25, 0x00	; 0
     35e:	80 77       	andi	r24, 0x70	; 112
     360:	99 27       	eor	r25, r25
     362:	95 95       	asr	r25
     364:	87 95       	ror	r24
     366:	95 95       	asr	r25
     368:	87 95       	ror	r24
     36a:	95 95       	asr	r25
     36c:	87 95       	ror	r24
     36e:	95 95       	asr	r25
     370:	87 95       	ror	r24
     372:	01 96       	adiw	r24, 0x01	; 1
     374:	03 97       	sbiw	r24, 0x03	; 3
     376:	94 f0       	brlt	.+36     	; 0x39c <can_auto_baudrate+0x146>
     378:	84 ee       	ldi	r24, 0xE4	; 228
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	fc 01       	movw	r30, r24
     37e:	80 81       	ld	r24, Z
     380:	88 2f       	mov	r24, r24
     382:	90 e0       	ldi	r25, 0x00	; 0
     384:	80 77       	andi	r24, 0x70	; 112
     386:	99 27       	eor	r25, r25
     388:	95 95       	asr	r25
     38a:	87 95       	ror	r24
     38c:	95 95       	asr	r25
     38e:	87 95       	ror	r24
     390:	95 95       	asr	r25
     392:	87 95       	ror	r24
     394:	95 95       	asr	r25
     396:	87 95       	ror	r24
     398:	8f 5f       	subi	r24, 0xFF	; 255
     39a:	01 c0       	rjmp	.+2      	; 0x39e <can_auto_baudrate+0x148>
     39c:	82 e0       	ldi	r24, 0x02	; 2
     39e:	8e 83       	std	Y+6, r24	; 0x06
        ntq  = Max ((prs + phs1 + phs2 + 1) , NTQ_MIN);
     3a0:	8b 81       	ldd	r24, Y+3	; 0x03
     3a2:	28 2f       	mov	r18, r24
     3a4:	30 e0       	ldi	r19, 0x00	; 0
     3a6:	8d 81       	ldd	r24, Y+5	; 0x05
     3a8:	88 2f       	mov	r24, r24
     3aa:	90 e0       	ldi	r25, 0x00	; 0
     3ac:	28 0f       	add	r18, r24
     3ae:	39 1f       	adc	r19, r25
     3b0:	8e 81       	ldd	r24, Y+6	; 0x06
     3b2:	88 2f       	mov	r24, r24
     3b4:	90 e0       	ldi	r25, 0x00	; 0
     3b6:	82 0f       	add	r24, r18
     3b8:	93 1f       	adc	r25, r19
     3ba:	01 96       	adiw	r24, 0x01	; 1
     3bc:	88 30       	cpi	r24, 0x08	; 8
     3be:	91 05       	cpc	r25, r1
     3c0:	14 f4       	brge	.+4      	; 0x3c6 <can_auto_baudrate+0x170>
     3c2:	88 e0       	ldi	r24, 0x08	; 8
     3c4:	90 e0       	ldi	r25, 0x00	; 0
     3c6:	8c 83       	std	Y+4, r24	; 0x04
        phs1_inc = evaluate = 1;   //! To enter in "while (evaluate ..." loop
     3c8:	81 e0       	ldi	r24, 0x01	; 1
     3ca:	8a 87       	std	Y+10, r24	; 0x0a
     3cc:	8a 85       	ldd	r24, Y+10	; 0x0a
     3ce:	8f 83       	std	Y+7, r24	; 0x07
        try_conf = 0;       //! Look for the next configuration
     3d0:	1b 86       	std	Y+11, r1	; 0x0b
        wait_for_rx = 0;    //! Skip "while (wait_for_rx ..." loop
     3d2:	19 86       	std	Y+9, r1	; 0x09
    }

    //! --- Clear all MOb's (CANMSG not cleared)
    for (u8_temp0 = 0; u8_temp0 < NB_MOB; u8_temp0++)
     3d4:	19 82       	std	Y+1, r1	; 0x01
     3d6:	1d c0       	rjmp	.+58     	; 0x412 <can_auto_baudrate+0x1bc>
    {
        Can_set_mob(u8_temp0);  //! Page index
     3d8:	8d ee       	ldi	r24, 0xED	; 237
     3da:	90 e0       	ldi	r25, 0x00	; 0
     3dc:	29 81       	ldd	r18, Y+1	; 0x01
     3de:	22 95       	swap	r18
     3e0:	20 7f       	andi	r18, 0xF0	; 240
     3e2:	fc 01       	movw	r30, r24
     3e4:	20 83       	st	Z, r18
        Can_clear_mob();        //! All MOb Registers = 0x00
     3e6:	8e ee       	ldi	r24, 0xEE	; 238
     3e8:	90 e0       	ldi	r25, 0x00	; 0
     3ea:	99 8b       	std	Y+17, r25	; 0x11
     3ec:	88 8b       	std	Y+16, r24	; 0x10
     3ee:	09 c0       	rjmp	.+18     	; 0x402 <can_auto_baudrate+0x1ac>
     3f0:	88 89       	ldd	r24, Y+16	; 0x10
     3f2:	99 89       	ldd	r25, Y+17	; 0x11
     3f4:	fc 01       	movw	r30, r24
     3f6:	10 82       	st	Z, r1
     3f8:	88 89       	ldd	r24, Y+16	; 0x10
     3fa:	99 89       	ldd	r25, Y+17	; 0x11
     3fc:	01 96       	adiw	r24, 0x01	; 1
     3fe:	99 8b       	std	Y+17, r25	; 0x11
     400:	88 8b       	std	Y+16, r24	; 0x10
     402:	88 89       	ldd	r24, Y+16	; 0x10
     404:	99 89       	ldd	r25, Y+17	; 0x11
     406:	88 3f       	cpi	r24, 0xF8	; 248
     408:	91 05       	cpc	r25, r1
     40a:	90 f3       	brcs	.-28     	; 0x3f0 <can_auto_baudrate+0x19a>
        try_conf = 0;       //! Look for the next configuration
        wait_for_rx = 0;    //! Skip "while (wait_for_rx ..." loop
    }

    //! --- Clear all MOb's (CANMSG not cleared)
    for (u8_temp0 = 0; u8_temp0 < NB_MOB; u8_temp0++)
     40c:	89 81       	ldd	r24, Y+1	; 0x01
     40e:	8f 5f       	subi	r24, 0xFF	; 255
     410:	89 83       	std	Y+1, r24	; 0x01
     412:	89 81       	ldd	r24, Y+1	; 0x01
     414:	86 30       	cpi	r24, 0x06	; 6
     416:	00 f3       	brcs	.-64     	; 0x3d8 <can_auto_baudrate+0x182>
    {
        Can_set_mob(u8_temp0);  //! Page index
        Can_clear_mob();        //! All MOb Registers = 0x00
    }

    while (bt_not_found == 1)
     418:	81 c1       	rjmp	.+770    	; 0x71c <can_auto_baudrate+0x4c6>
    {
        if (try_conf == 1)
     41a:	8b 85       	ldd	r24, Y+11	; 0x0b
     41c:	81 30       	cpi	r24, 0x01	; 1
     41e:	09 f0       	breq	.+2      	; 0x422 <can_auto_baudrate+0x1cc>
     420:	74 c0       	rjmp	.+232    	; 0x50a <can_auto_baudrate+0x2b4>
        {
            Can_reset();
     422:	88 ed       	ldi	r24, 0xD8	; 216
     424:	90 e0       	ldi	r25, 0x00	; 0
     426:	21 e0       	ldi	r18, 0x01	; 1
     428:	fc 01       	movw	r30, r24
     42a:	20 83       	st	Z, r18
            conf_index++;
     42c:	8d 85       	ldd	r24, Y+13	; 0x0d
     42e:	9e 85       	ldd	r25, Y+14	; 0x0e
     430:	01 96       	adiw	r24, 0x01	; 1
     432:	9e 87       	std	Y+14, r25	; 0x0e
     434:	8d 87       	std	Y+13, r24	; 0x0d
            ovrtim_flag=0;
     436:	1c 86       	std	Y+12, r1	; 0x0c

            //! --- CANBTx registers update (sjw = phs2/2, 3 sample points)
            CANBT1 = ((brp-1) << BRP);
     438:	82 ee       	ldi	r24, 0xE2	; 226
     43a:	90 e0       	ldi	r25, 0x00	; 0
     43c:	2a 81       	ldd	r18, Y+2	; 0x02
     43e:	21 50       	subi	r18, 0x01	; 1
     440:	22 0f       	add	r18, r18
     442:	fc 01       	movw	r30, r24
     444:	20 83       	st	Z, r18
            CANBT2 = (((phs2 >> 1)-1) << SJW) |((prs-1) << PRS);
     446:	83 ee       	ldi	r24, 0xE3	; 227
     448:	90 e0       	ldi	r25, 0x00	; 0
     44a:	2e 81       	ldd	r18, Y+6	; 0x06
     44c:	26 95       	lsr	r18
     44e:	22 2f       	mov	r18, r18
     450:	30 e0       	ldi	r19, 0x00	; 0
     452:	21 50       	subi	r18, 0x01	; 1
     454:	31 09       	sbc	r19, r1
     456:	22 0f       	add	r18, r18
     458:	33 1f       	adc	r19, r19
     45a:	22 95       	swap	r18
     45c:	32 95       	swap	r19
     45e:	30 7f       	andi	r19, 0xF0	; 240
     460:	32 27       	eor	r19, r18
     462:	20 7f       	andi	r18, 0xF0	; 240
     464:	32 27       	eor	r19, r18
     466:	42 2f       	mov	r20, r18
     468:	2b 81       	ldd	r18, Y+3	; 0x03
     46a:	22 2f       	mov	r18, r18
     46c:	30 e0       	ldi	r19, 0x00	; 0
     46e:	21 50       	subi	r18, 0x01	; 1
     470:	31 09       	sbc	r19, r1
     472:	22 0f       	add	r18, r18
     474:	33 1f       	adc	r19, r19
     476:	24 2b       	or	r18, r20
     478:	fc 01       	movw	r30, r24
     47a:	20 83       	st	Z, r18
            CANBT3 = (((phs2-1) << PHS2) | ((phs1-1) << PHS1) | (1<<SMP));
     47c:	84 ee       	ldi	r24, 0xE4	; 228
     47e:	90 e0       	ldi	r25, 0x00	; 0
     480:	2e 81       	ldd	r18, Y+6	; 0x06
     482:	22 2f       	mov	r18, r18
     484:	30 e0       	ldi	r19, 0x00	; 0
     486:	21 50       	subi	r18, 0x01	; 1
     488:	31 09       	sbc	r19, r1
     48a:	22 95       	swap	r18
     48c:	32 95       	swap	r19
     48e:	30 7f       	andi	r19, 0xF0	; 240
     490:	32 27       	eor	r19, r18
     492:	20 7f       	andi	r18, 0xF0	; 240
     494:	32 27       	eor	r19, r18
     496:	42 2f       	mov	r20, r18
     498:	2d 81       	ldd	r18, Y+5	; 0x05
     49a:	22 2f       	mov	r18, r18
     49c:	30 e0       	ldi	r19, 0x00	; 0
     49e:	21 50       	subi	r18, 0x01	; 1
     4a0:	31 09       	sbc	r19, r1
     4a2:	22 0f       	add	r18, r18
     4a4:	33 1f       	adc	r19, r19
     4a6:	24 2b       	or	r18, r20
     4a8:	21 60       	ori	r18, 0x01	; 1
     4aa:	fc 01       	movw	r30, r24
     4ac:	20 83       	st	Z, r18

            //! --- Set CAN-Timer - Used for time-out
            //!     There are 641 (0x281) possible evaluations. The first one provides the faster
            //!         the faster bit timing, the last one gives the slower. It is necessary to
            //!         modulate the time-out versus bit timing (0x281>>3=0x50, matching an U8).
            CANTCON = (uint8_t)(conf_index >> 3);
     4ae:	85 ee       	ldi	r24, 0xE5	; 229
     4b0:	90 e0       	ldi	r25, 0x00	; 0
     4b2:	2d 85       	ldd	r18, Y+13	; 0x0d
     4b4:	3e 85       	ldd	r19, Y+14	; 0x0e
     4b6:	36 95       	lsr	r19
     4b8:	27 95       	ror	r18
     4ba:	36 95       	lsr	r19
     4bc:	27 95       	ror	r18
     4be:	36 95       	lsr	r19
     4c0:	27 95       	ror	r18
     4c2:	fc 01       	movw	r30, r24
     4c4:	20 83       	st	Z, r18

            //! --- MOb configuration
            Can_set_mob(MOB_0);                 //! Use MOb-0
     4c6:	8d ee       	ldi	r24, 0xED	; 237
     4c8:	90 e0       	ldi	r25, 0x00	; 0
     4ca:	fc 01       	movw	r30, r24
     4cc:	10 82       	st	Z, r1
            CANSTMOB = 0;                       //! Reset MOb status (undone by "Can_reset()")
     4ce:	8e ee       	ldi	r24, 0xEE	; 238
     4d0:	90 e0       	ldi	r25, 0x00	; 0
     4d2:	fc 01       	movw	r30, r24
     4d4:	10 82       	st	Z, r1
            CANCDMOB = (MOB_Rx_ENA  << CONMOB); //! MOb 0 in receive mode
     4d6:	8f ee       	ldi	r24, 0xEF	; 239
     4d8:	90 e0       	ldi	r25, 0x00	; 0
     4da:	20 e8       	ldi	r18, 0x80	; 128
     4dc:	fc 01       	movw	r30, r24
     4de:	20 83       	st	Z, r18

            //! CAN controller configuration
            CANGCON = (1<<LISTEN) | (1<<ENASTB);//! Enable CAN controller in "listen" mode
     4e0:	88 ed       	ldi	r24, 0xD8	; 216
     4e2:	90 e0       	ldi	r25, 0x00	; 0
     4e4:	2a e0       	ldi	r18, 0x0A	; 10
     4e6:	fc 01       	movw	r30, r24
     4e8:	20 83       	st	Z, r18
            while ((CANGSTA & (1<<ENFG)) == 0); //! Wait for Enable OK
     4ea:	00 00       	nop
     4ec:	89 ed       	ldi	r24, 0xD9	; 217
     4ee:	90 e0       	ldi	r25, 0x00	; 0
     4f0:	fc 01       	movw	r30, r24
     4f2:	80 81       	ld	r24, Z
     4f4:	88 2f       	mov	r24, r24
     4f6:	90 e0       	ldi	r25, 0x00	; 0
     4f8:	84 70       	andi	r24, 0x04	; 4
     4fa:	99 27       	eor	r25, r25
     4fc:	89 2b       	or	r24, r25
     4fe:	b1 f3       	breq	.-20     	; 0x4ec <can_auto_baudrate+0x296>
            CANGIT = 0xFF;                      //! Reset General errors and OVRTIM flag
     500:	8a ed       	ldi	r24, 0xDA	; 218
     502:	90 e0       	ldi	r25, 0x00	; 0
     504:	2f ef       	ldi	r18, 0xFF	; 255
     506:	fc 01       	movw	r30, r24
     508:	20 83       	st	Z, r18
        //! --- WAIT_FOR_RX LOOP:
        //!     ================
        //!     Try to perform a CAN message reception in "LISTEN" mode without error and
        //!     before a time_out done by CAN-Timer.
        //!     Else gives the hand to "EVALUATE LOOP" to have a new set of bit timing.
        while (wait_for_rx == 1)
     50a:	68 c0       	rjmp	.+208    	; 0x5dc <can_auto_baudrate+0x386>
        {
            u8_temp0 = CANSTMOB;
     50c:	8e ee       	ldi	r24, 0xEE	; 238
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	fc 01       	movw	r30, r24
     512:	80 81       	ld	r24, Z
     514:	89 83       	std	Y+1, r24	; 0x01
            //! --- RxOK received ?
            if ((u8_temp0 & (1<<RXOK)) != 0)
     516:	89 81       	ldd	r24, Y+1	; 0x01
     518:	88 2f       	mov	r24, r24
     51a:	90 e0       	ldi	r25, 0x00	; 0
     51c:	80 72       	andi	r24, 0x20	; 32
     51e:	99 27       	eor	r25, r25
     520:	89 2b       	or	r24, r25
     522:	f1 f0       	breq	.+60     	; 0x560 <can_auto_baudrate+0x30a>
            {   //! --- It is the successful output of "can_auto_baudrate" function
                wait_for_rx = 0;    //! Out of "while (wait_for_rx ..." loop
     524:	19 86       	std	Y+9, r1	; 0x09
                evaluate = 0;       //! Will skip "while (evaluate ..." loop
     526:	1a 86       	std	Y+10, r1	; 0x0a
                bt_not_found = 0;   //! Out of "while (bt_not_found ..." loop
     528:	18 86       	std	Y+8, r1	; 0x08
                bt_performed = 1;   //! Return flag = TRUE
     52a:	81 e0       	ldi	r24, 0x01	; 1
     52c:	8f 87       	std	Y+15, r24	; 0x0f
                DISABLE_MOB;        //! Disable MOb-0
     52e:	8f ee       	ldi	r24, 0xEF	; 239
     530:	90 e0       	ldi	r25, 0x00	; 0
     532:	2f ee       	ldi	r18, 0xEF	; 239
     534:	30 e0       	ldi	r19, 0x00	; 0
     536:	f9 01       	movw	r30, r18
     538:	20 81       	ld	r18, Z
     53a:	2f 73       	andi	r18, 0x3F	; 63
     53c:	fc 01       	movw	r30, r24
     53e:	20 83       	st	Z, r18
                CANGCON = 0x00;     //! Disable CAN controller & reset "listen" mode
     540:	88 ed       	ldi	r24, 0xD8	; 216
     542:	90 e0       	ldi	r25, 0x00	; 0
     544:	fc 01       	movw	r30, r24
     546:	10 82       	st	Z, r1
                while ((CANGSTA & (1<<ENFG)) != 0); //! Wait for Disable OK
     548:	00 00       	nop
     54a:	89 ed       	ldi	r24, 0xD9	; 217
     54c:	90 e0       	ldi	r25, 0x00	; 0
     54e:	fc 01       	movw	r30, r24
     550:	80 81       	ld	r24, Z
     552:	88 2f       	mov	r24, r24
     554:	90 e0       	ldi	r25, 0x00	; 0
     556:	84 70       	andi	r24, 0x04	; 4
     558:	99 27       	eor	r25, r25
     55a:	89 2b       	or	r24, r25
     55c:	b1 f7       	brne	.-20     	; 0x54a <can_auto_baudrate+0x2f4>
     55e:	3e c0       	rjmp	.+124    	; 0x5dc <can_auto_baudrate+0x386>
            }
             //! --- Else stop if any errors
             else
            {
                //! --- MOb error ?
                if ((u8_temp0 & ((1<<BERR)|(1<<SERR)|(1<<CERR)|(1<<FERR)|(1<<AERR))) !=0)
     560:	89 81       	ldd	r24, Y+1	; 0x01
     562:	88 2f       	mov	r24, r24
     564:	90 e0       	ldi	r25, 0x00	; 0
     566:	8f 71       	andi	r24, 0x1F	; 31
     568:	99 27       	eor	r25, r25
     56a:	89 2b       	or	r24, r25
     56c:	19 f0       	breq	.+6      	; 0x574 <can_auto_baudrate+0x31e>
                {
                    evaluate = 1;       //! Will enter in "while (evaluate ..." loop
     56e:	81 e0       	ldi	r24, 0x01	; 1
     570:	8a 87       	std	Y+10, r24	; 0x0a
                    wait_for_rx = 0;    //! Out of "while (wait_for_rx ..." loop
     572:	19 86       	std	Y+9, r1	; 0x09
                }

                u8_temp0 = CANGIT;
     574:	8a ed       	ldi	r24, 0xDA	; 218
     576:	90 e0       	ldi	r25, 0x00	; 0
     578:	fc 01       	movw	r30, r24
     57a:	80 81       	ld	r24, Z
     57c:	89 83       	std	Y+1, r24	; 0x01

                //! --- Time_out reached ?
                if ((u8_temp0 & (1<<OVRTIM)) !=0 )
     57e:	89 81       	ldd	r24, Y+1	; 0x01
     580:	88 2f       	mov	r24, r24
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	80 72       	andi	r24, 0x20	; 32
     586:	99 27       	eor	r25, r25
     588:	89 2b       	or	r24, r25
     58a:	e1 f0       	breq	.+56     	; 0x5c4 <can_auto_baudrate+0x36e>
                {
                    if (ovrtim_flag==0)
     58c:	8c 85       	ldd	r24, Y+12	; 0x0c
     58e:	88 23       	and	r24, r24
     590:	69 f4       	brne	.+26     	; 0x5ac <can_auto_baudrate+0x356>
                    {
                        //! --- First Time_out
                        CANGIT |= (1<<OVRTIM);  // Reset OVRTIM
     592:	8a ed       	ldi	r24, 0xDA	; 218
     594:	90 e0       	ldi	r25, 0x00	; 0
     596:	2a ed       	ldi	r18, 0xDA	; 218
     598:	30 e0       	ldi	r19, 0x00	; 0
     59a:	f9 01       	movw	r30, r18
     59c:	20 81       	ld	r18, Z
     59e:	20 62       	ori	r18, 0x20	; 32
     5a0:	fc 01       	movw	r30, r24
     5a2:	20 83       	st	Z, r18
                        ovrtim_flag++;
     5a4:	8c 85       	ldd	r24, Y+12	; 0x0c
     5a6:	8f 5f       	subi	r24, 0xFF	; 255
     5a8:	8c 87       	std	Y+12, r24	; 0x0c
     5aa:	0c c0       	rjmp	.+24     	; 0x5c4 <can_auto_baudrate+0x36e>
                    }
                    else
                    {
                        //! --- Second Time_out
                        CANGIT |= (1<<OVRTIM);  // Reset OVRTIM
     5ac:	8a ed       	ldi	r24, 0xDA	; 218
     5ae:	90 e0       	ldi	r25, 0x00	; 0
     5b0:	2a ed       	ldi	r18, 0xDA	; 218
     5b2:	30 e0       	ldi	r19, 0x00	; 0
     5b4:	f9 01       	movw	r30, r18
     5b6:	20 81       	ld	r18, Z
     5b8:	20 62       	ori	r18, 0x20	; 32
     5ba:	fc 01       	movw	r30, r24
     5bc:	20 83       	st	Z, r18
                        evaluate = 1;           //! Will enter in "while (evaluate ..." loop
     5be:	81 e0       	ldi	r24, 0x01	; 1
     5c0:	8a 87       	std	Y+10, r24	; 0x0a
                        wait_for_rx = 0;        //! Out of "while (wait_for_rx ..." loop
     5c2:	19 86       	std	Y+9, r1	; 0x09
                    }
                }

                //! --- General error ?
                if ((u8_temp0 & ((1<<SERG)|(1<<CERG)|(1<<FERG)|(1<<AERG))) !=0)
     5c4:	89 81       	ldd	r24, Y+1	; 0x01
     5c6:	88 2f       	mov	r24, r24
     5c8:	90 e0       	ldi	r25, 0x00	; 0
     5ca:	8f 70       	andi	r24, 0x0F	; 15
     5cc:	99 27       	eor	r25, r25
     5ce:	89 2b       	or	r24, r25
     5d0:	29 f0       	breq	.+10     	; 0x5dc <can_auto_baudrate+0x386>
                {
                    evaluate = 1;       //! Will enter in "while (evaluate ..." loop
     5d2:	81 e0       	ldi	r24, 0x01	; 1
     5d4:	8a 87       	std	Y+10, r24	; 0x0a
                    wait_for_rx = 0;    //! Out of "while (wait_for_rx ..." loop
     5d6:	19 86       	std	Y+9, r1	; 0x09
                    try_conf = 1;       //! Try this configuration
     5d8:	81 e0       	ldi	r24, 0x01	; 1
     5da:	8b 87       	std	Y+11, r24	; 0x0b
        //! --- WAIT_FOR_RX LOOP:
        //!     ================
        //!     Try to perform a CAN message reception in "LISTEN" mode without error and
        //!     before a time_out done by CAN-Timer.
        //!     Else gives the hand to "EVALUATE LOOP" to have a new set of bit timing.
        while (wait_for_rx == 1)
     5dc:	89 85       	ldd	r24, Y+9	; 0x09
     5de:	81 30       	cpi	r24, 0x01	; 1
     5e0:	09 f4       	brne	.+2      	; 0x5e4 <can_auto_baudrate+0x38e>
     5e2:	94 cf       	rjmp	.-216    	; 0x50c <can_auto_baudrate+0x2b6>
        //!     then Phase2=Phase1 and if Phase1>5, Phase1 can be equal to Phase2 or
        //!     Phase2+1. After this, the number of TQ is increased up to its high
        //!     limit and after it is the Prescaler. During the computing high (80%)
        //!     and low (75%) limits of sampling point location are tested. SJW and
        //!     the number of sampling points are not calculated in this loop.
        while (evaluate == 1)
     5e4:	97 c0       	rjmp	.+302    	; 0x714 <can_auto_baudrate+0x4be>
        {
            if (phs1_inc != 0) phs1++;
     5e6:	8f 81       	ldd	r24, Y+7	; 0x07
     5e8:	88 23       	and	r24, r24
     5ea:	19 f0       	breq	.+6      	; 0x5f2 <can_auto_baudrate+0x39c>
     5ec:	8d 81       	ldd	r24, Y+5	; 0x05
     5ee:	8f 5f       	subi	r24, 0xFF	; 255
     5f0:	8d 83       	std	Y+5, r24	; 0x05
            phs1_inc = 1;
     5f2:	81 e0       	ldi	r24, 0x01	; 1
     5f4:	8f 83       	std	Y+7, r24	; 0x07

            // --- The following test takes into account the previous incrementation of phs1
            if ((phs1 > PHS1_MAX) && (phs2 >= PHS2_MAX))
     5f6:	8d 81       	ldd	r24, Y+5	; 0x05
     5f8:	89 30       	cpi	r24, 0x09	; 9
     5fa:	a0 f1       	brcs	.+104    	; 0x664 <can_auto_baudrate+0x40e>
     5fc:	8e 81       	ldd	r24, Y+6	; 0x06
     5fe:	88 30       	cpi	r24, 0x08	; 8
     600:	88 f1       	brcs	.+98     	; 0x664 <can_auto_baudrate+0x40e>
            {
                phs1 = PHS1_MIN;
     602:	82 e0       	ldi	r24, 0x02	; 2
     604:	8d 83       	std	Y+5, r24	; 0x05
                phs2 = PHS2_MIN;
     606:	82 e0       	ldi	r24, 0x02	; 2
     608:	8e 83       	std	Y+6, r24	; 0x06
                phs1_inc = 0;
     60a:	1f 82       	std	Y+7, r1	; 0x07
                if (ntq != NTQ_MAX) ntq++;
     60c:	8c 81       	ldd	r24, Y+4	; 0x04
     60e:	89 31       	cpi	r24, 0x19	; 25
     610:	21 f0       	breq	.+8      	; 0x61a <can_auto_baudrate+0x3c4>
     612:	8c 81       	ldd	r24, Y+4	; 0x04
     614:	8f 5f       	subi	r24, 0xFF	; 255
     616:	8c 83       	std	Y+4, r24	; 0x04
     618:	24 c0       	rjmp	.+72     	; 0x662 <can_auto_baudrate+0x40c>
                else
                {
                    ntq = NTQ_MIN;
     61a:	88 e0       	ldi	r24, 0x08	; 8
     61c:	8c 83       	std	Y+4, r24	; 0x04
                    if (brp != BRP_MAX) brp++;
     61e:	8a 81       	ldd	r24, Y+2	; 0x02
     620:	80 34       	cpi	r24, 0x40	; 64
     622:	21 f0       	breq	.+8      	; 0x62c <can_auto_baudrate+0x3d6>
     624:	8a 81       	ldd	r24, Y+2	; 0x02
     626:	8f 5f       	subi	r24, 0xFF	; 255
     628:	8a 83       	std	Y+2, r24	; 0x02
     62a:	1b c0       	rjmp	.+54     	; 0x662 <can_auto_baudrate+0x40c>
                    else
                    {
                        //! --- It is the failing of "can_auto_baudrate" function
                        evaluate = 0;       //! Out of "while (evaluate ..." loop
     62c:	1a 86       	std	Y+10, r1	; 0x0a
                        bt_performed = 0;   //! Return flag = FALSE
     62e:	1f 86       	std	Y+15, r1	; 0x0f
                        bt_not_found = 0;   //! Out of "while (bt_not_found ..." loop
     630:	18 86       	std	Y+8, r1	; 0x08
                        DISABLE_MOB;        //! Disable MOb-0
     632:	8f ee       	ldi	r24, 0xEF	; 239
     634:	90 e0       	ldi	r25, 0x00	; 0
     636:	2f ee       	ldi	r18, 0xEF	; 239
     638:	30 e0       	ldi	r19, 0x00	; 0
     63a:	f9 01       	movw	r30, r18
     63c:	20 81       	ld	r18, Z
     63e:	2f 73       	andi	r18, 0x3F	; 63
     640:	fc 01       	movw	r30, r24
     642:	20 83       	st	Z, r18
                        CANGCON = 0x00;     //! Disable CAN controller & reset "listen" mode
     644:	88 ed       	ldi	r24, 0xD8	; 216
     646:	90 e0       	ldi	r25, 0x00	; 0
     648:	fc 01       	movw	r30, r24
     64a:	10 82       	st	Z, r1
                        while ((CANGSTA & (1<<ENFG)) != 0); //! Wait for Disable OK
     64c:	00 00       	nop
     64e:	89 ed       	ldi	r24, 0xD9	; 217
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	fc 01       	movw	r30, r24
     654:	80 81       	ld	r24, Z
     656:	88 2f       	mov	r24, r24
     658:	90 e0       	ldi	r25, 0x00	; 0
     65a:	84 70       	andi	r24, 0x04	; 4
     65c:	99 27       	eor	r25, r25
     65e:	89 2b       	or	r24, r25
     660:	b1 f7       	brne	.-20     	; 0x64e <can_auto_baudrate+0x3f8>
            if ((phs1 > PHS1_MAX) && (phs2 >= PHS2_MAX))
            {
                phs1 = PHS1_MIN;
                phs2 = PHS2_MIN;
                phs1_inc = 0;
                if (ntq != NTQ_MAX) ntq++;
     662:	58 c0       	rjmp	.+176    	; 0x714 <can_auto_baudrate+0x4be>
                }
            }
            else    // if (phs1 > PHS1_MAX ...
            {
                //! --- If psh1 > 5 then phs1 =phs2 or =phs2+1, else phs1=phs2
                if (phs1>5)
     664:	8d 81       	ldd	r24, Y+5	; 0x05
     666:	86 30       	cpi	r24, 0x06	; 6
     668:	80 f0       	brcs	.+32     	; 0x68a <can_auto_baudrate+0x434>
                {
                    if (phs1>(phs2+1)) phs1=(++phs2);
     66a:	8d 81       	ldd	r24, Y+5	; 0x05
     66c:	28 2f       	mov	r18, r24
     66e:	30 e0       	ldi	r19, 0x00	; 0
     670:	8e 81       	ldd	r24, Y+6	; 0x06
     672:	88 2f       	mov	r24, r24
     674:	90 e0       	ldi	r25, 0x00	; 0
     676:	01 96       	adiw	r24, 0x01	; 1
     678:	82 17       	cp	r24, r18
     67a:	93 07       	cpc	r25, r19
     67c:	44 f4       	brge	.+16     	; 0x68e <can_auto_baudrate+0x438>
     67e:	8e 81       	ldd	r24, Y+6	; 0x06
     680:	8f 5f       	subi	r24, 0xFF	; 255
     682:	8e 83       	std	Y+6, r24	; 0x06
     684:	8e 81       	ldd	r24, Y+6	; 0x06
     686:	8d 83       	std	Y+5, r24	; 0x05
     688:	02 c0       	rjmp	.+4      	; 0x68e <can_auto_baudrate+0x438>
                }
                else
                {
                phs2=phs1;
     68a:	8d 81       	ldd	r24, Y+5	; 0x05
     68c:	8e 83       	std	Y+6, r24	; 0x06
                }
                prs = ntq - ( phs1 + phs2 + 1 );
     68e:	9d 81       	ldd	r25, Y+5	; 0x05
     690:	8e 81       	ldd	r24, Y+6	; 0x06
     692:	89 0f       	add	r24, r25
     694:	9c 81       	ldd	r25, Y+4	; 0x04
     696:	f9 2f       	mov	r31, r25
     698:	f8 1b       	sub	r31, r24
     69a:	8f 2f       	mov	r24, r31
     69c:	81 50       	subi	r24, 0x01	; 1
     69e:	8b 83       	std	Y+3, r24	; 0x03

                //! --- Test PRS limits
                if ((prs <= PRS_MAX) && (prs >= PRS_MIN))
     6a0:	8b 81       	ldd	r24, Y+3	; 0x03
     6a2:	89 30       	cpi	r24, 0x09	; 9
     6a4:	b8 f5       	brcc	.+110    	; 0x714 <can_auto_baudrate+0x4be>
     6a6:	8b 81       	ldd	r24, Y+3	; 0x03
     6a8:	88 23       	and	r24, r24
     6aa:	a1 f1       	breq	.+104    	; 0x714 <can_auto_baudrate+0x4be>
                {
                    //! --- Values  accepted if  80% >= sampling point >= 75%
                    if (((phs2<<2) >= (1+prs+phs1)) && ((phs2+phs2+phs2) <= (1+prs+phs1)))
     6ac:	8e 81       	ldd	r24, Y+6	; 0x06
     6ae:	88 2f       	mov	r24, r24
     6b0:	90 e0       	ldi	r25, 0x00	; 0
     6b2:	9c 01       	movw	r18, r24
     6b4:	22 0f       	add	r18, r18
     6b6:	33 1f       	adc	r19, r19
     6b8:	22 0f       	add	r18, r18
     6ba:	33 1f       	adc	r19, r19
     6bc:	8b 81       	ldd	r24, Y+3	; 0x03
     6be:	88 2f       	mov	r24, r24
     6c0:	90 e0       	ldi	r25, 0x00	; 0
     6c2:	ac 01       	movw	r20, r24
     6c4:	4f 5f       	subi	r20, 0xFF	; 255
     6c6:	5f 4f       	sbci	r21, 0xFF	; 255
     6c8:	8d 81       	ldd	r24, Y+5	; 0x05
     6ca:	88 2f       	mov	r24, r24
     6cc:	90 e0       	ldi	r25, 0x00	; 0
     6ce:	84 0f       	add	r24, r20
     6d0:	95 1f       	adc	r25, r21
     6d2:	28 17       	cp	r18, r24
     6d4:	39 07       	cpc	r19, r25
     6d6:	f4 f0       	brlt	.+60     	; 0x714 <can_auto_baudrate+0x4be>
     6d8:	8e 81       	ldd	r24, Y+6	; 0x06
     6da:	28 2f       	mov	r18, r24
     6dc:	30 e0       	ldi	r19, 0x00	; 0
     6de:	8e 81       	ldd	r24, Y+6	; 0x06
     6e0:	88 2f       	mov	r24, r24
     6e2:	90 e0       	ldi	r25, 0x00	; 0
     6e4:	28 0f       	add	r18, r24
     6e6:	39 1f       	adc	r19, r25
     6e8:	8e 81       	ldd	r24, Y+6	; 0x06
     6ea:	88 2f       	mov	r24, r24
     6ec:	90 e0       	ldi	r25, 0x00	; 0
     6ee:	28 0f       	add	r18, r24
     6f0:	39 1f       	adc	r19, r25
     6f2:	8b 81       	ldd	r24, Y+3	; 0x03
     6f4:	88 2f       	mov	r24, r24
     6f6:	90 e0       	ldi	r25, 0x00	; 0
     6f8:	ac 01       	movw	r20, r24
     6fa:	4f 5f       	subi	r20, 0xFF	; 255
     6fc:	5f 4f       	sbci	r21, 0xFF	; 255
     6fe:	8d 81       	ldd	r24, Y+5	; 0x05
     700:	88 2f       	mov	r24, r24
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	84 0f       	add	r24, r20
     706:	95 1f       	adc	r25, r21
     708:	82 17       	cp	r24, r18
     70a:	93 07       	cpc	r25, r19
     70c:	1c f0       	brlt	.+6      	; 0x714 <can_auto_baudrate+0x4be>
                    {
                        evaluate = 0;     //! Out of "while (evaluate ..." loop &
     70e:	1a 86       	std	Y+10, r1	; 0x0a
                        wait_for_rx = 1;  //!    new "while (bt_not_found ..." loop
     710:	81 e0       	ldi	r24, 0x01	; 1
     712:	89 87       	std	Y+9, r24	; 0x09
        //!     then Phase2=Phase1 and if Phase1>5, Phase1 can be equal to Phase2 or
        //!     Phase2+1. After this, the number of TQ is increased up to its high
        //!     limit and after it is the Prescaler. During the computing high (80%)
        //!     and low (75%) limits of sampling point location are tested. SJW and
        //!     the number of sampling points are not calculated in this loop.
        while (evaluate == 1)
     714:	8a 85       	ldd	r24, Y+10	; 0x0a
     716:	81 30       	cpi	r24, 0x01	; 1
     718:	09 f4       	brne	.+2      	; 0x71c <can_auto_baudrate+0x4c6>
     71a:	65 cf       	rjmp	.-310    	; 0x5e6 <can_auto_baudrate+0x390>
    {
        Can_set_mob(u8_temp0);  //! Page index
        Can_clear_mob();        //! All MOb Registers = 0x00
    }

    while (bt_not_found == 1)
     71c:	88 85       	ldd	r24, Y+8	; 0x08
     71e:	81 30       	cpi	r24, 0x01	; 1
     720:	09 f4       	brne	.+2      	; 0x724 <can_auto_baudrate+0x4ce>
     722:	7b ce       	rjmp	.-778    	; 0x41a <can_auto_baudrate+0x1c4>
                }
            }
        } // while (evaluate ...
    } // while (bt_not_found ...

    return (bt_performed);
     724:	8f 85       	ldd	r24, Y+15	; 0x0f
}
     726:	62 96       	adiw	r28, 0x12	; 18
     728:	0f b6       	in	r0, 0x3f	; 63
     72a:	f8 94       	cli
     72c:	de bf       	out	0x3e, r29	; 62
     72e:	0f be       	out	0x3f, r0	; 63
     730:	cd bf       	out	0x3d, r28	; 61
     732:	df 91       	pop	r29
     734:	cf 91       	pop	r28
     736:	08 95       	ret

00000738 <can_fixed_baudrate>:
//!
//! @return Baudrate Status
//!         fixed = 1: baudrate performed
//------------------------------------------------------------------------------
uint8_t can_fixed_baudrate(uint8_t mode)
{
     738:	cf 93       	push	r28
     73a:	df 93       	push	r29
     73c:	1f 92       	push	r1
     73e:	cd b7       	in	r28, 0x3d	; 61
     740:	de b7       	in	r29, 0x3e	; 62
     742:	89 83       	std	Y+1, r24	; 0x01
    Can_reset();
     744:	88 ed       	ldi	r24, 0xD8	; 216
     746:	90 e0       	ldi	r25, 0x00	; 0
     748:	21 e0       	ldi	r18, 0x01	; 1
     74a:	fc 01       	movw	r30, r24
     74c:	20 83       	st	Z, r18
    Can_conf_bt();
     74e:	82 ee       	ldi	r24, 0xE2	; 226
     750:	90 e0       	ldi	r25, 0x00	; 0
     752:	26 e0       	ldi	r18, 0x06	; 6
     754:	fc 01       	movw	r30, r24
     756:	20 83       	st	Z, r18
     758:	83 ee       	ldi	r24, 0xE3	; 227
     75a:	90 e0       	ldi	r25, 0x00	; 0
     75c:	24 e0       	ldi	r18, 0x04	; 4
     75e:	fc 01       	movw	r30, r24
     760:	20 83       	st	Z, r18
     762:	84 ee       	ldi	r24, 0xE4	; 228
     764:	90 e0       	ldi	r25, 0x00	; 0
     766:	23 e1       	ldi	r18, 0x13	; 19
     768:	fc 01       	movw	r30, r24
     76a:	20 83       	st	Z, r18
    return 1;
     76c:	81 e0       	ldi	r24, 0x01	; 1
     76e:	0f 90       	pop	r0
     770:	df 91       	pop	r29
     772:	cf 91       	pop	r28
     774:	08 95       	ret

00000776 <can_init>:
//!         ==0: research of bit timing configuration failed
//!         ==1: baudrate performed 
//!
//------------------------------------------------------------------------------
uint8_t can_init(uint8_t mode)
{
     776:	cf 93       	push	r28
     778:	df 93       	push	r29
     77a:	1f 92       	push	r1
     77c:	cd b7       	in	r28, 0x3d	; 61
     77e:	de b7       	in	r29, 0x3e	; 62
     780:	89 83       	std	Y+1, r24	; 0x01
    if ((Can_bit_timing(mode))==0) return (0);  // c.f. macro in "can_drv.h"
     782:	89 81       	ldd	r24, Y+1	; 0x01
     784:	0e 94 9c 03 	call	0x738	; 0x738 <can_fixed_baudrate>
     788:	88 23       	and	r24, r24
     78a:	11 f4       	brne	.+4      	; 0x790 <can_init+0x1a>
     78c:	80 e0       	ldi	r24, 0x00	; 0
     78e:	0c c0       	rjmp	.+24     	; 0x7a8 <can_init+0x32>
    can_clear_all_mob();                        // c.f. function in "can_drv.c"
     790:	0e 94 68 00 	call	0xd0	; 0xd0 <can_clear_all_mob>
    Can_enable();                               // c.f. macro in "can_drv.h" 
     794:	88 ed       	ldi	r24, 0xD8	; 216
     796:	90 e0       	ldi	r25, 0x00	; 0
     798:	28 ed       	ldi	r18, 0xD8	; 216
     79a:	30 e0       	ldi	r19, 0x00	; 0
     79c:	f9 01       	movw	r30, r18
     79e:	20 81       	ld	r18, Z
     7a0:	22 60       	ori	r18, 0x02	; 2
     7a2:	fc 01       	movw	r30, r24
     7a4:	20 83       	st	Z, r18
    return (1);
     7a6:	81 e0       	ldi	r24, 0x01	; 1
}
     7a8:	0f 90       	pop	r0
     7aa:	df 91       	pop	r29
     7ac:	cf 91       	pop	r28
     7ae:	08 95       	ret

000007b0 <can_cmd>:
//! @return CAN_CMD_ACCEPTED - command is accepted
//!         CAN_CMD_REFUSED  - command is refused
//!
//------------------------------------------------------------------------------
uint8_t can_cmd(st_cmd_t* cmd)
{
     7b0:	cf 93       	push	r28
     7b2:	df 93       	push	r29
     7b4:	cd b7       	in	r28, 0x3d	; 61
     7b6:	de b7       	in	r29, 0x3e	; 62
     7b8:	2a 97       	sbiw	r28, 0x0a	; 10
     7ba:	0f b6       	in	r0, 0x3f	; 63
     7bc:	f8 94       	cli
     7be:	de bf       	out	0x3e, r29	; 62
     7c0:	0f be       	out	0x3f, r0	; 63
     7c2:	cd bf       	out	0x3d, r28	; 61
     7c4:	9a 87       	std	Y+10, r25	; 0x0a
     7c6:	89 87       	std	Y+9, r24	; 0x09
  uint8_t mob_handle, cpt;
  uint32_t u32_temp;
  
  if (cmd->cmd == CMD_ABORT)
     7c8:	89 85       	ldd	r24, Y+9	; 0x09
     7ca:	9a 85       	ldd	r25, Y+10	; 0x0a
     7cc:	fc 01       	movw	r30, r24
     7ce:	81 81       	ldd	r24, Z+1	; 0x01
     7d0:	8c 30       	cpi	r24, 0x0C	; 12
     7d2:	39 f5       	brne	.+78     	; 0x822 <can_cmd+0x72>
  {
    if (cmd->status == MOB_PENDING)
     7d4:	89 85       	ldd	r24, Y+9	; 0x09
     7d6:	9a 85       	ldd	r25, Y+10	; 0x0a
     7d8:	fc 01       	movw	r30, r24
     7da:	81 85       	ldd	r24, Z+9	; 0x09
     7dc:	80 36       	cpi	r24, 0x60	; 96
     7de:	d9 f4       	brne	.+54     	; 0x816 <can_cmd+0x66>
    {
      // Rx or Tx not yet performed
      Can_set_mob(cmd->handle);
     7e0:	8d ee       	ldi	r24, 0xED	; 237
     7e2:	90 e0       	ldi	r25, 0x00	; 0
     7e4:	29 85       	ldd	r18, Y+9	; 0x09
     7e6:	3a 85       	ldd	r19, Y+10	; 0x0a
     7e8:	f9 01       	movw	r30, r18
     7ea:	20 81       	ld	r18, Z
     7ec:	22 95       	swap	r18
     7ee:	20 7f       	andi	r18, 0xF0	; 240
     7f0:	fc 01       	movw	r30, r24
     7f2:	20 83       	st	Z, r18
      Can_mob_abort();
     7f4:	8f ee       	ldi	r24, 0xEF	; 239
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	2f ee       	ldi	r18, 0xEF	; 239
     7fa:	30 e0       	ldi	r19, 0x00	; 0
     7fc:	f9 01       	movw	r30, r18
     7fe:	20 81       	ld	r18, Z
     800:	2f 73       	andi	r18, 0x3F	; 63
     802:	fc 01       	movw	r30, r24
     804:	20 83       	st	Z, r18
      Can_clear_status_mob();       // To be sure !
     806:	8e ee       	ldi	r24, 0xEE	; 238
     808:	90 e0       	ldi	r25, 0x00	; 0
     80a:	fc 01       	movw	r30, r24
     80c:	10 82       	st	Z, r1
      cmd->handle = 0;
     80e:	89 85       	ldd	r24, Y+9	; 0x09
     810:	9a 85       	ldd	r25, Y+10	; 0x0a
     812:	fc 01       	movw	r30, r24
     814:	10 82       	st	Z, r1
    }
    cmd->status = STATUS_CLEARED; 
     816:	89 85       	ldd	r24, Y+9	; 0x09
     818:	9a 85       	ldd	r25, Y+10	; 0x0a
     81a:	fc 01       	movw	r30, r24
     81c:	11 86       	std	Z+9, r1	; 0x09
     81e:	0c 94 64 0e 	jmp	0x1cc8	; 0x1cc8 <__stack+0xbc9>
  }
  else
  {
    mob_handle = can_get_mob_free();
     822:	0e 94 96 00 	call	0x12c	; 0x12c <can_get_mob_free>
     826:	8c 83       	std	Y+4, r24	; 0x04
    if (mob_handle!= NO_MOB)
     828:	8c 81       	ldd	r24, Y+4	; 0x04
     82a:	8f 3f       	cpi	r24, 0xFF	; 255
     82c:	11 f4       	brne	.+4      	; 0x832 <can_cmd+0x82>
     82e:	0c 94 5d 0e 	jmp	0x1cba	; 0x1cba <__stack+0xbbb>
    {
      cmd->status = MOB_PENDING; 
     832:	89 85       	ldd	r24, Y+9	; 0x09
     834:	9a 85       	ldd	r25, Y+10	; 0x0a
     836:	20 e6       	ldi	r18, 0x60	; 96
     838:	fc 01       	movw	r30, r24
     83a:	21 87       	std	Z+9, r18	; 0x09
      cmd->handle = mob_handle;
     83c:	89 85       	ldd	r24, Y+9	; 0x09
     83e:	9a 85       	ldd	r25, Y+10	; 0x0a
     840:	2c 81       	ldd	r18, Y+4	; 0x04
     842:	fc 01       	movw	r30, r24
     844:	20 83       	st	Z, r18
      Can_set_mob(mob_handle);
     846:	8d ee       	ldi	r24, 0xED	; 237
     848:	90 e0       	ldi	r25, 0x00	; 0
     84a:	2c 81       	ldd	r18, Y+4	; 0x04
     84c:	22 95       	swap	r18
     84e:	20 7f       	andi	r18, 0xF0	; 240
     850:	fc 01       	movw	r30, r24
     852:	20 83       	st	Z, r18
      Can_clear_mob();
     854:	8e ee       	ldi	r24, 0xEE	; 238
     856:	90 e0       	ldi	r25, 0x00	; 0
     858:	9b 83       	std	Y+3, r25	; 0x03
     85a:	8a 83       	std	Y+2, r24	; 0x02
     85c:	09 c0       	rjmp	.+18     	; 0x870 <can_cmd+0xc0>
     85e:	8a 81       	ldd	r24, Y+2	; 0x02
     860:	9b 81       	ldd	r25, Y+3	; 0x03
     862:	fc 01       	movw	r30, r24
     864:	10 82       	st	Z, r1
     866:	8a 81       	ldd	r24, Y+2	; 0x02
     868:	9b 81       	ldd	r25, Y+3	; 0x03
     86a:	01 96       	adiw	r24, 0x01	; 1
     86c:	9b 83       	std	Y+3, r25	; 0x03
     86e:	8a 83       	std	Y+2, r24	; 0x02
     870:	8a 81       	ldd	r24, Y+2	; 0x02
     872:	9b 81       	ldd	r25, Y+3	; 0x03
     874:	88 3f       	cpi	r24, 0xF8	; 248
     876:	91 05       	cpc	r25, r1
     878:	90 f3       	brcs	.-28     	; 0x85e <can_cmd+0xae>
          
      switch (cmd->cmd)
     87a:	89 85       	ldd	r24, Y+9	; 0x09
     87c:	9a 85       	ldd	r25, Y+10	; 0x0a
     87e:	fc 01       	movw	r30, r24
     880:	81 81       	ldd	r24, Z+1	; 0x01
     882:	88 2f       	mov	r24, r24
     884:	90 e0       	ldi	r25, 0x00	; 0
     886:	09 2e       	mov	r0, r25
     888:	00 0c       	add	r0, r0
     88a:	aa 0b       	sbc	r26, r26
     88c:	bb 0b       	sbc	r27, r27
     88e:	41 e0       	ldi	r20, 0x01	; 1
     890:	50 e0       	ldi	r21, 0x00	; 0
     892:	2a e0       	ldi	r18, 0x0A	; 10
     894:	30 e0       	ldi	r19, 0x00	; 0
     896:	84 1b       	sub	r24, r20
     898:	95 0b       	sbc	r25, r21
     89a:	28 17       	cp	r18, r24
     89c:	39 07       	cpc	r19, r25
     89e:	10 f4       	brcc	.+4      	; 0x8a4 <can_cmd+0xf4>
     8a0:	0c 94 57 0e 	jmp	0x1cae	; 0x1cae <__stack+0xbaf>
     8a4:	82 5c       	subi	r24, 0xC2	; 194
     8a6:	9f 4f       	sbci	r25, 0xFF	; 255
     8a8:	fc 01       	movw	r30, r24
     8aa:	0c 94 46 28 	jmp	0x508c	; 0x508c <__tablejump2__>
      {
        //------------      
        case CMD_TX:    
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
     8ae:	89 85       	ldd	r24, Y+9	; 0x09
     8b0:	9a 85       	ldd	r25, Y+10	; 0x0a
     8b2:	fc 01       	movw	r30, r24
     8b4:	83 85       	ldd	r24, Z+11	; 0x0b
     8b6:	88 23       	and	r24, r24
     8b8:	09 f4       	brne	.+2      	; 0x8bc <can_cmd+0x10c>
     8ba:	69 c0       	rjmp	.+210    	; 0x98e <can_cmd+0x1de>
     8bc:	83 ef       	ldi	r24, 0xF3	; 243
     8be:	90 e0       	ldi	r25, 0x00	; 0
     8c0:	29 85       	ldd	r18, Y+9	; 0x09
     8c2:	3a 85       	ldd	r19, Y+10	; 0x0a
     8c4:	2e 5f       	subi	r18, 0xFE	; 254
     8c6:	3f 4f       	sbci	r19, 0xFF	; 255
     8c8:	2d 5f       	subi	r18, 0xFD	; 253
     8ca:	3f 4f       	sbci	r19, 0xFF	; 255
     8cc:	f9 01       	movw	r30, r18
     8ce:	20 81       	ld	r18, Z
     8d0:	42 2f       	mov	r20, r18
     8d2:	44 0f       	add	r20, r20
     8d4:	44 0f       	add	r20, r20
     8d6:	44 0f       	add	r20, r20
     8d8:	29 85       	ldd	r18, Y+9	; 0x09
     8da:	3a 85       	ldd	r19, Y+10	; 0x0a
     8dc:	2e 5f       	subi	r18, 0xFE	; 254
     8de:	3f 4f       	sbci	r19, 0xFF	; 255
     8e0:	2e 5f       	subi	r18, 0xFE	; 254
     8e2:	3f 4f       	sbci	r19, 0xFF	; 255
     8e4:	f9 01       	movw	r30, r18
     8e6:	20 81       	ld	r18, Z
     8e8:	22 95       	swap	r18
     8ea:	26 95       	lsr	r18
     8ec:	27 70       	andi	r18, 0x07	; 7
     8ee:	24 0f       	add	r18, r20
     8f0:	fc 01       	movw	r30, r24
     8f2:	20 83       	st	Z, r18
     8f4:	82 ef       	ldi	r24, 0xF2	; 242
     8f6:	90 e0       	ldi	r25, 0x00	; 0
     8f8:	29 85       	ldd	r18, Y+9	; 0x09
     8fa:	3a 85       	ldd	r19, Y+10	; 0x0a
     8fc:	2e 5f       	subi	r18, 0xFE	; 254
     8fe:	3f 4f       	sbci	r19, 0xFF	; 255
     900:	2e 5f       	subi	r18, 0xFE	; 254
     902:	3f 4f       	sbci	r19, 0xFF	; 255
     904:	f9 01       	movw	r30, r18
     906:	20 81       	ld	r18, Z
     908:	42 2f       	mov	r20, r18
     90a:	44 0f       	add	r20, r20
     90c:	44 0f       	add	r20, r20
     90e:	44 0f       	add	r20, r20
     910:	29 85       	ldd	r18, Y+9	; 0x09
     912:	3a 85       	ldd	r19, Y+10	; 0x0a
     914:	2e 5f       	subi	r18, 0xFE	; 254
     916:	3f 4f       	sbci	r19, 0xFF	; 255
     918:	2f 5f       	subi	r18, 0xFF	; 255
     91a:	3f 4f       	sbci	r19, 0xFF	; 255
     91c:	f9 01       	movw	r30, r18
     91e:	20 81       	ld	r18, Z
     920:	22 95       	swap	r18
     922:	26 95       	lsr	r18
     924:	27 70       	andi	r18, 0x07	; 7
     926:	24 0f       	add	r18, r20
     928:	fc 01       	movw	r30, r24
     92a:	20 83       	st	Z, r18
     92c:	81 ef       	ldi	r24, 0xF1	; 241
     92e:	90 e0       	ldi	r25, 0x00	; 0
     930:	29 85       	ldd	r18, Y+9	; 0x09
     932:	3a 85       	ldd	r19, Y+10	; 0x0a
     934:	2e 5f       	subi	r18, 0xFE	; 254
     936:	3f 4f       	sbci	r19, 0xFF	; 255
     938:	2f 5f       	subi	r18, 0xFF	; 255
     93a:	3f 4f       	sbci	r19, 0xFF	; 255
     93c:	f9 01       	movw	r30, r18
     93e:	20 81       	ld	r18, Z
     940:	42 2f       	mov	r20, r18
     942:	44 0f       	add	r20, r20
     944:	44 0f       	add	r20, r20
     946:	44 0f       	add	r20, r20
     948:	29 85       	ldd	r18, Y+9	; 0x09
     94a:	3a 85       	ldd	r19, Y+10	; 0x0a
     94c:	2e 5f       	subi	r18, 0xFE	; 254
     94e:	3f 4f       	sbci	r19, 0xFF	; 255
     950:	f9 01       	movw	r30, r18
     952:	20 81       	ld	r18, Z
     954:	22 95       	swap	r18
     956:	26 95       	lsr	r18
     958:	27 70       	andi	r18, 0x07	; 7
     95a:	24 0f       	add	r18, r20
     95c:	fc 01       	movw	r30, r24
     95e:	20 83       	st	Z, r18
     960:	80 ef       	ldi	r24, 0xF0	; 240
     962:	90 e0       	ldi	r25, 0x00	; 0
     964:	29 85       	ldd	r18, Y+9	; 0x09
     966:	3a 85       	ldd	r19, Y+10	; 0x0a
     968:	2e 5f       	subi	r18, 0xFE	; 254
     96a:	3f 4f       	sbci	r19, 0xFF	; 255
     96c:	f9 01       	movw	r30, r18
     96e:	20 81       	ld	r18, Z
     970:	22 0f       	add	r18, r18
     972:	22 0f       	add	r18, r18
     974:	22 0f       	add	r18, r18
     976:	fc 01       	movw	r30, r24
     978:	20 83       	st	Z, r18
     97a:	8f ee       	ldi	r24, 0xEF	; 239
     97c:	90 e0       	ldi	r25, 0x00	; 0
     97e:	2f ee       	ldi	r18, 0xEF	; 239
     980:	30 e0       	ldi	r19, 0x00	; 0
     982:	f9 01       	movw	r30, r18
     984:	20 81       	ld	r18, Z
     986:	20 61       	ori	r18, 0x10	; 16
     988:	fc 01       	movw	r30, r24
     98a:	20 83       	st	Z, r18
     98c:	30 c0       	rjmp	.+96     	; 0x9ee <can_cmd+0x23e>
          else              { Can_set_std_id(cmd->id.std);}
     98e:	83 ef       	ldi	r24, 0xF3	; 243
     990:	90 e0       	ldi	r25, 0x00	; 0
     992:	29 85       	ldd	r18, Y+9	; 0x09
     994:	3a 85       	ldd	r19, Y+10	; 0x0a
     996:	2e 5f       	subi	r18, 0xFE	; 254
     998:	3f 4f       	sbci	r19, 0xFF	; 255
     99a:	2f 5f       	subi	r18, 0xFF	; 255
     99c:	3f 4f       	sbci	r19, 0xFF	; 255
     99e:	f9 01       	movw	r30, r18
     9a0:	20 81       	ld	r18, Z
     9a2:	42 2f       	mov	r20, r18
     9a4:	42 95       	swap	r20
     9a6:	44 0f       	add	r20, r20
     9a8:	40 7e       	andi	r20, 0xE0	; 224
     9aa:	29 85       	ldd	r18, Y+9	; 0x09
     9ac:	3a 85       	ldd	r19, Y+10	; 0x0a
     9ae:	2e 5f       	subi	r18, 0xFE	; 254
     9b0:	3f 4f       	sbci	r19, 0xFF	; 255
     9b2:	f9 01       	movw	r30, r18
     9b4:	20 81       	ld	r18, Z
     9b6:	26 95       	lsr	r18
     9b8:	26 95       	lsr	r18
     9ba:	26 95       	lsr	r18
     9bc:	24 0f       	add	r18, r20
     9be:	fc 01       	movw	r30, r24
     9c0:	20 83       	st	Z, r18
     9c2:	82 ef       	ldi	r24, 0xF2	; 242
     9c4:	90 e0       	ldi	r25, 0x00	; 0
     9c6:	29 85       	ldd	r18, Y+9	; 0x09
     9c8:	3a 85       	ldd	r19, Y+10	; 0x0a
     9ca:	2e 5f       	subi	r18, 0xFE	; 254
     9cc:	3f 4f       	sbci	r19, 0xFF	; 255
     9ce:	f9 01       	movw	r30, r18
     9d0:	20 81       	ld	r18, Z
     9d2:	22 95       	swap	r18
     9d4:	22 0f       	add	r18, r18
     9d6:	20 7e       	andi	r18, 0xE0	; 224
     9d8:	fc 01       	movw	r30, r24
     9da:	20 83       	st	Z, r18
     9dc:	8f ee       	ldi	r24, 0xEF	; 239
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	2f ee       	ldi	r18, 0xEF	; 239
     9e2:	30 e0       	ldi	r19, 0x00	; 0
     9e4:	f9 01       	movw	r30, r18
     9e6:	20 81       	ld	r18, Z
     9e8:	2f 7e       	andi	r18, 0xEF	; 239
     9ea:	fc 01       	movw	r30, r24
     9ec:	20 83       	st	Z, r18
          for (cpt=0;cpt<cmd->dlc;cpt++) CANMSG = *(cmd->pt_data + cpt);
     9ee:	19 82       	std	Y+1, r1	; 0x01
     9f0:	13 c0       	rjmp	.+38     	; 0xa18 <can_cmd+0x268>
     9f2:	8a ef       	ldi	r24, 0xFA	; 250
     9f4:	90 e0       	ldi	r25, 0x00	; 0
     9f6:	29 85       	ldd	r18, Y+9	; 0x09
     9f8:	3a 85       	ldd	r19, Y+10	; 0x0a
     9fa:	f9 01       	movw	r30, r18
     9fc:	47 81       	ldd	r20, Z+7	; 0x07
     9fe:	50 85       	ldd	r21, Z+8	; 0x08
     a00:	29 81       	ldd	r18, Y+1	; 0x01
     a02:	22 2f       	mov	r18, r18
     a04:	30 e0       	ldi	r19, 0x00	; 0
     a06:	24 0f       	add	r18, r20
     a08:	35 1f       	adc	r19, r21
     a0a:	f9 01       	movw	r30, r18
     a0c:	20 81       	ld	r18, Z
     a0e:	fc 01       	movw	r30, r24
     a10:	20 83       	st	Z, r18
     a12:	89 81       	ldd	r24, Y+1	; 0x01
     a14:	8f 5f       	subi	r24, 0xFF	; 255
     a16:	89 83       	std	Y+1, r24	; 0x01
     a18:	89 85       	ldd	r24, Y+9	; 0x09
     a1a:	9a 85       	ldd	r25, Y+10	; 0x0a
     a1c:	fc 01       	movw	r30, r24
     a1e:	96 81       	ldd	r25, Z+6	; 0x06
     a20:	89 81       	ldd	r24, Y+1	; 0x01
     a22:	89 17       	cp	r24, r25
     a24:	30 f3       	brcs	.-52     	; 0x9f2 <can_cmd+0x242>
          if (cmd->ctrl.rtr) Can_set_rtr(); 
     a26:	89 85       	ldd	r24, Y+9	; 0x09
     a28:	9a 85       	ldd	r25, Y+10	; 0x0a
     a2a:	fc 01       	movw	r30, r24
     a2c:	82 85       	ldd	r24, Z+10	; 0x0a
     a2e:	88 23       	and	r24, r24
     a30:	51 f0       	breq	.+20     	; 0xa46 <can_cmd+0x296>
     a32:	80 ef       	ldi	r24, 0xF0	; 240
     a34:	90 e0       	ldi	r25, 0x00	; 0
     a36:	20 ef       	ldi	r18, 0xF0	; 240
     a38:	30 e0       	ldi	r19, 0x00	; 0
     a3a:	f9 01       	movw	r30, r18
     a3c:	20 81       	ld	r18, Z
     a3e:	24 60       	ori	r18, 0x04	; 4
     a40:	fc 01       	movw	r30, r24
     a42:	20 83       	st	Z, r18
     a44:	09 c0       	rjmp	.+18     	; 0xa58 <can_cmd+0x2a8>
            else Can_clear_rtr();    
     a46:	80 ef       	ldi	r24, 0xF0	; 240
     a48:	90 e0       	ldi	r25, 0x00	; 0
     a4a:	20 ef       	ldi	r18, 0xF0	; 240
     a4c:	30 e0       	ldi	r19, 0x00	; 0
     a4e:	f9 01       	movw	r30, r18
     a50:	20 81       	ld	r18, Z
     a52:	2b 7f       	andi	r18, 0xFB	; 251
     a54:	fc 01       	movw	r30, r24
     a56:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
     a58:	8f ee       	ldi	r24, 0xEF	; 239
     a5a:	90 e0       	ldi	r25, 0x00	; 0
     a5c:	2f ee       	ldi	r18, 0xEF	; 239
     a5e:	30 e0       	ldi	r19, 0x00	; 0
     a60:	f9 01       	movw	r30, r18
     a62:	40 81       	ld	r20, Z
     a64:	29 85       	ldd	r18, Y+9	; 0x09
     a66:	3a 85       	ldd	r19, Y+10	; 0x0a
     a68:	f9 01       	movw	r30, r18
     a6a:	26 81       	ldd	r18, Z+6	; 0x06
     a6c:	24 2b       	or	r18, r20
     a6e:	fc 01       	movw	r30, r24
     a70:	20 83       	st	Z, r18
          Can_config_tx();
     a72:	8f ee       	ldi	r24, 0xEF	; 239
     a74:	90 e0       	ldi	r25, 0x00	; 0
     a76:	2f ee       	ldi	r18, 0xEF	; 239
     a78:	30 e0       	ldi	r19, 0x00	; 0
     a7a:	f9 01       	movw	r30, r18
     a7c:	20 81       	ld	r18, Z
     a7e:	2f 73       	andi	r18, 0x3F	; 63
     a80:	fc 01       	movw	r30, r24
     a82:	20 83       	st	Z, r18
     a84:	8f ee       	ldi	r24, 0xEF	; 239
     a86:	90 e0       	ldi	r25, 0x00	; 0
     a88:	2f ee       	ldi	r18, 0xEF	; 239
     a8a:	30 e0       	ldi	r19, 0x00	; 0
     a8c:	f9 01       	movw	r30, r18
     a8e:	20 81       	ld	r18, Z
     a90:	20 64       	ori	r18, 0x40	; 64
     a92:	fc 01       	movw	r30, r24
     a94:	20 83       	st	Z, r18
          break;
     a96:	0c 94 5c 0e 	jmp	0x1cb8	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_TX_DATA:    
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
     a9a:	89 85       	ldd	r24, Y+9	; 0x09
     a9c:	9a 85       	ldd	r25, Y+10	; 0x0a
     a9e:	fc 01       	movw	r30, r24
     aa0:	83 85       	ldd	r24, Z+11	; 0x0b
     aa2:	88 23       	and	r24, r24
     aa4:	09 f4       	brne	.+2      	; 0xaa8 <can_cmd+0x2f8>
     aa6:	69 c0       	rjmp	.+210    	; 0xb7a <can_cmd+0x3ca>
     aa8:	83 ef       	ldi	r24, 0xF3	; 243
     aaa:	90 e0       	ldi	r25, 0x00	; 0
     aac:	29 85       	ldd	r18, Y+9	; 0x09
     aae:	3a 85       	ldd	r19, Y+10	; 0x0a
     ab0:	2e 5f       	subi	r18, 0xFE	; 254
     ab2:	3f 4f       	sbci	r19, 0xFF	; 255
     ab4:	2d 5f       	subi	r18, 0xFD	; 253
     ab6:	3f 4f       	sbci	r19, 0xFF	; 255
     ab8:	f9 01       	movw	r30, r18
     aba:	20 81       	ld	r18, Z
     abc:	42 2f       	mov	r20, r18
     abe:	44 0f       	add	r20, r20
     ac0:	44 0f       	add	r20, r20
     ac2:	44 0f       	add	r20, r20
     ac4:	29 85       	ldd	r18, Y+9	; 0x09
     ac6:	3a 85       	ldd	r19, Y+10	; 0x0a
     ac8:	2e 5f       	subi	r18, 0xFE	; 254
     aca:	3f 4f       	sbci	r19, 0xFF	; 255
     acc:	2e 5f       	subi	r18, 0xFE	; 254
     ace:	3f 4f       	sbci	r19, 0xFF	; 255
     ad0:	f9 01       	movw	r30, r18
     ad2:	20 81       	ld	r18, Z
     ad4:	22 95       	swap	r18
     ad6:	26 95       	lsr	r18
     ad8:	27 70       	andi	r18, 0x07	; 7
     ada:	24 0f       	add	r18, r20
     adc:	fc 01       	movw	r30, r24
     ade:	20 83       	st	Z, r18
     ae0:	82 ef       	ldi	r24, 0xF2	; 242
     ae2:	90 e0       	ldi	r25, 0x00	; 0
     ae4:	29 85       	ldd	r18, Y+9	; 0x09
     ae6:	3a 85       	ldd	r19, Y+10	; 0x0a
     ae8:	2e 5f       	subi	r18, 0xFE	; 254
     aea:	3f 4f       	sbci	r19, 0xFF	; 255
     aec:	2e 5f       	subi	r18, 0xFE	; 254
     aee:	3f 4f       	sbci	r19, 0xFF	; 255
     af0:	f9 01       	movw	r30, r18
     af2:	20 81       	ld	r18, Z
     af4:	42 2f       	mov	r20, r18
     af6:	44 0f       	add	r20, r20
     af8:	44 0f       	add	r20, r20
     afa:	44 0f       	add	r20, r20
     afc:	29 85       	ldd	r18, Y+9	; 0x09
     afe:	3a 85       	ldd	r19, Y+10	; 0x0a
     b00:	2e 5f       	subi	r18, 0xFE	; 254
     b02:	3f 4f       	sbci	r19, 0xFF	; 255
     b04:	2f 5f       	subi	r18, 0xFF	; 255
     b06:	3f 4f       	sbci	r19, 0xFF	; 255
     b08:	f9 01       	movw	r30, r18
     b0a:	20 81       	ld	r18, Z
     b0c:	22 95       	swap	r18
     b0e:	26 95       	lsr	r18
     b10:	27 70       	andi	r18, 0x07	; 7
     b12:	24 0f       	add	r18, r20
     b14:	fc 01       	movw	r30, r24
     b16:	20 83       	st	Z, r18
     b18:	81 ef       	ldi	r24, 0xF1	; 241
     b1a:	90 e0       	ldi	r25, 0x00	; 0
     b1c:	29 85       	ldd	r18, Y+9	; 0x09
     b1e:	3a 85       	ldd	r19, Y+10	; 0x0a
     b20:	2e 5f       	subi	r18, 0xFE	; 254
     b22:	3f 4f       	sbci	r19, 0xFF	; 255
     b24:	2f 5f       	subi	r18, 0xFF	; 255
     b26:	3f 4f       	sbci	r19, 0xFF	; 255
     b28:	f9 01       	movw	r30, r18
     b2a:	20 81       	ld	r18, Z
     b2c:	42 2f       	mov	r20, r18
     b2e:	44 0f       	add	r20, r20
     b30:	44 0f       	add	r20, r20
     b32:	44 0f       	add	r20, r20
     b34:	29 85       	ldd	r18, Y+9	; 0x09
     b36:	3a 85       	ldd	r19, Y+10	; 0x0a
     b38:	2e 5f       	subi	r18, 0xFE	; 254
     b3a:	3f 4f       	sbci	r19, 0xFF	; 255
     b3c:	f9 01       	movw	r30, r18
     b3e:	20 81       	ld	r18, Z
     b40:	22 95       	swap	r18
     b42:	26 95       	lsr	r18
     b44:	27 70       	andi	r18, 0x07	; 7
     b46:	24 0f       	add	r18, r20
     b48:	fc 01       	movw	r30, r24
     b4a:	20 83       	st	Z, r18
     b4c:	80 ef       	ldi	r24, 0xF0	; 240
     b4e:	90 e0       	ldi	r25, 0x00	; 0
     b50:	29 85       	ldd	r18, Y+9	; 0x09
     b52:	3a 85       	ldd	r19, Y+10	; 0x0a
     b54:	2e 5f       	subi	r18, 0xFE	; 254
     b56:	3f 4f       	sbci	r19, 0xFF	; 255
     b58:	f9 01       	movw	r30, r18
     b5a:	20 81       	ld	r18, Z
     b5c:	22 0f       	add	r18, r18
     b5e:	22 0f       	add	r18, r18
     b60:	22 0f       	add	r18, r18
     b62:	fc 01       	movw	r30, r24
     b64:	20 83       	st	Z, r18
     b66:	8f ee       	ldi	r24, 0xEF	; 239
     b68:	90 e0       	ldi	r25, 0x00	; 0
     b6a:	2f ee       	ldi	r18, 0xEF	; 239
     b6c:	30 e0       	ldi	r19, 0x00	; 0
     b6e:	f9 01       	movw	r30, r18
     b70:	20 81       	ld	r18, Z
     b72:	20 61       	ori	r18, 0x10	; 16
     b74:	fc 01       	movw	r30, r24
     b76:	20 83       	st	Z, r18
     b78:	30 c0       	rjmp	.+96     	; 0xbda <can_cmd+0x42a>
          else              { Can_set_std_id(cmd->id.std);}
     b7a:	83 ef       	ldi	r24, 0xF3	; 243
     b7c:	90 e0       	ldi	r25, 0x00	; 0
     b7e:	29 85       	ldd	r18, Y+9	; 0x09
     b80:	3a 85       	ldd	r19, Y+10	; 0x0a
     b82:	2e 5f       	subi	r18, 0xFE	; 254
     b84:	3f 4f       	sbci	r19, 0xFF	; 255
     b86:	2f 5f       	subi	r18, 0xFF	; 255
     b88:	3f 4f       	sbci	r19, 0xFF	; 255
     b8a:	f9 01       	movw	r30, r18
     b8c:	20 81       	ld	r18, Z
     b8e:	42 2f       	mov	r20, r18
     b90:	42 95       	swap	r20
     b92:	44 0f       	add	r20, r20
     b94:	40 7e       	andi	r20, 0xE0	; 224
     b96:	29 85       	ldd	r18, Y+9	; 0x09
     b98:	3a 85       	ldd	r19, Y+10	; 0x0a
     b9a:	2e 5f       	subi	r18, 0xFE	; 254
     b9c:	3f 4f       	sbci	r19, 0xFF	; 255
     b9e:	f9 01       	movw	r30, r18
     ba0:	20 81       	ld	r18, Z
     ba2:	26 95       	lsr	r18
     ba4:	26 95       	lsr	r18
     ba6:	26 95       	lsr	r18
     ba8:	24 0f       	add	r18, r20
     baa:	fc 01       	movw	r30, r24
     bac:	20 83       	st	Z, r18
     bae:	82 ef       	ldi	r24, 0xF2	; 242
     bb0:	90 e0       	ldi	r25, 0x00	; 0
     bb2:	29 85       	ldd	r18, Y+9	; 0x09
     bb4:	3a 85       	ldd	r19, Y+10	; 0x0a
     bb6:	2e 5f       	subi	r18, 0xFE	; 254
     bb8:	3f 4f       	sbci	r19, 0xFF	; 255
     bba:	f9 01       	movw	r30, r18
     bbc:	20 81       	ld	r18, Z
     bbe:	22 95       	swap	r18
     bc0:	22 0f       	add	r18, r18
     bc2:	20 7e       	andi	r18, 0xE0	; 224
     bc4:	fc 01       	movw	r30, r24
     bc6:	20 83       	st	Z, r18
     bc8:	8f ee       	ldi	r24, 0xEF	; 239
     bca:	90 e0       	ldi	r25, 0x00	; 0
     bcc:	2f ee       	ldi	r18, 0xEF	; 239
     bce:	30 e0       	ldi	r19, 0x00	; 0
     bd0:	f9 01       	movw	r30, r18
     bd2:	20 81       	ld	r18, Z
     bd4:	2f 7e       	andi	r18, 0xEF	; 239
     bd6:	fc 01       	movw	r30, r24
     bd8:	20 83       	st	Z, r18
          for (cpt=0;cpt<cmd->dlc;cpt++) CANMSG = *(cmd->pt_data + cpt);
     bda:	19 82       	std	Y+1, r1	; 0x01
     bdc:	13 c0       	rjmp	.+38     	; 0xc04 <can_cmd+0x454>
     bde:	8a ef       	ldi	r24, 0xFA	; 250
     be0:	90 e0       	ldi	r25, 0x00	; 0
     be2:	29 85       	ldd	r18, Y+9	; 0x09
     be4:	3a 85       	ldd	r19, Y+10	; 0x0a
     be6:	f9 01       	movw	r30, r18
     be8:	47 81       	ldd	r20, Z+7	; 0x07
     bea:	50 85       	ldd	r21, Z+8	; 0x08
     bec:	29 81       	ldd	r18, Y+1	; 0x01
     bee:	22 2f       	mov	r18, r18
     bf0:	30 e0       	ldi	r19, 0x00	; 0
     bf2:	24 0f       	add	r18, r20
     bf4:	35 1f       	adc	r19, r21
     bf6:	f9 01       	movw	r30, r18
     bf8:	20 81       	ld	r18, Z
     bfa:	fc 01       	movw	r30, r24
     bfc:	20 83       	st	Z, r18
     bfe:	89 81       	ldd	r24, Y+1	; 0x01
     c00:	8f 5f       	subi	r24, 0xFF	; 255
     c02:	89 83       	std	Y+1, r24	; 0x01
     c04:	89 85       	ldd	r24, Y+9	; 0x09
     c06:	9a 85       	ldd	r25, Y+10	; 0x0a
     c08:	fc 01       	movw	r30, r24
     c0a:	96 81       	ldd	r25, Z+6	; 0x06
     c0c:	89 81       	ldd	r24, Y+1	; 0x01
     c0e:	89 17       	cp	r24, r25
     c10:	30 f3       	brcs	.-52     	; 0xbde <can_cmd+0x42e>
          cmd->ctrl.rtr=0; Can_clear_rtr();
     c12:	89 85       	ldd	r24, Y+9	; 0x09
     c14:	9a 85       	ldd	r25, Y+10	; 0x0a
     c16:	fc 01       	movw	r30, r24
     c18:	12 86       	std	Z+10, r1	; 0x0a
     c1a:	80 ef       	ldi	r24, 0xF0	; 240
     c1c:	90 e0       	ldi	r25, 0x00	; 0
     c1e:	20 ef       	ldi	r18, 0xF0	; 240
     c20:	30 e0       	ldi	r19, 0x00	; 0
     c22:	f9 01       	movw	r30, r18
     c24:	20 81       	ld	r18, Z
     c26:	2b 7f       	andi	r18, 0xFB	; 251
     c28:	fc 01       	movw	r30, r24
     c2a:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
     c2c:	8f ee       	ldi	r24, 0xEF	; 239
     c2e:	90 e0       	ldi	r25, 0x00	; 0
     c30:	2f ee       	ldi	r18, 0xEF	; 239
     c32:	30 e0       	ldi	r19, 0x00	; 0
     c34:	f9 01       	movw	r30, r18
     c36:	40 81       	ld	r20, Z
     c38:	29 85       	ldd	r18, Y+9	; 0x09
     c3a:	3a 85       	ldd	r19, Y+10	; 0x0a
     c3c:	f9 01       	movw	r30, r18
     c3e:	26 81       	ldd	r18, Z+6	; 0x06
     c40:	24 2b       	or	r18, r20
     c42:	fc 01       	movw	r30, r24
     c44:	20 83       	st	Z, r18
          Can_config_tx();
     c46:	8f ee       	ldi	r24, 0xEF	; 239
     c48:	90 e0       	ldi	r25, 0x00	; 0
     c4a:	2f ee       	ldi	r18, 0xEF	; 239
     c4c:	30 e0       	ldi	r19, 0x00	; 0
     c4e:	f9 01       	movw	r30, r18
     c50:	20 81       	ld	r18, Z
     c52:	2f 73       	andi	r18, 0x3F	; 63
     c54:	fc 01       	movw	r30, r24
     c56:	20 83       	st	Z, r18
     c58:	8f ee       	ldi	r24, 0xEF	; 239
     c5a:	90 e0       	ldi	r25, 0x00	; 0
     c5c:	2f ee       	ldi	r18, 0xEF	; 239
     c5e:	30 e0       	ldi	r19, 0x00	; 0
     c60:	f9 01       	movw	r30, r18
     c62:	20 81       	ld	r18, Z
     c64:	20 64       	ori	r18, 0x40	; 64
     c66:	fc 01       	movw	r30, r24
     c68:	20 83       	st	Z, r18
          break;
     c6a:	0c 94 5c 0e 	jmp	0x1cb8	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_TX_REMOTE:       
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
     c6e:	89 85       	ldd	r24, Y+9	; 0x09
     c70:	9a 85       	ldd	r25, Y+10	; 0x0a
     c72:	fc 01       	movw	r30, r24
     c74:	83 85       	ldd	r24, Z+11	; 0x0b
     c76:	88 23       	and	r24, r24
     c78:	09 f4       	brne	.+2      	; 0xc7c <can_cmd+0x4cc>
     c7a:	69 c0       	rjmp	.+210    	; 0xd4e <can_cmd+0x59e>
     c7c:	83 ef       	ldi	r24, 0xF3	; 243
     c7e:	90 e0       	ldi	r25, 0x00	; 0
     c80:	29 85       	ldd	r18, Y+9	; 0x09
     c82:	3a 85       	ldd	r19, Y+10	; 0x0a
     c84:	2e 5f       	subi	r18, 0xFE	; 254
     c86:	3f 4f       	sbci	r19, 0xFF	; 255
     c88:	2d 5f       	subi	r18, 0xFD	; 253
     c8a:	3f 4f       	sbci	r19, 0xFF	; 255
     c8c:	f9 01       	movw	r30, r18
     c8e:	20 81       	ld	r18, Z
     c90:	42 2f       	mov	r20, r18
     c92:	44 0f       	add	r20, r20
     c94:	44 0f       	add	r20, r20
     c96:	44 0f       	add	r20, r20
     c98:	29 85       	ldd	r18, Y+9	; 0x09
     c9a:	3a 85       	ldd	r19, Y+10	; 0x0a
     c9c:	2e 5f       	subi	r18, 0xFE	; 254
     c9e:	3f 4f       	sbci	r19, 0xFF	; 255
     ca0:	2e 5f       	subi	r18, 0xFE	; 254
     ca2:	3f 4f       	sbci	r19, 0xFF	; 255
     ca4:	f9 01       	movw	r30, r18
     ca6:	20 81       	ld	r18, Z
     ca8:	22 95       	swap	r18
     caa:	26 95       	lsr	r18
     cac:	27 70       	andi	r18, 0x07	; 7
     cae:	24 0f       	add	r18, r20
     cb0:	fc 01       	movw	r30, r24
     cb2:	20 83       	st	Z, r18
     cb4:	82 ef       	ldi	r24, 0xF2	; 242
     cb6:	90 e0       	ldi	r25, 0x00	; 0
     cb8:	29 85       	ldd	r18, Y+9	; 0x09
     cba:	3a 85       	ldd	r19, Y+10	; 0x0a
     cbc:	2e 5f       	subi	r18, 0xFE	; 254
     cbe:	3f 4f       	sbci	r19, 0xFF	; 255
     cc0:	2e 5f       	subi	r18, 0xFE	; 254
     cc2:	3f 4f       	sbci	r19, 0xFF	; 255
     cc4:	f9 01       	movw	r30, r18
     cc6:	20 81       	ld	r18, Z
     cc8:	42 2f       	mov	r20, r18
     cca:	44 0f       	add	r20, r20
     ccc:	44 0f       	add	r20, r20
     cce:	44 0f       	add	r20, r20
     cd0:	29 85       	ldd	r18, Y+9	; 0x09
     cd2:	3a 85       	ldd	r19, Y+10	; 0x0a
     cd4:	2e 5f       	subi	r18, 0xFE	; 254
     cd6:	3f 4f       	sbci	r19, 0xFF	; 255
     cd8:	2f 5f       	subi	r18, 0xFF	; 255
     cda:	3f 4f       	sbci	r19, 0xFF	; 255
     cdc:	f9 01       	movw	r30, r18
     cde:	20 81       	ld	r18, Z
     ce0:	22 95       	swap	r18
     ce2:	26 95       	lsr	r18
     ce4:	27 70       	andi	r18, 0x07	; 7
     ce6:	24 0f       	add	r18, r20
     ce8:	fc 01       	movw	r30, r24
     cea:	20 83       	st	Z, r18
     cec:	81 ef       	ldi	r24, 0xF1	; 241
     cee:	90 e0       	ldi	r25, 0x00	; 0
     cf0:	29 85       	ldd	r18, Y+9	; 0x09
     cf2:	3a 85       	ldd	r19, Y+10	; 0x0a
     cf4:	2e 5f       	subi	r18, 0xFE	; 254
     cf6:	3f 4f       	sbci	r19, 0xFF	; 255
     cf8:	2f 5f       	subi	r18, 0xFF	; 255
     cfa:	3f 4f       	sbci	r19, 0xFF	; 255
     cfc:	f9 01       	movw	r30, r18
     cfe:	20 81       	ld	r18, Z
     d00:	42 2f       	mov	r20, r18
     d02:	44 0f       	add	r20, r20
     d04:	44 0f       	add	r20, r20
     d06:	44 0f       	add	r20, r20
     d08:	29 85       	ldd	r18, Y+9	; 0x09
     d0a:	3a 85       	ldd	r19, Y+10	; 0x0a
     d0c:	2e 5f       	subi	r18, 0xFE	; 254
     d0e:	3f 4f       	sbci	r19, 0xFF	; 255
     d10:	f9 01       	movw	r30, r18
     d12:	20 81       	ld	r18, Z
     d14:	22 95       	swap	r18
     d16:	26 95       	lsr	r18
     d18:	27 70       	andi	r18, 0x07	; 7
     d1a:	24 0f       	add	r18, r20
     d1c:	fc 01       	movw	r30, r24
     d1e:	20 83       	st	Z, r18
     d20:	80 ef       	ldi	r24, 0xF0	; 240
     d22:	90 e0       	ldi	r25, 0x00	; 0
     d24:	29 85       	ldd	r18, Y+9	; 0x09
     d26:	3a 85       	ldd	r19, Y+10	; 0x0a
     d28:	2e 5f       	subi	r18, 0xFE	; 254
     d2a:	3f 4f       	sbci	r19, 0xFF	; 255
     d2c:	f9 01       	movw	r30, r18
     d2e:	20 81       	ld	r18, Z
     d30:	22 0f       	add	r18, r18
     d32:	22 0f       	add	r18, r18
     d34:	22 0f       	add	r18, r18
     d36:	fc 01       	movw	r30, r24
     d38:	20 83       	st	Z, r18
     d3a:	8f ee       	ldi	r24, 0xEF	; 239
     d3c:	90 e0       	ldi	r25, 0x00	; 0
     d3e:	2f ee       	ldi	r18, 0xEF	; 239
     d40:	30 e0       	ldi	r19, 0x00	; 0
     d42:	f9 01       	movw	r30, r18
     d44:	20 81       	ld	r18, Z
     d46:	20 61       	ori	r18, 0x10	; 16
     d48:	fc 01       	movw	r30, r24
     d4a:	20 83       	st	Z, r18
     d4c:	30 c0       	rjmp	.+96     	; 0xdae <can_cmd+0x5fe>
          else              { Can_set_std_id(cmd->id.std);}
     d4e:	83 ef       	ldi	r24, 0xF3	; 243
     d50:	90 e0       	ldi	r25, 0x00	; 0
     d52:	29 85       	ldd	r18, Y+9	; 0x09
     d54:	3a 85       	ldd	r19, Y+10	; 0x0a
     d56:	2e 5f       	subi	r18, 0xFE	; 254
     d58:	3f 4f       	sbci	r19, 0xFF	; 255
     d5a:	2f 5f       	subi	r18, 0xFF	; 255
     d5c:	3f 4f       	sbci	r19, 0xFF	; 255
     d5e:	f9 01       	movw	r30, r18
     d60:	20 81       	ld	r18, Z
     d62:	42 2f       	mov	r20, r18
     d64:	42 95       	swap	r20
     d66:	44 0f       	add	r20, r20
     d68:	40 7e       	andi	r20, 0xE0	; 224
     d6a:	29 85       	ldd	r18, Y+9	; 0x09
     d6c:	3a 85       	ldd	r19, Y+10	; 0x0a
     d6e:	2e 5f       	subi	r18, 0xFE	; 254
     d70:	3f 4f       	sbci	r19, 0xFF	; 255
     d72:	f9 01       	movw	r30, r18
     d74:	20 81       	ld	r18, Z
     d76:	26 95       	lsr	r18
     d78:	26 95       	lsr	r18
     d7a:	26 95       	lsr	r18
     d7c:	24 0f       	add	r18, r20
     d7e:	fc 01       	movw	r30, r24
     d80:	20 83       	st	Z, r18
     d82:	82 ef       	ldi	r24, 0xF2	; 242
     d84:	90 e0       	ldi	r25, 0x00	; 0
     d86:	29 85       	ldd	r18, Y+9	; 0x09
     d88:	3a 85       	ldd	r19, Y+10	; 0x0a
     d8a:	2e 5f       	subi	r18, 0xFE	; 254
     d8c:	3f 4f       	sbci	r19, 0xFF	; 255
     d8e:	f9 01       	movw	r30, r18
     d90:	20 81       	ld	r18, Z
     d92:	22 95       	swap	r18
     d94:	22 0f       	add	r18, r18
     d96:	20 7e       	andi	r18, 0xE0	; 224
     d98:	fc 01       	movw	r30, r24
     d9a:	20 83       	st	Z, r18
     d9c:	8f ee       	ldi	r24, 0xEF	; 239
     d9e:	90 e0       	ldi	r25, 0x00	; 0
     da0:	2f ee       	ldi	r18, 0xEF	; 239
     da2:	30 e0       	ldi	r19, 0x00	; 0
     da4:	f9 01       	movw	r30, r18
     da6:	20 81       	ld	r18, Z
     da8:	2f 7e       	andi	r18, 0xEF	; 239
     daa:	fc 01       	movw	r30, r24
     dac:	20 83       	st	Z, r18
          cmd->ctrl.rtr=1; Can_set_rtr();
     dae:	89 85       	ldd	r24, Y+9	; 0x09
     db0:	9a 85       	ldd	r25, Y+10	; 0x0a
     db2:	21 e0       	ldi	r18, 0x01	; 1
     db4:	fc 01       	movw	r30, r24
     db6:	22 87       	std	Z+10, r18	; 0x0a
     db8:	80 ef       	ldi	r24, 0xF0	; 240
     dba:	90 e0       	ldi	r25, 0x00	; 0
     dbc:	20 ef       	ldi	r18, 0xF0	; 240
     dbe:	30 e0       	ldi	r19, 0x00	; 0
     dc0:	f9 01       	movw	r30, r18
     dc2:	20 81       	ld	r18, Z
     dc4:	24 60       	ori	r18, 0x04	; 4
     dc6:	fc 01       	movw	r30, r24
     dc8:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
     dca:	8f ee       	ldi	r24, 0xEF	; 239
     dcc:	90 e0       	ldi	r25, 0x00	; 0
     dce:	2f ee       	ldi	r18, 0xEF	; 239
     dd0:	30 e0       	ldi	r19, 0x00	; 0
     dd2:	f9 01       	movw	r30, r18
     dd4:	40 81       	ld	r20, Z
     dd6:	29 85       	ldd	r18, Y+9	; 0x09
     dd8:	3a 85       	ldd	r19, Y+10	; 0x0a
     dda:	f9 01       	movw	r30, r18
     ddc:	26 81       	ldd	r18, Z+6	; 0x06
     dde:	24 2b       	or	r18, r20
     de0:	fc 01       	movw	r30, r24
     de2:	20 83       	st	Z, r18
          Can_config_tx();
     de4:	8f ee       	ldi	r24, 0xEF	; 239
     de6:	90 e0       	ldi	r25, 0x00	; 0
     de8:	2f ee       	ldi	r18, 0xEF	; 239
     dea:	30 e0       	ldi	r19, 0x00	; 0
     dec:	f9 01       	movw	r30, r18
     dee:	20 81       	ld	r18, Z
     df0:	2f 73       	andi	r18, 0x3F	; 63
     df2:	fc 01       	movw	r30, r24
     df4:	20 83       	st	Z, r18
     df6:	8f ee       	ldi	r24, 0xEF	; 239
     df8:	90 e0       	ldi	r25, 0x00	; 0
     dfa:	2f ee       	ldi	r18, 0xEF	; 239
     dfc:	30 e0       	ldi	r19, 0x00	; 0
     dfe:	f9 01       	movw	r30, r18
     e00:	20 81       	ld	r18, Z
     e02:	20 64       	ori	r18, 0x40	; 64
     e04:	fc 01       	movw	r30, r24
     e06:	20 83       	st	Z, r18
          break;
     e08:	57 c7       	rjmp	.+3758   	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_RX:
          u32_temp=0; Can_set_ext_msk(u32_temp);
     e0a:	1d 82       	std	Y+5, r1	; 0x05
     e0c:	1e 82       	std	Y+6, r1	; 0x06
     e0e:	1f 82       	std	Y+7, r1	; 0x07
     e10:	18 86       	std	Y+8, r1	; 0x08
     e12:	27 ef       	ldi	r18, 0xF7	; 247
     e14:	30 e0       	ldi	r19, 0x00	; 0
     e16:	ce 01       	movw	r24, r28
     e18:	05 96       	adiw	r24, 0x05	; 5
     e1a:	03 96       	adiw	r24, 0x03	; 3
     e1c:	fc 01       	movw	r30, r24
     e1e:	80 81       	ld	r24, Z
     e20:	48 2f       	mov	r20, r24
     e22:	44 0f       	add	r20, r20
     e24:	44 0f       	add	r20, r20
     e26:	44 0f       	add	r20, r20
     e28:	ce 01       	movw	r24, r28
     e2a:	05 96       	adiw	r24, 0x05	; 5
     e2c:	02 96       	adiw	r24, 0x02	; 2
     e2e:	fc 01       	movw	r30, r24
     e30:	80 81       	ld	r24, Z
     e32:	82 95       	swap	r24
     e34:	86 95       	lsr	r24
     e36:	87 70       	andi	r24, 0x07	; 7
     e38:	84 0f       	add	r24, r20
     e3a:	f9 01       	movw	r30, r18
     e3c:	80 83       	st	Z, r24
     e3e:	26 ef       	ldi	r18, 0xF6	; 246
     e40:	30 e0       	ldi	r19, 0x00	; 0
     e42:	ce 01       	movw	r24, r28
     e44:	05 96       	adiw	r24, 0x05	; 5
     e46:	02 96       	adiw	r24, 0x02	; 2
     e48:	fc 01       	movw	r30, r24
     e4a:	80 81       	ld	r24, Z
     e4c:	48 2f       	mov	r20, r24
     e4e:	44 0f       	add	r20, r20
     e50:	44 0f       	add	r20, r20
     e52:	44 0f       	add	r20, r20
     e54:	ce 01       	movw	r24, r28
     e56:	05 96       	adiw	r24, 0x05	; 5
     e58:	01 96       	adiw	r24, 0x01	; 1
     e5a:	fc 01       	movw	r30, r24
     e5c:	80 81       	ld	r24, Z
     e5e:	82 95       	swap	r24
     e60:	86 95       	lsr	r24
     e62:	87 70       	andi	r24, 0x07	; 7
     e64:	84 0f       	add	r24, r20
     e66:	f9 01       	movw	r30, r18
     e68:	80 83       	st	Z, r24
     e6a:	25 ef       	ldi	r18, 0xF5	; 245
     e6c:	30 e0       	ldi	r19, 0x00	; 0
     e6e:	ce 01       	movw	r24, r28
     e70:	05 96       	adiw	r24, 0x05	; 5
     e72:	01 96       	adiw	r24, 0x01	; 1
     e74:	fc 01       	movw	r30, r24
     e76:	80 81       	ld	r24, Z
     e78:	48 2f       	mov	r20, r24
     e7a:	44 0f       	add	r20, r20
     e7c:	44 0f       	add	r20, r20
     e7e:	44 0f       	add	r20, r20
     e80:	ce 01       	movw	r24, r28
     e82:	05 96       	adiw	r24, 0x05	; 5
     e84:	fc 01       	movw	r30, r24
     e86:	80 81       	ld	r24, Z
     e88:	82 95       	swap	r24
     e8a:	86 95       	lsr	r24
     e8c:	87 70       	andi	r24, 0x07	; 7
     e8e:	84 0f       	add	r24, r20
     e90:	f9 01       	movw	r30, r18
     e92:	80 83       	st	Z, r24
     e94:	84 ef       	ldi	r24, 0xF4	; 244
     e96:	90 e0       	ldi	r25, 0x00	; 0
     e98:	9e 01       	movw	r18, r28
     e9a:	2b 5f       	subi	r18, 0xFB	; 251
     e9c:	3f 4f       	sbci	r19, 0xFF	; 255
     e9e:	f9 01       	movw	r30, r18
     ea0:	20 81       	ld	r18, Z
     ea2:	22 0f       	add	r18, r18
     ea4:	22 0f       	add	r18, r18
     ea6:	22 0f       	add	r18, r18
     ea8:	fc 01       	movw	r30, r24
     eaa:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
     eac:	8f ee       	ldi	r24, 0xEF	; 239
     eae:	90 e0       	ldi	r25, 0x00	; 0
     eb0:	2f ee       	ldi	r18, 0xEF	; 239
     eb2:	30 e0       	ldi	r19, 0x00	; 0
     eb4:	f9 01       	movw	r30, r18
     eb6:	40 81       	ld	r20, Z
     eb8:	29 85       	ldd	r18, Y+9	; 0x09
     eba:	3a 85       	ldd	r19, Y+10	; 0x0a
     ebc:	f9 01       	movw	r30, r18
     ebe:	26 81       	ldd	r18, Z+6	; 0x06
     ec0:	24 2b       	or	r18, r20
     ec2:	fc 01       	movw	r30, r24
     ec4:	20 83       	st	Z, r18
          Can_clear_rtrmsk();
     ec6:	84 ef       	ldi	r24, 0xF4	; 244
     ec8:	90 e0       	ldi	r25, 0x00	; 0
     eca:	24 ef       	ldi	r18, 0xF4	; 244
     ecc:	30 e0       	ldi	r19, 0x00	; 0
     ece:	f9 01       	movw	r30, r18
     ed0:	20 81       	ld	r18, Z
     ed2:	2b 7f       	andi	r18, 0xFB	; 251
     ed4:	fc 01       	movw	r30, r24
     ed6:	20 83       	st	Z, r18
          Can_clear_idemsk();
     ed8:	84 ef       	ldi	r24, 0xF4	; 244
     eda:	90 e0       	ldi	r25, 0x00	; 0
     edc:	24 ef       	ldi	r18, 0xF4	; 244
     ede:	30 e0       	ldi	r19, 0x00	; 0
     ee0:	f9 01       	movw	r30, r18
     ee2:	20 81       	ld	r18, Z
     ee4:	2e 7f       	andi	r18, 0xFE	; 254
     ee6:	fc 01       	movw	r30, r24
     ee8:	20 83       	st	Z, r18
          Can_config_rx();       
     eea:	8f ee       	ldi	r24, 0xEF	; 239
     eec:	90 e0       	ldi	r25, 0x00	; 0
     eee:	2f ee       	ldi	r18, 0xEF	; 239
     ef0:	30 e0       	ldi	r19, 0x00	; 0
     ef2:	f9 01       	movw	r30, r18
     ef4:	20 81       	ld	r18, Z
     ef6:	2f 73       	andi	r18, 0x3F	; 63
     ef8:	fc 01       	movw	r30, r24
     efa:	20 83       	st	Z, r18
     efc:	8f ee       	ldi	r24, 0xEF	; 239
     efe:	90 e0       	ldi	r25, 0x00	; 0
     f00:	2f ee       	ldi	r18, 0xEF	; 239
     f02:	30 e0       	ldi	r19, 0x00	; 0
     f04:	f9 01       	movw	r30, r18
     f06:	20 81       	ld	r18, Z
     f08:	20 68       	ori	r18, 0x80	; 128
     f0a:	fc 01       	movw	r30, r24
     f0c:	20 83       	st	Z, r18
          break;
     f0e:	d4 c6       	rjmp	.+3496   	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_RX_DATA:
          u32_temp=0; Can_set_ext_msk(u32_temp);
     f10:	1d 82       	std	Y+5, r1	; 0x05
     f12:	1e 82       	std	Y+6, r1	; 0x06
     f14:	1f 82       	std	Y+7, r1	; 0x07
     f16:	18 86       	std	Y+8, r1	; 0x08
     f18:	27 ef       	ldi	r18, 0xF7	; 247
     f1a:	30 e0       	ldi	r19, 0x00	; 0
     f1c:	ce 01       	movw	r24, r28
     f1e:	05 96       	adiw	r24, 0x05	; 5
     f20:	03 96       	adiw	r24, 0x03	; 3
     f22:	fc 01       	movw	r30, r24
     f24:	80 81       	ld	r24, Z
     f26:	48 2f       	mov	r20, r24
     f28:	44 0f       	add	r20, r20
     f2a:	44 0f       	add	r20, r20
     f2c:	44 0f       	add	r20, r20
     f2e:	ce 01       	movw	r24, r28
     f30:	05 96       	adiw	r24, 0x05	; 5
     f32:	02 96       	adiw	r24, 0x02	; 2
     f34:	fc 01       	movw	r30, r24
     f36:	80 81       	ld	r24, Z
     f38:	82 95       	swap	r24
     f3a:	86 95       	lsr	r24
     f3c:	87 70       	andi	r24, 0x07	; 7
     f3e:	84 0f       	add	r24, r20
     f40:	f9 01       	movw	r30, r18
     f42:	80 83       	st	Z, r24
     f44:	26 ef       	ldi	r18, 0xF6	; 246
     f46:	30 e0       	ldi	r19, 0x00	; 0
     f48:	ce 01       	movw	r24, r28
     f4a:	05 96       	adiw	r24, 0x05	; 5
     f4c:	02 96       	adiw	r24, 0x02	; 2
     f4e:	fc 01       	movw	r30, r24
     f50:	80 81       	ld	r24, Z
     f52:	48 2f       	mov	r20, r24
     f54:	44 0f       	add	r20, r20
     f56:	44 0f       	add	r20, r20
     f58:	44 0f       	add	r20, r20
     f5a:	ce 01       	movw	r24, r28
     f5c:	05 96       	adiw	r24, 0x05	; 5
     f5e:	01 96       	adiw	r24, 0x01	; 1
     f60:	fc 01       	movw	r30, r24
     f62:	80 81       	ld	r24, Z
     f64:	82 95       	swap	r24
     f66:	86 95       	lsr	r24
     f68:	87 70       	andi	r24, 0x07	; 7
     f6a:	84 0f       	add	r24, r20
     f6c:	f9 01       	movw	r30, r18
     f6e:	80 83       	st	Z, r24
     f70:	25 ef       	ldi	r18, 0xF5	; 245
     f72:	30 e0       	ldi	r19, 0x00	; 0
     f74:	ce 01       	movw	r24, r28
     f76:	05 96       	adiw	r24, 0x05	; 5
     f78:	01 96       	adiw	r24, 0x01	; 1
     f7a:	fc 01       	movw	r30, r24
     f7c:	80 81       	ld	r24, Z
     f7e:	48 2f       	mov	r20, r24
     f80:	44 0f       	add	r20, r20
     f82:	44 0f       	add	r20, r20
     f84:	44 0f       	add	r20, r20
     f86:	ce 01       	movw	r24, r28
     f88:	05 96       	adiw	r24, 0x05	; 5
     f8a:	fc 01       	movw	r30, r24
     f8c:	80 81       	ld	r24, Z
     f8e:	82 95       	swap	r24
     f90:	86 95       	lsr	r24
     f92:	87 70       	andi	r24, 0x07	; 7
     f94:	84 0f       	add	r24, r20
     f96:	f9 01       	movw	r30, r18
     f98:	80 83       	st	Z, r24
     f9a:	84 ef       	ldi	r24, 0xF4	; 244
     f9c:	90 e0       	ldi	r25, 0x00	; 0
     f9e:	9e 01       	movw	r18, r28
     fa0:	2b 5f       	subi	r18, 0xFB	; 251
     fa2:	3f 4f       	sbci	r19, 0xFF	; 255
     fa4:	f9 01       	movw	r30, r18
     fa6:	20 81       	ld	r18, Z
     fa8:	22 0f       	add	r18, r18
     faa:	22 0f       	add	r18, r18
     fac:	22 0f       	add	r18, r18
     fae:	fc 01       	movw	r30, r24
     fb0:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
     fb2:	8f ee       	ldi	r24, 0xEF	; 239
     fb4:	90 e0       	ldi	r25, 0x00	; 0
     fb6:	2f ee       	ldi	r18, 0xEF	; 239
     fb8:	30 e0       	ldi	r19, 0x00	; 0
     fba:	f9 01       	movw	r30, r18
     fbc:	40 81       	ld	r20, Z
     fbe:	29 85       	ldd	r18, Y+9	; 0x09
     fc0:	3a 85       	ldd	r19, Y+10	; 0x0a
     fc2:	f9 01       	movw	r30, r18
     fc4:	26 81       	ldd	r18, Z+6	; 0x06
     fc6:	24 2b       	or	r18, r20
     fc8:	fc 01       	movw	r30, r24
     fca:	20 83       	st	Z, r18
          cmd->ctrl.rtr=0; Can_set_rtrmsk(); Can_clear_rtr();
     fcc:	89 85       	ldd	r24, Y+9	; 0x09
     fce:	9a 85       	ldd	r25, Y+10	; 0x0a
     fd0:	fc 01       	movw	r30, r24
     fd2:	12 86       	std	Z+10, r1	; 0x0a
     fd4:	84 ef       	ldi	r24, 0xF4	; 244
     fd6:	90 e0       	ldi	r25, 0x00	; 0
     fd8:	24 ef       	ldi	r18, 0xF4	; 244
     fda:	30 e0       	ldi	r19, 0x00	; 0
     fdc:	f9 01       	movw	r30, r18
     fde:	20 81       	ld	r18, Z
     fe0:	24 60       	ori	r18, 0x04	; 4
     fe2:	fc 01       	movw	r30, r24
     fe4:	20 83       	st	Z, r18
     fe6:	80 ef       	ldi	r24, 0xF0	; 240
     fe8:	90 e0       	ldi	r25, 0x00	; 0
     fea:	20 ef       	ldi	r18, 0xF0	; 240
     fec:	30 e0       	ldi	r19, 0x00	; 0
     fee:	f9 01       	movw	r30, r18
     ff0:	20 81       	ld	r18, Z
     ff2:	2b 7f       	andi	r18, 0xFB	; 251
     ff4:	fc 01       	movw	r30, r24
     ff6:	20 83       	st	Z, r18
          Can_clear_idemsk();
     ff8:	84 ef       	ldi	r24, 0xF4	; 244
     ffa:	90 e0       	ldi	r25, 0x00	; 0
     ffc:	24 ef       	ldi	r18, 0xF4	; 244
     ffe:	30 e0       	ldi	r19, 0x00	; 0
    1000:	f9 01       	movw	r30, r18
    1002:	20 81       	ld	r18, Z
    1004:	2e 7f       	andi	r18, 0xFE	; 254
    1006:	fc 01       	movw	r30, r24
    1008:	20 83       	st	Z, r18
          Can_config_rx();       
    100a:	8f ee       	ldi	r24, 0xEF	; 239
    100c:	90 e0       	ldi	r25, 0x00	; 0
    100e:	2f ee       	ldi	r18, 0xEF	; 239
    1010:	30 e0       	ldi	r19, 0x00	; 0
    1012:	f9 01       	movw	r30, r18
    1014:	20 81       	ld	r18, Z
    1016:	2f 73       	andi	r18, 0x3F	; 63
    1018:	fc 01       	movw	r30, r24
    101a:	20 83       	st	Z, r18
    101c:	8f ee       	ldi	r24, 0xEF	; 239
    101e:	90 e0       	ldi	r25, 0x00	; 0
    1020:	2f ee       	ldi	r18, 0xEF	; 239
    1022:	30 e0       	ldi	r19, 0x00	; 0
    1024:	f9 01       	movw	r30, r18
    1026:	20 81       	ld	r18, Z
    1028:	20 68       	ori	r18, 0x80	; 128
    102a:	fc 01       	movw	r30, r24
    102c:	20 83       	st	Z, r18
          break;
    102e:	44 c6       	rjmp	.+3208   	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_RX_REMOTE:
          u32_temp=0; Can_set_ext_msk(u32_temp);
    1030:	1d 82       	std	Y+5, r1	; 0x05
    1032:	1e 82       	std	Y+6, r1	; 0x06
    1034:	1f 82       	std	Y+7, r1	; 0x07
    1036:	18 86       	std	Y+8, r1	; 0x08
    1038:	27 ef       	ldi	r18, 0xF7	; 247
    103a:	30 e0       	ldi	r19, 0x00	; 0
    103c:	ce 01       	movw	r24, r28
    103e:	05 96       	adiw	r24, 0x05	; 5
    1040:	03 96       	adiw	r24, 0x03	; 3
    1042:	fc 01       	movw	r30, r24
    1044:	80 81       	ld	r24, Z
    1046:	48 2f       	mov	r20, r24
    1048:	44 0f       	add	r20, r20
    104a:	44 0f       	add	r20, r20
    104c:	44 0f       	add	r20, r20
    104e:	ce 01       	movw	r24, r28
    1050:	05 96       	adiw	r24, 0x05	; 5
    1052:	02 96       	adiw	r24, 0x02	; 2
    1054:	fc 01       	movw	r30, r24
    1056:	80 81       	ld	r24, Z
    1058:	82 95       	swap	r24
    105a:	86 95       	lsr	r24
    105c:	87 70       	andi	r24, 0x07	; 7
    105e:	84 0f       	add	r24, r20
    1060:	f9 01       	movw	r30, r18
    1062:	80 83       	st	Z, r24
    1064:	26 ef       	ldi	r18, 0xF6	; 246
    1066:	30 e0       	ldi	r19, 0x00	; 0
    1068:	ce 01       	movw	r24, r28
    106a:	05 96       	adiw	r24, 0x05	; 5
    106c:	02 96       	adiw	r24, 0x02	; 2
    106e:	fc 01       	movw	r30, r24
    1070:	80 81       	ld	r24, Z
    1072:	48 2f       	mov	r20, r24
    1074:	44 0f       	add	r20, r20
    1076:	44 0f       	add	r20, r20
    1078:	44 0f       	add	r20, r20
    107a:	ce 01       	movw	r24, r28
    107c:	05 96       	adiw	r24, 0x05	; 5
    107e:	01 96       	adiw	r24, 0x01	; 1
    1080:	fc 01       	movw	r30, r24
    1082:	80 81       	ld	r24, Z
    1084:	82 95       	swap	r24
    1086:	86 95       	lsr	r24
    1088:	87 70       	andi	r24, 0x07	; 7
    108a:	84 0f       	add	r24, r20
    108c:	f9 01       	movw	r30, r18
    108e:	80 83       	st	Z, r24
    1090:	25 ef       	ldi	r18, 0xF5	; 245
    1092:	30 e0       	ldi	r19, 0x00	; 0
    1094:	ce 01       	movw	r24, r28
    1096:	05 96       	adiw	r24, 0x05	; 5
    1098:	01 96       	adiw	r24, 0x01	; 1
    109a:	fc 01       	movw	r30, r24
    109c:	80 81       	ld	r24, Z
    109e:	48 2f       	mov	r20, r24
    10a0:	44 0f       	add	r20, r20
    10a2:	44 0f       	add	r20, r20
    10a4:	44 0f       	add	r20, r20
    10a6:	ce 01       	movw	r24, r28
    10a8:	05 96       	adiw	r24, 0x05	; 5
    10aa:	fc 01       	movw	r30, r24
    10ac:	80 81       	ld	r24, Z
    10ae:	82 95       	swap	r24
    10b0:	86 95       	lsr	r24
    10b2:	87 70       	andi	r24, 0x07	; 7
    10b4:	84 0f       	add	r24, r20
    10b6:	f9 01       	movw	r30, r18
    10b8:	80 83       	st	Z, r24
    10ba:	84 ef       	ldi	r24, 0xF4	; 244
    10bc:	90 e0       	ldi	r25, 0x00	; 0
    10be:	9e 01       	movw	r18, r28
    10c0:	2b 5f       	subi	r18, 0xFB	; 251
    10c2:	3f 4f       	sbci	r19, 0xFF	; 255
    10c4:	f9 01       	movw	r30, r18
    10c6:	20 81       	ld	r18, Z
    10c8:	22 0f       	add	r18, r18
    10ca:	22 0f       	add	r18, r18
    10cc:	22 0f       	add	r18, r18
    10ce:	fc 01       	movw	r30, r24
    10d0:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    10d2:	8f ee       	ldi	r24, 0xEF	; 239
    10d4:	90 e0       	ldi	r25, 0x00	; 0
    10d6:	2f ee       	ldi	r18, 0xEF	; 239
    10d8:	30 e0       	ldi	r19, 0x00	; 0
    10da:	f9 01       	movw	r30, r18
    10dc:	40 81       	ld	r20, Z
    10de:	29 85       	ldd	r18, Y+9	; 0x09
    10e0:	3a 85       	ldd	r19, Y+10	; 0x0a
    10e2:	f9 01       	movw	r30, r18
    10e4:	26 81       	ldd	r18, Z+6	; 0x06
    10e6:	24 2b       	or	r18, r20
    10e8:	fc 01       	movw	r30, r24
    10ea:	20 83       	st	Z, r18
          cmd->ctrl.rtr=1; Can_set_rtrmsk(); Can_set_rtr();
    10ec:	89 85       	ldd	r24, Y+9	; 0x09
    10ee:	9a 85       	ldd	r25, Y+10	; 0x0a
    10f0:	21 e0       	ldi	r18, 0x01	; 1
    10f2:	fc 01       	movw	r30, r24
    10f4:	22 87       	std	Z+10, r18	; 0x0a
    10f6:	84 ef       	ldi	r24, 0xF4	; 244
    10f8:	90 e0       	ldi	r25, 0x00	; 0
    10fa:	24 ef       	ldi	r18, 0xF4	; 244
    10fc:	30 e0       	ldi	r19, 0x00	; 0
    10fe:	f9 01       	movw	r30, r18
    1100:	20 81       	ld	r18, Z
    1102:	24 60       	ori	r18, 0x04	; 4
    1104:	fc 01       	movw	r30, r24
    1106:	20 83       	st	Z, r18
    1108:	80 ef       	ldi	r24, 0xF0	; 240
    110a:	90 e0       	ldi	r25, 0x00	; 0
    110c:	20 ef       	ldi	r18, 0xF0	; 240
    110e:	30 e0       	ldi	r19, 0x00	; 0
    1110:	f9 01       	movw	r30, r18
    1112:	20 81       	ld	r18, Z
    1114:	24 60       	ori	r18, 0x04	; 4
    1116:	fc 01       	movw	r30, r24
    1118:	20 83       	st	Z, r18
          Can_clear_rplv();
    111a:	8f ee       	ldi	r24, 0xEF	; 239
    111c:	90 e0       	ldi	r25, 0x00	; 0
    111e:	2f ee       	ldi	r18, 0xEF	; 239
    1120:	30 e0       	ldi	r19, 0x00	; 0
    1122:	f9 01       	movw	r30, r18
    1124:	20 81       	ld	r18, Z
    1126:	2f 7d       	andi	r18, 0xDF	; 223
    1128:	fc 01       	movw	r30, r24
    112a:	20 83       	st	Z, r18
          Can_clear_idemsk();
    112c:	84 ef       	ldi	r24, 0xF4	; 244
    112e:	90 e0       	ldi	r25, 0x00	; 0
    1130:	24 ef       	ldi	r18, 0xF4	; 244
    1132:	30 e0       	ldi	r19, 0x00	; 0
    1134:	f9 01       	movw	r30, r18
    1136:	20 81       	ld	r18, Z
    1138:	2e 7f       	andi	r18, 0xFE	; 254
    113a:	fc 01       	movw	r30, r24
    113c:	20 83       	st	Z, r18
          Can_config_rx();       
    113e:	8f ee       	ldi	r24, 0xEF	; 239
    1140:	90 e0       	ldi	r25, 0x00	; 0
    1142:	2f ee       	ldi	r18, 0xEF	; 239
    1144:	30 e0       	ldi	r19, 0x00	; 0
    1146:	f9 01       	movw	r30, r18
    1148:	20 81       	ld	r18, Z
    114a:	2f 73       	andi	r18, 0x3F	; 63
    114c:	fc 01       	movw	r30, r24
    114e:	20 83       	st	Z, r18
    1150:	8f ee       	ldi	r24, 0xEF	; 239
    1152:	90 e0       	ldi	r25, 0x00	; 0
    1154:	2f ee       	ldi	r18, 0xEF	; 239
    1156:	30 e0       	ldi	r19, 0x00	; 0
    1158:	f9 01       	movw	r30, r18
    115a:	20 81       	ld	r18, Z
    115c:	20 68       	ori	r18, 0x80	; 128
    115e:	fc 01       	movw	r30, r24
    1160:	20 83       	st	Z, r18
          break;
    1162:	aa c5       	rjmp	.+2900   	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_RX_MASKED:
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
    1164:	89 85       	ldd	r24, Y+9	; 0x09
    1166:	9a 85       	ldd	r25, Y+10	; 0x0a
    1168:	fc 01       	movw	r30, r24
    116a:	83 85       	ldd	r24, Z+11	; 0x0b
    116c:	88 23       	and	r24, r24
    116e:	09 f4       	brne	.+2      	; 0x1172 <__stack+0x73>
    1170:	69 c0       	rjmp	.+210    	; 0x1244 <__stack+0x145>
    1172:	83 ef       	ldi	r24, 0xF3	; 243
    1174:	90 e0       	ldi	r25, 0x00	; 0
    1176:	29 85       	ldd	r18, Y+9	; 0x09
    1178:	3a 85       	ldd	r19, Y+10	; 0x0a
    117a:	2e 5f       	subi	r18, 0xFE	; 254
    117c:	3f 4f       	sbci	r19, 0xFF	; 255
    117e:	2d 5f       	subi	r18, 0xFD	; 253
    1180:	3f 4f       	sbci	r19, 0xFF	; 255
    1182:	f9 01       	movw	r30, r18
    1184:	20 81       	ld	r18, Z
    1186:	42 2f       	mov	r20, r18
    1188:	44 0f       	add	r20, r20
    118a:	44 0f       	add	r20, r20
    118c:	44 0f       	add	r20, r20
    118e:	29 85       	ldd	r18, Y+9	; 0x09
    1190:	3a 85       	ldd	r19, Y+10	; 0x0a
    1192:	2e 5f       	subi	r18, 0xFE	; 254
    1194:	3f 4f       	sbci	r19, 0xFF	; 255
    1196:	2e 5f       	subi	r18, 0xFE	; 254
    1198:	3f 4f       	sbci	r19, 0xFF	; 255
    119a:	f9 01       	movw	r30, r18
    119c:	20 81       	ld	r18, Z
    119e:	22 95       	swap	r18
    11a0:	26 95       	lsr	r18
    11a2:	27 70       	andi	r18, 0x07	; 7
    11a4:	24 0f       	add	r18, r20
    11a6:	fc 01       	movw	r30, r24
    11a8:	20 83       	st	Z, r18
    11aa:	82 ef       	ldi	r24, 0xF2	; 242
    11ac:	90 e0       	ldi	r25, 0x00	; 0
    11ae:	29 85       	ldd	r18, Y+9	; 0x09
    11b0:	3a 85       	ldd	r19, Y+10	; 0x0a
    11b2:	2e 5f       	subi	r18, 0xFE	; 254
    11b4:	3f 4f       	sbci	r19, 0xFF	; 255
    11b6:	2e 5f       	subi	r18, 0xFE	; 254
    11b8:	3f 4f       	sbci	r19, 0xFF	; 255
    11ba:	f9 01       	movw	r30, r18
    11bc:	20 81       	ld	r18, Z
    11be:	42 2f       	mov	r20, r18
    11c0:	44 0f       	add	r20, r20
    11c2:	44 0f       	add	r20, r20
    11c4:	44 0f       	add	r20, r20
    11c6:	29 85       	ldd	r18, Y+9	; 0x09
    11c8:	3a 85       	ldd	r19, Y+10	; 0x0a
    11ca:	2e 5f       	subi	r18, 0xFE	; 254
    11cc:	3f 4f       	sbci	r19, 0xFF	; 255
    11ce:	2f 5f       	subi	r18, 0xFF	; 255
    11d0:	3f 4f       	sbci	r19, 0xFF	; 255
    11d2:	f9 01       	movw	r30, r18
    11d4:	20 81       	ld	r18, Z
    11d6:	22 95       	swap	r18
    11d8:	26 95       	lsr	r18
    11da:	27 70       	andi	r18, 0x07	; 7
    11dc:	24 0f       	add	r18, r20
    11de:	fc 01       	movw	r30, r24
    11e0:	20 83       	st	Z, r18
    11e2:	81 ef       	ldi	r24, 0xF1	; 241
    11e4:	90 e0       	ldi	r25, 0x00	; 0
    11e6:	29 85       	ldd	r18, Y+9	; 0x09
    11e8:	3a 85       	ldd	r19, Y+10	; 0x0a
    11ea:	2e 5f       	subi	r18, 0xFE	; 254
    11ec:	3f 4f       	sbci	r19, 0xFF	; 255
    11ee:	2f 5f       	subi	r18, 0xFF	; 255
    11f0:	3f 4f       	sbci	r19, 0xFF	; 255
    11f2:	f9 01       	movw	r30, r18
    11f4:	20 81       	ld	r18, Z
    11f6:	42 2f       	mov	r20, r18
    11f8:	44 0f       	add	r20, r20
    11fa:	44 0f       	add	r20, r20
    11fc:	44 0f       	add	r20, r20
    11fe:	29 85       	ldd	r18, Y+9	; 0x09
    1200:	3a 85       	ldd	r19, Y+10	; 0x0a
    1202:	2e 5f       	subi	r18, 0xFE	; 254
    1204:	3f 4f       	sbci	r19, 0xFF	; 255
    1206:	f9 01       	movw	r30, r18
    1208:	20 81       	ld	r18, Z
    120a:	22 95       	swap	r18
    120c:	26 95       	lsr	r18
    120e:	27 70       	andi	r18, 0x07	; 7
    1210:	24 0f       	add	r18, r20
    1212:	fc 01       	movw	r30, r24
    1214:	20 83       	st	Z, r18
    1216:	80 ef       	ldi	r24, 0xF0	; 240
    1218:	90 e0       	ldi	r25, 0x00	; 0
    121a:	29 85       	ldd	r18, Y+9	; 0x09
    121c:	3a 85       	ldd	r19, Y+10	; 0x0a
    121e:	2e 5f       	subi	r18, 0xFE	; 254
    1220:	3f 4f       	sbci	r19, 0xFF	; 255
    1222:	f9 01       	movw	r30, r18
    1224:	20 81       	ld	r18, Z
    1226:	22 0f       	add	r18, r18
    1228:	22 0f       	add	r18, r18
    122a:	22 0f       	add	r18, r18
    122c:	fc 01       	movw	r30, r24
    122e:	20 83       	st	Z, r18
    1230:	8f ee       	ldi	r24, 0xEF	; 239
    1232:	90 e0       	ldi	r25, 0x00	; 0
    1234:	2f ee       	ldi	r18, 0xEF	; 239
    1236:	30 e0       	ldi	r19, 0x00	; 0
    1238:	f9 01       	movw	r30, r18
    123a:	20 81       	ld	r18, Z
    123c:	20 61       	ori	r18, 0x10	; 16
    123e:	fc 01       	movw	r30, r24
    1240:	20 83       	st	Z, r18
    1242:	30 c0       	rjmp	.+96     	; 0x12a4 <__stack+0x1a5>
          else              { Can_set_std_id(cmd->id.std);}
    1244:	83 ef       	ldi	r24, 0xF3	; 243
    1246:	90 e0       	ldi	r25, 0x00	; 0
    1248:	29 85       	ldd	r18, Y+9	; 0x09
    124a:	3a 85       	ldd	r19, Y+10	; 0x0a
    124c:	2e 5f       	subi	r18, 0xFE	; 254
    124e:	3f 4f       	sbci	r19, 0xFF	; 255
    1250:	2f 5f       	subi	r18, 0xFF	; 255
    1252:	3f 4f       	sbci	r19, 0xFF	; 255
    1254:	f9 01       	movw	r30, r18
    1256:	20 81       	ld	r18, Z
    1258:	42 2f       	mov	r20, r18
    125a:	42 95       	swap	r20
    125c:	44 0f       	add	r20, r20
    125e:	40 7e       	andi	r20, 0xE0	; 224
    1260:	29 85       	ldd	r18, Y+9	; 0x09
    1262:	3a 85       	ldd	r19, Y+10	; 0x0a
    1264:	2e 5f       	subi	r18, 0xFE	; 254
    1266:	3f 4f       	sbci	r19, 0xFF	; 255
    1268:	f9 01       	movw	r30, r18
    126a:	20 81       	ld	r18, Z
    126c:	26 95       	lsr	r18
    126e:	26 95       	lsr	r18
    1270:	26 95       	lsr	r18
    1272:	24 0f       	add	r18, r20
    1274:	fc 01       	movw	r30, r24
    1276:	20 83       	st	Z, r18
    1278:	82 ef       	ldi	r24, 0xF2	; 242
    127a:	90 e0       	ldi	r25, 0x00	; 0
    127c:	29 85       	ldd	r18, Y+9	; 0x09
    127e:	3a 85       	ldd	r19, Y+10	; 0x0a
    1280:	2e 5f       	subi	r18, 0xFE	; 254
    1282:	3f 4f       	sbci	r19, 0xFF	; 255
    1284:	f9 01       	movw	r30, r18
    1286:	20 81       	ld	r18, Z
    1288:	22 95       	swap	r18
    128a:	22 0f       	add	r18, r18
    128c:	20 7e       	andi	r18, 0xE0	; 224
    128e:	fc 01       	movw	r30, r24
    1290:	20 83       	st	Z, r18
    1292:	8f ee       	ldi	r24, 0xEF	; 239
    1294:	90 e0       	ldi	r25, 0x00	; 0
    1296:	2f ee       	ldi	r18, 0xEF	; 239
    1298:	30 e0       	ldi	r19, 0x00	; 0
    129a:	f9 01       	movw	r30, r18
    129c:	20 81       	ld	r18, Z
    129e:	2f 7e       	andi	r18, 0xEF	; 239
    12a0:	fc 01       	movw	r30, r24
    12a2:	20 83       	st	Z, r18
          u32_temp=~0; Can_set_ext_msk(u32_temp);
    12a4:	8f ef       	ldi	r24, 0xFF	; 255
    12a6:	9f ef       	ldi	r25, 0xFF	; 255
    12a8:	dc 01       	movw	r26, r24
    12aa:	8d 83       	std	Y+5, r24	; 0x05
    12ac:	9e 83       	std	Y+6, r25	; 0x06
    12ae:	af 83       	std	Y+7, r26	; 0x07
    12b0:	b8 87       	std	Y+8, r27	; 0x08
    12b2:	27 ef       	ldi	r18, 0xF7	; 247
    12b4:	30 e0       	ldi	r19, 0x00	; 0
    12b6:	ce 01       	movw	r24, r28
    12b8:	05 96       	adiw	r24, 0x05	; 5
    12ba:	03 96       	adiw	r24, 0x03	; 3
    12bc:	fc 01       	movw	r30, r24
    12be:	80 81       	ld	r24, Z
    12c0:	48 2f       	mov	r20, r24
    12c2:	44 0f       	add	r20, r20
    12c4:	44 0f       	add	r20, r20
    12c6:	44 0f       	add	r20, r20
    12c8:	ce 01       	movw	r24, r28
    12ca:	05 96       	adiw	r24, 0x05	; 5
    12cc:	02 96       	adiw	r24, 0x02	; 2
    12ce:	fc 01       	movw	r30, r24
    12d0:	80 81       	ld	r24, Z
    12d2:	82 95       	swap	r24
    12d4:	86 95       	lsr	r24
    12d6:	87 70       	andi	r24, 0x07	; 7
    12d8:	84 0f       	add	r24, r20
    12da:	f9 01       	movw	r30, r18
    12dc:	80 83       	st	Z, r24
    12de:	26 ef       	ldi	r18, 0xF6	; 246
    12e0:	30 e0       	ldi	r19, 0x00	; 0
    12e2:	ce 01       	movw	r24, r28
    12e4:	05 96       	adiw	r24, 0x05	; 5
    12e6:	02 96       	adiw	r24, 0x02	; 2
    12e8:	fc 01       	movw	r30, r24
    12ea:	80 81       	ld	r24, Z
    12ec:	48 2f       	mov	r20, r24
    12ee:	44 0f       	add	r20, r20
    12f0:	44 0f       	add	r20, r20
    12f2:	44 0f       	add	r20, r20
    12f4:	ce 01       	movw	r24, r28
    12f6:	05 96       	adiw	r24, 0x05	; 5
    12f8:	01 96       	adiw	r24, 0x01	; 1
    12fa:	fc 01       	movw	r30, r24
    12fc:	80 81       	ld	r24, Z
    12fe:	82 95       	swap	r24
    1300:	86 95       	lsr	r24
    1302:	87 70       	andi	r24, 0x07	; 7
    1304:	84 0f       	add	r24, r20
    1306:	f9 01       	movw	r30, r18
    1308:	80 83       	st	Z, r24
    130a:	25 ef       	ldi	r18, 0xF5	; 245
    130c:	30 e0       	ldi	r19, 0x00	; 0
    130e:	ce 01       	movw	r24, r28
    1310:	05 96       	adiw	r24, 0x05	; 5
    1312:	01 96       	adiw	r24, 0x01	; 1
    1314:	fc 01       	movw	r30, r24
    1316:	80 81       	ld	r24, Z
    1318:	48 2f       	mov	r20, r24
    131a:	44 0f       	add	r20, r20
    131c:	44 0f       	add	r20, r20
    131e:	44 0f       	add	r20, r20
    1320:	ce 01       	movw	r24, r28
    1322:	05 96       	adiw	r24, 0x05	; 5
    1324:	fc 01       	movw	r30, r24
    1326:	80 81       	ld	r24, Z
    1328:	82 95       	swap	r24
    132a:	86 95       	lsr	r24
    132c:	87 70       	andi	r24, 0x07	; 7
    132e:	84 0f       	add	r24, r20
    1330:	f9 01       	movw	r30, r18
    1332:	80 83       	st	Z, r24
    1334:	84 ef       	ldi	r24, 0xF4	; 244
    1336:	90 e0       	ldi	r25, 0x00	; 0
    1338:	9e 01       	movw	r18, r28
    133a:	2b 5f       	subi	r18, 0xFB	; 251
    133c:	3f 4f       	sbci	r19, 0xFF	; 255
    133e:	f9 01       	movw	r30, r18
    1340:	20 81       	ld	r18, Z
    1342:	22 0f       	add	r18, r18
    1344:	22 0f       	add	r18, r18
    1346:	22 0f       	add	r18, r18
    1348:	fc 01       	movw	r30, r24
    134a:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    134c:	8f ee       	ldi	r24, 0xEF	; 239
    134e:	90 e0       	ldi	r25, 0x00	; 0
    1350:	2f ee       	ldi	r18, 0xEF	; 239
    1352:	30 e0       	ldi	r19, 0x00	; 0
    1354:	f9 01       	movw	r30, r18
    1356:	40 81       	ld	r20, Z
    1358:	29 85       	ldd	r18, Y+9	; 0x09
    135a:	3a 85       	ldd	r19, Y+10	; 0x0a
    135c:	f9 01       	movw	r30, r18
    135e:	26 81       	ldd	r18, Z+6	; 0x06
    1360:	24 2b       	or	r18, r20
    1362:	fc 01       	movw	r30, r24
    1364:	20 83       	st	Z, r18
          Can_clear_rtrmsk();
    1366:	84 ef       	ldi	r24, 0xF4	; 244
    1368:	90 e0       	ldi	r25, 0x00	; 0
    136a:	24 ef       	ldi	r18, 0xF4	; 244
    136c:	30 e0       	ldi	r19, 0x00	; 0
    136e:	f9 01       	movw	r30, r18
    1370:	20 81       	ld	r18, Z
    1372:	2b 7f       	andi	r18, 0xFB	; 251
    1374:	fc 01       	movw	r30, r24
    1376:	20 83       	st	Z, r18
          Can_set_idemsk();
    1378:	84 ef       	ldi	r24, 0xF4	; 244
    137a:	90 e0       	ldi	r25, 0x00	; 0
    137c:	24 ef       	ldi	r18, 0xF4	; 244
    137e:	30 e0       	ldi	r19, 0x00	; 0
    1380:	f9 01       	movw	r30, r18
    1382:	20 81       	ld	r18, Z
    1384:	21 60       	ori	r18, 0x01	; 1
    1386:	fc 01       	movw	r30, r24
    1388:	20 83       	st	Z, r18
          Can_config_rx();       
    138a:	8f ee       	ldi	r24, 0xEF	; 239
    138c:	90 e0       	ldi	r25, 0x00	; 0
    138e:	2f ee       	ldi	r18, 0xEF	; 239
    1390:	30 e0       	ldi	r19, 0x00	; 0
    1392:	f9 01       	movw	r30, r18
    1394:	20 81       	ld	r18, Z
    1396:	2f 73       	andi	r18, 0x3F	; 63
    1398:	fc 01       	movw	r30, r24
    139a:	20 83       	st	Z, r18
    139c:	8f ee       	ldi	r24, 0xEF	; 239
    139e:	90 e0       	ldi	r25, 0x00	; 0
    13a0:	2f ee       	ldi	r18, 0xEF	; 239
    13a2:	30 e0       	ldi	r19, 0x00	; 0
    13a4:	f9 01       	movw	r30, r18
    13a6:	20 81       	ld	r18, Z
    13a8:	20 68       	ori	r18, 0x80	; 128
    13aa:	fc 01       	movw	r30, r24
    13ac:	20 83       	st	Z, r18
          break;
    13ae:	84 c4       	rjmp	.+2312   	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_RX_DATA_MASKED:
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
    13b0:	89 85       	ldd	r24, Y+9	; 0x09
    13b2:	9a 85       	ldd	r25, Y+10	; 0x0a
    13b4:	fc 01       	movw	r30, r24
    13b6:	83 85       	ldd	r24, Z+11	; 0x0b
    13b8:	88 23       	and	r24, r24
    13ba:	09 f4       	brne	.+2      	; 0x13be <__stack+0x2bf>
    13bc:	69 c0       	rjmp	.+210    	; 0x1490 <__stack+0x391>
    13be:	83 ef       	ldi	r24, 0xF3	; 243
    13c0:	90 e0       	ldi	r25, 0x00	; 0
    13c2:	29 85       	ldd	r18, Y+9	; 0x09
    13c4:	3a 85       	ldd	r19, Y+10	; 0x0a
    13c6:	2e 5f       	subi	r18, 0xFE	; 254
    13c8:	3f 4f       	sbci	r19, 0xFF	; 255
    13ca:	2d 5f       	subi	r18, 0xFD	; 253
    13cc:	3f 4f       	sbci	r19, 0xFF	; 255
    13ce:	f9 01       	movw	r30, r18
    13d0:	20 81       	ld	r18, Z
    13d2:	42 2f       	mov	r20, r18
    13d4:	44 0f       	add	r20, r20
    13d6:	44 0f       	add	r20, r20
    13d8:	44 0f       	add	r20, r20
    13da:	29 85       	ldd	r18, Y+9	; 0x09
    13dc:	3a 85       	ldd	r19, Y+10	; 0x0a
    13de:	2e 5f       	subi	r18, 0xFE	; 254
    13e0:	3f 4f       	sbci	r19, 0xFF	; 255
    13e2:	2e 5f       	subi	r18, 0xFE	; 254
    13e4:	3f 4f       	sbci	r19, 0xFF	; 255
    13e6:	f9 01       	movw	r30, r18
    13e8:	20 81       	ld	r18, Z
    13ea:	22 95       	swap	r18
    13ec:	26 95       	lsr	r18
    13ee:	27 70       	andi	r18, 0x07	; 7
    13f0:	24 0f       	add	r18, r20
    13f2:	fc 01       	movw	r30, r24
    13f4:	20 83       	st	Z, r18
    13f6:	82 ef       	ldi	r24, 0xF2	; 242
    13f8:	90 e0       	ldi	r25, 0x00	; 0
    13fa:	29 85       	ldd	r18, Y+9	; 0x09
    13fc:	3a 85       	ldd	r19, Y+10	; 0x0a
    13fe:	2e 5f       	subi	r18, 0xFE	; 254
    1400:	3f 4f       	sbci	r19, 0xFF	; 255
    1402:	2e 5f       	subi	r18, 0xFE	; 254
    1404:	3f 4f       	sbci	r19, 0xFF	; 255
    1406:	f9 01       	movw	r30, r18
    1408:	20 81       	ld	r18, Z
    140a:	42 2f       	mov	r20, r18
    140c:	44 0f       	add	r20, r20
    140e:	44 0f       	add	r20, r20
    1410:	44 0f       	add	r20, r20
    1412:	29 85       	ldd	r18, Y+9	; 0x09
    1414:	3a 85       	ldd	r19, Y+10	; 0x0a
    1416:	2e 5f       	subi	r18, 0xFE	; 254
    1418:	3f 4f       	sbci	r19, 0xFF	; 255
    141a:	2f 5f       	subi	r18, 0xFF	; 255
    141c:	3f 4f       	sbci	r19, 0xFF	; 255
    141e:	f9 01       	movw	r30, r18
    1420:	20 81       	ld	r18, Z
    1422:	22 95       	swap	r18
    1424:	26 95       	lsr	r18
    1426:	27 70       	andi	r18, 0x07	; 7
    1428:	24 0f       	add	r18, r20
    142a:	fc 01       	movw	r30, r24
    142c:	20 83       	st	Z, r18
    142e:	81 ef       	ldi	r24, 0xF1	; 241
    1430:	90 e0       	ldi	r25, 0x00	; 0
    1432:	29 85       	ldd	r18, Y+9	; 0x09
    1434:	3a 85       	ldd	r19, Y+10	; 0x0a
    1436:	2e 5f       	subi	r18, 0xFE	; 254
    1438:	3f 4f       	sbci	r19, 0xFF	; 255
    143a:	2f 5f       	subi	r18, 0xFF	; 255
    143c:	3f 4f       	sbci	r19, 0xFF	; 255
    143e:	f9 01       	movw	r30, r18
    1440:	20 81       	ld	r18, Z
    1442:	42 2f       	mov	r20, r18
    1444:	44 0f       	add	r20, r20
    1446:	44 0f       	add	r20, r20
    1448:	44 0f       	add	r20, r20
    144a:	29 85       	ldd	r18, Y+9	; 0x09
    144c:	3a 85       	ldd	r19, Y+10	; 0x0a
    144e:	2e 5f       	subi	r18, 0xFE	; 254
    1450:	3f 4f       	sbci	r19, 0xFF	; 255
    1452:	f9 01       	movw	r30, r18
    1454:	20 81       	ld	r18, Z
    1456:	22 95       	swap	r18
    1458:	26 95       	lsr	r18
    145a:	27 70       	andi	r18, 0x07	; 7
    145c:	24 0f       	add	r18, r20
    145e:	fc 01       	movw	r30, r24
    1460:	20 83       	st	Z, r18
    1462:	80 ef       	ldi	r24, 0xF0	; 240
    1464:	90 e0       	ldi	r25, 0x00	; 0
    1466:	29 85       	ldd	r18, Y+9	; 0x09
    1468:	3a 85       	ldd	r19, Y+10	; 0x0a
    146a:	2e 5f       	subi	r18, 0xFE	; 254
    146c:	3f 4f       	sbci	r19, 0xFF	; 255
    146e:	f9 01       	movw	r30, r18
    1470:	20 81       	ld	r18, Z
    1472:	22 0f       	add	r18, r18
    1474:	22 0f       	add	r18, r18
    1476:	22 0f       	add	r18, r18
    1478:	fc 01       	movw	r30, r24
    147a:	20 83       	st	Z, r18
    147c:	8f ee       	ldi	r24, 0xEF	; 239
    147e:	90 e0       	ldi	r25, 0x00	; 0
    1480:	2f ee       	ldi	r18, 0xEF	; 239
    1482:	30 e0       	ldi	r19, 0x00	; 0
    1484:	f9 01       	movw	r30, r18
    1486:	20 81       	ld	r18, Z
    1488:	20 61       	ori	r18, 0x10	; 16
    148a:	fc 01       	movw	r30, r24
    148c:	20 83       	st	Z, r18
    148e:	30 c0       	rjmp	.+96     	; 0x14f0 <__stack+0x3f1>
          else              { Can_set_std_id(cmd->id.std);}
    1490:	83 ef       	ldi	r24, 0xF3	; 243
    1492:	90 e0       	ldi	r25, 0x00	; 0
    1494:	29 85       	ldd	r18, Y+9	; 0x09
    1496:	3a 85       	ldd	r19, Y+10	; 0x0a
    1498:	2e 5f       	subi	r18, 0xFE	; 254
    149a:	3f 4f       	sbci	r19, 0xFF	; 255
    149c:	2f 5f       	subi	r18, 0xFF	; 255
    149e:	3f 4f       	sbci	r19, 0xFF	; 255
    14a0:	f9 01       	movw	r30, r18
    14a2:	20 81       	ld	r18, Z
    14a4:	42 2f       	mov	r20, r18
    14a6:	42 95       	swap	r20
    14a8:	44 0f       	add	r20, r20
    14aa:	40 7e       	andi	r20, 0xE0	; 224
    14ac:	29 85       	ldd	r18, Y+9	; 0x09
    14ae:	3a 85       	ldd	r19, Y+10	; 0x0a
    14b0:	2e 5f       	subi	r18, 0xFE	; 254
    14b2:	3f 4f       	sbci	r19, 0xFF	; 255
    14b4:	f9 01       	movw	r30, r18
    14b6:	20 81       	ld	r18, Z
    14b8:	26 95       	lsr	r18
    14ba:	26 95       	lsr	r18
    14bc:	26 95       	lsr	r18
    14be:	24 0f       	add	r18, r20
    14c0:	fc 01       	movw	r30, r24
    14c2:	20 83       	st	Z, r18
    14c4:	82 ef       	ldi	r24, 0xF2	; 242
    14c6:	90 e0       	ldi	r25, 0x00	; 0
    14c8:	29 85       	ldd	r18, Y+9	; 0x09
    14ca:	3a 85       	ldd	r19, Y+10	; 0x0a
    14cc:	2e 5f       	subi	r18, 0xFE	; 254
    14ce:	3f 4f       	sbci	r19, 0xFF	; 255
    14d0:	f9 01       	movw	r30, r18
    14d2:	20 81       	ld	r18, Z
    14d4:	22 95       	swap	r18
    14d6:	22 0f       	add	r18, r18
    14d8:	20 7e       	andi	r18, 0xE0	; 224
    14da:	fc 01       	movw	r30, r24
    14dc:	20 83       	st	Z, r18
    14de:	8f ee       	ldi	r24, 0xEF	; 239
    14e0:	90 e0       	ldi	r25, 0x00	; 0
    14e2:	2f ee       	ldi	r18, 0xEF	; 239
    14e4:	30 e0       	ldi	r19, 0x00	; 0
    14e6:	f9 01       	movw	r30, r18
    14e8:	20 81       	ld	r18, Z
    14ea:	2f 7e       	andi	r18, 0xEF	; 239
    14ec:	fc 01       	movw	r30, r24
    14ee:	20 83       	st	Z, r18
          u32_temp=~0; Can_set_ext_msk(u32_temp);
    14f0:	8f ef       	ldi	r24, 0xFF	; 255
    14f2:	9f ef       	ldi	r25, 0xFF	; 255
    14f4:	dc 01       	movw	r26, r24
    14f6:	8d 83       	std	Y+5, r24	; 0x05
    14f8:	9e 83       	std	Y+6, r25	; 0x06
    14fa:	af 83       	std	Y+7, r26	; 0x07
    14fc:	b8 87       	std	Y+8, r27	; 0x08
    14fe:	27 ef       	ldi	r18, 0xF7	; 247
    1500:	30 e0       	ldi	r19, 0x00	; 0
    1502:	ce 01       	movw	r24, r28
    1504:	05 96       	adiw	r24, 0x05	; 5
    1506:	03 96       	adiw	r24, 0x03	; 3
    1508:	fc 01       	movw	r30, r24
    150a:	80 81       	ld	r24, Z
    150c:	48 2f       	mov	r20, r24
    150e:	44 0f       	add	r20, r20
    1510:	44 0f       	add	r20, r20
    1512:	44 0f       	add	r20, r20
    1514:	ce 01       	movw	r24, r28
    1516:	05 96       	adiw	r24, 0x05	; 5
    1518:	02 96       	adiw	r24, 0x02	; 2
    151a:	fc 01       	movw	r30, r24
    151c:	80 81       	ld	r24, Z
    151e:	82 95       	swap	r24
    1520:	86 95       	lsr	r24
    1522:	87 70       	andi	r24, 0x07	; 7
    1524:	84 0f       	add	r24, r20
    1526:	f9 01       	movw	r30, r18
    1528:	80 83       	st	Z, r24
    152a:	26 ef       	ldi	r18, 0xF6	; 246
    152c:	30 e0       	ldi	r19, 0x00	; 0
    152e:	ce 01       	movw	r24, r28
    1530:	05 96       	adiw	r24, 0x05	; 5
    1532:	02 96       	adiw	r24, 0x02	; 2
    1534:	fc 01       	movw	r30, r24
    1536:	80 81       	ld	r24, Z
    1538:	48 2f       	mov	r20, r24
    153a:	44 0f       	add	r20, r20
    153c:	44 0f       	add	r20, r20
    153e:	44 0f       	add	r20, r20
    1540:	ce 01       	movw	r24, r28
    1542:	05 96       	adiw	r24, 0x05	; 5
    1544:	01 96       	adiw	r24, 0x01	; 1
    1546:	fc 01       	movw	r30, r24
    1548:	80 81       	ld	r24, Z
    154a:	82 95       	swap	r24
    154c:	86 95       	lsr	r24
    154e:	87 70       	andi	r24, 0x07	; 7
    1550:	84 0f       	add	r24, r20
    1552:	f9 01       	movw	r30, r18
    1554:	80 83       	st	Z, r24
    1556:	25 ef       	ldi	r18, 0xF5	; 245
    1558:	30 e0       	ldi	r19, 0x00	; 0
    155a:	ce 01       	movw	r24, r28
    155c:	05 96       	adiw	r24, 0x05	; 5
    155e:	01 96       	adiw	r24, 0x01	; 1
    1560:	fc 01       	movw	r30, r24
    1562:	80 81       	ld	r24, Z
    1564:	48 2f       	mov	r20, r24
    1566:	44 0f       	add	r20, r20
    1568:	44 0f       	add	r20, r20
    156a:	44 0f       	add	r20, r20
    156c:	ce 01       	movw	r24, r28
    156e:	05 96       	adiw	r24, 0x05	; 5
    1570:	fc 01       	movw	r30, r24
    1572:	80 81       	ld	r24, Z
    1574:	82 95       	swap	r24
    1576:	86 95       	lsr	r24
    1578:	87 70       	andi	r24, 0x07	; 7
    157a:	84 0f       	add	r24, r20
    157c:	f9 01       	movw	r30, r18
    157e:	80 83       	st	Z, r24
    1580:	84 ef       	ldi	r24, 0xF4	; 244
    1582:	90 e0       	ldi	r25, 0x00	; 0
    1584:	9e 01       	movw	r18, r28
    1586:	2b 5f       	subi	r18, 0xFB	; 251
    1588:	3f 4f       	sbci	r19, 0xFF	; 255
    158a:	f9 01       	movw	r30, r18
    158c:	20 81       	ld	r18, Z
    158e:	22 0f       	add	r18, r18
    1590:	22 0f       	add	r18, r18
    1592:	22 0f       	add	r18, r18
    1594:	fc 01       	movw	r30, r24
    1596:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    1598:	8f ee       	ldi	r24, 0xEF	; 239
    159a:	90 e0       	ldi	r25, 0x00	; 0
    159c:	2f ee       	ldi	r18, 0xEF	; 239
    159e:	30 e0       	ldi	r19, 0x00	; 0
    15a0:	f9 01       	movw	r30, r18
    15a2:	40 81       	ld	r20, Z
    15a4:	29 85       	ldd	r18, Y+9	; 0x09
    15a6:	3a 85       	ldd	r19, Y+10	; 0x0a
    15a8:	f9 01       	movw	r30, r18
    15aa:	26 81       	ldd	r18, Z+6	; 0x06
    15ac:	24 2b       	or	r18, r20
    15ae:	fc 01       	movw	r30, r24
    15b0:	20 83       	st	Z, r18
          cmd->ctrl.rtr=0; Can_set_rtrmsk(); Can_clear_rtr();
    15b2:	89 85       	ldd	r24, Y+9	; 0x09
    15b4:	9a 85       	ldd	r25, Y+10	; 0x0a
    15b6:	fc 01       	movw	r30, r24
    15b8:	12 86       	std	Z+10, r1	; 0x0a
    15ba:	84 ef       	ldi	r24, 0xF4	; 244
    15bc:	90 e0       	ldi	r25, 0x00	; 0
    15be:	24 ef       	ldi	r18, 0xF4	; 244
    15c0:	30 e0       	ldi	r19, 0x00	; 0
    15c2:	f9 01       	movw	r30, r18
    15c4:	20 81       	ld	r18, Z
    15c6:	24 60       	ori	r18, 0x04	; 4
    15c8:	fc 01       	movw	r30, r24
    15ca:	20 83       	st	Z, r18
    15cc:	80 ef       	ldi	r24, 0xF0	; 240
    15ce:	90 e0       	ldi	r25, 0x00	; 0
    15d0:	20 ef       	ldi	r18, 0xF0	; 240
    15d2:	30 e0       	ldi	r19, 0x00	; 0
    15d4:	f9 01       	movw	r30, r18
    15d6:	20 81       	ld	r18, Z
    15d8:	2b 7f       	andi	r18, 0xFB	; 251
    15da:	fc 01       	movw	r30, r24
    15dc:	20 83       	st	Z, r18
          Can_set_idemsk();
    15de:	84 ef       	ldi	r24, 0xF4	; 244
    15e0:	90 e0       	ldi	r25, 0x00	; 0
    15e2:	24 ef       	ldi	r18, 0xF4	; 244
    15e4:	30 e0       	ldi	r19, 0x00	; 0
    15e6:	f9 01       	movw	r30, r18
    15e8:	20 81       	ld	r18, Z
    15ea:	21 60       	ori	r18, 0x01	; 1
    15ec:	fc 01       	movw	r30, r24
    15ee:	20 83       	st	Z, r18
          Can_config_rx();       
    15f0:	8f ee       	ldi	r24, 0xEF	; 239
    15f2:	90 e0       	ldi	r25, 0x00	; 0
    15f4:	2f ee       	ldi	r18, 0xEF	; 239
    15f6:	30 e0       	ldi	r19, 0x00	; 0
    15f8:	f9 01       	movw	r30, r18
    15fa:	20 81       	ld	r18, Z
    15fc:	2f 73       	andi	r18, 0x3F	; 63
    15fe:	fc 01       	movw	r30, r24
    1600:	20 83       	st	Z, r18
    1602:	8f ee       	ldi	r24, 0xEF	; 239
    1604:	90 e0       	ldi	r25, 0x00	; 0
    1606:	2f ee       	ldi	r18, 0xEF	; 239
    1608:	30 e0       	ldi	r19, 0x00	; 0
    160a:	f9 01       	movw	r30, r18
    160c:	20 81       	ld	r18, Z
    160e:	20 68       	ori	r18, 0x80	; 128
    1610:	fc 01       	movw	r30, r24
    1612:	20 83       	st	Z, r18
          break;
    1614:	51 c3       	rjmp	.+1698   	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_RX_REMOTE_MASKED:
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
    1616:	89 85       	ldd	r24, Y+9	; 0x09
    1618:	9a 85       	ldd	r25, Y+10	; 0x0a
    161a:	fc 01       	movw	r30, r24
    161c:	83 85       	ldd	r24, Z+11	; 0x0b
    161e:	88 23       	and	r24, r24
    1620:	09 f4       	brne	.+2      	; 0x1624 <__stack+0x525>
    1622:	69 c0       	rjmp	.+210    	; 0x16f6 <__stack+0x5f7>
    1624:	83 ef       	ldi	r24, 0xF3	; 243
    1626:	90 e0       	ldi	r25, 0x00	; 0
    1628:	29 85       	ldd	r18, Y+9	; 0x09
    162a:	3a 85       	ldd	r19, Y+10	; 0x0a
    162c:	2e 5f       	subi	r18, 0xFE	; 254
    162e:	3f 4f       	sbci	r19, 0xFF	; 255
    1630:	2d 5f       	subi	r18, 0xFD	; 253
    1632:	3f 4f       	sbci	r19, 0xFF	; 255
    1634:	f9 01       	movw	r30, r18
    1636:	20 81       	ld	r18, Z
    1638:	42 2f       	mov	r20, r18
    163a:	44 0f       	add	r20, r20
    163c:	44 0f       	add	r20, r20
    163e:	44 0f       	add	r20, r20
    1640:	29 85       	ldd	r18, Y+9	; 0x09
    1642:	3a 85       	ldd	r19, Y+10	; 0x0a
    1644:	2e 5f       	subi	r18, 0xFE	; 254
    1646:	3f 4f       	sbci	r19, 0xFF	; 255
    1648:	2e 5f       	subi	r18, 0xFE	; 254
    164a:	3f 4f       	sbci	r19, 0xFF	; 255
    164c:	f9 01       	movw	r30, r18
    164e:	20 81       	ld	r18, Z
    1650:	22 95       	swap	r18
    1652:	26 95       	lsr	r18
    1654:	27 70       	andi	r18, 0x07	; 7
    1656:	24 0f       	add	r18, r20
    1658:	fc 01       	movw	r30, r24
    165a:	20 83       	st	Z, r18
    165c:	82 ef       	ldi	r24, 0xF2	; 242
    165e:	90 e0       	ldi	r25, 0x00	; 0
    1660:	29 85       	ldd	r18, Y+9	; 0x09
    1662:	3a 85       	ldd	r19, Y+10	; 0x0a
    1664:	2e 5f       	subi	r18, 0xFE	; 254
    1666:	3f 4f       	sbci	r19, 0xFF	; 255
    1668:	2e 5f       	subi	r18, 0xFE	; 254
    166a:	3f 4f       	sbci	r19, 0xFF	; 255
    166c:	f9 01       	movw	r30, r18
    166e:	20 81       	ld	r18, Z
    1670:	42 2f       	mov	r20, r18
    1672:	44 0f       	add	r20, r20
    1674:	44 0f       	add	r20, r20
    1676:	44 0f       	add	r20, r20
    1678:	29 85       	ldd	r18, Y+9	; 0x09
    167a:	3a 85       	ldd	r19, Y+10	; 0x0a
    167c:	2e 5f       	subi	r18, 0xFE	; 254
    167e:	3f 4f       	sbci	r19, 0xFF	; 255
    1680:	2f 5f       	subi	r18, 0xFF	; 255
    1682:	3f 4f       	sbci	r19, 0xFF	; 255
    1684:	f9 01       	movw	r30, r18
    1686:	20 81       	ld	r18, Z
    1688:	22 95       	swap	r18
    168a:	26 95       	lsr	r18
    168c:	27 70       	andi	r18, 0x07	; 7
    168e:	24 0f       	add	r18, r20
    1690:	fc 01       	movw	r30, r24
    1692:	20 83       	st	Z, r18
    1694:	81 ef       	ldi	r24, 0xF1	; 241
    1696:	90 e0       	ldi	r25, 0x00	; 0
    1698:	29 85       	ldd	r18, Y+9	; 0x09
    169a:	3a 85       	ldd	r19, Y+10	; 0x0a
    169c:	2e 5f       	subi	r18, 0xFE	; 254
    169e:	3f 4f       	sbci	r19, 0xFF	; 255
    16a0:	2f 5f       	subi	r18, 0xFF	; 255
    16a2:	3f 4f       	sbci	r19, 0xFF	; 255
    16a4:	f9 01       	movw	r30, r18
    16a6:	20 81       	ld	r18, Z
    16a8:	42 2f       	mov	r20, r18
    16aa:	44 0f       	add	r20, r20
    16ac:	44 0f       	add	r20, r20
    16ae:	44 0f       	add	r20, r20
    16b0:	29 85       	ldd	r18, Y+9	; 0x09
    16b2:	3a 85       	ldd	r19, Y+10	; 0x0a
    16b4:	2e 5f       	subi	r18, 0xFE	; 254
    16b6:	3f 4f       	sbci	r19, 0xFF	; 255
    16b8:	f9 01       	movw	r30, r18
    16ba:	20 81       	ld	r18, Z
    16bc:	22 95       	swap	r18
    16be:	26 95       	lsr	r18
    16c0:	27 70       	andi	r18, 0x07	; 7
    16c2:	24 0f       	add	r18, r20
    16c4:	fc 01       	movw	r30, r24
    16c6:	20 83       	st	Z, r18
    16c8:	80 ef       	ldi	r24, 0xF0	; 240
    16ca:	90 e0       	ldi	r25, 0x00	; 0
    16cc:	29 85       	ldd	r18, Y+9	; 0x09
    16ce:	3a 85       	ldd	r19, Y+10	; 0x0a
    16d0:	2e 5f       	subi	r18, 0xFE	; 254
    16d2:	3f 4f       	sbci	r19, 0xFF	; 255
    16d4:	f9 01       	movw	r30, r18
    16d6:	20 81       	ld	r18, Z
    16d8:	22 0f       	add	r18, r18
    16da:	22 0f       	add	r18, r18
    16dc:	22 0f       	add	r18, r18
    16de:	fc 01       	movw	r30, r24
    16e0:	20 83       	st	Z, r18
    16e2:	8f ee       	ldi	r24, 0xEF	; 239
    16e4:	90 e0       	ldi	r25, 0x00	; 0
    16e6:	2f ee       	ldi	r18, 0xEF	; 239
    16e8:	30 e0       	ldi	r19, 0x00	; 0
    16ea:	f9 01       	movw	r30, r18
    16ec:	20 81       	ld	r18, Z
    16ee:	20 61       	ori	r18, 0x10	; 16
    16f0:	fc 01       	movw	r30, r24
    16f2:	20 83       	st	Z, r18
    16f4:	30 c0       	rjmp	.+96     	; 0x1756 <__stack+0x657>
          else              { Can_set_std_id(cmd->id.std);}
    16f6:	83 ef       	ldi	r24, 0xF3	; 243
    16f8:	90 e0       	ldi	r25, 0x00	; 0
    16fa:	29 85       	ldd	r18, Y+9	; 0x09
    16fc:	3a 85       	ldd	r19, Y+10	; 0x0a
    16fe:	2e 5f       	subi	r18, 0xFE	; 254
    1700:	3f 4f       	sbci	r19, 0xFF	; 255
    1702:	2f 5f       	subi	r18, 0xFF	; 255
    1704:	3f 4f       	sbci	r19, 0xFF	; 255
    1706:	f9 01       	movw	r30, r18
    1708:	20 81       	ld	r18, Z
    170a:	42 2f       	mov	r20, r18
    170c:	42 95       	swap	r20
    170e:	44 0f       	add	r20, r20
    1710:	40 7e       	andi	r20, 0xE0	; 224
    1712:	29 85       	ldd	r18, Y+9	; 0x09
    1714:	3a 85       	ldd	r19, Y+10	; 0x0a
    1716:	2e 5f       	subi	r18, 0xFE	; 254
    1718:	3f 4f       	sbci	r19, 0xFF	; 255
    171a:	f9 01       	movw	r30, r18
    171c:	20 81       	ld	r18, Z
    171e:	26 95       	lsr	r18
    1720:	26 95       	lsr	r18
    1722:	26 95       	lsr	r18
    1724:	24 0f       	add	r18, r20
    1726:	fc 01       	movw	r30, r24
    1728:	20 83       	st	Z, r18
    172a:	82 ef       	ldi	r24, 0xF2	; 242
    172c:	90 e0       	ldi	r25, 0x00	; 0
    172e:	29 85       	ldd	r18, Y+9	; 0x09
    1730:	3a 85       	ldd	r19, Y+10	; 0x0a
    1732:	2e 5f       	subi	r18, 0xFE	; 254
    1734:	3f 4f       	sbci	r19, 0xFF	; 255
    1736:	f9 01       	movw	r30, r18
    1738:	20 81       	ld	r18, Z
    173a:	22 95       	swap	r18
    173c:	22 0f       	add	r18, r18
    173e:	20 7e       	andi	r18, 0xE0	; 224
    1740:	fc 01       	movw	r30, r24
    1742:	20 83       	st	Z, r18
    1744:	8f ee       	ldi	r24, 0xEF	; 239
    1746:	90 e0       	ldi	r25, 0x00	; 0
    1748:	2f ee       	ldi	r18, 0xEF	; 239
    174a:	30 e0       	ldi	r19, 0x00	; 0
    174c:	f9 01       	movw	r30, r18
    174e:	20 81       	ld	r18, Z
    1750:	2f 7e       	andi	r18, 0xEF	; 239
    1752:	fc 01       	movw	r30, r24
    1754:	20 83       	st	Z, r18
          u32_temp=~0; Can_set_ext_msk(u32_temp);
    1756:	8f ef       	ldi	r24, 0xFF	; 255
    1758:	9f ef       	ldi	r25, 0xFF	; 255
    175a:	dc 01       	movw	r26, r24
    175c:	8d 83       	std	Y+5, r24	; 0x05
    175e:	9e 83       	std	Y+6, r25	; 0x06
    1760:	af 83       	std	Y+7, r26	; 0x07
    1762:	b8 87       	std	Y+8, r27	; 0x08
    1764:	27 ef       	ldi	r18, 0xF7	; 247
    1766:	30 e0       	ldi	r19, 0x00	; 0
    1768:	ce 01       	movw	r24, r28
    176a:	05 96       	adiw	r24, 0x05	; 5
    176c:	03 96       	adiw	r24, 0x03	; 3
    176e:	fc 01       	movw	r30, r24
    1770:	80 81       	ld	r24, Z
    1772:	48 2f       	mov	r20, r24
    1774:	44 0f       	add	r20, r20
    1776:	44 0f       	add	r20, r20
    1778:	44 0f       	add	r20, r20
    177a:	ce 01       	movw	r24, r28
    177c:	05 96       	adiw	r24, 0x05	; 5
    177e:	02 96       	adiw	r24, 0x02	; 2
    1780:	fc 01       	movw	r30, r24
    1782:	80 81       	ld	r24, Z
    1784:	82 95       	swap	r24
    1786:	86 95       	lsr	r24
    1788:	87 70       	andi	r24, 0x07	; 7
    178a:	84 0f       	add	r24, r20
    178c:	f9 01       	movw	r30, r18
    178e:	80 83       	st	Z, r24
    1790:	26 ef       	ldi	r18, 0xF6	; 246
    1792:	30 e0       	ldi	r19, 0x00	; 0
    1794:	ce 01       	movw	r24, r28
    1796:	05 96       	adiw	r24, 0x05	; 5
    1798:	02 96       	adiw	r24, 0x02	; 2
    179a:	fc 01       	movw	r30, r24
    179c:	80 81       	ld	r24, Z
    179e:	48 2f       	mov	r20, r24
    17a0:	44 0f       	add	r20, r20
    17a2:	44 0f       	add	r20, r20
    17a4:	44 0f       	add	r20, r20
    17a6:	ce 01       	movw	r24, r28
    17a8:	05 96       	adiw	r24, 0x05	; 5
    17aa:	01 96       	adiw	r24, 0x01	; 1
    17ac:	fc 01       	movw	r30, r24
    17ae:	80 81       	ld	r24, Z
    17b0:	82 95       	swap	r24
    17b2:	86 95       	lsr	r24
    17b4:	87 70       	andi	r24, 0x07	; 7
    17b6:	84 0f       	add	r24, r20
    17b8:	f9 01       	movw	r30, r18
    17ba:	80 83       	st	Z, r24
    17bc:	25 ef       	ldi	r18, 0xF5	; 245
    17be:	30 e0       	ldi	r19, 0x00	; 0
    17c0:	ce 01       	movw	r24, r28
    17c2:	05 96       	adiw	r24, 0x05	; 5
    17c4:	01 96       	adiw	r24, 0x01	; 1
    17c6:	fc 01       	movw	r30, r24
    17c8:	80 81       	ld	r24, Z
    17ca:	48 2f       	mov	r20, r24
    17cc:	44 0f       	add	r20, r20
    17ce:	44 0f       	add	r20, r20
    17d0:	44 0f       	add	r20, r20
    17d2:	ce 01       	movw	r24, r28
    17d4:	05 96       	adiw	r24, 0x05	; 5
    17d6:	fc 01       	movw	r30, r24
    17d8:	80 81       	ld	r24, Z
    17da:	82 95       	swap	r24
    17dc:	86 95       	lsr	r24
    17de:	87 70       	andi	r24, 0x07	; 7
    17e0:	84 0f       	add	r24, r20
    17e2:	f9 01       	movw	r30, r18
    17e4:	80 83       	st	Z, r24
    17e6:	84 ef       	ldi	r24, 0xF4	; 244
    17e8:	90 e0       	ldi	r25, 0x00	; 0
    17ea:	9e 01       	movw	r18, r28
    17ec:	2b 5f       	subi	r18, 0xFB	; 251
    17ee:	3f 4f       	sbci	r19, 0xFF	; 255
    17f0:	f9 01       	movw	r30, r18
    17f2:	20 81       	ld	r18, Z
    17f4:	22 0f       	add	r18, r18
    17f6:	22 0f       	add	r18, r18
    17f8:	22 0f       	add	r18, r18
    17fa:	fc 01       	movw	r30, r24
    17fc:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    17fe:	8f ee       	ldi	r24, 0xEF	; 239
    1800:	90 e0       	ldi	r25, 0x00	; 0
    1802:	2f ee       	ldi	r18, 0xEF	; 239
    1804:	30 e0       	ldi	r19, 0x00	; 0
    1806:	f9 01       	movw	r30, r18
    1808:	40 81       	ld	r20, Z
    180a:	29 85       	ldd	r18, Y+9	; 0x09
    180c:	3a 85       	ldd	r19, Y+10	; 0x0a
    180e:	f9 01       	movw	r30, r18
    1810:	26 81       	ldd	r18, Z+6	; 0x06
    1812:	24 2b       	or	r18, r20
    1814:	fc 01       	movw	r30, r24
    1816:	20 83       	st	Z, r18
          cmd->ctrl.rtr=1; Can_set_rtrmsk(); Can_set_rtr();
    1818:	89 85       	ldd	r24, Y+9	; 0x09
    181a:	9a 85       	ldd	r25, Y+10	; 0x0a
    181c:	21 e0       	ldi	r18, 0x01	; 1
    181e:	fc 01       	movw	r30, r24
    1820:	22 87       	std	Z+10, r18	; 0x0a
    1822:	84 ef       	ldi	r24, 0xF4	; 244
    1824:	90 e0       	ldi	r25, 0x00	; 0
    1826:	24 ef       	ldi	r18, 0xF4	; 244
    1828:	30 e0       	ldi	r19, 0x00	; 0
    182a:	f9 01       	movw	r30, r18
    182c:	20 81       	ld	r18, Z
    182e:	24 60       	ori	r18, 0x04	; 4
    1830:	fc 01       	movw	r30, r24
    1832:	20 83       	st	Z, r18
    1834:	80 ef       	ldi	r24, 0xF0	; 240
    1836:	90 e0       	ldi	r25, 0x00	; 0
    1838:	20 ef       	ldi	r18, 0xF0	; 240
    183a:	30 e0       	ldi	r19, 0x00	; 0
    183c:	f9 01       	movw	r30, r18
    183e:	20 81       	ld	r18, Z
    1840:	24 60       	ori	r18, 0x04	; 4
    1842:	fc 01       	movw	r30, r24
    1844:	20 83       	st	Z, r18
          Can_clear_rplv();
    1846:	8f ee       	ldi	r24, 0xEF	; 239
    1848:	90 e0       	ldi	r25, 0x00	; 0
    184a:	2f ee       	ldi	r18, 0xEF	; 239
    184c:	30 e0       	ldi	r19, 0x00	; 0
    184e:	f9 01       	movw	r30, r18
    1850:	20 81       	ld	r18, Z
    1852:	2f 7d       	andi	r18, 0xDF	; 223
    1854:	fc 01       	movw	r30, r24
    1856:	20 83       	st	Z, r18
          Can_set_idemsk();
    1858:	84 ef       	ldi	r24, 0xF4	; 244
    185a:	90 e0       	ldi	r25, 0x00	; 0
    185c:	24 ef       	ldi	r18, 0xF4	; 244
    185e:	30 e0       	ldi	r19, 0x00	; 0
    1860:	f9 01       	movw	r30, r18
    1862:	20 81       	ld	r18, Z
    1864:	21 60       	ori	r18, 0x01	; 1
    1866:	fc 01       	movw	r30, r24
    1868:	20 83       	st	Z, r18
          Can_config_rx();       
    186a:	8f ee       	ldi	r24, 0xEF	; 239
    186c:	90 e0       	ldi	r25, 0x00	; 0
    186e:	2f ee       	ldi	r18, 0xEF	; 239
    1870:	30 e0       	ldi	r19, 0x00	; 0
    1872:	f9 01       	movw	r30, r18
    1874:	20 81       	ld	r18, Z
    1876:	2f 73       	andi	r18, 0x3F	; 63
    1878:	fc 01       	movw	r30, r24
    187a:	20 83       	st	Z, r18
    187c:	8f ee       	ldi	r24, 0xEF	; 239
    187e:	90 e0       	ldi	r25, 0x00	; 0
    1880:	2f ee       	ldi	r18, 0xEF	; 239
    1882:	30 e0       	ldi	r19, 0x00	; 0
    1884:	f9 01       	movw	r30, r18
    1886:	20 81       	ld	r18, Z
    1888:	20 68       	ori	r18, 0x80	; 128
    188a:	fc 01       	movw	r30, r24
    188c:	20 83       	st	Z, r18
          break;
    188e:	14 c2       	rjmp	.+1064   	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_REPLY:
          for (cpt=0;cpt<cmd->dlc;cpt++) CANMSG = *(cmd->pt_data + cpt);
    1890:	19 82       	std	Y+1, r1	; 0x01
    1892:	13 c0       	rjmp	.+38     	; 0x18ba <__stack+0x7bb>
    1894:	8a ef       	ldi	r24, 0xFA	; 250
    1896:	90 e0       	ldi	r25, 0x00	; 0
    1898:	29 85       	ldd	r18, Y+9	; 0x09
    189a:	3a 85       	ldd	r19, Y+10	; 0x0a
    189c:	f9 01       	movw	r30, r18
    189e:	47 81       	ldd	r20, Z+7	; 0x07
    18a0:	50 85       	ldd	r21, Z+8	; 0x08
    18a2:	29 81       	ldd	r18, Y+1	; 0x01
    18a4:	22 2f       	mov	r18, r18
    18a6:	30 e0       	ldi	r19, 0x00	; 0
    18a8:	24 0f       	add	r18, r20
    18aa:	35 1f       	adc	r19, r21
    18ac:	f9 01       	movw	r30, r18
    18ae:	20 81       	ld	r18, Z
    18b0:	fc 01       	movw	r30, r24
    18b2:	20 83       	st	Z, r18
    18b4:	89 81       	ldd	r24, Y+1	; 0x01
    18b6:	8f 5f       	subi	r24, 0xFF	; 255
    18b8:	89 83       	std	Y+1, r24	; 0x01
    18ba:	89 85       	ldd	r24, Y+9	; 0x09
    18bc:	9a 85       	ldd	r25, Y+10	; 0x0a
    18be:	fc 01       	movw	r30, r24
    18c0:	96 81       	ldd	r25, Z+6	; 0x06
    18c2:	89 81       	ldd	r24, Y+1	; 0x01
    18c4:	89 17       	cp	r24, r25
    18c6:	30 f3       	brcs	.-52     	; 0x1894 <__stack+0x795>
          u32_temp=0; Can_set_ext_msk(u32_temp);
    18c8:	1d 82       	std	Y+5, r1	; 0x05
    18ca:	1e 82       	std	Y+6, r1	; 0x06
    18cc:	1f 82       	std	Y+7, r1	; 0x07
    18ce:	18 86       	std	Y+8, r1	; 0x08
    18d0:	27 ef       	ldi	r18, 0xF7	; 247
    18d2:	30 e0       	ldi	r19, 0x00	; 0
    18d4:	ce 01       	movw	r24, r28
    18d6:	05 96       	adiw	r24, 0x05	; 5
    18d8:	03 96       	adiw	r24, 0x03	; 3
    18da:	fc 01       	movw	r30, r24
    18dc:	80 81       	ld	r24, Z
    18de:	48 2f       	mov	r20, r24
    18e0:	44 0f       	add	r20, r20
    18e2:	44 0f       	add	r20, r20
    18e4:	44 0f       	add	r20, r20
    18e6:	ce 01       	movw	r24, r28
    18e8:	05 96       	adiw	r24, 0x05	; 5
    18ea:	02 96       	adiw	r24, 0x02	; 2
    18ec:	fc 01       	movw	r30, r24
    18ee:	80 81       	ld	r24, Z
    18f0:	82 95       	swap	r24
    18f2:	86 95       	lsr	r24
    18f4:	87 70       	andi	r24, 0x07	; 7
    18f6:	84 0f       	add	r24, r20
    18f8:	f9 01       	movw	r30, r18
    18fa:	80 83       	st	Z, r24
    18fc:	26 ef       	ldi	r18, 0xF6	; 246
    18fe:	30 e0       	ldi	r19, 0x00	; 0
    1900:	ce 01       	movw	r24, r28
    1902:	05 96       	adiw	r24, 0x05	; 5
    1904:	02 96       	adiw	r24, 0x02	; 2
    1906:	fc 01       	movw	r30, r24
    1908:	80 81       	ld	r24, Z
    190a:	48 2f       	mov	r20, r24
    190c:	44 0f       	add	r20, r20
    190e:	44 0f       	add	r20, r20
    1910:	44 0f       	add	r20, r20
    1912:	ce 01       	movw	r24, r28
    1914:	05 96       	adiw	r24, 0x05	; 5
    1916:	01 96       	adiw	r24, 0x01	; 1
    1918:	fc 01       	movw	r30, r24
    191a:	80 81       	ld	r24, Z
    191c:	82 95       	swap	r24
    191e:	86 95       	lsr	r24
    1920:	87 70       	andi	r24, 0x07	; 7
    1922:	84 0f       	add	r24, r20
    1924:	f9 01       	movw	r30, r18
    1926:	80 83       	st	Z, r24
    1928:	25 ef       	ldi	r18, 0xF5	; 245
    192a:	30 e0       	ldi	r19, 0x00	; 0
    192c:	ce 01       	movw	r24, r28
    192e:	05 96       	adiw	r24, 0x05	; 5
    1930:	01 96       	adiw	r24, 0x01	; 1
    1932:	fc 01       	movw	r30, r24
    1934:	80 81       	ld	r24, Z
    1936:	48 2f       	mov	r20, r24
    1938:	44 0f       	add	r20, r20
    193a:	44 0f       	add	r20, r20
    193c:	44 0f       	add	r20, r20
    193e:	ce 01       	movw	r24, r28
    1940:	05 96       	adiw	r24, 0x05	; 5
    1942:	fc 01       	movw	r30, r24
    1944:	80 81       	ld	r24, Z
    1946:	82 95       	swap	r24
    1948:	86 95       	lsr	r24
    194a:	87 70       	andi	r24, 0x07	; 7
    194c:	84 0f       	add	r24, r20
    194e:	f9 01       	movw	r30, r18
    1950:	80 83       	st	Z, r24
    1952:	84 ef       	ldi	r24, 0xF4	; 244
    1954:	90 e0       	ldi	r25, 0x00	; 0
    1956:	9e 01       	movw	r18, r28
    1958:	2b 5f       	subi	r18, 0xFB	; 251
    195a:	3f 4f       	sbci	r19, 0xFF	; 255
    195c:	f9 01       	movw	r30, r18
    195e:	20 81       	ld	r18, Z
    1960:	22 0f       	add	r18, r18
    1962:	22 0f       	add	r18, r18
    1964:	22 0f       	add	r18, r18
    1966:	fc 01       	movw	r30, r24
    1968:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    196a:	8f ee       	ldi	r24, 0xEF	; 239
    196c:	90 e0       	ldi	r25, 0x00	; 0
    196e:	2f ee       	ldi	r18, 0xEF	; 239
    1970:	30 e0       	ldi	r19, 0x00	; 0
    1972:	f9 01       	movw	r30, r18
    1974:	40 81       	ld	r20, Z
    1976:	29 85       	ldd	r18, Y+9	; 0x09
    1978:	3a 85       	ldd	r19, Y+10	; 0x0a
    197a:	f9 01       	movw	r30, r18
    197c:	26 81       	ldd	r18, Z+6	; 0x06
    197e:	24 2b       	or	r18, r20
    1980:	fc 01       	movw	r30, r24
    1982:	20 83       	st	Z, r18
          cmd->ctrl.rtr=1; Can_set_rtrmsk(); Can_set_rtr();
    1984:	89 85       	ldd	r24, Y+9	; 0x09
    1986:	9a 85       	ldd	r25, Y+10	; 0x0a
    1988:	21 e0       	ldi	r18, 0x01	; 1
    198a:	fc 01       	movw	r30, r24
    198c:	22 87       	std	Z+10, r18	; 0x0a
    198e:	84 ef       	ldi	r24, 0xF4	; 244
    1990:	90 e0       	ldi	r25, 0x00	; 0
    1992:	24 ef       	ldi	r18, 0xF4	; 244
    1994:	30 e0       	ldi	r19, 0x00	; 0
    1996:	f9 01       	movw	r30, r18
    1998:	20 81       	ld	r18, Z
    199a:	24 60       	ori	r18, 0x04	; 4
    199c:	fc 01       	movw	r30, r24
    199e:	20 83       	st	Z, r18
    19a0:	80 ef       	ldi	r24, 0xF0	; 240
    19a2:	90 e0       	ldi	r25, 0x00	; 0
    19a4:	20 ef       	ldi	r18, 0xF0	; 240
    19a6:	30 e0       	ldi	r19, 0x00	; 0
    19a8:	f9 01       	movw	r30, r18
    19aa:	20 81       	ld	r18, Z
    19ac:	24 60       	ori	r18, 0x04	; 4
    19ae:	fc 01       	movw	r30, r24
    19b0:	20 83       	st	Z, r18
          Can_set_rplv();
    19b2:	8f ee       	ldi	r24, 0xEF	; 239
    19b4:	90 e0       	ldi	r25, 0x00	; 0
    19b6:	2f ee       	ldi	r18, 0xEF	; 239
    19b8:	30 e0       	ldi	r19, 0x00	; 0
    19ba:	f9 01       	movw	r30, r18
    19bc:	20 81       	ld	r18, Z
    19be:	20 62       	ori	r18, 0x20	; 32
    19c0:	fc 01       	movw	r30, r24
    19c2:	20 83       	st	Z, r18
          Can_clear_idemsk();
    19c4:	84 ef       	ldi	r24, 0xF4	; 244
    19c6:	90 e0       	ldi	r25, 0x00	; 0
    19c8:	24 ef       	ldi	r18, 0xF4	; 244
    19ca:	30 e0       	ldi	r19, 0x00	; 0
    19cc:	f9 01       	movw	r30, r18
    19ce:	20 81       	ld	r18, Z
    19d0:	2e 7f       	andi	r18, 0xFE	; 254
    19d2:	fc 01       	movw	r30, r24
    19d4:	20 83       	st	Z, r18
          Can_config_rx();       
    19d6:	8f ee       	ldi	r24, 0xEF	; 239
    19d8:	90 e0       	ldi	r25, 0x00	; 0
    19da:	2f ee       	ldi	r18, 0xEF	; 239
    19dc:	30 e0       	ldi	r19, 0x00	; 0
    19de:	f9 01       	movw	r30, r18
    19e0:	20 81       	ld	r18, Z
    19e2:	2f 73       	andi	r18, 0x3F	; 63
    19e4:	fc 01       	movw	r30, r24
    19e6:	20 83       	st	Z, r18
    19e8:	8f ee       	ldi	r24, 0xEF	; 239
    19ea:	90 e0       	ldi	r25, 0x00	; 0
    19ec:	2f ee       	ldi	r18, 0xEF	; 239
    19ee:	30 e0       	ldi	r19, 0x00	; 0
    19f0:	f9 01       	movw	r30, r18
    19f2:	20 81       	ld	r18, Z
    19f4:	20 68       	ori	r18, 0x80	; 128
    19f6:	fc 01       	movw	r30, r24
    19f8:	20 83       	st	Z, r18
          break;
    19fa:	5e c1       	rjmp	.+700    	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_REPLY_MASKED:
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
    19fc:	89 85       	ldd	r24, Y+9	; 0x09
    19fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a00:	fc 01       	movw	r30, r24
    1a02:	83 85       	ldd	r24, Z+11	; 0x0b
    1a04:	88 23       	and	r24, r24
    1a06:	09 f4       	brne	.+2      	; 0x1a0a <__stack+0x90b>
    1a08:	69 c0       	rjmp	.+210    	; 0x1adc <__stack+0x9dd>
    1a0a:	83 ef       	ldi	r24, 0xF3	; 243
    1a0c:	90 e0       	ldi	r25, 0x00	; 0
    1a0e:	29 85       	ldd	r18, Y+9	; 0x09
    1a10:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a12:	2e 5f       	subi	r18, 0xFE	; 254
    1a14:	3f 4f       	sbci	r19, 0xFF	; 255
    1a16:	2d 5f       	subi	r18, 0xFD	; 253
    1a18:	3f 4f       	sbci	r19, 0xFF	; 255
    1a1a:	f9 01       	movw	r30, r18
    1a1c:	20 81       	ld	r18, Z
    1a1e:	42 2f       	mov	r20, r18
    1a20:	44 0f       	add	r20, r20
    1a22:	44 0f       	add	r20, r20
    1a24:	44 0f       	add	r20, r20
    1a26:	29 85       	ldd	r18, Y+9	; 0x09
    1a28:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a2a:	2e 5f       	subi	r18, 0xFE	; 254
    1a2c:	3f 4f       	sbci	r19, 0xFF	; 255
    1a2e:	2e 5f       	subi	r18, 0xFE	; 254
    1a30:	3f 4f       	sbci	r19, 0xFF	; 255
    1a32:	f9 01       	movw	r30, r18
    1a34:	20 81       	ld	r18, Z
    1a36:	22 95       	swap	r18
    1a38:	26 95       	lsr	r18
    1a3a:	27 70       	andi	r18, 0x07	; 7
    1a3c:	24 0f       	add	r18, r20
    1a3e:	fc 01       	movw	r30, r24
    1a40:	20 83       	st	Z, r18
    1a42:	82 ef       	ldi	r24, 0xF2	; 242
    1a44:	90 e0       	ldi	r25, 0x00	; 0
    1a46:	29 85       	ldd	r18, Y+9	; 0x09
    1a48:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a4a:	2e 5f       	subi	r18, 0xFE	; 254
    1a4c:	3f 4f       	sbci	r19, 0xFF	; 255
    1a4e:	2e 5f       	subi	r18, 0xFE	; 254
    1a50:	3f 4f       	sbci	r19, 0xFF	; 255
    1a52:	f9 01       	movw	r30, r18
    1a54:	20 81       	ld	r18, Z
    1a56:	42 2f       	mov	r20, r18
    1a58:	44 0f       	add	r20, r20
    1a5a:	44 0f       	add	r20, r20
    1a5c:	44 0f       	add	r20, r20
    1a5e:	29 85       	ldd	r18, Y+9	; 0x09
    1a60:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a62:	2e 5f       	subi	r18, 0xFE	; 254
    1a64:	3f 4f       	sbci	r19, 0xFF	; 255
    1a66:	2f 5f       	subi	r18, 0xFF	; 255
    1a68:	3f 4f       	sbci	r19, 0xFF	; 255
    1a6a:	f9 01       	movw	r30, r18
    1a6c:	20 81       	ld	r18, Z
    1a6e:	22 95       	swap	r18
    1a70:	26 95       	lsr	r18
    1a72:	27 70       	andi	r18, 0x07	; 7
    1a74:	24 0f       	add	r18, r20
    1a76:	fc 01       	movw	r30, r24
    1a78:	20 83       	st	Z, r18
    1a7a:	81 ef       	ldi	r24, 0xF1	; 241
    1a7c:	90 e0       	ldi	r25, 0x00	; 0
    1a7e:	29 85       	ldd	r18, Y+9	; 0x09
    1a80:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a82:	2e 5f       	subi	r18, 0xFE	; 254
    1a84:	3f 4f       	sbci	r19, 0xFF	; 255
    1a86:	2f 5f       	subi	r18, 0xFF	; 255
    1a88:	3f 4f       	sbci	r19, 0xFF	; 255
    1a8a:	f9 01       	movw	r30, r18
    1a8c:	20 81       	ld	r18, Z
    1a8e:	42 2f       	mov	r20, r18
    1a90:	44 0f       	add	r20, r20
    1a92:	44 0f       	add	r20, r20
    1a94:	44 0f       	add	r20, r20
    1a96:	29 85       	ldd	r18, Y+9	; 0x09
    1a98:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a9a:	2e 5f       	subi	r18, 0xFE	; 254
    1a9c:	3f 4f       	sbci	r19, 0xFF	; 255
    1a9e:	f9 01       	movw	r30, r18
    1aa0:	20 81       	ld	r18, Z
    1aa2:	22 95       	swap	r18
    1aa4:	26 95       	lsr	r18
    1aa6:	27 70       	andi	r18, 0x07	; 7
    1aa8:	24 0f       	add	r18, r20
    1aaa:	fc 01       	movw	r30, r24
    1aac:	20 83       	st	Z, r18
    1aae:	80 ef       	ldi	r24, 0xF0	; 240
    1ab0:	90 e0       	ldi	r25, 0x00	; 0
    1ab2:	29 85       	ldd	r18, Y+9	; 0x09
    1ab4:	3a 85       	ldd	r19, Y+10	; 0x0a
    1ab6:	2e 5f       	subi	r18, 0xFE	; 254
    1ab8:	3f 4f       	sbci	r19, 0xFF	; 255
    1aba:	f9 01       	movw	r30, r18
    1abc:	20 81       	ld	r18, Z
    1abe:	22 0f       	add	r18, r18
    1ac0:	22 0f       	add	r18, r18
    1ac2:	22 0f       	add	r18, r18
    1ac4:	fc 01       	movw	r30, r24
    1ac6:	20 83       	st	Z, r18
    1ac8:	8f ee       	ldi	r24, 0xEF	; 239
    1aca:	90 e0       	ldi	r25, 0x00	; 0
    1acc:	2f ee       	ldi	r18, 0xEF	; 239
    1ace:	30 e0       	ldi	r19, 0x00	; 0
    1ad0:	f9 01       	movw	r30, r18
    1ad2:	20 81       	ld	r18, Z
    1ad4:	20 61       	ori	r18, 0x10	; 16
    1ad6:	fc 01       	movw	r30, r24
    1ad8:	20 83       	st	Z, r18
    1ada:	30 c0       	rjmp	.+96     	; 0x1b3c <__stack+0xa3d>
          else              { Can_set_std_id(cmd->id.std);}
    1adc:	83 ef       	ldi	r24, 0xF3	; 243
    1ade:	90 e0       	ldi	r25, 0x00	; 0
    1ae0:	29 85       	ldd	r18, Y+9	; 0x09
    1ae2:	3a 85       	ldd	r19, Y+10	; 0x0a
    1ae4:	2e 5f       	subi	r18, 0xFE	; 254
    1ae6:	3f 4f       	sbci	r19, 0xFF	; 255
    1ae8:	2f 5f       	subi	r18, 0xFF	; 255
    1aea:	3f 4f       	sbci	r19, 0xFF	; 255
    1aec:	f9 01       	movw	r30, r18
    1aee:	20 81       	ld	r18, Z
    1af0:	42 2f       	mov	r20, r18
    1af2:	42 95       	swap	r20
    1af4:	44 0f       	add	r20, r20
    1af6:	40 7e       	andi	r20, 0xE0	; 224
    1af8:	29 85       	ldd	r18, Y+9	; 0x09
    1afa:	3a 85       	ldd	r19, Y+10	; 0x0a
    1afc:	2e 5f       	subi	r18, 0xFE	; 254
    1afe:	3f 4f       	sbci	r19, 0xFF	; 255
    1b00:	f9 01       	movw	r30, r18
    1b02:	20 81       	ld	r18, Z
    1b04:	26 95       	lsr	r18
    1b06:	26 95       	lsr	r18
    1b08:	26 95       	lsr	r18
    1b0a:	24 0f       	add	r18, r20
    1b0c:	fc 01       	movw	r30, r24
    1b0e:	20 83       	st	Z, r18
    1b10:	82 ef       	ldi	r24, 0xF2	; 242
    1b12:	90 e0       	ldi	r25, 0x00	; 0
    1b14:	29 85       	ldd	r18, Y+9	; 0x09
    1b16:	3a 85       	ldd	r19, Y+10	; 0x0a
    1b18:	2e 5f       	subi	r18, 0xFE	; 254
    1b1a:	3f 4f       	sbci	r19, 0xFF	; 255
    1b1c:	f9 01       	movw	r30, r18
    1b1e:	20 81       	ld	r18, Z
    1b20:	22 95       	swap	r18
    1b22:	22 0f       	add	r18, r18
    1b24:	20 7e       	andi	r18, 0xE0	; 224
    1b26:	fc 01       	movw	r30, r24
    1b28:	20 83       	st	Z, r18
    1b2a:	8f ee       	ldi	r24, 0xEF	; 239
    1b2c:	90 e0       	ldi	r25, 0x00	; 0
    1b2e:	2f ee       	ldi	r18, 0xEF	; 239
    1b30:	30 e0       	ldi	r19, 0x00	; 0
    1b32:	f9 01       	movw	r30, r18
    1b34:	20 81       	ld	r18, Z
    1b36:	2f 7e       	andi	r18, 0xEF	; 239
    1b38:	fc 01       	movw	r30, r24
    1b3a:	20 83       	st	Z, r18
          for (cpt=0;cpt<cmd->dlc;cpt++) CANMSG = *(cmd->pt_data + cpt);
    1b3c:	19 82       	std	Y+1, r1	; 0x01
    1b3e:	13 c0       	rjmp	.+38     	; 0x1b66 <__stack+0xa67>
    1b40:	8a ef       	ldi	r24, 0xFA	; 250
    1b42:	90 e0       	ldi	r25, 0x00	; 0
    1b44:	29 85       	ldd	r18, Y+9	; 0x09
    1b46:	3a 85       	ldd	r19, Y+10	; 0x0a
    1b48:	f9 01       	movw	r30, r18
    1b4a:	47 81       	ldd	r20, Z+7	; 0x07
    1b4c:	50 85       	ldd	r21, Z+8	; 0x08
    1b4e:	29 81       	ldd	r18, Y+1	; 0x01
    1b50:	22 2f       	mov	r18, r18
    1b52:	30 e0       	ldi	r19, 0x00	; 0
    1b54:	24 0f       	add	r18, r20
    1b56:	35 1f       	adc	r19, r21
    1b58:	f9 01       	movw	r30, r18
    1b5a:	20 81       	ld	r18, Z
    1b5c:	fc 01       	movw	r30, r24
    1b5e:	20 83       	st	Z, r18
    1b60:	89 81       	ldd	r24, Y+1	; 0x01
    1b62:	8f 5f       	subi	r24, 0xFF	; 255
    1b64:	89 83       	std	Y+1, r24	; 0x01
    1b66:	89 85       	ldd	r24, Y+9	; 0x09
    1b68:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b6a:	fc 01       	movw	r30, r24
    1b6c:	96 81       	ldd	r25, Z+6	; 0x06
    1b6e:	89 81       	ldd	r24, Y+1	; 0x01
    1b70:	89 17       	cp	r24, r25
    1b72:	30 f3       	brcs	.-52     	; 0x1b40 <__stack+0xa41>
          u32_temp=~0; Can_set_ext_msk(u32_temp);
    1b74:	8f ef       	ldi	r24, 0xFF	; 255
    1b76:	9f ef       	ldi	r25, 0xFF	; 255
    1b78:	dc 01       	movw	r26, r24
    1b7a:	8d 83       	std	Y+5, r24	; 0x05
    1b7c:	9e 83       	std	Y+6, r25	; 0x06
    1b7e:	af 83       	std	Y+7, r26	; 0x07
    1b80:	b8 87       	std	Y+8, r27	; 0x08
    1b82:	27 ef       	ldi	r18, 0xF7	; 247
    1b84:	30 e0       	ldi	r19, 0x00	; 0
    1b86:	ce 01       	movw	r24, r28
    1b88:	05 96       	adiw	r24, 0x05	; 5
    1b8a:	03 96       	adiw	r24, 0x03	; 3
    1b8c:	fc 01       	movw	r30, r24
    1b8e:	80 81       	ld	r24, Z
    1b90:	48 2f       	mov	r20, r24
    1b92:	44 0f       	add	r20, r20
    1b94:	44 0f       	add	r20, r20
    1b96:	44 0f       	add	r20, r20
    1b98:	ce 01       	movw	r24, r28
    1b9a:	05 96       	adiw	r24, 0x05	; 5
    1b9c:	02 96       	adiw	r24, 0x02	; 2
    1b9e:	fc 01       	movw	r30, r24
    1ba0:	80 81       	ld	r24, Z
    1ba2:	82 95       	swap	r24
    1ba4:	86 95       	lsr	r24
    1ba6:	87 70       	andi	r24, 0x07	; 7
    1ba8:	84 0f       	add	r24, r20
    1baa:	f9 01       	movw	r30, r18
    1bac:	80 83       	st	Z, r24
    1bae:	26 ef       	ldi	r18, 0xF6	; 246
    1bb0:	30 e0       	ldi	r19, 0x00	; 0
    1bb2:	ce 01       	movw	r24, r28
    1bb4:	05 96       	adiw	r24, 0x05	; 5
    1bb6:	02 96       	adiw	r24, 0x02	; 2
    1bb8:	fc 01       	movw	r30, r24
    1bba:	80 81       	ld	r24, Z
    1bbc:	48 2f       	mov	r20, r24
    1bbe:	44 0f       	add	r20, r20
    1bc0:	44 0f       	add	r20, r20
    1bc2:	44 0f       	add	r20, r20
    1bc4:	ce 01       	movw	r24, r28
    1bc6:	05 96       	adiw	r24, 0x05	; 5
    1bc8:	01 96       	adiw	r24, 0x01	; 1
    1bca:	fc 01       	movw	r30, r24
    1bcc:	80 81       	ld	r24, Z
    1bce:	82 95       	swap	r24
    1bd0:	86 95       	lsr	r24
    1bd2:	87 70       	andi	r24, 0x07	; 7
    1bd4:	84 0f       	add	r24, r20
    1bd6:	f9 01       	movw	r30, r18
    1bd8:	80 83       	st	Z, r24
    1bda:	25 ef       	ldi	r18, 0xF5	; 245
    1bdc:	30 e0       	ldi	r19, 0x00	; 0
    1bde:	ce 01       	movw	r24, r28
    1be0:	05 96       	adiw	r24, 0x05	; 5
    1be2:	01 96       	adiw	r24, 0x01	; 1
    1be4:	fc 01       	movw	r30, r24
    1be6:	80 81       	ld	r24, Z
    1be8:	48 2f       	mov	r20, r24
    1bea:	44 0f       	add	r20, r20
    1bec:	44 0f       	add	r20, r20
    1bee:	44 0f       	add	r20, r20
    1bf0:	ce 01       	movw	r24, r28
    1bf2:	05 96       	adiw	r24, 0x05	; 5
    1bf4:	fc 01       	movw	r30, r24
    1bf6:	80 81       	ld	r24, Z
    1bf8:	82 95       	swap	r24
    1bfa:	86 95       	lsr	r24
    1bfc:	87 70       	andi	r24, 0x07	; 7
    1bfe:	84 0f       	add	r24, r20
    1c00:	f9 01       	movw	r30, r18
    1c02:	80 83       	st	Z, r24
    1c04:	84 ef       	ldi	r24, 0xF4	; 244
    1c06:	90 e0       	ldi	r25, 0x00	; 0
    1c08:	9e 01       	movw	r18, r28
    1c0a:	2b 5f       	subi	r18, 0xFB	; 251
    1c0c:	3f 4f       	sbci	r19, 0xFF	; 255
    1c0e:	f9 01       	movw	r30, r18
    1c10:	20 81       	ld	r18, Z
    1c12:	22 0f       	add	r18, r18
    1c14:	22 0f       	add	r18, r18
    1c16:	22 0f       	add	r18, r18
    1c18:	fc 01       	movw	r30, r24
    1c1a:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    1c1c:	8f ee       	ldi	r24, 0xEF	; 239
    1c1e:	90 e0       	ldi	r25, 0x00	; 0
    1c20:	2f ee       	ldi	r18, 0xEF	; 239
    1c22:	30 e0       	ldi	r19, 0x00	; 0
    1c24:	f9 01       	movw	r30, r18
    1c26:	40 81       	ld	r20, Z
    1c28:	29 85       	ldd	r18, Y+9	; 0x09
    1c2a:	3a 85       	ldd	r19, Y+10	; 0x0a
    1c2c:	f9 01       	movw	r30, r18
    1c2e:	26 81       	ldd	r18, Z+6	; 0x06
    1c30:	24 2b       	or	r18, r20
    1c32:	fc 01       	movw	r30, r24
    1c34:	20 83       	st	Z, r18
          cmd->ctrl.rtr=1; Can_set_rtrmsk(); Can_set_rtr();
    1c36:	89 85       	ldd	r24, Y+9	; 0x09
    1c38:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c3a:	21 e0       	ldi	r18, 0x01	; 1
    1c3c:	fc 01       	movw	r30, r24
    1c3e:	22 87       	std	Z+10, r18	; 0x0a
    1c40:	84 ef       	ldi	r24, 0xF4	; 244
    1c42:	90 e0       	ldi	r25, 0x00	; 0
    1c44:	24 ef       	ldi	r18, 0xF4	; 244
    1c46:	30 e0       	ldi	r19, 0x00	; 0
    1c48:	f9 01       	movw	r30, r18
    1c4a:	20 81       	ld	r18, Z
    1c4c:	24 60       	ori	r18, 0x04	; 4
    1c4e:	fc 01       	movw	r30, r24
    1c50:	20 83       	st	Z, r18
    1c52:	80 ef       	ldi	r24, 0xF0	; 240
    1c54:	90 e0       	ldi	r25, 0x00	; 0
    1c56:	20 ef       	ldi	r18, 0xF0	; 240
    1c58:	30 e0       	ldi	r19, 0x00	; 0
    1c5a:	f9 01       	movw	r30, r18
    1c5c:	20 81       	ld	r18, Z
    1c5e:	24 60       	ori	r18, 0x04	; 4
    1c60:	fc 01       	movw	r30, r24
    1c62:	20 83       	st	Z, r18
          Can_set_rplv();
    1c64:	8f ee       	ldi	r24, 0xEF	; 239
    1c66:	90 e0       	ldi	r25, 0x00	; 0
    1c68:	2f ee       	ldi	r18, 0xEF	; 239
    1c6a:	30 e0       	ldi	r19, 0x00	; 0
    1c6c:	f9 01       	movw	r30, r18
    1c6e:	20 81       	ld	r18, Z
    1c70:	20 62       	ori	r18, 0x20	; 32
    1c72:	fc 01       	movw	r30, r24
    1c74:	20 83       	st	Z, r18
          Can_set_idemsk();
    1c76:	84 ef       	ldi	r24, 0xF4	; 244
    1c78:	90 e0       	ldi	r25, 0x00	; 0
    1c7a:	24 ef       	ldi	r18, 0xF4	; 244
    1c7c:	30 e0       	ldi	r19, 0x00	; 0
    1c7e:	f9 01       	movw	r30, r18
    1c80:	20 81       	ld	r18, Z
    1c82:	21 60       	ori	r18, 0x01	; 1
    1c84:	fc 01       	movw	r30, r24
    1c86:	20 83       	st	Z, r18
          Can_config_rx();       
    1c88:	8f ee       	ldi	r24, 0xEF	; 239
    1c8a:	90 e0       	ldi	r25, 0x00	; 0
    1c8c:	2f ee       	ldi	r18, 0xEF	; 239
    1c8e:	30 e0       	ldi	r19, 0x00	; 0
    1c90:	f9 01       	movw	r30, r18
    1c92:	20 81       	ld	r18, Z
    1c94:	2f 73       	andi	r18, 0x3F	; 63
    1c96:	fc 01       	movw	r30, r24
    1c98:	20 83       	st	Z, r18
    1c9a:	8f ee       	ldi	r24, 0xEF	; 239
    1c9c:	90 e0       	ldi	r25, 0x00	; 0
    1c9e:	2f ee       	ldi	r18, 0xEF	; 239
    1ca0:	30 e0       	ldi	r19, 0x00	; 0
    1ca2:	f9 01       	movw	r30, r18
    1ca4:	20 81       	ld	r18, Z
    1ca6:	20 68       	ori	r18, 0x80	; 128
    1ca8:	fc 01       	movw	r30, r24
    1caa:	20 83       	st	Z, r18
          break;
    1cac:	05 c0       	rjmp	.+10     	; 0x1cb8 <__stack+0xbb9>
        //------------      
        default:
          // case CMD_NONE or not implemented command
          cmd->status = STATUS_CLEARED; 
    1cae:	89 85       	ldd	r24, Y+9	; 0x09
    1cb0:	9a 85       	ldd	r25, Y+10	; 0x0a
    1cb2:	fc 01       	movw	r30, r24
    1cb4:	11 86       	std	Z+9, r1	; 0x09
          break;
    1cb6:	00 00       	nop
    1cb8:	07 c0       	rjmp	.+14     	; 0x1cc8 <__stack+0xbc9>
        //------------      
      } // switch (cmd ...
    } // if (mob_handle ...
    else
    {
      cmd->status = MOB_NOT_REACHED;
    1cba:	89 85       	ldd	r24, Y+9	; 0x09
    1cbc:	9a 85       	ldd	r25, Y+10	; 0x0a
    1cbe:	2f e1       	ldi	r18, 0x1F	; 31
    1cc0:	fc 01       	movw	r30, r24
    1cc2:	21 87       	std	Z+9, r18	; 0x09
      return CAN_CMD_REFUSED;
    1cc4:	8f ef       	ldi	r24, 0xFF	; 255
    1cc6:	01 c0       	rjmp	.+2      	; 0x1cca <__stack+0xbcb>
    }
  } // else of no CMD_ABORT
  return CAN_CMD_ACCEPTED;
    1cc8:	80 e0       	ldi	r24, 0x00	; 0
}
    1cca:	2a 96       	adiw	r28, 0x0a	; 10
    1ccc:	0f b6       	in	r0, 0x3f	; 63
    1cce:	f8 94       	cli
    1cd0:	de bf       	out	0x3e, r29	; 62
    1cd2:	0f be       	out	0x3f, r0	; 63
    1cd4:	cd bf       	out	0x3d, r28	; 61
    1cd6:	df 91       	pop	r29
    1cd8:	cf 91       	pop	r28
    1cda:	08 95       	ret

00001cdc <can_get_status>:
//!         CAN_STATUS_ERROR         - Error in configuration or in the
//!                                    CAN communication
//!
//------------------------------------------------------------------------------
uint8_t can_get_status (st_cmd_t* cmd)
{
    1cdc:	cf 93       	push	r28
    1cde:	df 93       	push	r29
    1ce0:	00 d0       	rcall	.+0      	; 0x1ce2 <can_get_status+0x6>
    1ce2:	00 d0       	rcall	.+0      	; 0x1ce4 <can_get_status+0x8>
    1ce4:	cd b7       	in	r28, 0x3d	; 61
    1ce6:	de b7       	in	r29, 0x3e	; 62
    1ce8:	9c 83       	std	Y+4, r25	; 0x04
    1cea:	8b 83       	std	Y+3, r24	; 0x03
    uint8_t a_status, rtn_val;
     
    a_status = cmd->status;
    1cec:	8b 81       	ldd	r24, Y+3	; 0x03
    1cee:	9c 81       	ldd	r25, Y+4	; 0x04
    1cf0:	fc 01       	movw	r30, r24
    1cf2:	81 85       	ldd	r24, Z+9	; 0x09
    1cf4:	8a 83       	std	Y+2, r24	; 0x02
    if ((a_status==STATUS_CLEARED)||(a_status==MOB_NOT_REACHED)||(a_status==MOB_DISABLE))
    1cf6:	8a 81       	ldd	r24, Y+2	; 0x02
    1cf8:	88 23       	and	r24, r24
    1cfa:	31 f0       	breq	.+12     	; 0x1d08 <can_get_status+0x2c>
    1cfc:	8a 81       	ldd	r24, Y+2	; 0x02
    1cfe:	8f 31       	cpi	r24, 0x1F	; 31
    1d00:	19 f0       	breq	.+6      	; 0x1d08 <can_get_status+0x2c>
    1d02:	8a 81       	ldd	r24, Y+2	; 0x02
    1d04:	8f 3f       	cpi	r24, 0xFF	; 255
    1d06:	11 f4       	brne	.+4      	; 0x1d0c <can_get_status+0x30>
    {
        return CAN_STATUS_ERROR;
    1d08:	82 e0       	ldi	r24, 0x02	; 2
    1d0a:	11 c1       	rjmp	.+546    	; 0x1f2e <can_get_status+0x252>
    }

    Can_set_mob(cmd->handle);
    1d0c:	8d ee       	ldi	r24, 0xED	; 237
    1d0e:	90 e0       	ldi	r25, 0x00	; 0
    1d10:	2b 81       	ldd	r18, Y+3	; 0x03
    1d12:	3c 81       	ldd	r19, Y+4	; 0x04
    1d14:	f9 01       	movw	r30, r18
    1d16:	20 81       	ld	r18, Z
    1d18:	22 95       	swap	r18
    1d1a:	20 7f       	andi	r18, 0xF0	; 240
    1d1c:	fc 01       	movw	r30, r24
    1d1e:	20 83       	st	Z, r18
    a_status = can_get_mob_status();
    1d20:	0e 94 cb 00 	call	0x196	; 0x196 <can_get_mob_status>
    1d24:	8a 83       	std	Y+2, r24	; 0x02
    
    switch (a_status)
    1d26:	8a 81       	ldd	r24, Y+2	; 0x02
    1d28:	88 2f       	mov	r24, r24
    1d2a:	90 e0       	ldi	r25, 0x00	; 0
    1d2c:	80 32       	cpi	r24, 0x20	; 32
    1d2e:	91 05       	cpc	r25, r1
    1d30:	89 f0       	breq	.+34     	; 0x1d54 <can_get_status+0x78>
    1d32:	81 32       	cpi	r24, 0x21	; 33
    1d34:	91 05       	cpc	r25, r1
    1d36:	1c f4       	brge	.+6      	; 0x1d3e <can_get_status+0x62>
    1d38:	89 2b       	or	r24, r25
    1d3a:	49 f0       	breq	.+18     	; 0x1d4e <can_get_status+0x72>
    1d3c:	e2 c0       	rjmp	.+452    	; 0x1f02 <can_get_status+0x226>
    1d3e:	80 34       	cpi	r24, 0x40	; 64
    1d40:	91 05       	cpc	r25, r1
    1d42:	09 f4       	brne	.+2      	; 0x1d46 <can_get_status+0x6a>
    1d44:	ca c0       	rjmp	.+404    	; 0x1eda <can_get_status+0x1fe>
    1d46:	80 3a       	cpi	r24, 0xA0	; 160
    1d48:	91 05       	cpc	r25, r1
    1d4a:	21 f0       	breq	.+8      	; 0x1d54 <can_get_status+0x78>
    1d4c:	da c0       	rjmp	.+436    	; 0x1f02 <can_get_status+0x226>
    {
        case MOB_NOT_COMPLETED:
            // cmd->status not updated
            rtn_val = CAN_STATUS_NOT_COMPLETED;
    1d4e:	81 e0       	ldi	r24, 0x01	; 1
    1d50:	89 83       	std	Y+1, r24	; 0x01
            break;
    1d52:	ec c0       	rjmp	.+472    	; 0x1f2c <can_get_status+0x250>
        //---------------      
        case MOB_RX_COMPLETED:     
        case MOB_RX_COMPLETED_DLCW:
            cmd->dlc = Can_get_dlc();
    1d54:	8f ee       	ldi	r24, 0xEF	; 239
    1d56:	90 e0       	ldi	r25, 0x00	; 0
    1d58:	fc 01       	movw	r30, r24
    1d5a:	80 81       	ld	r24, Z
    1d5c:	28 2f       	mov	r18, r24
    1d5e:	2f 70       	andi	r18, 0x0F	; 15
    1d60:	8b 81       	ldd	r24, Y+3	; 0x03
    1d62:	9c 81       	ldd	r25, Y+4	; 0x04
    1d64:	fc 01       	movw	r30, r24
    1d66:	26 83       	std	Z+6, r18	; 0x06
            can_get_data(cmd->pt_data);
    1d68:	8b 81       	ldd	r24, Y+3	; 0x03
    1d6a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d6c:	fc 01       	movw	r30, r24
    1d6e:	87 81       	ldd	r24, Z+7	; 0x07
    1d70:	90 85       	ldd	r25, Z+8	; 0x08
    1d72:	0e 94 fd 00 	call	0x1fa	; 0x1fa <can_get_data>
            cmd->ctrl.rtr = Can_get_rtr();
    1d76:	80 ef       	ldi	r24, 0xF0	; 240
    1d78:	90 e0       	ldi	r25, 0x00	; 0
    1d7a:	fc 01       	movw	r30, r24
    1d7c:	80 81       	ld	r24, Z
    1d7e:	88 2f       	mov	r24, r24
    1d80:	90 e0       	ldi	r25, 0x00	; 0
    1d82:	84 70       	andi	r24, 0x04	; 4
    1d84:	99 27       	eor	r25, r25
    1d86:	95 95       	asr	r25
    1d88:	87 95       	ror	r24
    1d8a:	95 95       	asr	r25
    1d8c:	87 95       	ror	r24
    1d8e:	28 2f       	mov	r18, r24
    1d90:	8b 81       	ldd	r24, Y+3	; 0x03
    1d92:	9c 81       	ldd	r25, Y+4	; 0x04
    1d94:	fc 01       	movw	r30, r24
    1d96:	22 87       	std	Z+10, r18	; 0x0a
            if (Can_get_ide()) // if extended frame
    1d98:	8f ee       	ldi	r24, 0xEF	; 239
    1d9a:	90 e0       	ldi	r25, 0x00	; 0
    1d9c:	fc 01       	movw	r30, r24
    1d9e:	80 81       	ld	r24, Z
    1da0:	88 2f       	mov	r24, r24
    1da2:	90 e0       	ldi	r25, 0x00	; 0
    1da4:	80 71       	andi	r24, 0x10	; 16
    1da6:	99 27       	eor	r25, r25
    1da8:	95 95       	asr	r25
    1daa:	87 95       	ror	r24
    1dac:	95 95       	asr	r25
    1dae:	87 95       	ror	r24
    1db0:	95 95       	asr	r25
    1db2:	87 95       	ror	r24
    1db4:	95 95       	asr	r25
    1db6:	87 95       	ror	r24
    1db8:	89 2b       	or	r24, r25
    1dba:	09 f4       	brne	.+2      	; 0x1dbe <can_get_status+0xe2>
    1dbc:	54 c0       	rjmp	.+168    	; 0x1e66 <can_get_status+0x18a>
            {
                cmd->ctrl.ide = 1; // extended frame
    1dbe:	8b 81       	ldd	r24, Y+3	; 0x03
    1dc0:	9c 81       	ldd	r25, Y+4	; 0x04
    1dc2:	21 e0       	ldi	r18, 0x01	; 1
    1dc4:	fc 01       	movw	r30, r24
    1dc6:	23 87       	std	Z+11, r18	; 0x0b
                Can_get_ext_id(cmd->id.ext);
    1dc8:	8b 81       	ldd	r24, Y+3	; 0x03
    1dca:	9c 81       	ldd	r25, Y+4	; 0x04
    1dcc:	02 96       	adiw	r24, 0x02	; 2
    1dce:	03 96       	adiw	r24, 0x03	; 3
    1dd0:	23 ef       	ldi	r18, 0xF3	; 243
    1dd2:	30 e0       	ldi	r19, 0x00	; 0
    1dd4:	f9 01       	movw	r30, r18
    1dd6:	20 81       	ld	r18, Z
    1dd8:	26 95       	lsr	r18
    1dda:	26 95       	lsr	r18
    1ddc:	26 95       	lsr	r18
    1dde:	fc 01       	movw	r30, r24
    1de0:	20 83       	st	Z, r18
    1de2:	8b 81       	ldd	r24, Y+3	; 0x03
    1de4:	9c 81       	ldd	r25, Y+4	; 0x04
    1de6:	02 96       	adiw	r24, 0x02	; 2
    1de8:	02 96       	adiw	r24, 0x02	; 2
    1dea:	22 ef       	ldi	r18, 0xF2	; 242
    1dec:	30 e0       	ldi	r19, 0x00	; 0
    1dee:	f9 01       	movw	r30, r18
    1df0:	20 81       	ld	r18, Z
    1df2:	42 2f       	mov	r20, r18
    1df4:	46 95       	lsr	r20
    1df6:	46 95       	lsr	r20
    1df8:	46 95       	lsr	r20
    1dfa:	23 ef       	ldi	r18, 0xF3	; 243
    1dfc:	30 e0       	ldi	r19, 0x00	; 0
    1dfe:	f9 01       	movw	r30, r18
    1e00:	20 81       	ld	r18, Z
    1e02:	22 95       	swap	r18
    1e04:	22 0f       	add	r18, r18
    1e06:	20 7e       	andi	r18, 0xE0	; 224
    1e08:	24 0f       	add	r18, r20
    1e0a:	fc 01       	movw	r30, r24
    1e0c:	20 83       	st	Z, r18
    1e0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e10:	9c 81       	ldd	r25, Y+4	; 0x04
    1e12:	02 96       	adiw	r24, 0x02	; 2
    1e14:	01 96       	adiw	r24, 0x01	; 1
    1e16:	21 ef       	ldi	r18, 0xF1	; 241
    1e18:	30 e0       	ldi	r19, 0x00	; 0
    1e1a:	f9 01       	movw	r30, r18
    1e1c:	20 81       	ld	r18, Z
    1e1e:	42 2f       	mov	r20, r18
    1e20:	46 95       	lsr	r20
    1e22:	46 95       	lsr	r20
    1e24:	46 95       	lsr	r20
    1e26:	22 ef       	ldi	r18, 0xF2	; 242
    1e28:	30 e0       	ldi	r19, 0x00	; 0
    1e2a:	f9 01       	movw	r30, r18
    1e2c:	20 81       	ld	r18, Z
    1e2e:	22 95       	swap	r18
    1e30:	22 0f       	add	r18, r18
    1e32:	20 7e       	andi	r18, 0xE0	; 224
    1e34:	24 0f       	add	r18, r20
    1e36:	fc 01       	movw	r30, r24
    1e38:	20 83       	st	Z, r18
    1e3a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e3c:	9c 81       	ldd	r25, Y+4	; 0x04
    1e3e:	02 96       	adiw	r24, 0x02	; 2
    1e40:	20 ef       	ldi	r18, 0xF0	; 240
    1e42:	30 e0       	ldi	r19, 0x00	; 0
    1e44:	f9 01       	movw	r30, r18
    1e46:	20 81       	ld	r18, Z
    1e48:	42 2f       	mov	r20, r18
    1e4a:	46 95       	lsr	r20
    1e4c:	46 95       	lsr	r20
    1e4e:	46 95       	lsr	r20
    1e50:	21 ef       	ldi	r18, 0xF1	; 241
    1e52:	30 e0       	ldi	r19, 0x00	; 0
    1e54:	f9 01       	movw	r30, r18
    1e56:	20 81       	ld	r18, Z
    1e58:	22 95       	swap	r18
    1e5a:	22 0f       	add	r18, r18
    1e5c:	20 7e       	andi	r18, 0xE0	; 224
    1e5e:	24 0f       	add	r18, r20
    1e60:	fc 01       	movw	r30, r24
    1e62:	20 83       	st	Z, r18
    1e64:	26 c0       	rjmp	.+76     	; 0x1eb2 <can_get_status+0x1d6>
            }
            else // else standard frame
                {
                    cmd->ctrl.ide = 0;
    1e66:	8b 81       	ldd	r24, Y+3	; 0x03
    1e68:	9c 81       	ldd	r25, Y+4	; 0x04
    1e6a:	fc 01       	movw	r30, r24
    1e6c:	13 86       	std	Z+11, r1	; 0x0b
                    Can_get_std_id(cmd->id.std);
    1e6e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e70:	9c 81       	ldd	r25, Y+4	; 0x04
    1e72:	02 96       	adiw	r24, 0x02	; 2
    1e74:	01 96       	adiw	r24, 0x01	; 1
    1e76:	23 ef       	ldi	r18, 0xF3	; 243
    1e78:	30 e0       	ldi	r19, 0x00	; 0
    1e7a:	f9 01       	movw	r30, r18
    1e7c:	20 81       	ld	r18, Z
    1e7e:	22 95       	swap	r18
    1e80:	26 95       	lsr	r18
    1e82:	27 70       	andi	r18, 0x07	; 7
    1e84:	fc 01       	movw	r30, r24
    1e86:	20 83       	st	Z, r18
    1e88:	8b 81       	ldd	r24, Y+3	; 0x03
    1e8a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e8c:	02 96       	adiw	r24, 0x02	; 2
    1e8e:	22 ef       	ldi	r18, 0xF2	; 242
    1e90:	30 e0       	ldi	r19, 0x00	; 0
    1e92:	f9 01       	movw	r30, r18
    1e94:	20 81       	ld	r18, Z
    1e96:	42 2f       	mov	r20, r18
    1e98:	42 95       	swap	r20
    1e9a:	46 95       	lsr	r20
    1e9c:	47 70       	andi	r20, 0x07	; 7
    1e9e:	23 ef       	ldi	r18, 0xF3	; 243
    1ea0:	30 e0       	ldi	r19, 0x00	; 0
    1ea2:	f9 01       	movw	r30, r18
    1ea4:	20 81       	ld	r18, Z
    1ea6:	22 0f       	add	r18, r18
    1ea8:	22 0f       	add	r18, r18
    1eaa:	22 0f       	add	r18, r18
    1eac:	24 0f       	add	r18, r20
    1eae:	fc 01       	movw	r30, r24
    1eb0:	20 83       	st	Z, r18
                }
            // Status field of descriptor: 0x20 if Rx completed
            // Status field of descriptor: 0xA0 if Rx completed with DLCWarning    
            cmd->status = a_status;
    1eb2:	8b 81       	ldd	r24, Y+3	; 0x03
    1eb4:	9c 81       	ldd	r25, Y+4	; 0x04
    1eb6:	2a 81       	ldd	r18, Y+2	; 0x02
    1eb8:	fc 01       	movw	r30, r24
    1eba:	21 87       	std	Z+9, r18	; 0x09
            Can_mob_abort();        // Freed the MOB
    1ebc:	8f ee       	ldi	r24, 0xEF	; 239
    1ebe:	90 e0       	ldi	r25, 0x00	; 0
    1ec0:	2f ee       	ldi	r18, 0xEF	; 239
    1ec2:	30 e0       	ldi	r19, 0x00	; 0
    1ec4:	f9 01       	movw	r30, r18
    1ec6:	20 81       	ld	r18, Z
    1ec8:	2f 73       	andi	r18, 0x3F	; 63
    1eca:	fc 01       	movw	r30, r24
    1ecc:	20 83       	st	Z, r18
            Can_clear_status_mob(); //   and reset MOb status
    1ece:	8e ee       	ldi	r24, 0xEE	; 238
    1ed0:	90 e0       	ldi	r25, 0x00	; 0
    1ed2:	fc 01       	movw	r30, r24
    1ed4:	10 82       	st	Z, r1
            rtn_val = CAN_STATUS_COMPLETED;
    1ed6:	19 82       	std	Y+1, r1	; 0x01
            break;
    1ed8:	29 c0       	rjmp	.+82     	; 0x1f2c <can_get_status+0x250>
        //---------------      
        case MOB_TX_COMPLETED:     
            // Status field of descriptor: 0x40 if Tx completed
            cmd->status = a_status;
    1eda:	8b 81       	ldd	r24, Y+3	; 0x03
    1edc:	9c 81       	ldd	r25, Y+4	; 0x04
    1ede:	2a 81       	ldd	r18, Y+2	; 0x02
    1ee0:	fc 01       	movw	r30, r24
    1ee2:	21 87       	std	Z+9, r18	; 0x09
            Can_mob_abort();        // Freed the MOB
    1ee4:	8f ee       	ldi	r24, 0xEF	; 239
    1ee6:	90 e0       	ldi	r25, 0x00	; 0
    1ee8:	2f ee       	ldi	r18, 0xEF	; 239
    1eea:	30 e0       	ldi	r19, 0x00	; 0
    1eec:	f9 01       	movw	r30, r18
    1eee:	20 81       	ld	r18, Z
    1ef0:	2f 73       	andi	r18, 0x3F	; 63
    1ef2:	fc 01       	movw	r30, r24
    1ef4:	20 83       	st	Z, r18
            Can_clear_status_mob(); //   and reset MOb status
    1ef6:	8e ee       	ldi	r24, 0xEE	; 238
    1ef8:	90 e0       	ldi	r25, 0x00	; 0
    1efa:	fc 01       	movw	r30, r24
    1efc:	10 82       	st	Z, r1
            rtn_val = CAN_STATUS_COMPLETED;
    1efe:	19 82       	std	Y+1, r1	; 0x01
            break;
    1f00:	15 c0       	rjmp	.+42     	; 0x1f2c <can_get_status+0x250>
        //---------------      
        default:
            // Status field of descriptor: (bin)000b.scfa if MOb error
            cmd->status = a_status;
    1f02:	8b 81       	ldd	r24, Y+3	; 0x03
    1f04:	9c 81       	ldd	r25, Y+4	; 0x04
    1f06:	2a 81       	ldd	r18, Y+2	; 0x02
    1f08:	fc 01       	movw	r30, r24
    1f0a:	21 87       	std	Z+9, r18	; 0x09
            Can_mob_abort();        // Freed the MOB
    1f0c:	8f ee       	ldi	r24, 0xEF	; 239
    1f0e:	90 e0       	ldi	r25, 0x00	; 0
    1f10:	2f ee       	ldi	r18, 0xEF	; 239
    1f12:	30 e0       	ldi	r19, 0x00	; 0
    1f14:	f9 01       	movw	r30, r18
    1f16:	20 81       	ld	r18, Z
    1f18:	2f 73       	andi	r18, 0x3F	; 63
    1f1a:	fc 01       	movw	r30, r24
    1f1c:	20 83       	st	Z, r18
            Can_clear_status_mob(); //   and reset MOb status
    1f1e:	8e ee       	ldi	r24, 0xEE	; 238
    1f20:	90 e0       	ldi	r25, 0x00	; 0
    1f22:	fc 01       	movw	r30, r24
    1f24:	10 82       	st	Z, r1
            rtn_val = CAN_STATUS_ERROR;
    1f26:	82 e0       	ldi	r24, 0x02	; 2
    1f28:	89 83       	std	Y+1, r24	; 0x01
            break;
    1f2a:	00 00       	nop
             
    } // switch (a_status...
 
    return (rtn_val);
    1f2c:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f2e:	0f 90       	pop	r0
    1f30:	0f 90       	pop	r0
    1f32:	0f 90       	pop	r0
    1f34:	0f 90       	pop	r0
    1f36:	df 91       	pop	r29
    1f38:	cf 91       	pop	r28
    1f3a:	08 95       	ret

00001f3c <main>:

#define mainLED_TASK_PRIORITY           1
#define mainHEARTBEAT_TASK_PRIORITY		2

int main(void)
{	
    1f3c:	af 92       	push	r10
    1f3e:	bf 92       	push	r11
    1f40:	cf 92       	push	r12
    1f42:	df 92       	push	r13
    1f44:	ef 92       	push	r14
    1f46:	ff 92       	push	r15
    1f48:	0f 93       	push	r16
    1f4a:	cf 93       	push	r28
    1f4c:	df 93       	push	r29
    1f4e:	cd b7       	in	r28, 0x3d	; 61
    1f50:	de b7       	in	r29, 0x3e	; 62
	can_init(1);	// Fixed baud rate
    1f52:	81 e0       	ldi	r24, 0x01	; 1
    1f54:	0e 94 bb 03 	call	0x776	; 0x776 <can_init>
	
	config_io_pin(IO_PORT_C, 0, IO_DIR_OUTPUT);
    1f58:	41 e0       	ldi	r20, 0x01	; 1
    1f5a:	60 e0       	ldi	r22, 0x00	; 0
    1f5c:	81 e0       	ldi	r24, 0x01	; 1
    1f5e:	0e 94 15 27 	call	0x4e2a	; 0x4e2a <config_io_pin>
	
    xTaskCreate(vLEDFlashTask, "LED", configMINIMAL_STACK_SIZE, 
    1f62:	a1 2c       	mov	r10, r1
    1f64:	b1 2c       	mov	r11, r1
    1f66:	c1 2c       	mov	r12, r1
    1f68:	d1 2c       	mov	r13, r1
    1f6a:	e1 2c       	mov	r14, r1
    1f6c:	f1 2c       	mov	r15, r1
    1f6e:	01 e0       	ldi	r16, 0x01	; 1
    1f70:	20 e0       	ldi	r18, 0x00	; 0
    1f72:	30 e0       	ldi	r19, 0x00	; 0
    1f74:	44 e6       	ldi	r20, 0x64	; 100
    1f76:	50 e0       	ldi	r21, 0x00	; 0
    1f78:	60 e0       	ldi	r22, 0x00	; 0
    1f7a:	71 e0       	ldi	r23, 0x01	; 1
    1f7c:	89 e1       	ldi	r24, 0x19	; 25
    1f7e:	98 e2       	ldi	r25, 0x28	; 40
    1f80:	0e 94 eb 1a 	call	0x35d6	; 0x35d6 <xTaskGenericCreate>
		NULL, mainLED_TASK_PRIORITY, NULL);
		
	xTaskCreate(vHeartbeatTask, "CAN", configMINIMAL_STACK_SIZE,
    1f84:	a1 2c       	mov	r10, r1
    1f86:	b1 2c       	mov	r11, r1
    1f88:	c1 2c       	mov	r12, r1
    1f8a:	d1 2c       	mov	r13, r1
    1f8c:	e1 2c       	mov	r14, r1
    1f8e:	f1 2c       	mov	r15, r1
    1f90:	02 e0       	ldi	r16, 0x02	; 2
    1f92:	20 e0       	ldi	r18, 0x00	; 0
    1f94:	30 e0       	ldi	r19, 0x00	; 0
    1f96:	44 e6       	ldi	r20, 0x64	; 100
    1f98:	50 e0       	ldi	r21, 0x00	; 0
    1f9a:	64 e0       	ldi	r22, 0x04	; 4
    1f9c:	71 e0       	ldi	r23, 0x01	; 1
    1f9e:	8f e2       	ldi	r24, 0x2F	; 47
    1fa0:	98 e2       	ldi	r25, 0x28	; 40
    1fa2:	0e 94 eb 1a 	call	0x35d6	; 0x35d6 <xTaskGenericCreate>
	NULL, mainHEARTBEAT_TASK_PRIORITY, NULL);
	
	vTaskStartScheduler();
    1fa6:	0e 94 da 1c 	call	0x39b4	; 0x39b4 <vTaskStartScheduler>
	
	return 0;
    1faa:	80 e0       	ldi	r24, 0x00	; 0
    1fac:	90 e0       	ldi	r25, 0x00	; 0
}
    1fae:	df 91       	pop	r29
    1fb0:	cf 91       	pop	r28
    1fb2:	0f 91       	pop	r16
    1fb4:	ff 90       	pop	r15
    1fb6:	ef 90       	pop	r14
    1fb8:	df 90       	pop	r13
    1fba:	cf 90       	pop	r12
    1fbc:	bf 90       	pop	r11
    1fbe:	af 90       	pop	r10
    1fc0:	08 95       	ret

00001fc2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1fc2:	cf 93       	push	r28
    1fc4:	df 93       	push	r29
    1fc6:	00 d0       	rcall	.+0      	; 0x1fc8 <vListInitialise+0x6>
    1fc8:	cd b7       	in	r28, 0x3d	; 61
    1fca:	de b7       	in	r29, 0x3e	; 62
    1fcc:	9a 83       	std	Y+2, r25	; 0x02
    1fce:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1fd0:	89 81       	ldd	r24, Y+1	; 0x01
    1fd2:	9a 81       	ldd	r25, Y+2	; 0x02
    1fd4:	9c 01       	movw	r18, r24
    1fd6:	2d 5f       	subi	r18, 0xFD	; 253
    1fd8:	3f 4f       	sbci	r19, 0xFF	; 255
    1fda:	89 81       	ldd	r24, Y+1	; 0x01
    1fdc:	9a 81       	ldd	r25, Y+2	; 0x02
    1fde:	fc 01       	movw	r30, r24
    1fe0:	32 83       	std	Z+2, r19	; 0x02
    1fe2:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1fe4:	89 81       	ldd	r24, Y+1	; 0x01
    1fe6:	9a 81       	ldd	r25, Y+2	; 0x02
    1fe8:	2f ef       	ldi	r18, 0xFF	; 255
    1fea:	3f ef       	ldi	r19, 0xFF	; 255
    1fec:	fc 01       	movw	r30, r24
    1fee:	34 83       	std	Z+4, r19	; 0x04
    1ff0:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1ff2:	89 81       	ldd	r24, Y+1	; 0x01
    1ff4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ff6:	9c 01       	movw	r18, r24
    1ff8:	2d 5f       	subi	r18, 0xFD	; 253
    1ffa:	3f 4f       	sbci	r19, 0xFF	; 255
    1ffc:	89 81       	ldd	r24, Y+1	; 0x01
    1ffe:	9a 81       	ldd	r25, Y+2	; 0x02
    2000:	fc 01       	movw	r30, r24
    2002:	36 83       	std	Z+6, r19	; 0x06
    2004:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2006:	89 81       	ldd	r24, Y+1	; 0x01
    2008:	9a 81       	ldd	r25, Y+2	; 0x02
    200a:	9c 01       	movw	r18, r24
    200c:	2d 5f       	subi	r18, 0xFD	; 253
    200e:	3f 4f       	sbci	r19, 0xFF	; 255
    2010:	89 81       	ldd	r24, Y+1	; 0x01
    2012:	9a 81       	ldd	r25, Y+2	; 0x02
    2014:	fc 01       	movw	r30, r24
    2016:	30 87       	std	Z+8, r19	; 0x08
    2018:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    201a:	89 81       	ldd	r24, Y+1	; 0x01
    201c:	9a 81       	ldd	r25, Y+2	; 0x02
    201e:	fc 01       	movw	r30, r24
    2020:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    2022:	0f 90       	pop	r0
    2024:	0f 90       	pop	r0
    2026:	df 91       	pop	r29
    2028:	cf 91       	pop	r28
    202a:	08 95       	ret

0000202c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    202c:	cf 93       	push	r28
    202e:	df 93       	push	r29
    2030:	00 d0       	rcall	.+0      	; 0x2032 <vListInitialiseItem+0x6>
    2032:	cd b7       	in	r28, 0x3d	; 61
    2034:	de b7       	in	r29, 0x3e	; 62
    2036:	9a 83       	std	Y+2, r25	; 0x02
    2038:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    203a:	89 81       	ldd	r24, Y+1	; 0x01
    203c:	9a 81       	ldd	r25, Y+2	; 0x02
    203e:	fc 01       	movw	r30, r24
    2040:	11 86       	std	Z+9, r1	; 0x09
    2042:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    2044:	0f 90       	pop	r0
    2046:	0f 90       	pop	r0
    2048:	df 91       	pop	r29
    204a:	cf 91       	pop	r28
    204c:	08 95       	ret

0000204e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    204e:	cf 93       	push	r28
    2050:	df 93       	push	r29
    2052:	00 d0       	rcall	.+0      	; 0x2054 <vListInsertEnd+0x6>
    2054:	00 d0       	rcall	.+0      	; 0x2056 <vListInsertEnd+0x8>
    2056:	00 d0       	rcall	.+0      	; 0x2058 <vListInsertEnd+0xa>
    2058:	cd b7       	in	r28, 0x3d	; 61
    205a:	de b7       	in	r29, 0x3e	; 62
    205c:	9c 83       	std	Y+4, r25	; 0x04
    205e:	8b 83       	std	Y+3, r24	; 0x03
    2060:	7e 83       	std	Y+6, r23	; 0x06
    2062:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    2064:	8b 81       	ldd	r24, Y+3	; 0x03
    2066:	9c 81       	ldd	r25, Y+4	; 0x04
    2068:	fc 01       	movw	r30, r24
    206a:	81 81       	ldd	r24, Z+1	; 0x01
    206c:	92 81       	ldd	r25, Z+2	; 0x02
    206e:	9a 83       	std	Y+2, r25	; 0x02
    2070:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    2072:	8d 81       	ldd	r24, Y+5	; 0x05
    2074:	9e 81       	ldd	r25, Y+6	; 0x06
    2076:	29 81       	ldd	r18, Y+1	; 0x01
    2078:	3a 81       	ldd	r19, Y+2	; 0x02
    207a:	fc 01       	movw	r30, r24
    207c:	33 83       	std	Z+3, r19	; 0x03
    207e:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2080:	89 81       	ldd	r24, Y+1	; 0x01
    2082:	9a 81       	ldd	r25, Y+2	; 0x02
    2084:	fc 01       	movw	r30, r24
    2086:	24 81       	ldd	r18, Z+4	; 0x04
    2088:	35 81       	ldd	r19, Z+5	; 0x05
    208a:	8d 81       	ldd	r24, Y+5	; 0x05
    208c:	9e 81       	ldd	r25, Y+6	; 0x06
    208e:	fc 01       	movw	r30, r24
    2090:	35 83       	std	Z+5, r19	; 0x05
    2092:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2094:	89 81       	ldd	r24, Y+1	; 0x01
    2096:	9a 81       	ldd	r25, Y+2	; 0x02
    2098:	fc 01       	movw	r30, r24
    209a:	84 81       	ldd	r24, Z+4	; 0x04
    209c:	95 81       	ldd	r25, Z+5	; 0x05
    209e:	2d 81       	ldd	r18, Y+5	; 0x05
    20a0:	3e 81       	ldd	r19, Y+6	; 0x06
    20a2:	fc 01       	movw	r30, r24
    20a4:	33 83       	std	Z+3, r19	; 0x03
    20a6:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    20a8:	89 81       	ldd	r24, Y+1	; 0x01
    20aa:	9a 81       	ldd	r25, Y+2	; 0x02
    20ac:	2d 81       	ldd	r18, Y+5	; 0x05
    20ae:	3e 81       	ldd	r19, Y+6	; 0x06
    20b0:	fc 01       	movw	r30, r24
    20b2:	35 83       	std	Z+5, r19	; 0x05
    20b4:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    20b6:	8d 81       	ldd	r24, Y+5	; 0x05
    20b8:	9e 81       	ldd	r25, Y+6	; 0x06
    20ba:	2b 81       	ldd	r18, Y+3	; 0x03
    20bc:	3c 81       	ldd	r19, Y+4	; 0x04
    20be:	fc 01       	movw	r30, r24
    20c0:	31 87       	std	Z+9, r19	; 0x09
    20c2:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    20c4:	8b 81       	ldd	r24, Y+3	; 0x03
    20c6:	9c 81       	ldd	r25, Y+4	; 0x04
    20c8:	fc 01       	movw	r30, r24
    20ca:	80 81       	ld	r24, Z
    20cc:	21 e0       	ldi	r18, 0x01	; 1
    20ce:	28 0f       	add	r18, r24
    20d0:	8b 81       	ldd	r24, Y+3	; 0x03
    20d2:	9c 81       	ldd	r25, Y+4	; 0x04
    20d4:	fc 01       	movw	r30, r24
    20d6:	20 83       	st	Z, r18
}
    20d8:	26 96       	adiw	r28, 0x06	; 6
    20da:	0f b6       	in	r0, 0x3f	; 63
    20dc:	f8 94       	cli
    20de:	de bf       	out	0x3e, r29	; 62
    20e0:	0f be       	out	0x3f, r0	; 63
    20e2:	cd bf       	out	0x3d, r28	; 61
    20e4:	df 91       	pop	r29
    20e6:	cf 91       	pop	r28
    20e8:	08 95       	ret

000020ea <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    20ea:	cf 93       	push	r28
    20ec:	df 93       	push	r29
    20ee:	cd b7       	in	r28, 0x3d	; 61
    20f0:	de b7       	in	r29, 0x3e	; 62
    20f2:	28 97       	sbiw	r28, 0x08	; 8
    20f4:	0f b6       	in	r0, 0x3f	; 63
    20f6:	f8 94       	cli
    20f8:	de bf       	out	0x3e, r29	; 62
    20fa:	0f be       	out	0x3f, r0	; 63
    20fc:	cd bf       	out	0x3d, r28	; 61
    20fe:	9e 83       	std	Y+6, r25	; 0x06
    2100:	8d 83       	std	Y+5, r24	; 0x05
    2102:	78 87       	std	Y+8, r23	; 0x08
    2104:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2106:	8f 81       	ldd	r24, Y+7	; 0x07
    2108:	98 85       	ldd	r25, Y+8	; 0x08
    210a:	fc 01       	movw	r30, r24
    210c:	80 81       	ld	r24, Z
    210e:	91 81       	ldd	r25, Z+1	; 0x01
    2110:	9c 83       	std	Y+4, r25	; 0x04
    2112:	8b 83       	std	Y+3, r24	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2114:	8b 81       	ldd	r24, Y+3	; 0x03
    2116:	9c 81       	ldd	r25, Y+4	; 0x04
    2118:	01 96       	adiw	r24, 0x01	; 1
    211a:	41 f4       	brne	.+16     	; 0x212c <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    211c:	8d 81       	ldd	r24, Y+5	; 0x05
    211e:	9e 81       	ldd	r25, Y+6	; 0x06
    2120:	fc 01       	movw	r30, r24
    2122:	87 81       	ldd	r24, Z+7	; 0x07
    2124:	90 85       	ldd	r25, Z+8	; 0x08
    2126:	9a 83       	std	Y+2, r25	; 0x02
    2128:	89 83       	std	Y+1, r24	; 0x01
    212a:	1a c0       	rjmp	.+52     	; 0x2160 <vListInsert+0x76>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    212c:	8d 81       	ldd	r24, Y+5	; 0x05
    212e:	9e 81       	ldd	r25, Y+6	; 0x06
    2130:	03 96       	adiw	r24, 0x03	; 3
    2132:	9a 83       	std	Y+2, r25	; 0x02
    2134:	89 83       	std	Y+1, r24	; 0x01
    2136:	07 c0       	rjmp	.+14     	; 0x2146 <vListInsert+0x5c>
    2138:	89 81       	ldd	r24, Y+1	; 0x01
    213a:	9a 81       	ldd	r25, Y+2	; 0x02
    213c:	fc 01       	movw	r30, r24
    213e:	82 81       	ldd	r24, Z+2	; 0x02
    2140:	93 81       	ldd	r25, Z+3	; 0x03
    2142:	9a 83       	std	Y+2, r25	; 0x02
    2144:	89 83       	std	Y+1, r24	; 0x01
    2146:	89 81       	ldd	r24, Y+1	; 0x01
    2148:	9a 81       	ldd	r25, Y+2	; 0x02
    214a:	fc 01       	movw	r30, r24
    214c:	82 81       	ldd	r24, Z+2	; 0x02
    214e:	93 81       	ldd	r25, Z+3	; 0x03
    2150:	fc 01       	movw	r30, r24
    2152:	20 81       	ld	r18, Z
    2154:	31 81       	ldd	r19, Z+1	; 0x01
    2156:	8b 81       	ldd	r24, Y+3	; 0x03
    2158:	9c 81       	ldd	r25, Y+4	; 0x04
    215a:	82 17       	cp	r24, r18
    215c:	93 07       	cpc	r25, r19
    215e:	60 f7       	brcc	.-40     	; 0x2138 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2160:	89 81       	ldd	r24, Y+1	; 0x01
    2162:	9a 81       	ldd	r25, Y+2	; 0x02
    2164:	fc 01       	movw	r30, r24
    2166:	22 81       	ldd	r18, Z+2	; 0x02
    2168:	33 81       	ldd	r19, Z+3	; 0x03
    216a:	8f 81       	ldd	r24, Y+7	; 0x07
    216c:	98 85       	ldd	r25, Y+8	; 0x08
    216e:	fc 01       	movw	r30, r24
    2170:	33 83       	std	Z+3, r19	; 0x03
    2172:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2174:	8f 81       	ldd	r24, Y+7	; 0x07
    2176:	98 85       	ldd	r25, Y+8	; 0x08
    2178:	fc 01       	movw	r30, r24
    217a:	82 81       	ldd	r24, Z+2	; 0x02
    217c:	93 81       	ldd	r25, Z+3	; 0x03
    217e:	2f 81       	ldd	r18, Y+7	; 0x07
    2180:	38 85       	ldd	r19, Y+8	; 0x08
    2182:	fc 01       	movw	r30, r24
    2184:	35 83       	std	Z+5, r19	; 0x05
    2186:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2188:	8f 81       	ldd	r24, Y+7	; 0x07
    218a:	98 85       	ldd	r25, Y+8	; 0x08
    218c:	29 81       	ldd	r18, Y+1	; 0x01
    218e:	3a 81       	ldd	r19, Y+2	; 0x02
    2190:	fc 01       	movw	r30, r24
    2192:	35 83       	std	Z+5, r19	; 0x05
    2194:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
    2196:	89 81       	ldd	r24, Y+1	; 0x01
    2198:	9a 81       	ldd	r25, Y+2	; 0x02
    219a:	2f 81       	ldd	r18, Y+7	; 0x07
    219c:	38 85       	ldd	r19, Y+8	; 0x08
    219e:	fc 01       	movw	r30, r24
    21a0:	33 83       	std	Z+3, r19	; 0x03
    21a2:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    21a4:	8f 81       	ldd	r24, Y+7	; 0x07
    21a6:	98 85       	ldd	r25, Y+8	; 0x08
    21a8:	2d 81       	ldd	r18, Y+5	; 0x05
    21aa:	3e 81       	ldd	r19, Y+6	; 0x06
    21ac:	fc 01       	movw	r30, r24
    21ae:	31 87       	std	Z+9, r19	; 0x09
    21b0:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    21b2:	8d 81       	ldd	r24, Y+5	; 0x05
    21b4:	9e 81       	ldd	r25, Y+6	; 0x06
    21b6:	fc 01       	movw	r30, r24
    21b8:	80 81       	ld	r24, Z
    21ba:	21 e0       	ldi	r18, 0x01	; 1
    21bc:	28 0f       	add	r18, r24
    21be:	8d 81       	ldd	r24, Y+5	; 0x05
    21c0:	9e 81       	ldd	r25, Y+6	; 0x06
    21c2:	fc 01       	movw	r30, r24
    21c4:	20 83       	st	Z, r18
}
    21c6:	28 96       	adiw	r28, 0x08	; 8
    21c8:	0f b6       	in	r0, 0x3f	; 63
    21ca:	f8 94       	cli
    21cc:	de bf       	out	0x3e, r29	; 62
    21ce:	0f be       	out	0x3f, r0	; 63
    21d0:	cd bf       	out	0x3d, r28	; 61
    21d2:	df 91       	pop	r29
    21d4:	cf 91       	pop	r28
    21d6:	08 95       	ret

000021d8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    21d8:	cf 93       	push	r28
    21da:	df 93       	push	r29
    21dc:	00 d0       	rcall	.+0      	; 0x21de <uxListRemove+0x6>
    21de:	00 d0       	rcall	.+0      	; 0x21e0 <uxListRemove+0x8>
    21e0:	cd b7       	in	r28, 0x3d	; 61
    21e2:	de b7       	in	r29, 0x3e	; 62
    21e4:	9c 83       	std	Y+4, r25	; 0x04
    21e6:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    21e8:	8b 81       	ldd	r24, Y+3	; 0x03
    21ea:	9c 81       	ldd	r25, Y+4	; 0x04
    21ec:	fc 01       	movw	r30, r24
    21ee:	80 85       	ldd	r24, Z+8	; 0x08
    21f0:	91 85       	ldd	r25, Z+9	; 0x09
    21f2:	9a 83       	std	Y+2, r25	; 0x02
    21f4:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    21f6:	8b 81       	ldd	r24, Y+3	; 0x03
    21f8:	9c 81       	ldd	r25, Y+4	; 0x04
    21fa:	fc 01       	movw	r30, r24
    21fc:	82 81       	ldd	r24, Z+2	; 0x02
    21fe:	93 81       	ldd	r25, Z+3	; 0x03
    2200:	2b 81       	ldd	r18, Y+3	; 0x03
    2202:	3c 81       	ldd	r19, Y+4	; 0x04
    2204:	f9 01       	movw	r30, r18
    2206:	24 81       	ldd	r18, Z+4	; 0x04
    2208:	35 81       	ldd	r19, Z+5	; 0x05
    220a:	fc 01       	movw	r30, r24
    220c:	35 83       	std	Z+5, r19	; 0x05
    220e:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2210:	8b 81       	ldd	r24, Y+3	; 0x03
    2212:	9c 81       	ldd	r25, Y+4	; 0x04
    2214:	fc 01       	movw	r30, r24
    2216:	84 81       	ldd	r24, Z+4	; 0x04
    2218:	95 81       	ldd	r25, Z+5	; 0x05
    221a:	2b 81       	ldd	r18, Y+3	; 0x03
    221c:	3c 81       	ldd	r19, Y+4	; 0x04
    221e:	f9 01       	movw	r30, r18
    2220:	22 81       	ldd	r18, Z+2	; 0x02
    2222:	33 81       	ldd	r19, Z+3	; 0x03
    2224:	fc 01       	movw	r30, r24
    2226:	33 83       	std	Z+3, r19	; 0x03
    2228:	22 83       	std	Z+2, r18	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    222a:	89 81       	ldd	r24, Y+1	; 0x01
    222c:	9a 81       	ldd	r25, Y+2	; 0x02
    222e:	fc 01       	movw	r30, r24
    2230:	21 81       	ldd	r18, Z+1	; 0x01
    2232:	32 81       	ldd	r19, Z+2	; 0x02
    2234:	8b 81       	ldd	r24, Y+3	; 0x03
    2236:	9c 81       	ldd	r25, Y+4	; 0x04
    2238:	28 17       	cp	r18, r24
    223a:	39 07       	cpc	r19, r25
    223c:	51 f4       	brne	.+20     	; 0x2252 <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    223e:	8b 81       	ldd	r24, Y+3	; 0x03
    2240:	9c 81       	ldd	r25, Y+4	; 0x04
    2242:	fc 01       	movw	r30, r24
    2244:	24 81       	ldd	r18, Z+4	; 0x04
    2246:	35 81       	ldd	r19, Z+5	; 0x05
    2248:	89 81       	ldd	r24, Y+1	; 0x01
    224a:	9a 81       	ldd	r25, Y+2	; 0x02
    224c:	fc 01       	movw	r30, r24
    224e:	32 83       	std	Z+2, r19	; 0x02
    2250:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    2252:	8b 81       	ldd	r24, Y+3	; 0x03
    2254:	9c 81       	ldd	r25, Y+4	; 0x04
    2256:	fc 01       	movw	r30, r24
    2258:	11 86       	std	Z+9, r1	; 0x09
    225a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    225c:	89 81       	ldd	r24, Y+1	; 0x01
    225e:	9a 81       	ldd	r25, Y+2	; 0x02
    2260:	fc 01       	movw	r30, r24
    2262:	80 81       	ld	r24, Z
    2264:	2f ef       	ldi	r18, 0xFF	; 255
    2266:	28 0f       	add	r18, r24
    2268:	89 81       	ldd	r24, Y+1	; 0x01
    226a:	9a 81       	ldd	r25, Y+2	; 0x02
    226c:	fc 01       	movw	r30, r24
    226e:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    2270:	89 81       	ldd	r24, Y+1	; 0x01
    2272:	9a 81       	ldd	r25, Y+2	; 0x02
    2274:	fc 01       	movw	r30, r24
    2276:	80 81       	ld	r24, Z
}
    2278:	0f 90       	pop	r0
    227a:	0f 90       	pop	r0
    227c:	0f 90       	pop	r0
    227e:	0f 90       	pop	r0
    2280:	df 91       	pop	r29
    2282:	cf 91       	pop	r28
    2284:	08 95       	ret

00002286 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2286:	cf 93       	push	r28
    2288:	df 93       	push	r29
    228a:	cd b7       	in	r28, 0x3d	; 61
    228c:	de b7       	in	r29, 0x3e	; 62
    228e:	28 97       	sbiw	r28, 0x08	; 8
    2290:	0f b6       	in	r0, 0x3f	; 63
    2292:	f8 94       	cli
    2294:	de bf       	out	0x3e, r29	; 62
    2296:	0f be       	out	0x3f, r0	; 63
    2298:	cd bf       	out	0x3d, r28	; 61
    229a:	9c 83       	std	Y+4, r25	; 0x04
    229c:	8b 83       	std	Y+3, r24	; 0x03
    229e:	7e 83       	std	Y+6, r23	; 0x06
    22a0:	6d 83       	std	Y+5, r22	; 0x05
    22a2:	58 87       	std	Y+8, r21	; 0x08
    22a4:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    22a6:	8b 81       	ldd	r24, Y+3	; 0x03
    22a8:	9c 81       	ldd	r25, Y+4	; 0x04
    22aa:	21 e1       	ldi	r18, 0x11	; 17
    22ac:	fc 01       	movw	r30, r24
    22ae:	20 83       	st	Z, r18
	pxTopOfStack--;
    22b0:	8b 81       	ldd	r24, Y+3	; 0x03
    22b2:	9c 81       	ldd	r25, Y+4	; 0x04
    22b4:	01 97       	sbiw	r24, 0x01	; 1
    22b6:	9c 83       	std	Y+4, r25	; 0x04
    22b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    22ba:	8b 81       	ldd	r24, Y+3	; 0x03
    22bc:	9c 81       	ldd	r25, Y+4	; 0x04
    22be:	22 e2       	ldi	r18, 0x22	; 34
    22c0:	fc 01       	movw	r30, r24
    22c2:	20 83       	st	Z, r18
	pxTopOfStack--;
    22c4:	8b 81       	ldd	r24, Y+3	; 0x03
    22c6:	9c 81       	ldd	r25, Y+4	; 0x04
    22c8:	01 97       	sbiw	r24, 0x01	; 1
    22ca:	9c 83       	std	Y+4, r25	; 0x04
    22cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    22ce:	8b 81       	ldd	r24, Y+3	; 0x03
    22d0:	9c 81       	ldd	r25, Y+4	; 0x04
    22d2:	23 e3       	ldi	r18, 0x33	; 51
    22d4:	fc 01       	movw	r30, r24
    22d6:	20 83       	st	Z, r18
	pxTopOfStack--;
    22d8:	8b 81       	ldd	r24, Y+3	; 0x03
    22da:	9c 81       	ldd	r25, Y+4	; 0x04
    22dc:	01 97       	sbiw	r24, 0x01	; 1
    22de:	9c 83       	std	Y+4, r25	; 0x04
    22e0:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    22e2:	8d 81       	ldd	r24, Y+5	; 0x05
    22e4:	9e 81       	ldd	r25, Y+6	; 0x06
    22e6:	9a 83       	std	Y+2, r25	; 0x02
    22e8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    22ea:	29 81       	ldd	r18, Y+1	; 0x01
    22ec:	8b 81       	ldd	r24, Y+3	; 0x03
    22ee:	9c 81       	ldd	r25, Y+4	; 0x04
    22f0:	fc 01       	movw	r30, r24
    22f2:	20 83       	st	Z, r18
	pxTopOfStack--;
    22f4:	8b 81       	ldd	r24, Y+3	; 0x03
    22f6:	9c 81       	ldd	r25, Y+4	; 0x04
    22f8:	01 97       	sbiw	r24, 0x01	; 1
    22fa:	9c 83       	std	Y+4, r25	; 0x04
    22fc:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    22fe:	89 81       	ldd	r24, Y+1	; 0x01
    2300:	9a 81       	ldd	r25, Y+2	; 0x02
    2302:	89 2f       	mov	r24, r25
    2304:	99 27       	eor	r25, r25
    2306:	9a 83       	std	Y+2, r25	; 0x02
    2308:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    230a:	29 81       	ldd	r18, Y+1	; 0x01
    230c:	8b 81       	ldd	r24, Y+3	; 0x03
    230e:	9c 81       	ldd	r25, Y+4	; 0x04
    2310:	fc 01       	movw	r30, r24
    2312:	20 83       	st	Z, r18
	pxTopOfStack--;
    2314:	8b 81       	ldd	r24, Y+3	; 0x03
    2316:	9c 81       	ldd	r25, Y+4	; 0x04
    2318:	01 97       	sbiw	r24, 0x01	; 1
    231a:	9c 83       	std	Y+4, r25	; 0x04
    231c:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    231e:	8b 81       	ldd	r24, Y+3	; 0x03
    2320:	9c 81       	ldd	r25, Y+4	; 0x04
    2322:	fc 01       	movw	r30, r24
    2324:	10 82       	st	Z, r1
	pxTopOfStack--;
    2326:	8b 81       	ldd	r24, Y+3	; 0x03
    2328:	9c 81       	ldd	r25, Y+4	; 0x04
    232a:	01 97       	sbiw	r24, 0x01	; 1
    232c:	9c 83       	std	Y+4, r25	; 0x04
    232e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2330:	8b 81       	ldd	r24, Y+3	; 0x03
    2332:	9c 81       	ldd	r25, Y+4	; 0x04
    2334:	20 e8       	ldi	r18, 0x80	; 128
    2336:	fc 01       	movw	r30, r24
    2338:	20 83       	st	Z, r18
	pxTopOfStack--;
    233a:	8b 81       	ldd	r24, Y+3	; 0x03
    233c:	9c 81       	ldd	r25, Y+4	; 0x04
    233e:	01 97       	sbiw	r24, 0x01	; 1
    2340:	9c 83       	std	Y+4, r25	; 0x04
    2342:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2344:	8b 81       	ldd	r24, Y+3	; 0x03
    2346:	9c 81       	ldd	r25, Y+4	; 0x04
    2348:	fc 01       	movw	r30, r24
    234a:	10 82       	st	Z, r1
	pxTopOfStack--;
    234c:	8b 81       	ldd	r24, Y+3	; 0x03
    234e:	9c 81       	ldd	r25, Y+4	; 0x04
    2350:	01 97       	sbiw	r24, 0x01	; 1
    2352:	9c 83       	std	Y+4, r25	; 0x04
    2354:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2356:	8b 81       	ldd	r24, Y+3	; 0x03
    2358:	9c 81       	ldd	r25, Y+4	; 0x04
    235a:	22 e0       	ldi	r18, 0x02	; 2
    235c:	fc 01       	movw	r30, r24
    235e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2360:	8b 81       	ldd	r24, Y+3	; 0x03
    2362:	9c 81       	ldd	r25, Y+4	; 0x04
    2364:	01 97       	sbiw	r24, 0x01	; 1
    2366:	9c 83       	std	Y+4, r25	; 0x04
    2368:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    236a:	8b 81       	ldd	r24, Y+3	; 0x03
    236c:	9c 81       	ldd	r25, Y+4	; 0x04
    236e:	23 e0       	ldi	r18, 0x03	; 3
    2370:	fc 01       	movw	r30, r24
    2372:	20 83       	st	Z, r18
	pxTopOfStack--;
    2374:	8b 81       	ldd	r24, Y+3	; 0x03
    2376:	9c 81       	ldd	r25, Y+4	; 0x04
    2378:	01 97       	sbiw	r24, 0x01	; 1
    237a:	9c 83       	std	Y+4, r25	; 0x04
    237c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    237e:	8b 81       	ldd	r24, Y+3	; 0x03
    2380:	9c 81       	ldd	r25, Y+4	; 0x04
    2382:	24 e0       	ldi	r18, 0x04	; 4
    2384:	fc 01       	movw	r30, r24
    2386:	20 83       	st	Z, r18
	pxTopOfStack--;
    2388:	8b 81       	ldd	r24, Y+3	; 0x03
    238a:	9c 81       	ldd	r25, Y+4	; 0x04
    238c:	01 97       	sbiw	r24, 0x01	; 1
    238e:	9c 83       	std	Y+4, r25	; 0x04
    2390:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2392:	8b 81       	ldd	r24, Y+3	; 0x03
    2394:	9c 81       	ldd	r25, Y+4	; 0x04
    2396:	25 e0       	ldi	r18, 0x05	; 5
    2398:	fc 01       	movw	r30, r24
    239a:	20 83       	st	Z, r18
	pxTopOfStack--;
    239c:	8b 81       	ldd	r24, Y+3	; 0x03
    239e:	9c 81       	ldd	r25, Y+4	; 0x04
    23a0:	01 97       	sbiw	r24, 0x01	; 1
    23a2:	9c 83       	std	Y+4, r25	; 0x04
    23a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    23a6:	8b 81       	ldd	r24, Y+3	; 0x03
    23a8:	9c 81       	ldd	r25, Y+4	; 0x04
    23aa:	26 e0       	ldi	r18, 0x06	; 6
    23ac:	fc 01       	movw	r30, r24
    23ae:	20 83       	st	Z, r18
	pxTopOfStack--;
    23b0:	8b 81       	ldd	r24, Y+3	; 0x03
    23b2:	9c 81       	ldd	r25, Y+4	; 0x04
    23b4:	01 97       	sbiw	r24, 0x01	; 1
    23b6:	9c 83       	std	Y+4, r25	; 0x04
    23b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    23ba:	8b 81       	ldd	r24, Y+3	; 0x03
    23bc:	9c 81       	ldd	r25, Y+4	; 0x04
    23be:	27 e0       	ldi	r18, 0x07	; 7
    23c0:	fc 01       	movw	r30, r24
    23c2:	20 83       	st	Z, r18
	pxTopOfStack--;
    23c4:	8b 81       	ldd	r24, Y+3	; 0x03
    23c6:	9c 81       	ldd	r25, Y+4	; 0x04
    23c8:	01 97       	sbiw	r24, 0x01	; 1
    23ca:	9c 83       	std	Y+4, r25	; 0x04
    23cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    23ce:	8b 81       	ldd	r24, Y+3	; 0x03
    23d0:	9c 81       	ldd	r25, Y+4	; 0x04
    23d2:	28 e0       	ldi	r18, 0x08	; 8
    23d4:	fc 01       	movw	r30, r24
    23d6:	20 83       	st	Z, r18
	pxTopOfStack--;
    23d8:	8b 81       	ldd	r24, Y+3	; 0x03
    23da:	9c 81       	ldd	r25, Y+4	; 0x04
    23dc:	01 97       	sbiw	r24, 0x01	; 1
    23de:	9c 83       	std	Y+4, r25	; 0x04
    23e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    23e2:	8b 81       	ldd	r24, Y+3	; 0x03
    23e4:	9c 81       	ldd	r25, Y+4	; 0x04
    23e6:	29 e0       	ldi	r18, 0x09	; 9
    23e8:	fc 01       	movw	r30, r24
    23ea:	20 83       	st	Z, r18
	pxTopOfStack--;
    23ec:	8b 81       	ldd	r24, Y+3	; 0x03
    23ee:	9c 81       	ldd	r25, Y+4	; 0x04
    23f0:	01 97       	sbiw	r24, 0x01	; 1
    23f2:	9c 83       	std	Y+4, r25	; 0x04
    23f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    23f6:	8b 81       	ldd	r24, Y+3	; 0x03
    23f8:	9c 81       	ldd	r25, Y+4	; 0x04
    23fa:	20 e1       	ldi	r18, 0x10	; 16
    23fc:	fc 01       	movw	r30, r24
    23fe:	20 83       	st	Z, r18
	pxTopOfStack--;
    2400:	8b 81       	ldd	r24, Y+3	; 0x03
    2402:	9c 81       	ldd	r25, Y+4	; 0x04
    2404:	01 97       	sbiw	r24, 0x01	; 1
    2406:	9c 83       	std	Y+4, r25	; 0x04
    2408:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    240a:	8b 81       	ldd	r24, Y+3	; 0x03
    240c:	9c 81       	ldd	r25, Y+4	; 0x04
    240e:	21 e1       	ldi	r18, 0x11	; 17
    2410:	fc 01       	movw	r30, r24
    2412:	20 83       	st	Z, r18
	pxTopOfStack--;
    2414:	8b 81       	ldd	r24, Y+3	; 0x03
    2416:	9c 81       	ldd	r25, Y+4	; 0x04
    2418:	01 97       	sbiw	r24, 0x01	; 1
    241a:	9c 83       	std	Y+4, r25	; 0x04
    241c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    241e:	8b 81       	ldd	r24, Y+3	; 0x03
    2420:	9c 81       	ldd	r25, Y+4	; 0x04
    2422:	22 e1       	ldi	r18, 0x12	; 18
    2424:	fc 01       	movw	r30, r24
    2426:	20 83       	st	Z, r18
	pxTopOfStack--;
    2428:	8b 81       	ldd	r24, Y+3	; 0x03
    242a:	9c 81       	ldd	r25, Y+4	; 0x04
    242c:	01 97       	sbiw	r24, 0x01	; 1
    242e:	9c 83       	std	Y+4, r25	; 0x04
    2430:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2432:	8b 81       	ldd	r24, Y+3	; 0x03
    2434:	9c 81       	ldd	r25, Y+4	; 0x04
    2436:	23 e1       	ldi	r18, 0x13	; 19
    2438:	fc 01       	movw	r30, r24
    243a:	20 83       	st	Z, r18
	pxTopOfStack--;
    243c:	8b 81       	ldd	r24, Y+3	; 0x03
    243e:	9c 81       	ldd	r25, Y+4	; 0x04
    2440:	01 97       	sbiw	r24, 0x01	; 1
    2442:	9c 83       	std	Y+4, r25	; 0x04
    2444:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2446:	8b 81       	ldd	r24, Y+3	; 0x03
    2448:	9c 81       	ldd	r25, Y+4	; 0x04
    244a:	24 e1       	ldi	r18, 0x14	; 20
    244c:	fc 01       	movw	r30, r24
    244e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2450:	8b 81       	ldd	r24, Y+3	; 0x03
    2452:	9c 81       	ldd	r25, Y+4	; 0x04
    2454:	01 97       	sbiw	r24, 0x01	; 1
    2456:	9c 83       	std	Y+4, r25	; 0x04
    2458:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    245a:	8b 81       	ldd	r24, Y+3	; 0x03
    245c:	9c 81       	ldd	r25, Y+4	; 0x04
    245e:	25 e1       	ldi	r18, 0x15	; 21
    2460:	fc 01       	movw	r30, r24
    2462:	20 83       	st	Z, r18
	pxTopOfStack--;
    2464:	8b 81       	ldd	r24, Y+3	; 0x03
    2466:	9c 81       	ldd	r25, Y+4	; 0x04
    2468:	01 97       	sbiw	r24, 0x01	; 1
    246a:	9c 83       	std	Y+4, r25	; 0x04
    246c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    246e:	8b 81       	ldd	r24, Y+3	; 0x03
    2470:	9c 81       	ldd	r25, Y+4	; 0x04
    2472:	26 e1       	ldi	r18, 0x16	; 22
    2474:	fc 01       	movw	r30, r24
    2476:	20 83       	st	Z, r18
	pxTopOfStack--;
    2478:	8b 81       	ldd	r24, Y+3	; 0x03
    247a:	9c 81       	ldd	r25, Y+4	; 0x04
    247c:	01 97       	sbiw	r24, 0x01	; 1
    247e:	9c 83       	std	Y+4, r25	; 0x04
    2480:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2482:	8b 81       	ldd	r24, Y+3	; 0x03
    2484:	9c 81       	ldd	r25, Y+4	; 0x04
    2486:	27 e1       	ldi	r18, 0x17	; 23
    2488:	fc 01       	movw	r30, r24
    248a:	20 83       	st	Z, r18
	pxTopOfStack--;
    248c:	8b 81       	ldd	r24, Y+3	; 0x03
    248e:	9c 81       	ldd	r25, Y+4	; 0x04
    2490:	01 97       	sbiw	r24, 0x01	; 1
    2492:	9c 83       	std	Y+4, r25	; 0x04
    2494:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2496:	8b 81       	ldd	r24, Y+3	; 0x03
    2498:	9c 81       	ldd	r25, Y+4	; 0x04
    249a:	28 e1       	ldi	r18, 0x18	; 24
    249c:	fc 01       	movw	r30, r24
    249e:	20 83       	st	Z, r18
	pxTopOfStack--;
    24a0:	8b 81       	ldd	r24, Y+3	; 0x03
    24a2:	9c 81       	ldd	r25, Y+4	; 0x04
    24a4:	01 97       	sbiw	r24, 0x01	; 1
    24a6:	9c 83       	std	Y+4, r25	; 0x04
    24a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    24aa:	8b 81       	ldd	r24, Y+3	; 0x03
    24ac:	9c 81       	ldd	r25, Y+4	; 0x04
    24ae:	29 e1       	ldi	r18, 0x19	; 25
    24b0:	fc 01       	movw	r30, r24
    24b2:	20 83       	st	Z, r18
	pxTopOfStack--;
    24b4:	8b 81       	ldd	r24, Y+3	; 0x03
    24b6:	9c 81       	ldd	r25, Y+4	; 0x04
    24b8:	01 97       	sbiw	r24, 0x01	; 1
    24ba:	9c 83       	std	Y+4, r25	; 0x04
    24bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    24be:	8b 81       	ldd	r24, Y+3	; 0x03
    24c0:	9c 81       	ldd	r25, Y+4	; 0x04
    24c2:	20 e2       	ldi	r18, 0x20	; 32
    24c4:	fc 01       	movw	r30, r24
    24c6:	20 83       	st	Z, r18
	pxTopOfStack--;
    24c8:	8b 81       	ldd	r24, Y+3	; 0x03
    24ca:	9c 81       	ldd	r25, Y+4	; 0x04
    24cc:	01 97       	sbiw	r24, 0x01	; 1
    24ce:	9c 83       	std	Y+4, r25	; 0x04
    24d0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    24d2:	8b 81       	ldd	r24, Y+3	; 0x03
    24d4:	9c 81       	ldd	r25, Y+4	; 0x04
    24d6:	21 e2       	ldi	r18, 0x21	; 33
    24d8:	fc 01       	movw	r30, r24
    24da:	20 83       	st	Z, r18
	pxTopOfStack--;
    24dc:	8b 81       	ldd	r24, Y+3	; 0x03
    24de:	9c 81       	ldd	r25, Y+4	; 0x04
    24e0:	01 97       	sbiw	r24, 0x01	; 1
    24e2:	9c 83       	std	Y+4, r25	; 0x04
    24e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    24e6:	8b 81       	ldd	r24, Y+3	; 0x03
    24e8:	9c 81       	ldd	r25, Y+4	; 0x04
    24ea:	22 e2       	ldi	r18, 0x22	; 34
    24ec:	fc 01       	movw	r30, r24
    24ee:	20 83       	st	Z, r18
	pxTopOfStack--;
    24f0:	8b 81       	ldd	r24, Y+3	; 0x03
    24f2:	9c 81       	ldd	r25, Y+4	; 0x04
    24f4:	01 97       	sbiw	r24, 0x01	; 1
    24f6:	9c 83       	std	Y+4, r25	; 0x04
    24f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    24fa:	8b 81       	ldd	r24, Y+3	; 0x03
    24fc:	9c 81       	ldd	r25, Y+4	; 0x04
    24fe:	23 e2       	ldi	r18, 0x23	; 35
    2500:	fc 01       	movw	r30, r24
    2502:	20 83       	st	Z, r18
	pxTopOfStack--;
    2504:	8b 81       	ldd	r24, Y+3	; 0x03
    2506:	9c 81       	ldd	r25, Y+4	; 0x04
    2508:	01 97       	sbiw	r24, 0x01	; 1
    250a:	9c 83       	std	Y+4, r25	; 0x04
    250c:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    250e:	8f 81       	ldd	r24, Y+7	; 0x07
    2510:	98 85       	ldd	r25, Y+8	; 0x08
    2512:	9a 83       	std	Y+2, r25	; 0x02
    2514:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2516:	29 81       	ldd	r18, Y+1	; 0x01
    2518:	8b 81       	ldd	r24, Y+3	; 0x03
    251a:	9c 81       	ldd	r25, Y+4	; 0x04
    251c:	fc 01       	movw	r30, r24
    251e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2520:	8b 81       	ldd	r24, Y+3	; 0x03
    2522:	9c 81       	ldd	r25, Y+4	; 0x04
    2524:	01 97       	sbiw	r24, 0x01	; 1
    2526:	9c 83       	std	Y+4, r25	; 0x04
    2528:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    252a:	89 81       	ldd	r24, Y+1	; 0x01
    252c:	9a 81       	ldd	r25, Y+2	; 0x02
    252e:	89 2f       	mov	r24, r25
    2530:	99 27       	eor	r25, r25
    2532:	9a 83       	std	Y+2, r25	; 0x02
    2534:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2536:	29 81       	ldd	r18, Y+1	; 0x01
    2538:	8b 81       	ldd	r24, Y+3	; 0x03
    253a:	9c 81       	ldd	r25, Y+4	; 0x04
    253c:	fc 01       	movw	r30, r24
    253e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2540:	8b 81       	ldd	r24, Y+3	; 0x03
    2542:	9c 81       	ldd	r25, Y+4	; 0x04
    2544:	01 97       	sbiw	r24, 0x01	; 1
    2546:	9c 83       	std	Y+4, r25	; 0x04
    2548:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    254a:	8b 81       	ldd	r24, Y+3	; 0x03
    254c:	9c 81       	ldd	r25, Y+4	; 0x04
    254e:	26 e2       	ldi	r18, 0x26	; 38
    2550:	fc 01       	movw	r30, r24
    2552:	20 83       	st	Z, r18
	pxTopOfStack--;
    2554:	8b 81       	ldd	r24, Y+3	; 0x03
    2556:	9c 81       	ldd	r25, Y+4	; 0x04
    2558:	01 97       	sbiw	r24, 0x01	; 1
    255a:	9c 83       	std	Y+4, r25	; 0x04
    255c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    255e:	8b 81       	ldd	r24, Y+3	; 0x03
    2560:	9c 81       	ldd	r25, Y+4	; 0x04
    2562:	27 e2       	ldi	r18, 0x27	; 39
    2564:	fc 01       	movw	r30, r24
    2566:	20 83       	st	Z, r18
	pxTopOfStack--;
    2568:	8b 81       	ldd	r24, Y+3	; 0x03
    256a:	9c 81       	ldd	r25, Y+4	; 0x04
    256c:	01 97       	sbiw	r24, 0x01	; 1
    256e:	9c 83       	std	Y+4, r25	; 0x04
    2570:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2572:	8b 81       	ldd	r24, Y+3	; 0x03
    2574:	9c 81       	ldd	r25, Y+4	; 0x04
    2576:	28 e2       	ldi	r18, 0x28	; 40
    2578:	fc 01       	movw	r30, r24
    257a:	20 83       	st	Z, r18
	pxTopOfStack--;
    257c:	8b 81       	ldd	r24, Y+3	; 0x03
    257e:	9c 81       	ldd	r25, Y+4	; 0x04
    2580:	01 97       	sbiw	r24, 0x01	; 1
    2582:	9c 83       	std	Y+4, r25	; 0x04
    2584:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2586:	8b 81       	ldd	r24, Y+3	; 0x03
    2588:	9c 81       	ldd	r25, Y+4	; 0x04
    258a:	29 e2       	ldi	r18, 0x29	; 41
    258c:	fc 01       	movw	r30, r24
    258e:	20 83       	st	Z, r18
	pxTopOfStack--;
    2590:	8b 81       	ldd	r24, Y+3	; 0x03
    2592:	9c 81       	ldd	r25, Y+4	; 0x04
    2594:	01 97       	sbiw	r24, 0x01	; 1
    2596:	9c 83       	std	Y+4, r25	; 0x04
    2598:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    259a:	8b 81       	ldd	r24, Y+3	; 0x03
    259c:	9c 81       	ldd	r25, Y+4	; 0x04
    259e:	20 e3       	ldi	r18, 0x30	; 48
    25a0:	fc 01       	movw	r30, r24
    25a2:	20 83       	st	Z, r18
	pxTopOfStack--;
    25a4:	8b 81       	ldd	r24, Y+3	; 0x03
    25a6:	9c 81       	ldd	r25, Y+4	; 0x04
    25a8:	01 97       	sbiw	r24, 0x01	; 1
    25aa:	9c 83       	std	Y+4, r25	; 0x04
    25ac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    25ae:	8b 81       	ldd	r24, Y+3	; 0x03
    25b0:	9c 81       	ldd	r25, Y+4	; 0x04
    25b2:	21 e3       	ldi	r18, 0x31	; 49
    25b4:	fc 01       	movw	r30, r24
    25b6:	20 83       	st	Z, r18
	pxTopOfStack--;
    25b8:	8b 81       	ldd	r24, Y+3	; 0x03
    25ba:	9c 81       	ldd	r25, Y+4	; 0x04
    25bc:	01 97       	sbiw	r24, 0x01	; 1
    25be:	9c 83       	std	Y+4, r25	; 0x04
    25c0:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    25c2:	8b 81       	ldd	r24, Y+3	; 0x03
    25c4:	9c 81       	ldd	r25, Y+4	; 0x04
}
    25c6:	28 96       	adiw	r28, 0x08	; 8
    25c8:	0f b6       	in	r0, 0x3f	; 63
    25ca:	f8 94       	cli
    25cc:	de bf       	out	0x3e, r29	; 62
    25ce:	0f be       	out	0x3f, r0	; 63
    25d0:	cd bf       	out	0x3d, r28	; 61
    25d2:	df 91       	pop	r29
    25d4:	cf 91       	pop	r28
    25d6:	08 95       	ret

000025d8 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    25d8:	cf 93       	push	r28
    25da:	df 93       	push	r29
    25dc:	cd b7       	in	r28, 0x3d	; 61
    25de:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    25e0:	0e 94 de 13 	call	0x27bc	; 0x27bc <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    25e4:	a0 91 fa 04 	lds	r26, 0x04FA
    25e8:	b0 91 fb 04 	lds	r27, 0x04FB
    25ec:	cd 91       	ld	r28, X+
    25ee:	cd bf       	out	0x3d, r28	; 61
    25f0:	dd 91       	ld	r29, X+
    25f2:	de bf       	out	0x3e, r29	; 62
    25f4:	ff 91       	pop	r31
    25f6:	ef 91       	pop	r30
    25f8:	df 91       	pop	r29
    25fa:	cf 91       	pop	r28
    25fc:	bf 91       	pop	r27
    25fe:	af 91       	pop	r26
    2600:	9f 91       	pop	r25
    2602:	8f 91       	pop	r24
    2604:	7f 91       	pop	r23
    2606:	6f 91       	pop	r22
    2608:	5f 91       	pop	r21
    260a:	4f 91       	pop	r20
    260c:	3f 91       	pop	r19
    260e:	2f 91       	pop	r18
    2610:	1f 91       	pop	r17
    2612:	0f 91       	pop	r16
    2614:	ff 90       	pop	r15
    2616:	ef 90       	pop	r14
    2618:	df 90       	pop	r13
    261a:	cf 90       	pop	r12
    261c:	bf 90       	pop	r11
    261e:	af 90       	pop	r10
    2620:	9f 90       	pop	r9
    2622:	8f 90       	pop	r8
    2624:	7f 90       	pop	r7
    2626:	6f 90       	pop	r6
    2628:	5f 90       	pop	r5
    262a:	4f 90       	pop	r4
    262c:	3f 90       	pop	r3
    262e:	2f 90       	pop	r2
    2630:	1f 90       	pop	r1
    2632:	0f 90       	pop	r0
    2634:	0f be       	out	0x3f, r0	; 63
    2636:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2638:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    263a:	81 e0       	ldi	r24, 0x01	; 1
}
    263c:	df 91       	pop	r29
    263e:	cf 91       	pop	r28
    2640:	08 95       	ret

00002642 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2642:	cf 93       	push	r28
    2644:	df 93       	push	r29
    2646:	cd b7       	in	r28, 0x3d	; 61
    2648:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    264a:	df 91       	pop	r29
    264c:	cf 91       	pop	r28
    264e:	08 95       	ret

00002650 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2650:	0f 92       	push	r0
    2652:	0f b6       	in	r0, 0x3f	; 63
    2654:	f8 94       	cli
    2656:	0f 92       	push	r0
    2658:	1f 92       	push	r1
    265a:	11 24       	eor	r1, r1
    265c:	2f 92       	push	r2
    265e:	3f 92       	push	r3
    2660:	4f 92       	push	r4
    2662:	5f 92       	push	r5
    2664:	6f 92       	push	r6
    2666:	7f 92       	push	r7
    2668:	8f 92       	push	r8
    266a:	9f 92       	push	r9
    266c:	af 92       	push	r10
    266e:	bf 92       	push	r11
    2670:	cf 92       	push	r12
    2672:	df 92       	push	r13
    2674:	ef 92       	push	r14
    2676:	ff 92       	push	r15
    2678:	0f 93       	push	r16
    267a:	1f 93       	push	r17
    267c:	2f 93       	push	r18
    267e:	3f 93       	push	r19
    2680:	4f 93       	push	r20
    2682:	5f 93       	push	r21
    2684:	6f 93       	push	r22
    2686:	7f 93       	push	r23
    2688:	8f 93       	push	r24
    268a:	9f 93       	push	r25
    268c:	af 93       	push	r26
    268e:	bf 93       	push	r27
    2690:	cf 93       	push	r28
    2692:	df 93       	push	r29
    2694:	ef 93       	push	r30
    2696:	ff 93       	push	r31
    2698:	a0 91 fa 04 	lds	r26, 0x04FA
    269c:	b0 91 fb 04 	lds	r27, 0x04FB
    26a0:	0d b6       	in	r0, 0x3d	; 61
    26a2:	0d 92       	st	X+, r0
    26a4:	0e b6       	in	r0, 0x3e	; 62
    26a6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    26a8:	0e 94 df 1e 	call	0x3dbe	; 0x3dbe <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    26ac:	a0 91 fa 04 	lds	r26, 0x04FA
    26b0:	b0 91 fb 04 	lds	r27, 0x04FB
    26b4:	cd 91       	ld	r28, X+
    26b6:	cd bf       	out	0x3d, r28	; 61
    26b8:	dd 91       	ld	r29, X+
    26ba:	de bf       	out	0x3e, r29	; 62
    26bc:	ff 91       	pop	r31
    26be:	ef 91       	pop	r30
    26c0:	df 91       	pop	r29
    26c2:	cf 91       	pop	r28
    26c4:	bf 91       	pop	r27
    26c6:	af 91       	pop	r26
    26c8:	9f 91       	pop	r25
    26ca:	8f 91       	pop	r24
    26cc:	7f 91       	pop	r23
    26ce:	6f 91       	pop	r22
    26d0:	5f 91       	pop	r21
    26d2:	4f 91       	pop	r20
    26d4:	3f 91       	pop	r19
    26d6:	2f 91       	pop	r18
    26d8:	1f 91       	pop	r17
    26da:	0f 91       	pop	r16
    26dc:	ff 90       	pop	r15
    26de:	ef 90       	pop	r14
    26e0:	df 90       	pop	r13
    26e2:	cf 90       	pop	r12
    26e4:	bf 90       	pop	r11
    26e6:	af 90       	pop	r10
    26e8:	9f 90       	pop	r9
    26ea:	8f 90       	pop	r8
    26ec:	7f 90       	pop	r7
    26ee:	6f 90       	pop	r6
    26f0:	5f 90       	pop	r5
    26f2:	4f 90       	pop	r4
    26f4:	3f 90       	pop	r3
    26f6:	2f 90       	pop	r2
    26f8:	1f 90       	pop	r1
    26fa:	0f 90       	pop	r0
    26fc:	0f be       	out	0x3f, r0	; 63
    26fe:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2700:	08 95       	ret

00002702 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2702:	0f 92       	push	r0
    2704:	0f b6       	in	r0, 0x3f	; 63
    2706:	f8 94       	cli
    2708:	0f 92       	push	r0
    270a:	1f 92       	push	r1
    270c:	11 24       	eor	r1, r1
    270e:	2f 92       	push	r2
    2710:	3f 92       	push	r3
    2712:	4f 92       	push	r4
    2714:	5f 92       	push	r5
    2716:	6f 92       	push	r6
    2718:	7f 92       	push	r7
    271a:	8f 92       	push	r8
    271c:	9f 92       	push	r9
    271e:	af 92       	push	r10
    2720:	bf 92       	push	r11
    2722:	cf 92       	push	r12
    2724:	df 92       	push	r13
    2726:	ef 92       	push	r14
    2728:	ff 92       	push	r15
    272a:	0f 93       	push	r16
    272c:	1f 93       	push	r17
    272e:	2f 93       	push	r18
    2730:	3f 93       	push	r19
    2732:	4f 93       	push	r20
    2734:	5f 93       	push	r21
    2736:	6f 93       	push	r22
    2738:	7f 93       	push	r23
    273a:	8f 93       	push	r24
    273c:	9f 93       	push	r25
    273e:	af 93       	push	r26
    2740:	bf 93       	push	r27
    2742:	cf 93       	push	r28
    2744:	df 93       	push	r29
    2746:	ef 93       	push	r30
    2748:	ff 93       	push	r31
    274a:	a0 91 fa 04 	lds	r26, 0x04FA
    274e:	b0 91 fb 04 	lds	r27, 0x04FB
    2752:	0d b6       	in	r0, 0x3d	; 61
    2754:	0d 92       	st	X+, r0
    2756:	0e b6       	in	r0, 0x3e	; 62
    2758:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    275a:	0e 94 f1 1d 	call	0x3be2	; 0x3be2 <xTaskIncrementTick>
    275e:	88 23       	and	r24, r24
    2760:	11 f0       	breq	.+4      	; 0x2766 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2762:	0e 94 df 1e 	call	0x3dbe	; 0x3dbe <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2766:	a0 91 fa 04 	lds	r26, 0x04FA
    276a:	b0 91 fb 04 	lds	r27, 0x04FB
    276e:	cd 91       	ld	r28, X+
    2770:	cd bf       	out	0x3d, r28	; 61
    2772:	dd 91       	ld	r29, X+
    2774:	de bf       	out	0x3e, r29	; 62
    2776:	ff 91       	pop	r31
    2778:	ef 91       	pop	r30
    277a:	df 91       	pop	r29
    277c:	cf 91       	pop	r28
    277e:	bf 91       	pop	r27
    2780:	af 91       	pop	r26
    2782:	9f 91       	pop	r25
    2784:	8f 91       	pop	r24
    2786:	7f 91       	pop	r23
    2788:	6f 91       	pop	r22
    278a:	5f 91       	pop	r21
    278c:	4f 91       	pop	r20
    278e:	3f 91       	pop	r19
    2790:	2f 91       	pop	r18
    2792:	1f 91       	pop	r17
    2794:	0f 91       	pop	r16
    2796:	ff 90       	pop	r15
    2798:	ef 90       	pop	r14
    279a:	df 90       	pop	r13
    279c:	cf 90       	pop	r12
    279e:	bf 90       	pop	r11
    27a0:	af 90       	pop	r10
    27a2:	9f 90       	pop	r9
    27a4:	8f 90       	pop	r8
    27a6:	7f 90       	pop	r7
    27a8:	6f 90       	pop	r6
    27aa:	5f 90       	pop	r5
    27ac:	4f 90       	pop	r4
    27ae:	3f 90       	pop	r3
    27b0:	2f 90       	pop	r2
    27b2:	1f 90       	pop	r1
    27b4:	0f 90       	pop	r0
    27b6:	0f be       	out	0x3f, r0	; 63
    27b8:	0f 90       	pop	r0

	asm volatile ( "ret" );
    27ba:	08 95       	ret

000027bc <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    27bc:	cf 93       	push	r28
    27be:	df 93       	push	r29
    27c0:	00 d0       	rcall	.+0      	; 0x27c2 <prvSetupTimerInterrupt+0x6>
    27c2:	00 d0       	rcall	.+0      	; 0x27c4 <prvSetupTimerInterrupt+0x8>
    27c4:	00 d0       	rcall	.+0      	; 0x27c6 <prvSetupTimerInterrupt+0xa>
    27c6:	cd b7       	in	r28, 0x3d	; 61
    27c8:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    27ca:	80 e8       	ldi	r24, 0x80	; 128
    27cc:	9e e3       	ldi	r25, 0x3E	; 62
    27ce:	a0 e0       	ldi	r26, 0x00	; 0
    27d0:	b0 e0       	ldi	r27, 0x00	; 0
    27d2:	89 83       	std	Y+1, r24	; 0x01
    27d4:	9a 83       	std	Y+2, r25	; 0x02
    27d6:	ab 83       	std	Y+3, r26	; 0x03
    27d8:	bc 83       	std	Y+4, r27	; 0x04

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    27da:	89 81       	ldd	r24, Y+1	; 0x01
    27dc:	9a 81       	ldd	r25, Y+2	; 0x02
    27de:	ab 81       	ldd	r26, Y+3	; 0x03
    27e0:	bc 81       	ldd	r27, Y+4	; 0x04
    27e2:	68 94       	set
    27e4:	15 f8       	bld	r1, 5
    27e6:	b6 95       	lsr	r27
    27e8:	a7 95       	ror	r26
    27ea:	97 95       	ror	r25
    27ec:	87 95       	ror	r24
    27ee:	16 94       	lsr	r1
    27f0:	d1 f7       	brne	.-12     	; 0x27e6 <prvSetupTimerInterrupt+0x2a>
    27f2:	89 83       	std	Y+1, r24	; 0x01
    27f4:	9a 83       	std	Y+2, r25	; 0x02
    27f6:	ab 83       	std	Y+3, r26	; 0x03
    27f8:	bc 83       	std	Y+4, r27	; 0x04

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    27fa:	89 81       	ldd	r24, Y+1	; 0x01
    27fc:	9a 81       	ldd	r25, Y+2	; 0x02
    27fe:	ab 81       	ldd	r26, Y+3	; 0x03
    2800:	bc 81       	ldd	r27, Y+4	; 0x04
    2802:	01 97       	sbiw	r24, 0x01	; 1
    2804:	a1 09       	sbc	r26, r1
    2806:	b1 09       	sbc	r27, r1
    2808:	89 83       	std	Y+1, r24	; 0x01
    280a:	9a 83       	std	Y+2, r25	; 0x02
    280c:	ab 83       	std	Y+3, r26	; 0x03
    280e:	bc 83       	std	Y+4, r27	; 0x04

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2810:	89 81       	ldd	r24, Y+1	; 0x01
    2812:	8d 83       	std	Y+5, r24	; 0x05
	ulCompareMatch >>= 8;
    2814:	89 81       	ldd	r24, Y+1	; 0x01
    2816:	9a 81       	ldd	r25, Y+2	; 0x02
    2818:	ab 81       	ldd	r26, Y+3	; 0x03
    281a:	bc 81       	ldd	r27, Y+4	; 0x04
    281c:	89 2f       	mov	r24, r25
    281e:	9a 2f       	mov	r25, r26
    2820:	ab 2f       	mov	r26, r27
    2822:	bb 27       	eor	r27, r27
    2824:	89 83       	std	Y+1, r24	; 0x01
    2826:	9a 83       	std	Y+2, r25	; 0x02
    2828:	ab 83       	std	Y+3, r26	; 0x03
    282a:	bc 83       	std	Y+4, r27	; 0x04
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    282c:	89 81       	ldd	r24, Y+1	; 0x01
    282e:	8e 83       	std	Y+6, r24	; 0x06
	OCR1AH = ucHighByte;
    2830:	89 e8       	ldi	r24, 0x89	; 137
    2832:	90 e0       	ldi	r25, 0x00	; 0
    2834:	2e 81       	ldd	r18, Y+6	; 0x06
    2836:	fc 01       	movw	r30, r24
    2838:	20 83       	st	Z, r18
	OCR1AL = ucLowByte;
    283a:	88 e8       	ldi	r24, 0x88	; 136
    283c:	90 e0       	ldi	r25, 0x00	; 0
    283e:	2d 81       	ldd	r18, Y+5	; 0x05
    2840:	fc 01       	movw	r30, r24
    2842:	20 83       	st	Z, r18

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2844:	8b e0       	ldi	r24, 0x0B	; 11
    2846:	8d 83       	std	Y+5, r24	; 0x05
	TCCR1B = ucLowByte;
    2848:	81 e8       	ldi	r24, 0x81	; 129
    284a:	90 e0       	ldi	r25, 0x00	; 0
    284c:	2d 81       	ldd	r18, Y+5	; 0x05
    284e:	fc 01       	movw	r30, r24
    2850:	20 83       	st	Z, r18

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    2852:	8f e6       	ldi	r24, 0x6F	; 111
    2854:	90 e0       	ldi	r25, 0x00	; 0
    2856:	fc 01       	movw	r30, r24
    2858:	80 81       	ld	r24, Z
    285a:	8d 83       	std	Y+5, r24	; 0x05
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    285c:	8d 81       	ldd	r24, Y+5	; 0x05
    285e:	82 60       	ori	r24, 0x02	; 2
    2860:	8d 83       	std	Y+5, r24	; 0x05
	TIMSK1 = ucLowByte;
    2862:	8f e6       	ldi	r24, 0x6F	; 111
    2864:	90 e0       	ldi	r25, 0x00	; 0
    2866:	2d 81       	ldd	r18, Y+5	; 0x05
    2868:	fc 01       	movw	r30, r24
    286a:	20 83       	st	Z, r18
	
	TCNT1 = 0;
    286c:	84 e8       	ldi	r24, 0x84	; 132
    286e:	90 e0       	ldi	r25, 0x00	; 0
    2870:	fc 01       	movw	r30, r24
    2872:	11 82       	std	Z+1, r1	; 0x01
    2874:	10 82       	st	Z, r1
}
    2876:	26 96       	adiw	r28, 0x06	; 6
    2878:	0f b6       	in	r0, 0x3f	; 63
    287a:	f8 94       	cli
    287c:	de bf       	out	0x3e, r29	; 62
    287e:	0f be       	out	0x3f, r0	; 63
    2880:	cd bf       	out	0x3d, r28	; 61
    2882:	df 91       	pop	r29
    2884:	cf 91       	pop	r28
    2886:	08 95       	ret

00002888 <__vector_12>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	ISR(TIMER1_COMPA_vect, ISR_NAKED)
	{
		vPortYieldFromTick();
    2888:	0e 94 81 13 	call	0x2702	; 0x2702 <vPortYieldFromTick>
		asm volatile ( "reti" );
    288c:	18 95       	reti

0000288e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    288e:	cf 93       	push	r28
    2890:	df 93       	push	r29
    2892:	00 d0       	rcall	.+0      	; 0x2894 <pvPortMalloc+0x6>
    2894:	00 d0       	rcall	.+0      	; 0x2896 <pvPortMalloc+0x8>
    2896:	cd b7       	in	r28, 0x3d	; 61
    2898:	de b7       	in	r29, 0x3e	; 62
    289a:	9c 83       	std	Y+4, r25	; 0x04
    289c:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    289e:	1a 82       	std	Y+2, r1	; 0x02
    28a0:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    28a2:	0e 94 22 1d 	call	0x3a44	; 0x3a44 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    28a6:	80 91 f8 04 	lds	r24, 0x04F8
    28aa:	90 91 f9 04 	lds	r25, 0x04F9
    28ae:	89 2b       	or	r24, r25
    28b0:	31 f4       	brne	.+12     	; 0x28be <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    28b2:	8f e0       	ldi	r24, 0x0F	; 15
    28b4:	91 e0       	ldi	r25, 0x01	; 1
    28b6:	90 93 f9 04 	sts	0x04F9, r25
    28ba:	80 93 f8 04 	sts	0x04F8, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    28be:	20 91 f6 04 	lds	r18, 0x04F6
    28c2:	30 91 f7 04 	lds	r19, 0x04F7
    28c6:	8b 81       	ldd	r24, Y+3	; 0x03
    28c8:	9c 81       	ldd	r25, Y+4	; 0x04
    28ca:	82 0f       	add	r24, r18
    28cc:	93 1f       	adc	r25, r19
    28ce:	87 3e       	cpi	r24, 0xE7	; 231
    28d0:	93 40       	sbci	r25, 0x03	; 3
    28d2:	38 f5       	brcc	.+78     	; 0x2922 <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    28d4:	20 91 f6 04 	lds	r18, 0x04F6
    28d8:	30 91 f7 04 	lds	r19, 0x04F7
    28dc:	8b 81       	ldd	r24, Y+3	; 0x03
    28de:	9c 81       	ldd	r25, Y+4	; 0x04
    28e0:	28 0f       	add	r18, r24
    28e2:	39 1f       	adc	r19, r25
    28e4:	80 91 f6 04 	lds	r24, 0x04F6
    28e8:	90 91 f7 04 	lds	r25, 0x04F7
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    28ec:	82 17       	cp	r24, r18
    28ee:	93 07       	cpc	r25, r19
    28f0:	c0 f4       	brcc	.+48     	; 0x2922 <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    28f2:	20 91 f8 04 	lds	r18, 0x04F8
    28f6:	30 91 f9 04 	lds	r19, 0x04F9
    28fa:	80 91 f6 04 	lds	r24, 0x04F6
    28fe:	90 91 f7 04 	lds	r25, 0x04F7
    2902:	82 0f       	add	r24, r18
    2904:	93 1f       	adc	r25, r19
    2906:	9a 83       	std	Y+2, r25	; 0x02
    2908:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    290a:	20 91 f6 04 	lds	r18, 0x04F6
    290e:	30 91 f7 04 	lds	r19, 0x04F7
    2912:	8b 81       	ldd	r24, Y+3	; 0x03
    2914:	9c 81       	ldd	r25, Y+4	; 0x04
    2916:	82 0f       	add	r24, r18
    2918:	93 1f       	adc	r25, r19
    291a:	90 93 f7 04 	sts	0x04F7, r25
    291e:	80 93 f6 04 	sts	0x04F6, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2922:	0e 94 2e 1d 	call	0x3a5c	; 0x3a5c <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    2926:	89 81       	ldd	r24, Y+1	; 0x01
    2928:	9a 81       	ldd	r25, Y+2	; 0x02
}
    292a:	0f 90       	pop	r0
    292c:	0f 90       	pop	r0
    292e:	0f 90       	pop	r0
    2930:	0f 90       	pop	r0
    2932:	df 91       	pop	r29
    2934:	cf 91       	pop	r28
    2936:	08 95       	ret

00002938 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2938:	cf 93       	push	r28
    293a:	df 93       	push	r29
    293c:	00 d0       	rcall	.+0      	; 0x293e <vPortFree+0x6>
    293e:	cd b7       	in	r28, 0x3d	; 61
    2940:	de b7       	in	r29, 0x3e	; 62
    2942:	9a 83       	std	Y+2, r25	; 0x02
    2944:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    2946:	0f 90       	pop	r0
    2948:	0f 90       	pop	r0
    294a:	df 91       	pop	r29
    294c:	cf 91       	pop	r28
    294e:	08 95       	ret

00002950 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2950:	cf 93       	push	r28
    2952:	df 93       	push	r29
    2954:	cd b7       	in	r28, 0x3d	; 61
    2956:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2958:	10 92 f7 04 	sts	0x04F7, r1
    295c:	10 92 f6 04 	sts	0x04F6, r1
}
    2960:	df 91       	pop	r29
    2962:	cf 91       	pop	r28
    2964:	08 95       	ret

00002966 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2966:	cf 93       	push	r28
    2968:	df 93       	push	r29
    296a:	cd b7       	in	r28, 0x3d	; 61
    296c:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    296e:	80 91 f6 04 	lds	r24, 0x04F6
    2972:	90 91 f7 04 	lds	r25, 0x04F7
    2976:	27 ee       	ldi	r18, 0xE7	; 231
    2978:	33 e0       	ldi	r19, 0x03	; 3
    297a:	a9 01       	movw	r20, r18
    297c:	48 1b       	sub	r20, r24
    297e:	59 0b       	sbc	r21, r25
    2980:	ca 01       	movw	r24, r20
}
    2982:	df 91       	pop	r29
    2984:	cf 91       	pop	r28
    2986:	08 95       	ret

00002988 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    2988:	cf 93       	push	r28
    298a:	df 93       	push	r29
    298c:	00 d0       	rcall	.+0      	; 0x298e <xQueueGenericReset+0x6>
    298e:	00 d0       	rcall	.+0      	; 0x2990 <xQueueGenericReset+0x8>
    2990:	1f 92       	push	r1
    2992:	cd b7       	in	r28, 0x3d	; 61
    2994:	de b7       	in	r29, 0x3e	; 62
    2996:	9c 83       	std	Y+4, r25	; 0x04
    2998:	8b 83       	std	Y+3, r24	; 0x03
    299a:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    299c:	8b 81       	ldd	r24, Y+3	; 0x03
    299e:	9c 81       	ldd	r25, Y+4	; 0x04
    29a0:	9a 83       	std	Y+2, r25	; 0x02
    29a2:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    29a4:	0f b6       	in	r0, 0x3f	; 63
    29a6:	f8 94       	cli
    29a8:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    29aa:	89 81       	ldd	r24, Y+1	; 0x01
    29ac:	9a 81       	ldd	r25, Y+2	; 0x02
    29ae:	fc 01       	movw	r30, r24
    29b0:	80 81       	ld	r24, Z
    29b2:	91 81       	ldd	r25, Z+1	; 0x01
    29b4:	29 81       	ldd	r18, Y+1	; 0x01
    29b6:	3a 81       	ldd	r19, Y+2	; 0x02
    29b8:	f9 01       	movw	r30, r18
    29ba:	23 8d       	ldd	r18, Z+27	; 0x1b
    29bc:	42 2f       	mov	r20, r18
    29be:	50 e0       	ldi	r21, 0x00	; 0
    29c0:	29 81       	ldd	r18, Y+1	; 0x01
    29c2:	3a 81       	ldd	r19, Y+2	; 0x02
    29c4:	f9 01       	movw	r30, r18
    29c6:	24 8d       	ldd	r18, Z+28	; 0x1c
    29c8:	22 2f       	mov	r18, r18
    29ca:	30 e0       	ldi	r19, 0x00	; 0
    29cc:	42 9f       	mul	r20, r18
    29ce:	b0 01       	movw	r22, r0
    29d0:	43 9f       	mul	r20, r19
    29d2:	70 0d       	add	r23, r0
    29d4:	52 9f       	mul	r21, r18
    29d6:	70 0d       	add	r23, r0
    29d8:	11 24       	eor	r1, r1
    29da:	9b 01       	movw	r18, r22
    29dc:	28 0f       	add	r18, r24
    29de:	39 1f       	adc	r19, r25
    29e0:	89 81       	ldd	r24, Y+1	; 0x01
    29e2:	9a 81       	ldd	r25, Y+2	; 0x02
    29e4:	fc 01       	movw	r30, r24
    29e6:	33 83       	std	Z+3, r19	; 0x03
    29e8:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    29ea:	89 81       	ldd	r24, Y+1	; 0x01
    29ec:	9a 81       	ldd	r25, Y+2	; 0x02
    29ee:	fc 01       	movw	r30, r24
    29f0:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    29f2:	89 81       	ldd	r24, Y+1	; 0x01
    29f4:	9a 81       	ldd	r25, Y+2	; 0x02
    29f6:	fc 01       	movw	r30, r24
    29f8:	20 81       	ld	r18, Z
    29fa:	31 81       	ldd	r19, Z+1	; 0x01
    29fc:	89 81       	ldd	r24, Y+1	; 0x01
    29fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2a00:	fc 01       	movw	r30, r24
    2a02:	35 83       	std	Z+5, r19	; 0x05
    2a04:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    2a06:	89 81       	ldd	r24, Y+1	; 0x01
    2a08:	9a 81       	ldd	r25, Y+2	; 0x02
    2a0a:	fc 01       	movw	r30, r24
    2a0c:	80 81       	ld	r24, Z
    2a0e:	91 81       	ldd	r25, Z+1	; 0x01
    2a10:	29 81       	ldd	r18, Y+1	; 0x01
    2a12:	3a 81       	ldd	r19, Y+2	; 0x02
    2a14:	f9 01       	movw	r30, r18
    2a16:	23 8d       	ldd	r18, Z+27	; 0x1b
    2a18:	22 2f       	mov	r18, r18
    2a1a:	30 e0       	ldi	r19, 0x00	; 0
    2a1c:	a9 01       	movw	r20, r18
    2a1e:	41 50       	subi	r20, 0x01	; 1
    2a20:	51 09       	sbc	r21, r1
    2a22:	29 81       	ldd	r18, Y+1	; 0x01
    2a24:	3a 81       	ldd	r19, Y+2	; 0x02
    2a26:	f9 01       	movw	r30, r18
    2a28:	24 8d       	ldd	r18, Z+28	; 0x1c
    2a2a:	22 2f       	mov	r18, r18
    2a2c:	30 e0       	ldi	r19, 0x00	; 0
    2a2e:	42 9f       	mul	r20, r18
    2a30:	b0 01       	movw	r22, r0
    2a32:	43 9f       	mul	r20, r19
    2a34:	70 0d       	add	r23, r0
    2a36:	52 9f       	mul	r21, r18
    2a38:	70 0d       	add	r23, r0
    2a3a:	11 24       	eor	r1, r1
    2a3c:	9b 01       	movw	r18, r22
    2a3e:	28 0f       	add	r18, r24
    2a40:	39 1f       	adc	r19, r25
    2a42:	89 81       	ldd	r24, Y+1	; 0x01
    2a44:	9a 81       	ldd	r25, Y+2	; 0x02
    2a46:	fc 01       	movw	r30, r24
    2a48:	37 83       	std	Z+7, r19	; 0x07
    2a4a:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    2a4c:	89 81       	ldd	r24, Y+1	; 0x01
    2a4e:	9a 81       	ldd	r25, Y+2	; 0x02
    2a50:	2f ef       	ldi	r18, 0xFF	; 255
    2a52:	fc 01       	movw	r30, r24
    2a54:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    2a56:	89 81       	ldd	r24, Y+1	; 0x01
    2a58:	9a 81       	ldd	r25, Y+2	; 0x02
    2a5a:	2f ef       	ldi	r18, 0xFF	; 255
    2a5c:	fc 01       	movw	r30, r24
    2a5e:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    2a60:	8d 81       	ldd	r24, Y+5	; 0x05
    2a62:	88 23       	and	r24, r24
    2a64:	81 f4       	brne	.+32     	; 0x2a86 <xQueueGenericReset+0xfe>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2a66:	89 81       	ldd	r24, Y+1	; 0x01
    2a68:	9a 81       	ldd	r25, Y+2	; 0x02
    2a6a:	fc 01       	movw	r30, r24
    2a6c:	80 85       	ldd	r24, Z+8	; 0x08
    2a6e:	88 23       	and	r24, r24
    2a70:	a1 f0       	breq	.+40     	; 0x2a9a <xQueueGenericReset+0x112>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2a72:	89 81       	ldd	r24, Y+1	; 0x01
    2a74:	9a 81       	ldd	r25, Y+2	; 0x02
    2a76:	08 96       	adiw	r24, 0x08	; 8
    2a78:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <xTaskRemoveFromEventList>
    2a7c:	81 30       	cpi	r24, 0x01	; 1
    2a7e:	69 f4       	brne	.+26     	; 0x2a9a <xQueueGenericReset+0x112>
				{
					queueYIELD_IF_USING_PREEMPTION();
    2a80:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortYield>
    2a84:	0a c0       	rjmp	.+20     	; 0x2a9a <xQueueGenericReset+0x112>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2a86:	89 81       	ldd	r24, Y+1	; 0x01
    2a88:	9a 81       	ldd	r25, Y+2	; 0x02
    2a8a:	08 96       	adiw	r24, 0x08	; 8
    2a8c:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    2a90:	89 81       	ldd	r24, Y+1	; 0x01
    2a92:	9a 81       	ldd	r25, Y+2	; 0x02
    2a94:	41 96       	adiw	r24, 0x11	; 17
    2a96:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    2a9a:	0f 90       	pop	r0
    2a9c:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    2a9e:	81 e0       	ldi	r24, 0x01	; 1
}
    2aa0:	0f 90       	pop	r0
    2aa2:	0f 90       	pop	r0
    2aa4:	0f 90       	pop	r0
    2aa6:	0f 90       	pop	r0
    2aa8:	0f 90       	pop	r0
    2aaa:	df 91       	pop	r29
    2aac:	cf 91       	pop	r28
    2aae:	08 95       	ret

00002ab0 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    2ab0:	cf 93       	push	r28
    2ab2:	df 93       	push	r29
    2ab4:	cd b7       	in	r28, 0x3d	; 61
    2ab6:	de b7       	in	r29, 0x3e	; 62
    2ab8:	29 97       	sbiw	r28, 0x09	; 9
    2aba:	0f b6       	in	r0, 0x3f	; 63
    2abc:	f8 94       	cli
    2abe:	de bf       	out	0x3e, r29	; 62
    2ac0:	0f be       	out	0x3f, r0	; 63
    2ac2:	cd bf       	out	0x3d, r28	; 61
    2ac4:	8f 83       	std	Y+7, r24	; 0x07
    2ac6:	68 87       	std	Y+8, r22	; 0x08
    2ac8:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    2aca:	1c 82       	std	Y+4, r1	; 0x04
    2acc:	1b 82       	std	Y+3, r1	; 0x03
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
    2ace:	88 85       	ldd	r24, Y+8	; 0x08
    2ad0:	88 23       	and	r24, r24
    2ad2:	19 f4       	brne	.+6      	; 0x2ada <xQueueGenericCreate+0x2a>
	{
		/* There is not going to be a queue storage area. */
		xQueueSizeInBytes = ( size_t ) 0;
    2ad4:	1a 82       	std	Y+2, r1	; 0x02
    2ad6:	19 82       	std	Y+1, r1	; 0x01
    2ad8:	11 c0       	rjmp	.+34     	; 0x2afc <xQueueGenericCreate+0x4c>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2ada:	8f 81       	ldd	r24, Y+7	; 0x07
    2adc:	28 2f       	mov	r18, r24
    2ade:	30 e0       	ldi	r19, 0x00	; 0
    2ae0:	88 85       	ldd	r24, Y+8	; 0x08
    2ae2:	88 2f       	mov	r24, r24
    2ae4:	90 e0       	ldi	r25, 0x00	; 0
    2ae6:	28 9f       	mul	r18, r24
    2ae8:	a0 01       	movw	r20, r0
    2aea:	29 9f       	mul	r18, r25
    2aec:	50 0d       	add	r21, r0
    2aee:	38 9f       	mul	r19, r24
    2af0:	50 0d       	add	r21, r0
    2af2:	11 24       	eor	r1, r1
    2af4:	ca 01       	movw	r24, r20
    2af6:	01 96       	adiw	r24, 0x01	; 1
    2af8:	9a 83       	std	Y+2, r25	; 0x02
    2afa:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    2afc:	89 81       	ldd	r24, Y+1	; 0x01
    2afe:	9a 81       	ldd	r25, Y+2	; 0x02
    2b00:	4f 96       	adiw	r24, 0x1f	; 31
    2b02:	0e 94 47 14 	call	0x288e	; 0x288e <pvPortMalloc>
    2b06:	9e 83       	std	Y+6, r25	; 0x06
    2b08:	8d 83       	std	Y+5, r24	; 0x05

	if( pxNewQueue != NULL )
    2b0a:	8d 81       	ldd	r24, Y+5	; 0x05
    2b0c:	9e 81       	ldd	r25, Y+6	; 0x06
    2b0e:	89 2b       	or	r24, r25
    2b10:	41 f1       	breq	.+80     	; 0x2b62 <xQueueGenericCreate+0xb2>
	{
		if( uxItemSize == ( UBaseType_t ) 0 )
    2b12:	88 85       	ldd	r24, Y+8	; 0x08
    2b14:	88 23       	and	r24, r24
    2b16:	41 f4       	brne	.+16     	; 0x2b28 <xQueueGenericCreate+0x78>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    2b18:	8d 81       	ldd	r24, Y+5	; 0x05
    2b1a:	9e 81       	ldd	r25, Y+6	; 0x06
    2b1c:	2d 81       	ldd	r18, Y+5	; 0x05
    2b1e:	3e 81       	ldd	r19, Y+6	; 0x06
    2b20:	fc 01       	movw	r30, r24
    2b22:	31 83       	std	Z+1, r19	; 0x01
    2b24:	20 83       	st	Z, r18
    2b26:	0a c0       	rjmp	.+20     	; 0x2b3c <xQueueGenericCreate+0x8c>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
    2b28:	8d 81       	ldd	r24, Y+5	; 0x05
    2b2a:	9e 81       	ldd	r25, Y+6	; 0x06
    2b2c:	9c 01       	movw	r18, r24
    2b2e:	21 5e       	subi	r18, 0xE1	; 225
    2b30:	3f 4f       	sbci	r19, 0xFF	; 255
    2b32:	8d 81       	ldd	r24, Y+5	; 0x05
    2b34:	9e 81       	ldd	r25, Y+6	; 0x06
    2b36:	fc 01       	movw	r30, r24
    2b38:	31 83       	std	Z+1, r19	; 0x01
    2b3a:	20 83       	st	Z, r18
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
    2b3c:	8d 81       	ldd	r24, Y+5	; 0x05
    2b3e:	9e 81       	ldd	r25, Y+6	; 0x06
    2b40:	2f 81       	ldd	r18, Y+7	; 0x07
    2b42:	fc 01       	movw	r30, r24
    2b44:	23 8f       	std	Z+27, r18	; 0x1b
		pxNewQueue->uxItemSize = uxItemSize;
    2b46:	8d 81       	ldd	r24, Y+5	; 0x05
    2b48:	9e 81       	ldd	r25, Y+6	; 0x06
    2b4a:	28 85       	ldd	r18, Y+8	; 0x08
    2b4c:	fc 01       	movw	r30, r24
    2b4e:	24 8f       	std	Z+28, r18	; 0x1c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2b50:	8d 81       	ldd	r24, Y+5	; 0x05
    2b52:	9e 81       	ldd	r25, Y+6	; 0x06
    2b54:	61 e0       	ldi	r22, 0x01	; 1
    2b56:	0e 94 c4 14 	call	0x2988	; 0x2988 <xQueueGenericReset>
			pxNewQueue->pxQueueSetContainer = NULL;
		}
		#endif /* configUSE_QUEUE_SETS */

		traceQUEUE_CREATE( pxNewQueue );
		xReturn = pxNewQueue;
    2b5a:	8d 81       	ldd	r24, Y+5	; 0x05
    2b5c:	9e 81       	ldd	r25, Y+6	; 0x06
    2b5e:	9c 83       	std	Y+4, r25	; 0x04
    2b60:	8b 83       	std	Y+3, r24	; 0x03
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    2b62:	8b 81       	ldd	r24, Y+3	; 0x03
    2b64:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2b66:	29 96       	adiw	r28, 0x09	; 9
    2b68:	0f b6       	in	r0, 0x3f	; 63
    2b6a:	f8 94       	cli
    2b6c:	de bf       	out	0x3e, r29	; 62
    2b6e:	0f be       	out	0x3f, r0	; 63
    2b70:	cd bf       	out	0x3d, r28	; 61
    2b72:	df 91       	pop	r29
    2b74:	cf 91       	pop	r28
    2b76:	08 95       	ret

00002b78 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    2b78:	cf 93       	push	r28
    2b7a:	df 93       	push	r29
    2b7c:	cd b7       	in	r28, 0x3d	; 61
    2b7e:	de b7       	in	r29, 0x3e	; 62
    2b80:	2e 97       	sbiw	r28, 0x0e	; 14
    2b82:	0f b6       	in	r0, 0x3f	; 63
    2b84:	f8 94       	cli
    2b86:	de bf       	out	0x3e, r29	; 62
    2b88:	0f be       	out	0x3f, r0	; 63
    2b8a:	cd bf       	out	0x3d, r28	; 61
    2b8c:	99 87       	std	Y+9, r25	; 0x09
    2b8e:	88 87       	std	Y+8, r24	; 0x08
    2b90:	7b 87       	std	Y+11, r23	; 0x0b
    2b92:	6a 87       	std	Y+10, r22	; 0x0a
    2b94:	5d 87       	std	Y+13, r21	; 0x0d
    2b96:	4c 87       	std	Y+12, r20	; 0x0c
    2b98:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2b9a:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2b9c:	88 85       	ldd	r24, Y+8	; 0x08
    2b9e:	99 85       	ldd	r25, Y+9	; 0x09
    2ba0:	9b 83       	std	Y+3, r25	; 0x03
    2ba2:	8a 83       	std	Y+2, r24	; 0x02
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2ba4:	0f b6       	in	r0, 0x3f	; 63
    2ba6:	f8 94       	cli
    2ba8:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2baa:	8a 81       	ldd	r24, Y+2	; 0x02
    2bac:	9b 81       	ldd	r25, Y+3	; 0x03
    2bae:	fc 01       	movw	r30, r24
    2bb0:	22 8d       	ldd	r18, Z+26	; 0x1a
    2bb2:	8a 81       	ldd	r24, Y+2	; 0x02
    2bb4:	9b 81       	ldd	r25, Y+3	; 0x03
    2bb6:	fc 01       	movw	r30, r24
    2bb8:	83 8d       	ldd	r24, Z+27	; 0x1b
    2bba:	28 17       	cp	r18, r24
    2bbc:	18 f0       	brcs	.+6      	; 0x2bc4 <xQueueGenericSend+0x4c>
    2bbe:	8e 85       	ldd	r24, Y+14	; 0x0e
    2bc0:	82 30       	cpi	r24, 0x02	; 2
    2bc2:	11 f5       	brne	.+68     	; 0x2c08 <xQueueGenericSend+0x90>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2bc4:	2a 85       	ldd	r18, Y+10	; 0x0a
    2bc6:	3b 85       	ldd	r19, Y+11	; 0x0b
    2bc8:	8a 81       	ldd	r24, Y+2	; 0x02
    2bca:	9b 81       	ldd	r25, Y+3	; 0x03
    2bcc:	4e 85       	ldd	r20, Y+14	; 0x0e
    2bce:	b9 01       	movw	r22, r18
    2bd0:	0e 94 01 19 	call	0x3202	; 0x3202 <prvCopyDataToQueue>
    2bd4:	8c 83       	std	Y+4, r24	; 0x04
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2bd6:	8a 81       	ldd	r24, Y+2	; 0x02
    2bd8:	9b 81       	ldd	r25, Y+3	; 0x03
    2bda:	fc 01       	movw	r30, r24
    2bdc:	81 89       	ldd	r24, Z+17	; 0x11
    2bde:	88 23       	and	r24, r24
    2be0:	51 f0       	breq	.+20     	; 0x2bf6 <xQueueGenericSend+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2be2:	8a 81       	ldd	r24, Y+2	; 0x02
    2be4:	9b 81       	ldd	r25, Y+3	; 0x03
    2be6:	41 96       	adiw	r24, 0x11	; 17
    2be8:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <xTaskRemoveFromEventList>
    2bec:	81 30       	cpi	r24, 0x01	; 1
    2bee:	41 f4       	brne	.+16     	; 0x2c00 <xQueueGenericSend+0x88>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2bf0:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortYield>
    2bf4:	05 c0       	rjmp	.+10     	; 0x2c00 <xQueueGenericSend+0x88>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    2bf6:	8c 81       	ldd	r24, Y+4	; 0x04
    2bf8:	88 23       	and	r24, r24
    2bfa:	11 f0       	breq	.+4      	; 0x2c00 <xQueueGenericSend+0x88>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2bfc:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2c00:	0f 90       	pop	r0
    2c02:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2c04:	81 e0       	ldi	r24, 0x01	; 1
    2c06:	61 c0       	rjmp	.+194    	; 0x2cca <xQueueGenericSend+0x152>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2c08:	8c 85       	ldd	r24, Y+12	; 0x0c
    2c0a:	9d 85       	ldd	r25, Y+13	; 0x0d
    2c0c:	89 2b       	or	r24, r25
    2c0e:	21 f4       	brne	.+8      	; 0x2c18 <xQueueGenericSend+0xa0>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2c10:	0f 90       	pop	r0
    2c12:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2c14:	80 e0       	ldi	r24, 0x00	; 0
    2c16:	59 c0       	rjmp	.+178    	; 0x2cca <xQueueGenericSend+0x152>
				}
				else if( xEntryTimeSet == pdFALSE )
    2c18:	89 81       	ldd	r24, Y+1	; 0x01
    2c1a:	88 23       	and	r24, r24
    2c1c:	31 f4       	brne	.+12     	; 0x2c2a <xQueueGenericSend+0xb2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2c1e:	ce 01       	movw	r24, r28
    2c20:	05 96       	adiw	r24, 0x05	; 5
    2c22:	0e 94 9f 20 	call	0x413e	; 0x413e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2c26:	81 e0       	ldi	r24, 0x01	; 1
    2c28:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2c2a:	0f 90       	pop	r0
    2c2c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2c2e:	0e 94 22 1d 	call	0x3a44	; 0x3a44 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2c32:	0f b6       	in	r0, 0x3f	; 63
    2c34:	f8 94       	cli
    2c36:	0f 92       	push	r0
    2c38:	8a 81       	ldd	r24, Y+2	; 0x02
    2c3a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c3c:	fc 01       	movw	r30, r24
    2c3e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2c40:	8f 3f       	cpi	r24, 0xFF	; 255
    2c42:	21 f4       	brne	.+8      	; 0x2c4c <xQueueGenericSend+0xd4>
    2c44:	8a 81       	ldd	r24, Y+2	; 0x02
    2c46:	9b 81       	ldd	r25, Y+3	; 0x03
    2c48:	fc 01       	movw	r30, r24
    2c4a:	15 8e       	std	Z+29, r1	; 0x1d
    2c4c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c4e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c50:	fc 01       	movw	r30, r24
    2c52:	86 8d       	ldd	r24, Z+30	; 0x1e
    2c54:	8f 3f       	cpi	r24, 0xFF	; 255
    2c56:	21 f4       	brne	.+8      	; 0x2c60 <xQueueGenericSend+0xe8>
    2c58:	8a 81       	ldd	r24, Y+2	; 0x02
    2c5a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c5c:	fc 01       	movw	r30, r24
    2c5e:	16 8e       	std	Z+30, r1	; 0x1e
    2c60:	0f 90       	pop	r0
    2c62:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2c64:	9e 01       	movw	r18, r28
    2c66:	24 5f       	subi	r18, 0xF4	; 244
    2c68:	3f 4f       	sbci	r19, 0xFF	; 255
    2c6a:	ce 01       	movw	r24, r28
    2c6c:	05 96       	adiw	r24, 0x05	; 5
    2c6e:	b9 01       	movw	r22, r18
    2c70:	0e 94 ba 20 	call	0x4174	; 0x4174 <xTaskCheckForTimeOut>
    2c74:	88 23       	and	r24, r24
    2c76:	01 f5       	brne	.+64     	; 0x2cb8 <xQueueGenericSend+0x140>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2c78:	8a 81       	ldd	r24, Y+2	; 0x02
    2c7a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c7c:	0e 94 ac 1a 	call	0x3558	; 0x3558 <prvIsQueueFull>
    2c80:	88 23       	and	r24, r24
    2c82:	99 f0       	breq	.+38     	; 0x2caa <xQueueGenericSend+0x132>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2c84:	2c 85       	ldd	r18, Y+12	; 0x0c
    2c86:	3d 85       	ldd	r19, Y+13	; 0x0d
    2c88:	8a 81       	ldd	r24, Y+2	; 0x02
    2c8a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c8c:	08 96       	adiw	r24, 0x08	; 8
    2c8e:	b9 01       	movw	r22, r18
    2c90:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2c94:	8a 81       	ldd	r24, Y+2	; 0x02
    2c96:	9b 81       	ldd	r25, Y+3	; 0x03
    2c98:	0e 94 11 1a 	call	0x3422	; 0x3422 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2c9c:	0e 94 2e 1d 	call	0x3a5c	; 0x3a5c <xTaskResumeAll>
    2ca0:	88 23       	and	r24, r24
    2ca2:	91 f4       	brne	.+36     	; 0x2cc8 <xQueueGenericSend+0x150>
				{
					portYIELD_WITHIN_API();
    2ca4:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortYield>
    2ca8:	0f c0       	rjmp	.+30     	; 0x2cc8 <xQueueGenericSend+0x150>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2caa:	8a 81       	ldd	r24, Y+2	; 0x02
    2cac:	9b 81       	ldd	r25, Y+3	; 0x03
    2cae:	0e 94 11 1a 	call	0x3422	; 0x3422 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2cb2:	0e 94 2e 1d 	call	0x3a5c	; 0x3a5c <xTaskResumeAll>
    2cb6:	76 cf       	rjmp	.-276    	; 0x2ba4 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2cb8:	8a 81       	ldd	r24, Y+2	; 0x02
    2cba:	9b 81       	ldd	r25, Y+3	; 0x03
    2cbc:	0e 94 11 1a 	call	0x3422	; 0x3422 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2cc0:	0e 94 2e 1d 	call	0x3a5c	; 0x3a5c <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2cc4:	80 e0       	ldi	r24, 0x00	; 0
    2cc6:	01 c0       	rjmp	.+2      	; 0x2cca <xQueueGenericSend+0x152>
		}
	}
    2cc8:	6d cf       	rjmp	.-294    	; 0x2ba4 <xQueueGenericSend+0x2c>
}
    2cca:	2e 96       	adiw	r28, 0x0e	; 14
    2ccc:	0f b6       	in	r0, 0x3f	; 63
    2cce:	f8 94       	cli
    2cd0:	de bf       	out	0x3e, r29	; 62
    2cd2:	0f be       	out	0x3f, r0	; 63
    2cd4:	cd bf       	out	0x3d, r28	; 61
    2cd6:	df 91       	pop	r29
    2cd8:	cf 91       	pop	r28
    2cda:	08 95       	ret

00002cdc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    2cdc:	cf 93       	push	r28
    2cde:	df 93       	push	r29
    2ce0:	cd b7       	in	r28, 0x3d	; 61
    2ce2:	de b7       	in	r29, 0x3e	; 62
    2ce4:	2b 97       	sbiw	r28, 0x0b	; 11
    2ce6:	0f b6       	in	r0, 0x3f	; 63
    2ce8:	f8 94       	cli
    2cea:	de bf       	out	0x3e, r29	; 62
    2cec:	0f be       	out	0x3f, r0	; 63
    2cee:	cd bf       	out	0x3d, r28	; 61
    2cf0:	9e 83       	std	Y+6, r25	; 0x06
    2cf2:	8d 83       	std	Y+5, r24	; 0x05
    2cf4:	78 87       	std	Y+8, r23	; 0x08
    2cf6:	6f 83       	std	Y+7, r22	; 0x07
    2cf8:	5a 87       	std	Y+10, r21	; 0x0a
    2cfa:	49 87       	std	Y+9, r20	; 0x09
    2cfc:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2cfe:	8d 81       	ldd	r24, Y+5	; 0x05
    2d00:	9e 81       	ldd	r25, Y+6	; 0x06
    2d02:	9b 83       	std	Y+3, r25	; 0x03
    2d04:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2d06:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2d08:	8a 81       	ldd	r24, Y+2	; 0x02
    2d0a:	9b 81       	ldd	r25, Y+3	; 0x03
    2d0c:	fc 01       	movw	r30, r24
    2d0e:	22 8d       	ldd	r18, Z+26	; 0x1a
    2d10:	8a 81       	ldd	r24, Y+2	; 0x02
    2d12:	9b 81       	ldd	r25, Y+3	; 0x03
    2d14:	fc 01       	movw	r30, r24
    2d16:	83 8d       	ldd	r24, Z+27	; 0x1b
    2d18:	28 17       	cp	r18, r24
    2d1a:	18 f0       	brcs	.+6      	; 0x2d22 <xQueueGenericSendFromISR+0x46>
    2d1c:	8b 85       	ldd	r24, Y+11	; 0x0b
    2d1e:	82 30       	cpi	r24, 0x02	; 2
    2d20:	91 f5       	brne	.+100    	; 0x2d86 <xQueueGenericSendFromISR+0xaa>
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2d22:	2f 81       	ldd	r18, Y+7	; 0x07
    2d24:	38 85       	ldd	r19, Y+8	; 0x08
    2d26:	8a 81       	ldd	r24, Y+2	; 0x02
    2d28:	9b 81       	ldd	r25, Y+3	; 0x03
    2d2a:	4b 85       	ldd	r20, Y+11	; 0x0b
    2d2c:	b9 01       	movw	r22, r18
    2d2e:	0e 94 01 19 	call	0x3202	; 0x3202 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2d32:	8a 81       	ldd	r24, Y+2	; 0x02
    2d34:	9b 81       	ldd	r25, Y+3	; 0x03
    2d36:	fc 01       	movw	r30, r24
    2d38:	86 8d       	ldd	r24, Z+30	; 0x1e
    2d3a:	8f 3f       	cpi	r24, 0xFF	; 255
    2d3c:	b9 f4       	brne	.+46     	; 0x2d6c <xQueueGenericSendFromISR+0x90>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2d3e:	8a 81       	ldd	r24, Y+2	; 0x02
    2d40:	9b 81       	ldd	r25, Y+3	; 0x03
    2d42:	fc 01       	movw	r30, r24
    2d44:	81 89       	ldd	r24, Z+17	; 0x11
    2d46:	88 23       	and	r24, r24
    2d48:	d9 f0       	breq	.+54     	; 0x2d80 <xQueueGenericSendFromISR+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2d4a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d4c:	9b 81       	ldd	r25, Y+3	; 0x03
    2d4e:	41 96       	adiw	r24, 0x11	; 17
    2d50:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <xTaskRemoveFromEventList>
    2d54:	88 23       	and	r24, r24
    2d56:	a1 f0       	breq	.+40     	; 0x2d80 <xQueueGenericSendFromISR+0xa4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2d58:	89 85       	ldd	r24, Y+9	; 0x09
    2d5a:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d5c:	89 2b       	or	r24, r25
    2d5e:	81 f0       	breq	.+32     	; 0x2d80 <xQueueGenericSendFromISR+0xa4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2d60:	89 85       	ldd	r24, Y+9	; 0x09
    2d62:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d64:	21 e0       	ldi	r18, 0x01	; 1
    2d66:	fc 01       	movw	r30, r24
    2d68:	20 83       	st	Z, r18
    2d6a:	0a c0       	rjmp	.+20     	; 0x2d80 <xQueueGenericSendFromISR+0xa4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2d6c:	8a 81       	ldd	r24, Y+2	; 0x02
    2d6e:	9b 81       	ldd	r25, Y+3	; 0x03
    2d70:	fc 01       	movw	r30, r24
    2d72:	86 8d       	ldd	r24, Z+30	; 0x1e
    2d74:	8f 5f       	subi	r24, 0xFF	; 255
    2d76:	28 2f       	mov	r18, r24
    2d78:	8a 81       	ldd	r24, Y+2	; 0x02
    2d7a:	9b 81       	ldd	r25, Y+3	; 0x03
    2d7c:	fc 01       	movw	r30, r24
    2d7e:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    2d80:	81 e0       	ldi	r24, 0x01	; 1
    2d82:	89 83       	std	Y+1, r24	; 0x01
    2d84:	01 c0       	rjmp	.+2      	; 0x2d88 <xQueueGenericSendFromISR+0xac>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2d86:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2d88:	89 81       	ldd	r24, Y+1	; 0x01
}
    2d8a:	2b 96       	adiw	r28, 0x0b	; 11
    2d8c:	0f b6       	in	r0, 0x3f	; 63
    2d8e:	f8 94       	cli
    2d90:	de bf       	out	0x3e, r29	; 62
    2d92:	0f be       	out	0x3f, r0	; 63
    2d94:	cd bf       	out	0x3d, r28	; 61
    2d96:	df 91       	pop	r29
    2d98:	cf 91       	pop	r28
    2d9a:	08 95       	ret

00002d9c <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2d9c:	cf 93       	push	r28
    2d9e:	df 93       	push	r29
    2da0:	cd b7       	in	r28, 0x3d	; 61
    2da2:	de b7       	in	r29, 0x3e	; 62
    2da4:	28 97       	sbiw	r28, 0x08	; 8
    2da6:	0f b6       	in	r0, 0x3f	; 63
    2da8:	f8 94       	cli
    2daa:	de bf       	out	0x3e, r29	; 62
    2dac:	0f be       	out	0x3f, r0	; 63
    2dae:	cd bf       	out	0x3d, r28	; 61
    2db0:	9e 83       	std	Y+6, r25	; 0x06
    2db2:	8d 83       	std	Y+5, r24	; 0x05
    2db4:	78 87       	std	Y+8, r23	; 0x08
    2db6:	6f 83       	std	Y+7, r22	; 0x07
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2db8:	8d 81       	ldd	r24, Y+5	; 0x05
    2dba:	9e 81       	ldd	r25, Y+6	; 0x06
    2dbc:	9b 83       	std	Y+3, r25	; 0x03
    2dbe:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2dc0:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2dc2:	8a 81       	ldd	r24, Y+2	; 0x02
    2dc4:	9b 81       	ldd	r25, Y+3	; 0x03
    2dc6:	fc 01       	movw	r30, r24
    2dc8:	22 8d       	ldd	r18, Z+26	; 0x1a
    2dca:	8a 81       	ldd	r24, Y+2	; 0x02
    2dcc:	9b 81       	ldd	r25, Y+3	; 0x03
    2dce:	fc 01       	movw	r30, r24
    2dd0:	83 8d       	ldd	r24, Z+27	; 0x1b
    2dd2:	28 17       	cp	r18, r24
    2dd4:	a0 f5       	brcc	.+104    	; 0x2e3e <xQueueGiveFromISR+0xa2>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    2dd6:	8a 81       	ldd	r24, Y+2	; 0x02
    2dd8:	9b 81       	ldd	r25, Y+3	; 0x03
    2dda:	fc 01       	movw	r30, r24
    2ddc:	82 8d       	ldd	r24, Z+26	; 0x1a
    2dde:	21 e0       	ldi	r18, 0x01	; 1
    2de0:	28 0f       	add	r18, r24
    2de2:	8a 81       	ldd	r24, Y+2	; 0x02
    2de4:	9b 81       	ldd	r25, Y+3	; 0x03
    2de6:	fc 01       	movw	r30, r24
    2de8:	22 8f       	std	Z+26, r18	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2dea:	8a 81       	ldd	r24, Y+2	; 0x02
    2dec:	9b 81       	ldd	r25, Y+3	; 0x03
    2dee:	fc 01       	movw	r30, r24
    2df0:	86 8d       	ldd	r24, Z+30	; 0x1e
    2df2:	8f 3f       	cpi	r24, 0xFF	; 255
    2df4:	b9 f4       	brne	.+46     	; 0x2e24 <xQueueGiveFromISR+0x88>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2df6:	8a 81       	ldd	r24, Y+2	; 0x02
    2df8:	9b 81       	ldd	r25, Y+3	; 0x03
    2dfa:	fc 01       	movw	r30, r24
    2dfc:	81 89       	ldd	r24, Z+17	; 0x11
    2dfe:	88 23       	and	r24, r24
    2e00:	d9 f0       	breq	.+54     	; 0x2e38 <xQueueGiveFromISR+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2e02:	8a 81       	ldd	r24, Y+2	; 0x02
    2e04:	9b 81       	ldd	r25, Y+3	; 0x03
    2e06:	41 96       	adiw	r24, 0x11	; 17
    2e08:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <xTaskRemoveFromEventList>
    2e0c:	88 23       	and	r24, r24
    2e0e:	a1 f0       	breq	.+40     	; 0x2e38 <xQueueGiveFromISR+0x9c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2e10:	8f 81       	ldd	r24, Y+7	; 0x07
    2e12:	98 85       	ldd	r25, Y+8	; 0x08
    2e14:	89 2b       	or	r24, r25
    2e16:	81 f0       	breq	.+32     	; 0x2e38 <xQueueGiveFromISR+0x9c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2e18:	8f 81       	ldd	r24, Y+7	; 0x07
    2e1a:	98 85       	ldd	r25, Y+8	; 0x08
    2e1c:	21 e0       	ldi	r18, 0x01	; 1
    2e1e:	fc 01       	movw	r30, r24
    2e20:	20 83       	st	Z, r18
    2e22:	0a c0       	rjmp	.+20     	; 0x2e38 <xQueueGiveFromISR+0x9c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2e24:	8a 81       	ldd	r24, Y+2	; 0x02
    2e26:	9b 81       	ldd	r25, Y+3	; 0x03
    2e28:	fc 01       	movw	r30, r24
    2e2a:	86 8d       	ldd	r24, Z+30	; 0x1e
    2e2c:	8f 5f       	subi	r24, 0xFF	; 255
    2e2e:	28 2f       	mov	r18, r24
    2e30:	8a 81       	ldd	r24, Y+2	; 0x02
    2e32:	9b 81       	ldd	r25, Y+3	; 0x03
    2e34:	fc 01       	movw	r30, r24
    2e36:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    2e38:	81 e0       	ldi	r24, 0x01	; 1
    2e3a:	89 83       	std	Y+1, r24	; 0x01
    2e3c:	01 c0       	rjmp	.+2      	; 0x2e40 <xQueueGiveFromISR+0xa4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2e3e:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2e40:	89 81       	ldd	r24, Y+1	; 0x01
}
    2e42:	28 96       	adiw	r28, 0x08	; 8
    2e44:	0f b6       	in	r0, 0x3f	; 63
    2e46:	f8 94       	cli
    2e48:	de bf       	out	0x3e, r29	; 62
    2e4a:	0f be       	out	0x3f, r0	; 63
    2e4c:	cd bf       	out	0x3d, r28	; 61
    2e4e:	df 91       	pop	r29
    2e50:	cf 91       	pop	r28
    2e52:	08 95       	ret

00002e54 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    2e54:	cf 93       	push	r28
    2e56:	df 93       	push	r29
    2e58:	cd b7       	in	r28, 0x3d	; 61
    2e5a:	de b7       	in	r29, 0x3e	; 62
    2e5c:	2f 97       	sbiw	r28, 0x0f	; 15
    2e5e:	0f b6       	in	r0, 0x3f	; 63
    2e60:	f8 94       	cli
    2e62:	de bf       	out	0x3e, r29	; 62
    2e64:	0f be       	out	0x3f, r0	; 63
    2e66:	cd bf       	out	0x3d, r28	; 61
    2e68:	9a 87       	std	Y+10, r25	; 0x0a
    2e6a:	89 87       	std	Y+9, r24	; 0x09
    2e6c:	7c 87       	std	Y+12, r23	; 0x0c
    2e6e:	6b 87       	std	Y+11, r22	; 0x0b
    2e70:	5e 87       	std	Y+14, r21	; 0x0e
    2e72:	4d 87       	std	Y+13, r20	; 0x0d
    2e74:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    2e76:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2e78:	89 85       	ldd	r24, Y+9	; 0x09
    2e7a:	9a 85       	ldd	r25, Y+10	; 0x0a
    2e7c:	9b 83       	std	Y+3, r25	; 0x03
    2e7e:	8a 83       	std	Y+2, r24	; 0x02
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2e80:	0f b6       	in	r0, 0x3f	; 63
    2e82:	f8 94       	cli
    2e84:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2e86:	8a 81       	ldd	r24, Y+2	; 0x02
    2e88:	9b 81       	ldd	r25, Y+3	; 0x03
    2e8a:	fc 01       	movw	r30, r24
    2e8c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e8e:	88 23       	and	r24, r24
    2e90:	09 f4       	brne	.+2      	; 0x2e94 <xQueueGenericReceive+0x40>
    2e92:	45 c0       	rjmp	.+138    	; 0x2f1e <xQueueGenericReceive+0xca>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2e94:	8a 81       	ldd	r24, Y+2	; 0x02
    2e96:	9b 81       	ldd	r25, Y+3	; 0x03
    2e98:	fc 01       	movw	r30, r24
    2e9a:	86 81       	ldd	r24, Z+6	; 0x06
    2e9c:	97 81       	ldd	r25, Z+7	; 0x07
    2e9e:	9d 83       	std	Y+5, r25	; 0x05
    2ea0:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2ea2:	2b 85       	ldd	r18, Y+11	; 0x0b
    2ea4:	3c 85       	ldd	r19, Y+12	; 0x0c
    2ea6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ea8:	9b 81       	ldd	r25, Y+3	; 0x03
    2eaa:	b9 01       	movw	r22, r18
    2eac:	0e 94 c1 19 	call	0x3382	; 0x3382 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2eb0:	8f 85       	ldd	r24, Y+15	; 0x0f
    2eb2:	88 23       	and	r24, r24
    2eb4:	d1 f4       	brne	.+52     	; 0x2eea <xQueueGenericReceive+0x96>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    2eb6:	8a 81       	ldd	r24, Y+2	; 0x02
    2eb8:	9b 81       	ldd	r25, Y+3	; 0x03
    2eba:	fc 01       	movw	r30, r24
    2ebc:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ebe:	2f ef       	ldi	r18, 0xFF	; 255
    2ec0:	28 0f       	add	r18, r24
    2ec2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ec4:	9b 81       	ldd	r25, Y+3	; 0x03
    2ec6:	fc 01       	movw	r30, r24
    2ec8:	22 8f       	std	Z+26, r18	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2eca:	8a 81       	ldd	r24, Y+2	; 0x02
    2ecc:	9b 81       	ldd	r25, Y+3	; 0x03
    2ece:	fc 01       	movw	r30, r24
    2ed0:	80 85       	ldd	r24, Z+8	; 0x08
    2ed2:	88 23       	and	r24, r24
    2ed4:	01 f1       	breq	.+64     	; 0x2f16 <xQueueGenericReceive+0xc2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2ed6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ed8:	9b 81       	ldd	r25, Y+3	; 0x03
    2eda:	08 96       	adiw	r24, 0x08	; 8
    2edc:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <xTaskRemoveFromEventList>
    2ee0:	81 30       	cpi	r24, 0x01	; 1
    2ee2:	c9 f4       	brne	.+50     	; 0x2f16 <xQueueGenericReceive+0xc2>
						{
							queueYIELD_IF_USING_PREEMPTION();
    2ee4:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortYield>
    2ee8:	16 c0       	rjmp	.+44     	; 0x2f16 <xQueueGenericReceive+0xc2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2eea:	8a 81       	ldd	r24, Y+2	; 0x02
    2eec:	9b 81       	ldd	r25, Y+3	; 0x03
    2eee:	2c 81       	ldd	r18, Y+4	; 0x04
    2ef0:	3d 81       	ldd	r19, Y+5	; 0x05
    2ef2:	fc 01       	movw	r30, r24
    2ef4:	37 83       	std	Z+7, r19	; 0x07
    2ef6:	26 83       	std	Z+6, r18	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2ef8:	8a 81       	ldd	r24, Y+2	; 0x02
    2efa:	9b 81       	ldd	r25, Y+3	; 0x03
    2efc:	fc 01       	movw	r30, r24
    2efe:	81 89       	ldd	r24, Z+17	; 0x11
    2f00:	88 23       	and	r24, r24
    2f02:	49 f0       	breq	.+18     	; 0x2f16 <xQueueGenericReceive+0xc2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2f04:	8a 81       	ldd	r24, Y+2	; 0x02
    2f06:	9b 81       	ldd	r25, Y+3	; 0x03
    2f08:	41 96       	adiw	r24, 0x11	; 17
    2f0a:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <xTaskRemoveFromEventList>
    2f0e:	88 23       	and	r24, r24
    2f10:	11 f0       	breq	.+4      	; 0x2f16 <xQueueGenericReceive+0xc2>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    2f12:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    2f16:	0f 90       	pop	r0
    2f18:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2f1a:	81 e0       	ldi	r24, 0x01	; 1
    2f1c:	61 c0       	rjmp	.+194    	; 0x2fe0 <xQueueGenericReceive+0x18c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2f1e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2f20:	9e 85       	ldd	r25, Y+14	; 0x0e
    2f22:	89 2b       	or	r24, r25
    2f24:	21 f4       	brne	.+8      	; 0x2f2e <xQueueGenericReceive+0xda>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2f26:	0f 90       	pop	r0
    2f28:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2f2a:	80 e0       	ldi	r24, 0x00	; 0
    2f2c:	59 c0       	rjmp	.+178    	; 0x2fe0 <xQueueGenericReceive+0x18c>
				}
				else if( xEntryTimeSet == pdFALSE )
    2f2e:	89 81       	ldd	r24, Y+1	; 0x01
    2f30:	88 23       	and	r24, r24
    2f32:	31 f4       	brne	.+12     	; 0x2f40 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2f34:	ce 01       	movw	r24, r28
    2f36:	06 96       	adiw	r24, 0x06	; 6
    2f38:	0e 94 9f 20 	call	0x413e	; 0x413e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2f3c:	81 e0       	ldi	r24, 0x01	; 1
    2f3e:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2f40:	0f 90       	pop	r0
    2f42:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2f44:	0e 94 22 1d 	call	0x3a44	; 0x3a44 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2f48:	0f b6       	in	r0, 0x3f	; 63
    2f4a:	f8 94       	cli
    2f4c:	0f 92       	push	r0
    2f4e:	8a 81       	ldd	r24, Y+2	; 0x02
    2f50:	9b 81       	ldd	r25, Y+3	; 0x03
    2f52:	fc 01       	movw	r30, r24
    2f54:	85 8d       	ldd	r24, Z+29	; 0x1d
    2f56:	8f 3f       	cpi	r24, 0xFF	; 255
    2f58:	21 f4       	brne	.+8      	; 0x2f62 <xQueueGenericReceive+0x10e>
    2f5a:	8a 81       	ldd	r24, Y+2	; 0x02
    2f5c:	9b 81       	ldd	r25, Y+3	; 0x03
    2f5e:	fc 01       	movw	r30, r24
    2f60:	15 8e       	std	Z+29, r1	; 0x1d
    2f62:	8a 81       	ldd	r24, Y+2	; 0x02
    2f64:	9b 81       	ldd	r25, Y+3	; 0x03
    2f66:	fc 01       	movw	r30, r24
    2f68:	86 8d       	ldd	r24, Z+30	; 0x1e
    2f6a:	8f 3f       	cpi	r24, 0xFF	; 255
    2f6c:	21 f4       	brne	.+8      	; 0x2f76 <xQueueGenericReceive+0x122>
    2f6e:	8a 81       	ldd	r24, Y+2	; 0x02
    2f70:	9b 81       	ldd	r25, Y+3	; 0x03
    2f72:	fc 01       	movw	r30, r24
    2f74:	16 8e       	std	Z+30, r1	; 0x1e
    2f76:	0f 90       	pop	r0
    2f78:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2f7a:	9e 01       	movw	r18, r28
    2f7c:	23 5f       	subi	r18, 0xF3	; 243
    2f7e:	3f 4f       	sbci	r19, 0xFF	; 255
    2f80:	ce 01       	movw	r24, r28
    2f82:	06 96       	adiw	r24, 0x06	; 6
    2f84:	b9 01       	movw	r22, r18
    2f86:	0e 94 ba 20 	call	0x4174	; 0x4174 <xTaskCheckForTimeOut>
    2f8a:	88 23       	and	r24, r24
    2f8c:	01 f5       	brne	.+64     	; 0x2fce <xQueueGenericReceive+0x17a>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2f8e:	8a 81       	ldd	r24, Y+2	; 0x02
    2f90:	9b 81       	ldd	r25, Y+3	; 0x03
    2f92:	0e 94 75 1a 	call	0x34ea	; 0x34ea <prvIsQueueEmpty>
    2f96:	88 23       	and	r24, r24
    2f98:	99 f0       	breq	.+38     	; 0x2fc0 <xQueueGenericReceive+0x16c>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2f9a:	2d 85       	ldd	r18, Y+13	; 0x0d
    2f9c:	3e 85       	ldd	r19, Y+14	; 0x0e
    2f9e:	8a 81       	ldd	r24, Y+2	; 0x02
    2fa0:	9b 81       	ldd	r25, Y+3	; 0x03
    2fa2:	41 96       	adiw	r24, 0x11	; 17
    2fa4:	b9 01       	movw	r22, r18
    2fa6:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2faa:	8a 81       	ldd	r24, Y+2	; 0x02
    2fac:	9b 81       	ldd	r25, Y+3	; 0x03
    2fae:	0e 94 11 1a 	call	0x3422	; 0x3422 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2fb2:	0e 94 2e 1d 	call	0x3a5c	; 0x3a5c <xTaskResumeAll>
    2fb6:	88 23       	and	r24, r24
    2fb8:	91 f4       	brne	.+36     	; 0x2fde <xQueueGenericReceive+0x18a>
				{
					portYIELD_WITHIN_API();
    2fba:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortYield>
    2fbe:	0f c0       	rjmp	.+30     	; 0x2fde <xQueueGenericReceive+0x18a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2fc0:	8a 81       	ldd	r24, Y+2	; 0x02
    2fc2:	9b 81       	ldd	r25, Y+3	; 0x03
    2fc4:	0e 94 11 1a 	call	0x3422	; 0x3422 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2fc8:	0e 94 2e 1d 	call	0x3a5c	; 0x3a5c <xTaskResumeAll>
    2fcc:	59 cf       	rjmp	.-334    	; 0x2e80 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2fce:	8a 81       	ldd	r24, Y+2	; 0x02
    2fd0:	9b 81       	ldd	r25, Y+3	; 0x03
    2fd2:	0e 94 11 1a 	call	0x3422	; 0x3422 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2fd6:	0e 94 2e 1d 	call	0x3a5c	; 0x3a5c <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2fda:	80 e0       	ldi	r24, 0x00	; 0
    2fdc:	01 c0       	rjmp	.+2      	; 0x2fe0 <xQueueGenericReceive+0x18c>
		}
	}
    2fde:	50 cf       	rjmp	.-352    	; 0x2e80 <xQueueGenericReceive+0x2c>
}
    2fe0:	2f 96       	adiw	r28, 0x0f	; 15
    2fe2:	0f b6       	in	r0, 0x3f	; 63
    2fe4:	f8 94       	cli
    2fe6:	de bf       	out	0x3e, r29	; 62
    2fe8:	0f be       	out	0x3f, r0	; 63
    2fea:	cd bf       	out	0x3d, r28	; 61
    2fec:	df 91       	pop	r29
    2fee:	cf 91       	pop	r28
    2ff0:	08 95       	ret

00002ff2 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2ff2:	cf 93       	push	r28
    2ff4:	df 93       	push	r29
    2ff6:	cd b7       	in	r28, 0x3d	; 61
    2ff8:	de b7       	in	r29, 0x3e	; 62
    2ffa:	2a 97       	sbiw	r28, 0x0a	; 10
    2ffc:	0f b6       	in	r0, 0x3f	; 63
    2ffe:	f8 94       	cli
    3000:	de bf       	out	0x3e, r29	; 62
    3002:	0f be       	out	0x3f, r0	; 63
    3004:	cd bf       	out	0x3d, r28	; 61
    3006:	9e 83       	std	Y+6, r25	; 0x06
    3008:	8d 83       	std	Y+5, r24	; 0x05
    300a:	78 87       	std	Y+8, r23	; 0x08
    300c:	6f 83       	std	Y+7, r22	; 0x07
    300e:	5a 87       	std	Y+10, r21	; 0x0a
    3010:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3012:	8d 81       	ldd	r24, Y+5	; 0x05
    3014:	9e 81       	ldd	r25, Y+6	; 0x06
    3016:	9b 83       	std	Y+3, r25	; 0x03
    3018:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    301a:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    301c:	8a 81       	ldd	r24, Y+2	; 0x02
    301e:	9b 81       	ldd	r25, Y+3	; 0x03
    3020:	fc 01       	movw	r30, r24
    3022:	82 8d       	ldd	r24, Z+26	; 0x1a
    3024:	88 23       	and	r24, r24
    3026:	d9 f1       	breq	.+118    	; 0x309e <xQueueReceiveFromISR+0xac>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3028:	2f 81       	ldd	r18, Y+7	; 0x07
    302a:	38 85       	ldd	r19, Y+8	; 0x08
    302c:	8a 81       	ldd	r24, Y+2	; 0x02
    302e:	9b 81       	ldd	r25, Y+3	; 0x03
    3030:	b9 01       	movw	r22, r18
    3032:	0e 94 c1 19 	call	0x3382	; 0x3382 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    3036:	8a 81       	ldd	r24, Y+2	; 0x02
    3038:	9b 81       	ldd	r25, Y+3	; 0x03
    303a:	fc 01       	movw	r30, r24
    303c:	82 8d       	ldd	r24, Z+26	; 0x1a
    303e:	2f ef       	ldi	r18, 0xFF	; 255
    3040:	28 0f       	add	r18, r24
    3042:	8a 81       	ldd	r24, Y+2	; 0x02
    3044:	9b 81       	ldd	r25, Y+3	; 0x03
    3046:	fc 01       	movw	r30, r24
    3048:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    304a:	8a 81       	ldd	r24, Y+2	; 0x02
    304c:	9b 81       	ldd	r25, Y+3	; 0x03
    304e:	fc 01       	movw	r30, r24
    3050:	85 8d       	ldd	r24, Z+29	; 0x1d
    3052:	8f 3f       	cpi	r24, 0xFF	; 255
    3054:	b9 f4       	brne	.+46     	; 0x3084 <xQueueReceiveFromISR+0x92>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3056:	8a 81       	ldd	r24, Y+2	; 0x02
    3058:	9b 81       	ldd	r25, Y+3	; 0x03
    305a:	fc 01       	movw	r30, r24
    305c:	80 85       	ldd	r24, Z+8	; 0x08
    305e:	88 23       	and	r24, r24
    3060:	d9 f0       	breq	.+54     	; 0x3098 <xQueueReceiveFromISR+0xa6>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3062:	8a 81       	ldd	r24, Y+2	; 0x02
    3064:	9b 81       	ldd	r25, Y+3	; 0x03
    3066:	08 96       	adiw	r24, 0x08	; 8
    3068:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <xTaskRemoveFromEventList>
    306c:	88 23       	and	r24, r24
    306e:	a1 f0       	breq	.+40     	; 0x3098 <xQueueReceiveFromISR+0xa6>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    3070:	89 85       	ldd	r24, Y+9	; 0x09
    3072:	9a 85       	ldd	r25, Y+10	; 0x0a
    3074:	89 2b       	or	r24, r25
    3076:	81 f0       	breq	.+32     	; 0x3098 <xQueueReceiveFromISR+0xa6>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    3078:	89 85       	ldd	r24, Y+9	; 0x09
    307a:	9a 85       	ldd	r25, Y+10	; 0x0a
    307c:	21 e0       	ldi	r18, 0x01	; 1
    307e:	fc 01       	movw	r30, r24
    3080:	20 83       	st	Z, r18
    3082:	0a c0       	rjmp	.+20     	; 0x3098 <xQueueReceiveFromISR+0xa6>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    3084:	8a 81       	ldd	r24, Y+2	; 0x02
    3086:	9b 81       	ldd	r25, Y+3	; 0x03
    3088:	fc 01       	movw	r30, r24
    308a:	85 8d       	ldd	r24, Z+29	; 0x1d
    308c:	8f 5f       	subi	r24, 0xFF	; 255
    308e:	28 2f       	mov	r18, r24
    3090:	8a 81       	ldd	r24, Y+2	; 0x02
    3092:	9b 81       	ldd	r25, Y+3	; 0x03
    3094:	fc 01       	movw	r30, r24
    3096:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    3098:	81 e0       	ldi	r24, 0x01	; 1
    309a:	89 83       	std	Y+1, r24	; 0x01
    309c:	01 c0       	rjmp	.+2      	; 0x30a0 <xQueueReceiveFromISR+0xae>
		}
		else
		{
			xReturn = pdFAIL;
    309e:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    30a0:	89 81       	ldd	r24, Y+1	; 0x01
}
    30a2:	2a 96       	adiw	r28, 0x0a	; 10
    30a4:	0f b6       	in	r0, 0x3f	; 63
    30a6:	f8 94       	cli
    30a8:	de bf       	out	0x3e, r29	; 62
    30aa:	0f be       	out	0x3f, r0	; 63
    30ac:	cd bf       	out	0x3d, r28	; 61
    30ae:	df 91       	pop	r29
    30b0:	cf 91       	pop	r28
    30b2:	08 95       	ret

000030b4 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    30b4:	cf 93       	push	r28
    30b6:	df 93       	push	r29
    30b8:	cd b7       	in	r28, 0x3d	; 61
    30ba:	de b7       	in	r29, 0x3e	; 62
    30bc:	2a 97       	sbiw	r28, 0x0a	; 10
    30be:	0f b6       	in	r0, 0x3f	; 63
    30c0:	f8 94       	cli
    30c2:	de bf       	out	0x3e, r29	; 62
    30c4:	0f be       	out	0x3f, r0	; 63
    30c6:	cd bf       	out	0x3d, r28	; 61
    30c8:	98 87       	std	Y+8, r25	; 0x08
    30ca:	8f 83       	std	Y+7, r24	; 0x07
    30cc:	7a 87       	std	Y+10, r23	; 0x0a
    30ce:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    30d0:	8f 81       	ldd	r24, Y+7	; 0x07
    30d2:	98 85       	ldd	r25, Y+8	; 0x08
    30d4:	9b 83       	std	Y+3, r25	; 0x03
    30d6:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    30d8:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    30da:	8a 81       	ldd	r24, Y+2	; 0x02
    30dc:	9b 81       	ldd	r25, Y+3	; 0x03
    30de:	fc 01       	movw	r30, r24
    30e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    30e2:	88 23       	and	r24, r24
    30e4:	c1 f0       	breq	.+48     	; 0x3116 <xQueuePeekFromISR+0x62>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    30e6:	8a 81       	ldd	r24, Y+2	; 0x02
    30e8:	9b 81       	ldd	r25, Y+3	; 0x03
    30ea:	fc 01       	movw	r30, r24
    30ec:	86 81       	ldd	r24, Z+6	; 0x06
    30ee:	97 81       	ldd	r25, Z+7	; 0x07
    30f0:	9e 83       	std	Y+6, r25	; 0x06
    30f2:	8d 83       	std	Y+5, r24	; 0x05
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    30f4:	29 85       	ldd	r18, Y+9	; 0x09
    30f6:	3a 85       	ldd	r19, Y+10	; 0x0a
    30f8:	8a 81       	ldd	r24, Y+2	; 0x02
    30fa:	9b 81       	ldd	r25, Y+3	; 0x03
    30fc:	b9 01       	movw	r22, r18
    30fe:	0e 94 c1 19 	call	0x3382	; 0x3382 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    3102:	8a 81       	ldd	r24, Y+2	; 0x02
    3104:	9b 81       	ldd	r25, Y+3	; 0x03
    3106:	2d 81       	ldd	r18, Y+5	; 0x05
    3108:	3e 81       	ldd	r19, Y+6	; 0x06
    310a:	fc 01       	movw	r30, r24
    310c:	37 83       	std	Z+7, r19	; 0x07
    310e:	26 83       	std	Z+6, r18	; 0x06

			xReturn = pdPASS;
    3110:	81 e0       	ldi	r24, 0x01	; 1
    3112:	89 83       	std	Y+1, r24	; 0x01
    3114:	01 c0       	rjmp	.+2      	; 0x3118 <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
    3116:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3118:	89 81       	ldd	r24, Y+1	; 0x01
}
    311a:	2a 96       	adiw	r28, 0x0a	; 10
    311c:	0f b6       	in	r0, 0x3f	; 63
    311e:	f8 94       	cli
    3120:	de bf       	out	0x3e, r29	; 62
    3122:	0f be       	out	0x3f, r0	; 63
    3124:	cd bf       	out	0x3d, r28	; 61
    3126:	df 91       	pop	r29
    3128:	cf 91       	pop	r28
    312a:	08 95       	ret

0000312c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    312c:	cf 93       	push	r28
    312e:	df 93       	push	r29
    3130:	00 d0       	rcall	.+0      	; 0x3132 <uxQueueMessagesWaiting+0x6>
    3132:	1f 92       	push	r1
    3134:	cd b7       	in	r28, 0x3d	; 61
    3136:	de b7       	in	r29, 0x3e	; 62
    3138:	9b 83       	std	Y+3, r25	; 0x03
    313a:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    313c:	0f b6       	in	r0, 0x3f	; 63
    313e:	f8 94       	cli
    3140:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3142:	8a 81       	ldd	r24, Y+2	; 0x02
    3144:	9b 81       	ldd	r25, Y+3	; 0x03
    3146:	fc 01       	movw	r30, r24
    3148:	82 8d       	ldd	r24, Z+26	; 0x1a
    314a:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    314c:	0f 90       	pop	r0
    314e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3150:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3152:	0f 90       	pop	r0
    3154:	0f 90       	pop	r0
    3156:	0f 90       	pop	r0
    3158:	df 91       	pop	r29
    315a:	cf 91       	pop	r28
    315c:	08 95       	ret

0000315e <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    315e:	cf 93       	push	r28
    3160:	df 93       	push	r29
    3162:	00 d0       	rcall	.+0      	; 0x3164 <uxQueueSpacesAvailable+0x6>
    3164:	00 d0       	rcall	.+0      	; 0x3166 <uxQueueSpacesAvailable+0x8>
    3166:	1f 92       	push	r1
    3168:	cd b7       	in	r28, 0x3d	; 61
    316a:	de b7       	in	r29, 0x3e	; 62
    316c:	9d 83       	std	Y+5, r25	; 0x05
    316e:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    3170:	8c 81       	ldd	r24, Y+4	; 0x04
    3172:	9d 81       	ldd	r25, Y+5	; 0x05
    3174:	9a 83       	std	Y+2, r25	; 0x02
    3176:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3178:	0f b6       	in	r0, 0x3f	; 63
    317a:	f8 94       	cli
    317c:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    317e:	89 81       	ldd	r24, Y+1	; 0x01
    3180:	9a 81       	ldd	r25, Y+2	; 0x02
    3182:	fc 01       	movw	r30, r24
    3184:	23 8d       	ldd	r18, Z+27	; 0x1b
    3186:	89 81       	ldd	r24, Y+1	; 0x01
    3188:	9a 81       	ldd	r25, Y+2	; 0x02
    318a:	fc 01       	movw	r30, r24
    318c:	82 8d       	ldd	r24, Z+26	; 0x1a
    318e:	f2 2f       	mov	r31, r18
    3190:	f8 1b       	sub	r31, r24
    3192:	8f 2f       	mov	r24, r31
    3194:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    3196:	0f 90       	pop	r0
    3198:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    319a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    319c:	0f 90       	pop	r0
    319e:	0f 90       	pop	r0
    31a0:	0f 90       	pop	r0
    31a2:	0f 90       	pop	r0
    31a4:	0f 90       	pop	r0
    31a6:	df 91       	pop	r29
    31a8:	cf 91       	pop	r28
    31aa:	08 95       	ret

000031ac <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    31ac:	cf 93       	push	r28
    31ae:	df 93       	push	r29
    31b0:	00 d0       	rcall	.+0      	; 0x31b2 <uxQueueMessagesWaitingFromISR+0x6>
    31b2:	1f 92       	push	r1
    31b4:	cd b7       	in	r28, 0x3d	; 61
    31b6:	de b7       	in	r29, 0x3e	; 62
    31b8:	9b 83       	std	Y+3, r25	; 0x03
    31ba:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    31bc:	8a 81       	ldd	r24, Y+2	; 0x02
    31be:	9b 81       	ldd	r25, Y+3	; 0x03
    31c0:	fc 01       	movw	r30, r24
    31c2:	82 8d       	ldd	r24, Z+26	; 0x1a
    31c4:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    31c6:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    31c8:	0f 90       	pop	r0
    31ca:	0f 90       	pop	r0
    31cc:	0f 90       	pop	r0
    31ce:	df 91       	pop	r29
    31d0:	cf 91       	pop	r28
    31d2:	08 95       	ret

000031d4 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    31d4:	cf 93       	push	r28
    31d6:	df 93       	push	r29
    31d8:	00 d0       	rcall	.+0      	; 0x31da <vQueueDelete+0x6>
    31da:	00 d0       	rcall	.+0      	; 0x31dc <vQueueDelete+0x8>
    31dc:	cd b7       	in	r28, 0x3d	; 61
    31de:	de b7       	in	r29, 0x3e	; 62
    31e0:	9c 83       	std	Y+4, r25	; 0x04
    31e2:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    31e4:	8b 81       	ldd	r24, Y+3	; 0x03
    31e6:	9c 81       	ldd	r25, Y+4	; 0x04
    31e8:	9a 83       	std	Y+2, r25	; 0x02
    31ea:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue );
    31ec:	89 81       	ldd	r24, Y+1	; 0x01
    31ee:	9a 81       	ldd	r25, Y+2	; 0x02
    31f0:	0e 94 9c 14 	call	0x2938	; 0x2938 <vPortFree>
}
    31f4:	0f 90       	pop	r0
    31f6:	0f 90       	pop	r0
    31f8:	0f 90       	pop	r0
    31fa:	0f 90       	pop	r0
    31fc:	df 91       	pop	r29
    31fe:	cf 91       	pop	r28
    3200:	08 95       	ret

00003202 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    3202:	cf 93       	push	r28
    3204:	df 93       	push	r29
    3206:	00 d0       	rcall	.+0      	; 0x3208 <prvCopyDataToQueue+0x6>
    3208:	00 d0       	rcall	.+0      	; 0x320a <prvCopyDataToQueue+0x8>
    320a:	00 d0       	rcall	.+0      	; 0x320c <prvCopyDataToQueue+0xa>
    320c:	cd b7       	in	r28, 0x3d	; 61
    320e:	de b7       	in	r29, 0x3e	; 62
    3210:	9b 83       	std	Y+3, r25	; 0x03
    3212:	8a 83       	std	Y+2, r24	; 0x02
    3214:	7d 83       	std	Y+5, r23	; 0x05
    3216:	6c 83       	std	Y+4, r22	; 0x04
    3218:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    321a:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    321c:	8a 81       	ldd	r24, Y+2	; 0x02
    321e:	9b 81       	ldd	r25, Y+3	; 0x03
    3220:	fc 01       	movw	r30, r24
    3222:	84 8d       	ldd	r24, Z+28	; 0x1c
    3224:	88 23       	and	r24, r24
    3226:	09 f4       	brne	.+2      	; 0x322a <prvCopyDataToQueue+0x28>
    3228:	98 c0       	rjmp	.+304    	; 0x335a <prvCopyDataToQueue+0x158>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    322a:	8e 81       	ldd	r24, Y+6	; 0x06
    322c:	88 23       	and	r24, r24
    322e:	d9 f5       	brne	.+118    	; 0x32a6 <prvCopyDataToQueue+0xa4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    3230:	8a 81       	ldd	r24, Y+2	; 0x02
    3232:	9b 81       	ldd	r25, Y+3	; 0x03
    3234:	fc 01       	movw	r30, r24
    3236:	84 8d       	ldd	r24, Z+28	; 0x1c
    3238:	48 2f       	mov	r20, r24
    323a:	50 e0       	ldi	r21, 0x00	; 0
    323c:	8a 81       	ldd	r24, Y+2	; 0x02
    323e:	9b 81       	ldd	r25, Y+3	; 0x03
    3240:	fc 01       	movw	r30, r24
    3242:	84 81       	ldd	r24, Z+4	; 0x04
    3244:	95 81       	ldd	r25, Z+5	; 0x05
    3246:	2c 81       	ldd	r18, Y+4	; 0x04
    3248:	3d 81       	ldd	r19, Y+5	; 0x05
    324a:	b9 01       	movw	r22, r18
    324c:	0e 94 4c 28 	call	0x5098	; 0x5098 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    3250:	8a 81       	ldd	r24, Y+2	; 0x02
    3252:	9b 81       	ldd	r25, Y+3	; 0x03
    3254:	fc 01       	movw	r30, r24
    3256:	24 81       	ldd	r18, Z+4	; 0x04
    3258:	35 81       	ldd	r19, Z+5	; 0x05
    325a:	8a 81       	ldd	r24, Y+2	; 0x02
    325c:	9b 81       	ldd	r25, Y+3	; 0x03
    325e:	fc 01       	movw	r30, r24
    3260:	84 8d       	ldd	r24, Z+28	; 0x1c
    3262:	88 2f       	mov	r24, r24
    3264:	90 e0       	ldi	r25, 0x00	; 0
    3266:	28 0f       	add	r18, r24
    3268:	39 1f       	adc	r19, r25
    326a:	8a 81       	ldd	r24, Y+2	; 0x02
    326c:	9b 81       	ldd	r25, Y+3	; 0x03
    326e:	fc 01       	movw	r30, r24
    3270:	35 83       	std	Z+5, r19	; 0x05
    3272:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3274:	8a 81       	ldd	r24, Y+2	; 0x02
    3276:	9b 81       	ldd	r25, Y+3	; 0x03
    3278:	fc 01       	movw	r30, r24
    327a:	24 81       	ldd	r18, Z+4	; 0x04
    327c:	35 81       	ldd	r19, Z+5	; 0x05
    327e:	8a 81       	ldd	r24, Y+2	; 0x02
    3280:	9b 81       	ldd	r25, Y+3	; 0x03
    3282:	fc 01       	movw	r30, r24
    3284:	82 81       	ldd	r24, Z+2	; 0x02
    3286:	93 81       	ldd	r25, Z+3	; 0x03
    3288:	28 17       	cp	r18, r24
    328a:	39 07       	cpc	r19, r25
    328c:	08 f4       	brcc	.+2      	; 0x3290 <prvCopyDataToQueue+0x8e>
    328e:	65 c0       	rjmp	.+202    	; 0x335a <prvCopyDataToQueue+0x158>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3290:	8a 81       	ldd	r24, Y+2	; 0x02
    3292:	9b 81       	ldd	r25, Y+3	; 0x03
    3294:	fc 01       	movw	r30, r24
    3296:	20 81       	ld	r18, Z
    3298:	31 81       	ldd	r19, Z+1	; 0x01
    329a:	8a 81       	ldd	r24, Y+2	; 0x02
    329c:	9b 81       	ldd	r25, Y+3	; 0x03
    329e:	fc 01       	movw	r30, r24
    32a0:	35 83       	std	Z+5, r19	; 0x05
    32a2:	24 83       	std	Z+4, r18	; 0x04
    32a4:	5a c0       	rjmp	.+180    	; 0x335a <prvCopyDataToQueue+0x158>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    32a6:	8a 81       	ldd	r24, Y+2	; 0x02
    32a8:	9b 81       	ldd	r25, Y+3	; 0x03
    32aa:	fc 01       	movw	r30, r24
    32ac:	84 8d       	ldd	r24, Z+28	; 0x1c
    32ae:	48 2f       	mov	r20, r24
    32b0:	50 e0       	ldi	r21, 0x00	; 0
    32b2:	8a 81       	ldd	r24, Y+2	; 0x02
    32b4:	9b 81       	ldd	r25, Y+3	; 0x03
    32b6:	fc 01       	movw	r30, r24
    32b8:	86 81       	ldd	r24, Z+6	; 0x06
    32ba:	97 81       	ldd	r25, Z+7	; 0x07
    32bc:	2c 81       	ldd	r18, Y+4	; 0x04
    32be:	3d 81       	ldd	r19, Y+5	; 0x05
    32c0:	b9 01       	movw	r22, r18
    32c2:	0e 94 4c 28 	call	0x5098	; 0x5098 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    32c6:	8a 81       	ldd	r24, Y+2	; 0x02
    32c8:	9b 81       	ldd	r25, Y+3	; 0x03
    32ca:	fc 01       	movw	r30, r24
    32cc:	26 81       	ldd	r18, Z+6	; 0x06
    32ce:	37 81       	ldd	r19, Z+7	; 0x07
    32d0:	8a 81       	ldd	r24, Y+2	; 0x02
    32d2:	9b 81       	ldd	r25, Y+3	; 0x03
    32d4:	fc 01       	movw	r30, r24
    32d6:	84 8d       	ldd	r24, Z+28	; 0x1c
    32d8:	88 2f       	mov	r24, r24
    32da:	90 e0       	ldi	r25, 0x00	; 0
    32dc:	91 95       	neg	r25
    32de:	81 95       	neg	r24
    32e0:	91 09       	sbc	r25, r1
    32e2:	28 0f       	add	r18, r24
    32e4:	39 1f       	adc	r19, r25
    32e6:	8a 81       	ldd	r24, Y+2	; 0x02
    32e8:	9b 81       	ldd	r25, Y+3	; 0x03
    32ea:	fc 01       	movw	r30, r24
    32ec:	37 83       	std	Z+7, r19	; 0x07
    32ee:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    32f0:	8a 81       	ldd	r24, Y+2	; 0x02
    32f2:	9b 81       	ldd	r25, Y+3	; 0x03
    32f4:	fc 01       	movw	r30, r24
    32f6:	26 81       	ldd	r18, Z+6	; 0x06
    32f8:	37 81       	ldd	r19, Z+7	; 0x07
    32fa:	8a 81       	ldd	r24, Y+2	; 0x02
    32fc:	9b 81       	ldd	r25, Y+3	; 0x03
    32fe:	fc 01       	movw	r30, r24
    3300:	80 81       	ld	r24, Z
    3302:	91 81       	ldd	r25, Z+1	; 0x01
    3304:	28 17       	cp	r18, r24
    3306:	39 07       	cpc	r19, r25
    3308:	a8 f4       	brcc	.+42     	; 0x3334 <prvCopyDataToQueue+0x132>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    330a:	8a 81       	ldd	r24, Y+2	; 0x02
    330c:	9b 81       	ldd	r25, Y+3	; 0x03
    330e:	fc 01       	movw	r30, r24
    3310:	22 81       	ldd	r18, Z+2	; 0x02
    3312:	33 81       	ldd	r19, Z+3	; 0x03
    3314:	8a 81       	ldd	r24, Y+2	; 0x02
    3316:	9b 81       	ldd	r25, Y+3	; 0x03
    3318:	fc 01       	movw	r30, r24
    331a:	84 8d       	ldd	r24, Z+28	; 0x1c
    331c:	88 2f       	mov	r24, r24
    331e:	90 e0       	ldi	r25, 0x00	; 0
    3320:	91 95       	neg	r25
    3322:	81 95       	neg	r24
    3324:	91 09       	sbc	r25, r1
    3326:	28 0f       	add	r18, r24
    3328:	39 1f       	adc	r19, r25
    332a:	8a 81       	ldd	r24, Y+2	; 0x02
    332c:	9b 81       	ldd	r25, Y+3	; 0x03
    332e:	fc 01       	movw	r30, r24
    3330:	37 83       	std	Z+7, r19	; 0x07
    3332:	26 83       	std	Z+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    3334:	8e 81       	ldd	r24, Y+6	; 0x06
    3336:	82 30       	cpi	r24, 0x02	; 2
    3338:	81 f4       	brne	.+32     	; 0x335a <prvCopyDataToQueue+0x158>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    333a:	8a 81       	ldd	r24, Y+2	; 0x02
    333c:	9b 81       	ldd	r25, Y+3	; 0x03
    333e:	fc 01       	movw	r30, r24
    3340:	82 8d       	ldd	r24, Z+26	; 0x1a
    3342:	88 23       	and	r24, r24
    3344:	51 f0       	breq	.+20     	; 0x335a <prvCopyDataToQueue+0x158>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    3346:	8a 81       	ldd	r24, Y+2	; 0x02
    3348:	9b 81       	ldd	r25, Y+3	; 0x03
    334a:	fc 01       	movw	r30, r24
    334c:	82 8d       	ldd	r24, Z+26	; 0x1a
    334e:	2f ef       	ldi	r18, 0xFF	; 255
    3350:	28 0f       	add	r18, r24
    3352:	8a 81       	ldd	r24, Y+2	; 0x02
    3354:	9b 81       	ldd	r25, Y+3	; 0x03
    3356:	fc 01       	movw	r30, r24
    3358:	22 8f       	std	Z+26, r18	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    335a:	8a 81       	ldd	r24, Y+2	; 0x02
    335c:	9b 81       	ldd	r25, Y+3	; 0x03
    335e:	fc 01       	movw	r30, r24
    3360:	82 8d       	ldd	r24, Z+26	; 0x1a
    3362:	21 e0       	ldi	r18, 0x01	; 1
    3364:	28 0f       	add	r18, r24
    3366:	8a 81       	ldd	r24, Y+2	; 0x02
    3368:	9b 81       	ldd	r25, Y+3	; 0x03
    336a:	fc 01       	movw	r30, r24
    336c:	22 8f       	std	Z+26, r18	; 0x1a

	return xReturn;
    336e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3370:	26 96       	adiw	r28, 0x06	; 6
    3372:	0f b6       	in	r0, 0x3f	; 63
    3374:	f8 94       	cli
    3376:	de bf       	out	0x3e, r29	; 62
    3378:	0f be       	out	0x3f, r0	; 63
    337a:	cd bf       	out	0x3d, r28	; 61
    337c:	df 91       	pop	r29
    337e:	cf 91       	pop	r28
    3380:	08 95       	ret

00003382 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    3382:	cf 93       	push	r28
    3384:	df 93       	push	r29
    3386:	00 d0       	rcall	.+0      	; 0x3388 <prvCopyDataFromQueue+0x6>
    3388:	00 d0       	rcall	.+0      	; 0x338a <prvCopyDataFromQueue+0x8>
    338a:	cd b7       	in	r28, 0x3d	; 61
    338c:	de b7       	in	r29, 0x3e	; 62
    338e:	9a 83       	std	Y+2, r25	; 0x02
    3390:	89 83       	std	Y+1, r24	; 0x01
    3392:	7c 83       	std	Y+4, r23	; 0x04
    3394:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3396:	89 81       	ldd	r24, Y+1	; 0x01
    3398:	9a 81       	ldd	r25, Y+2	; 0x02
    339a:	fc 01       	movw	r30, r24
    339c:	84 8d       	ldd	r24, Z+28	; 0x1c
    339e:	88 23       	and	r24, r24
    33a0:	c9 f1       	breq	.+114    	; 0x3414 <prvCopyDataFromQueue+0x92>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    33a2:	89 81       	ldd	r24, Y+1	; 0x01
    33a4:	9a 81       	ldd	r25, Y+2	; 0x02
    33a6:	fc 01       	movw	r30, r24
    33a8:	26 81       	ldd	r18, Z+6	; 0x06
    33aa:	37 81       	ldd	r19, Z+7	; 0x07
    33ac:	89 81       	ldd	r24, Y+1	; 0x01
    33ae:	9a 81       	ldd	r25, Y+2	; 0x02
    33b0:	fc 01       	movw	r30, r24
    33b2:	84 8d       	ldd	r24, Z+28	; 0x1c
    33b4:	88 2f       	mov	r24, r24
    33b6:	90 e0       	ldi	r25, 0x00	; 0
    33b8:	28 0f       	add	r18, r24
    33ba:	39 1f       	adc	r19, r25
    33bc:	89 81       	ldd	r24, Y+1	; 0x01
    33be:	9a 81       	ldd	r25, Y+2	; 0x02
    33c0:	fc 01       	movw	r30, r24
    33c2:	37 83       	std	Z+7, r19	; 0x07
    33c4:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    33c6:	89 81       	ldd	r24, Y+1	; 0x01
    33c8:	9a 81       	ldd	r25, Y+2	; 0x02
    33ca:	fc 01       	movw	r30, r24
    33cc:	26 81       	ldd	r18, Z+6	; 0x06
    33ce:	37 81       	ldd	r19, Z+7	; 0x07
    33d0:	89 81       	ldd	r24, Y+1	; 0x01
    33d2:	9a 81       	ldd	r25, Y+2	; 0x02
    33d4:	fc 01       	movw	r30, r24
    33d6:	82 81       	ldd	r24, Z+2	; 0x02
    33d8:	93 81       	ldd	r25, Z+3	; 0x03
    33da:	28 17       	cp	r18, r24
    33dc:	39 07       	cpc	r19, r25
    33de:	50 f0       	brcs	.+20     	; 0x33f4 <prvCopyDataFromQueue+0x72>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    33e0:	89 81       	ldd	r24, Y+1	; 0x01
    33e2:	9a 81       	ldd	r25, Y+2	; 0x02
    33e4:	fc 01       	movw	r30, r24
    33e6:	20 81       	ld	r18, Z
    33e8:	31 81       	ldd	r19, Z+1	; 0x01
    33ea:	89 81       	ldd	r24, Y+1	; 0x01
    33ec:	9a 81       	ldd	r25, Y+2	; 0x02
    33ee:	fc 01       	movw	r30, r24
    33f0:	37 83       	std	Z+7, r19	; 0x07
    33f2:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    33f4:	89 81       	ldd	r24, Y+1	; 0x01
    33f6:	9a 81       	ldd	r25, Y+2	; 0x02
    33f8:	fc 01       	movw	r30, r24
    33fa:	84 8d       	ldd	r24, Z+28	; 0x1c
    33fc:	48 2f       	mov	r20, r24
    33fe:	50 e0       	ldi	r21, 0x00	; 0
    3400:	89 81       	ldd	r24, Y+1	; 0x01
    3402:	9a 81       	ldd	r25, Y+2	; 0x02
    3404:	fc 01       	movw	r30, r24
    3406:	26 81       	ldd	r18, Z+6	; 0x06
    3408:	37 81       	ldd	r19, Z+7	; 0x07
    340a:	8b 81       	ldd	r24, Y+3	; 0x03
    340c:	9c 81       	ldd	r25, Y+4	; 0x04
    340e:	b9 01       	movw	r22, r18
    3410:	0e 94 4c 28 	call	0x5098	; 0x5098 <memcpy>
	}
}
    3414:	0f 90       	pop	r0
    3416:	0f 90       	pop	r0
    3418:	0f 90       	pop	r0
    341a:	0f 90       	pop	r0
    341c:	df 91       	pop	r29
    341e:	cf 91       	pop	r28
    3420:	08 95       	ret

00003422 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3422:	cf 93       	push	r28
    3424:	df 93       	push	r29
    3426:	00 d0       	rcall	.+0      	; 0x3428 <prvUnlockQueue+0x6>
    3428:	cd b7       	in	r28, 0x3d	; 61
    342a:	de b7       	in	r29, 0x3e	; 62
    342c:	9a 83       	std	Y+2, r25	; 0x02
    342e:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3430:	0f b6       	in	r0, 0x3f	; 63
    3432:	f8 94       	cli
    3434:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3436:	1b c0       	rjmp	.+54     	; 0x346e <prvUnlockQueue+0x4c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3438:	89 81       	ldd	r24, Y+1	; 0x01
    343a:	9a 81       	ldd	r25, Y+2	; 0x02
    343c:	fc 01       	movw	r30, r24
    343e:	81 89       	ldd	r24, Z+17	; 0x11
    3440:	88 23       	and	r24, r24
    3442:	51 f0       	breq	.+20     	; 0x3458 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3444:	89 81       	ldd	r24, Y+1	; 0x01
    3446:	9a 81       	ldd	r25, Y+2	; 0x02
    3448:	41 96       	adiw	r24, 0x11	; 17
    344a:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <xTaskRemoveFromEventList>
    344e:	88 23       	and	r24, r24
    3450:	21 f0       	breq	.+8      	; 0x345a <prvUnlockQueue+0x38>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    3452:	0e 94 22 21 	call	0x4244	; 0x4244 <vTaskMissedYield>
    3456:	01 c0       	rjmp	.+2      	; 0x345a <prvUnlockQueue+0x38>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
    3458:	10 c0       	rjmp	.+32     	; 0x347a <prvUnlockQueue+0x58>
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    345a:	89 81       	ldd	r24, Y+1	; 0x01
    345c:	9a 81       	ldd	r25, Y+2	; 0x02
    345e:	fc 01       	movw	r30, r24
    3460:	86 8d       	ldd	r24, Z+30	; 0x1e
    3462:	81 50       	subi	r24, 0x01	; 1
    3464:	28 2f       	mov	r18, r24
    3466:	89 81       	ldd	r24, Y+1	; 0x01
    3468:	9a 81       	ldd	r25, Y+2	; 0x02
    346a:	fc 01       	movw	r30, r24
    346c:	26 8f       	std	Z+30, r18	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    346e:	89 81       	ldd	r24, Y+1	; 0x01
    3470:	9a 81       	ldd	r25, Y+2	; 0x02
    3472:	fc 01       	movw	r30, r24
    3474:	86 8d       	ldd	r24, Z+30	; 0x1e
    3476:	18 16       	cp	r1, r24
    3478:	fc f2       	brlt	.-66     	; 0x3438 <prvUnlockQueue+0x16>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    347a:	89 81       	ldd	r24, Y+1	; 0x01
    347c:	9a 81       	ldd	r25, Y+2	; 0x02
    347e:	2f ef       	ldi	r18, 0xFF	; 255
    3480:	fc 01       	movw	r30, r24
    3482:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    3484:	0f 90       	pop	r0
    3486:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3488:	0f b6       	in	r0, 0x3f	; 63
    348a:	f8 94       	cli
    348c:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    348e:	1b c0       	rjmp	.+54     	; 0x34c6 <prvUnlockQueue+0xa4>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3490:	89 81       	ldd	r24, Y+1	; 0x01
    3492:	9a 81       	ldd	r25, Y+2	; 0x02
    3494:	fc 01       	movw	r30, r24
    3496:	80 85       	ldd	r24, Z+8	; 0x08
    3498:	88 23       	and	r24, r24
    349a:	a1 f0       	breq	.+40     	; 0x34c4 <prvUnlockQueue+0xa2>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    349c:	89 81       	ldd	r24, Y+1	; 0x01
    349e:	9a 81       	ldd	r25, Y+2	; 0x02
    34a0:	08 96       	adiw	r24, 0x08	; 8
    34a2:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <xTaskRemoveFromEventList>
    34a6:	88 23       	and	r24, r24
    34a8:	11 f0       	breq	.+4      	; 0x34ae <prvUnlockQueue+0x8c>
				{
					vTaskMissedYield();
    34aa:	0e 94 22 21 	call	0x4244	; 0x4244 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    34ae:	89 81       	ldd	r24, Y+1	; 0x01
    34b0:	9a 81       	ldd	r25, Y+2	; 0x02
    34b2:	fc 01       	movw	r30, r24
    34b4:	85 8d       	ldd	r24, Z+29	; 0x1d
    34b6:	81 50       	subi	r24, 0x01	; 1
    34b8:	28 2f       	mov	r18, r24
    34ba:	89 81       	ldd	r24, Y+1	; 0x01
    34bc:	9a 81       	ldd	r25, Y+2	; 0x02
    34be:	fc 01       	movw	r30, r24
    34c0:	25 8f       	std	Z+29, r18	; 0x1d
    34c2:	01 c0       	rjmp	.+2      	; 0x34c6 <prvUnlockQueue+0xa4>
			}
			else
			{
				break;
    34c4:	06 c0       	rjmp	.+12     	; 0x34d2 <prvUnlockQueue+0xb0>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    34c6:	89 81       	ldd	r24, Y+1	; 0x01
    34c8:	9a 81       	ldd	r25, Y+2	; 0x02
    34ca:	fc 01       	movw	r30, r24
    34cc:	85 8d       	ldd	r24, Z+29	; 0x1d
    34ce:	18 16       	cp	r1, r24
    34d0:	fc f2       	brlt	.-66     	; 0x3490 <prvUnlockQueue+0x6e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    34d2:	89 81       	ldd	r24, Y+1	; 0x01
    34d4:	9a 81       	ldd	r25, Y+2	; 0x02
    34d6:	2f ef       	ldi	r18, 0xFF	; 255
    34d8:	fc 01       	movw	r30, r24
    34da:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    34dc:	0f 90       	pop	r0
    34de:	0f be       	out	0x3f, r0	; 63
}
    34e0:	0f 90       	pop	r0
    34e2:	0f 90       	pop	r0
    34e4:	df 91       	pop	r29
    34e6:	cf 91       	pop	r28
    34e8:	08 95       	ret

000034ea <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    34ea:	cf 93       	push	r28
    34ec:	df 93       	push	r29
    34ee:	00 d0       	rcall	.+0      	; 0x34f0 <prvIsQueueEmpty+0x6>
    34f0:	1f 92       	push	r1
    34f2:	cd b7       	in	r28, 0x3d	; 61
    34f4:	de b7       	in	r29, 0x3e	; 62
    34f6:	9b 83       	std	Y+3, r25	; 0x03
    34f8:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    34fa:	0f b6       	in	r0, 0x3f	; 63
    34fc:	f8 94       	cli
    34fe:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3500:	8a 81       	ldd	r24, Y+2	; 0x02
    3502:	9b 81       	ldd	r25, Y+3	; 0x03
    3504:	fc 01       	movw	r30, r24
    3506:	82 8d       	ldd	r24, Z+26	; 0x1a
    3508:	88 23       	and	r24, r24
    350a:	19 f4       	brne	.+6      	; 0x3512 <prvIsQueueEmpty+0x28>
		{
			xReturn = pdTRUE;
    350c:	81 e0       	ldi	r24, 0x01	; 1
    350e:	89 83       	std	Y+1, r24	; 0x01
    3510:	01 c0       	rjmp	.+2      	; 0x3514 <prvIsQueueEmpty+0x2a>
		}
		else
		{
			xReturn = pdFALSE;
    3512:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3514:	0f 90       	pop	r0
    3516:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3518:	89 81       	ldd	r24, Y+1	; 0x01
}
    351a:	0f 90       	pop	r0
    351c:	0f 90       	pop	r0
    351e:	0f 90       	pop	r0
    3520:	df 91       	pop	r29
    3522:	cf 91       	pop	r28
    3524:	08 95       	ret

00003526 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    3526:	cf 93       	push	r28
    3528:	df 93       	push	r29
    352a:	00 d0       	rcall	.+0      	; 0x352c <xQueueIsQueueEmptyFromISR+0x6>
    352c:	1f 92       	push	r1
    352e:	cd b7       	in	r28, 0x3d	; 61
    3530:	de b7       	in	r29, 0x3e	; 62
    3532:	9b 83       	std	Y+3, r25	; 0x03
    3534:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3536:	8a 81       	ldd	r24, Y+2	; 0x02
    3538:	9b 81       	ldd	r25, Y+3	; 0x03
    353a:	fc 01       	movw	r30, r24
    353c:	82 8d       	ldd	r24, Z+26	; 0x1a
    353e:	88 23       	and	r24, r24
    3540:	19 f4       	brne	.+6      	; 0x3548 <xQueueIsQueueEmptyFromISR+0x22>
	{
		xReturn = pdTRUE;
    3542:	81 e0       	ldi	r24, 0x01	; 1
    3544:	89 83       	std	Y+1, r24	; 0x01
    3546:	01 c0       	rjmp	.+2      	; 0x354a <xQueueIsQueueEmptyFromISR+0x24>
	}
	else
	{
		xReturn = pdFALSE;
    3548:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    354a:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    354c:	0f 90       	pop	r0
    354e:	0f 90       	pop	r0
    3550:	0f 90       	pop	r0
    3552:	df 91       	pop	r29
    3554:	cf 91       	pop	r28
    3556:	08 95       	ret

00003558 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    3558:	cf 93       	push	r28
    355a:	df 93       	push	r29
    355c:	00 d0       	rcall	.+0      	; 0x355e <prvIsQueueFull+0x6>
    355e:	1f 92       	push	r1
    3560:	cd b7       	in	r28, 0x3d	; 61
    3562:	de b7       	in	r29, 0x3e	; 62
    3564:	9b 83       	std	Y+3, r25	; 0x03
    3566:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3568:	0f b6       	in	r0, 0x3f	; 63
    356a:	f8 94       	cli
    356c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    356e:	8a 81       	ldd	r24, Y+2	; 0x02
    3570:	9b 81       	ldd	r25, Y+3	; 0x03
    3572:	fc 01       	movw	r30, r24
    3574:	22 8d       	ldd	r18, Z+26	; 0x1a
    3576:	8a 81       	ldd	r24, Y+2	; 0x02
    3578:	9b 81       	ldd	r25, Y+3	; 0x03
    357a:	fc 01       	movw	r30, r24
    357c:	83 8d       	ldd	r24, Z+27	; 0x1b
    357e:	28 17       	cp	r18, r24
    3580:	19 f4       	brne	.+6      	; 0x3588 <prvIsQueueFull+0x30>
		{
			xReturn = pdTRUE;
    3582:	81 e0       	ldi	r24, 0x01	; 1
    3584:	89 83       	std	Y+1, r24	; 0x01
    3586:	01 c0       	rjmp	.+2      	; 0x358a <prvIsQueueFull+0x32>
		}
		else
		{
			xReturn = pdFALSE;
    3588:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    358a:	0f 90       	pop	r0
    358c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    358e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3590:	0f 90       	pop	r0
    3592:	0f 90       	pop	r0
    3594:	0f 90       	pop	r0
    3596:	df 91       	pop	r29
    3598:	cf 91       	pop	r28
    359a:	08 95       	ret

0000359c <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    359c:	cf 93       	push	r28
    359e:	df 93       	push	r29
    35a0:	00 d0       	rcall	.+0      	; 0x35a2 <xQueueIsQueueFullFromISR+0x6>
    35a2:	1f 92       	push	r1
    35a4:	cd b7       	in	r28, 0x3d	; 61
    35a6:	de b7       	in	r29, 0x3e	; 62
    35a8:	9b 83       	std	Y+3, r25	; 0x03
    35aa:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    35ac:	8a 81       	ldd	r24, Y+2	; 0x02
    35ae:	9b 81       	ldd	r25, Y+3	; 0x03
    35b0:	fc 01       	movw	r30, r24
    35b2:	22 8d       	ldd	r18, Z+26	; 0x1a
    35b4:	8a 81       	ldd	r24, Y+2	; 0x02
    35b6:	9b 81       	ldd	r25, Y+3	; 0x03
    35b8:	fc 01       	movw	r30, r24
    35ba:	83 8d       	ldd	r24, Z+27	; 0x1b
    35bc:	28 17       	cp	r18, r24
    35be:	19 f4       	brne	.+6      	; 0x35c6 <xQueueIsQueueFullFromISR+0x2a>
	{
		xReturn = pdTRUE;
    35c0:	81 e0       	ldi	r24, 0x01	; 1
    35c2:	89 83       	std	Y+1, r24	; 0x01
    35c4:	01 c0       	rjmp	.+2      	; 0x35c8 <xQueueIsQueueFullFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    35c6:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    35c8:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    35ca:	0f 90       	pop	r0
    35cc:	0f 90       	pop	r0
    35ce:	0f 90       	pop	r0
    35d0:	df 91       	pop	r29
    35d2:	cf 91       	pop	r28
    35d4:	08 95       	ret

000035d6 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    35d6:	af 92       	push	r10
    35d8:	bf 92       	push	r11
    35da:	cf 92       	push	r12
    35dc:	df 92       	push	r13
    35de:	ef 92       	push	r14
    35e0:	ff 92       	push	r15
    35e2:	0f 93       	push	r16
    35e4:	1f 93       	push	r17
    35e6:	cf 93       	push	r28
    35e8:	df 93       	push	r29
    35ea:	cd b7       	in	r28, 0x3d	; 61
    35ec:	de b7       	in	r29, 0x3e	; 62
    35ee:	64 97       	sbiw	r28, 0x14	; 20
    35f0:	0f b6       	in	r0, 0x3f	; 63
    35f2:	f8 94       	cli
    35f4:	de bf       	out	0x3e, r29	; 62
    35f6:	0f be       	out	0x3f, r0	; 63
    35f8:	cd bf       	out	0x3d, r28	; 61
    35fa:	9f 83       	std	Y+7, r25	; 0x07
    35fc:	8e 83       	std	Y+6, r24	; 0x06
    35fe:	79 87       	std	Y+9, r23	; 0x09
    3600:	68 87       	std	Y+8, r22	; 0x08
    3602:	5b 87       	std	Y+11, r21	; 0x0b
    3604:	4a 87       	std	Y+10, r20	; 0x0a
    3606:	3d 87       	std	Y+13, r19	; 0x0d
    3608:	2c 87       	std	Y+12, r18	; 0x0c
    360a:	0e 87       	std	Y+14, r16	; 0x0e
    360c:	f8 8a       	std	Y+16, r15	; 0x10
    360e:	ef 86       	std	Y+15, r14	; 0x0f
    3610:	da 8a       	std	Y+18, r13	; 0x12
    3612:	c9 8a       	std	Y+17, r12	; 0x11
    3614:	bc 8a       	std	Y+20, r11	; 0x14
    3616:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    3618:	29 89       	ldd	r18, Y+17	; 0x11
    361a:	3a 89       	ldd	r19, Y+18	; 0x12
    361c:	8a 85       	ldd	r24, Y+10	; 0x0a
    361e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3620:	b9 01       	movw	r22, r18
    3622:	0e 94 87 22 	call	0x450e	; 0x450e <prvAllocateTCBAndStack>
    3626:	9b 83       	std	Y+3, r25	; 0x03
    3628:	8a 83       	std	Y+2, r24	; 0x02

	if( pxNewTCB != NULL )
    362a:	8a 81       	ldd	r24, Y+2	; 0x02
    362c:	9b 81       	ldd	r25, Y+3	; 0x03
    362e:	89 2b       	or	r24, r25
    3630:	09 f4       	brne	.+2      	; 0x3634 <xTaskGenericCreate+0x5e>
    3632:	91 c0       	rjmp	.+290    	; 0x3756 <xTaskGenericCreate+0x180>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    3634:	8a 81       	ldd	r24, Y+2	; 0x02
    3636:	9b 81       	ldd	r25, Y+3	; 0x03
    3638:	fc 01       	movw	r30, r24
    363a:	27 89       	ldd	r18, Z+23	; 0x17
    363c:	30 8d       	ldd	r19, Z+24	; 0x18
    363e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3640:	9b 85       	ldd	r25, Y+11	; 0x0b
    3642:	01 97       	sbiw	r24, 0x01	; 1
    3644:	82 0f       	add	r24, r18
    3646:	93 1f       	adc	r25, r19
    3648:	9d 83       	std	Y+5, r25	; 0x05
    364a:	8c 83       	std	Y+4, r24	; 0x04
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    364c:	4a 85       	ldd	r20, Y+10	; 0x0a
    364e:	5b 85       	ldd	r21, Y+11	; 0x0b
    3650:	2b 89       	ldd	r18, Y+19	; 0x13
    3652:	3c 89       	ldd	r19, Y+20	; 0x14
    3654:	68 85       	ldd	r22, Y+8	; 0x08
    3656:	79 85       	ldd	r23, Y+9	; 0x09
    3658:	8a 81       	ldd	r24, Y+2	; 0x02
    365a:	9b 81       	ldd	r25, Y+3	; 0x03
    365c:	8a 01       	movw	r16, r20
    365e:	4e 85       	ldd	r20, Y+14	; 0x0e
    3660:	0e 94 3c 21 	call	0x4278	; 0x4278 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3664:	4c 85       	ldd	r20, Y+12	; 0x0c
    3666:	5d 85       	ldd	r21, Y+13	; 0x0d
    3668:	2e 81       	ldd	r18, Y+6	; 0x06
    366a:	3f 81       	ldd	r19, Y+7	; 0x07
    366c:	8c 81       	ldd	r24, Y+4	; 0x04
    366e:	9d 81       	ldd	r25, Y+5	; 0x05
    3670:	b9 01       	movw	r22, r18
    3672:	0e 94 43 11 	call	0x2286	; 0x2286 <pxPortInitialiseStack>
    3676:	9c 01       	movw	r18, r24
    3678:	8a 81       	ldd	r24, Y+2	; 0x02
    367a:	9b 81       	ldd	r25, Y+3	; 0x03
    367c:	fc 01       	movw	r30, r24
    367e:	31 83       	std	Z+1, r19	; 0x01
    3680:	20 83       	st	Z, r18
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    3682:	8f 85       	ldd	r24, Y+15	; 0x0f
    3684:	98 89       	ldd	r25, Y+16	; 0x10
    3686:	89 2b       	or	r24, r25
    3688:	39 f0       	breq	.+14     	; 0x3698 <xTaskGenericCreate+0xc2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    368a:	8f 85       	ldd	r24, Y+15	; 0x0f
    368c:	98 89       	ldd	r25, Y+16	; 0x10
    368e:	2a 81       	ldd	r18, Y+2	; 0x02
    3690:	3b 81       	ldd	r19, Y+3	; 0x03
    3692:	fc 01       	movw	r30, r24
    3694:	31 83       	std	Z+1, r19	; 0x01
    3696:	20 83       	st	Z, r18
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    3698:	0f b6       	in	r0, 0x3f	; 63
    369a:	f8 94       	cli
    369c:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    369e:	80 91 49 05 	lds	r24, 0x0549
    36a2:	8f 5f       	subi	r24, 0xFF	; 255
    36a4:	80 93 49 05 	sts	0x0549, r24
			if( pxCurrentTCB == NULL )
    36a8:	80 91 fa 04 	lds	r24, 0x04FA
    36ac:	90 91 fb 04 	lds	r25, 0x04FB
    36b0:	89 2b       	or	r24, r25
    36b2:	69 f4       	brne	.+26     	; 0x36ce <xTaskGenericCreate+0xf8>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    36b4:	8a 81       	ldd	r24, Y+2	; 0x02
    36b6:	9b 81       	ldd	r25, Y+3	; 0x03
    36b8:	90 93 fb 04 	sts	0x04FB, r25
    36bc:	80 93 fa 04 	sts	0x04FA, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    36c0:	80 91 49 05 	lds	r24, 0x0549
    36c4:	81 30       	cpi	r24, 0x01	; 1
    36c6:	b1 f4       	brne	.+44     	; 0x36f4 <xTaskGenericCreate+0x11e>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    36c8:	0e 94 c0 21 	call	0x4380	; 0x4380 <prvInitialiseTaskLists>
    36cc:	13 c0       	rjmp	.+38     	; 0x36f4 <xTaskGenericCreate+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    36ce:	80 91 4d 05 	lds	r24, 0x054D
    36d2:	88 23       	and	r24, r24
    36d4:	79 f4       	brne	.+30     	; 0x36f4 <xTaskGenericCreate+0x11e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    36d6:	80 91 fa 04 	lds	r24, 0x04FA
    36da:	90 91 fb 04 	lds	r25, 0x04FB
    36de:	fc 01       	movw	r30, r24
    36e0:	96 89       	ldd	r25, Z+22	; 0x16
    36e2:	8e 85       	ldd	r24, Y+14	; 0x0e
    36e4:	89 17       	cp	r24, r25
    36e6:	30 f0       	brcs	.+12     	; 0x36f4 <xTaskGenericCreate+0x11e>
					{
						pxCurrentTCB = pxNewTCB;
    36e8:	8a 81       	ldd	r24, Y+2	; 0x02
    36ea:	9b 81       	ldd	r25, Y+3	; 0x03
    36ec:	90 93 fb 04 	sts	0x04FB, r25
    36f0:	80 93 fa 04 	sts	0x04FA, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    36f4:	80 91 51 05 	lds	r24, 0x0551
    36f8:	8f 5f       	subi	r24, 0xFF	; 255
    36fa:	80 93 51 05 	sts	0x0551, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    36fe:	8a 81       	ldd	r24, Y+2	; 0x02
    3700:	9b 81       	ldd	r25, Y+3	; 0x03
    3702:	fc 01       	movw	r30, r24
    3704:	96 89       	ldd	r25, Z+22	; 0x16
    3706:	80 91 4c 05 	lds	r24, 0x054C
    370a:	89 17       	cp	r24, r25
    370c:	30 f4       	brcc	.+12     	; 0x371a <xTaskGenericCreate+0x144>
    370e:	8a 81       	ldd	r24, Y+2	; 0x02
    3710:	9b 81       	ldd	r25, Y+3	; 0x03
    3712:	fc 01       	movw	r30, r24
    3714:	86 89       	ldd	r24, Z+22	; 0x16
    3716:	80 93 4c 05 	sts	0x054C, r24
    371a:	8a 81       	ldd	r24, Y+2	; 0x02
    371c:	9b 81       	ldd	r25, Y+3	; 0x03
    371e:	ac 01       	movw	r20, r24
    3720:	4e 5f       	subi	r20, 0xFE	; 254
    3722:	5f 4f       	sbci	r21, 0xFF	; 255
    3724:	8a 81       	ldd	r24, Y+2	; 0x02
    3726:	9b 81       	ldd	r25, Y+3	; 0x03
    3728:	fc 01       	movw	r30, r24
    372a:	86 89       	ldd	r24, Z+22	; 0x16
    372c:	28 2f       	mov	r18, r24
    372e:	30 e0       	ldi	r19, 0x00	; 0
    3730:	c9 01       	movw	r24, r18
    3732:	88 0f       	add	r24, r24
    3734:	99 1f       	adc	r25, r25
    3736:	88 0f       	add	r24, r24
    3738:	99 1f       	adc	r25, r25
    373a:	88 0f       	add	r24, r24
    373c:	99 1f       	adc	r25, r25
    373e:	82 0f       	add	r24, r18
    3740:	93 1f       	adc	r25, r19
    3742:	84 50       	subi	r24, 0x04	; 4
    3744:	9b 4f       	sbci	r25, 0xFB	; 251
    3746:	ba 01       	movw	r22, r20
    3748:	0e 94 27 10 	call	0x204e	; 0x204e <vListInsertEnd>

			xReturn = pdPASS;
    374c:	81 e0       	ldi	r24, 0x01	; 1
    374e:	89 83       	std	Y+1, r24	; 0x01
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    3750:	0f 90       	pop	r0
    3752:	0f be       	out	0x3f, r0	; 63
    3754:	02 c0       	rjmp	.+4      	; 0x375a <xTaskGenericCreate+0x184>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3756:	8f ef       	ldi	r24, 0xFF	; 255
    3758:	89 83       	std	Y+1, r24	; 0x01
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    375a:	89 81       	ldd	r24, Y+1	; 0x01
    375c:	81 30       	cpi	r24, 0x01	; 1
    375e:	79 f4       	brne	.+30     	; 0x377e <xTaskGenericCreate+0x1a8>
	{
		if( xSchedulerRunning != pdFALSE )
    3760:	80 91 4d 05 	lds	r24, 0x054D
    3764:	88 23       	and	r24, r24
    3766:	59 f0       	breq	.+22     	; 0x377e <xTaskGenericCreate+0x1a8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    3768:	80 91 fa 04 	lds	r24, 0x04FA
    376c:	90 91 fb 04 	lds	r25, 0x04FB
    3770:	fc 01       	movw	r30, r24
    3772:	96 89       	ldd	r25, Z+22	; 0x16
    3774:	8e 85       	ldd	r24, Y+14	; 0x0e
    3776:	98 17       	cp	r25, r24
    3778:	10 f4       	brcc	.+4      	; 0x377e <xTaskGenericCreate+0x1a8>
			{
				taskYIELD_IF_USING_PREEMPTION();
    377a:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    377e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3780:	64 96       	adiw	r28, 0x14	; 20
    3782:	0f b6       	in	r0, 0x3f	; 63
    3784:	f8 94       	cli
    3786:	de bf       	out	0x3e, r29	; 62
    3788:	0f be       	out	0x3f, r0	; 63
    378a:	cd bf       	out	0x3d, r28	; 61
    378c:	df 91       	pop	r29
    378e:	cf 91       	pop	r28
    3790:	1f 91       	pop	r17
    3792:	0f 91       	pop	r16
    3794:	ff 90       	pop	r15
    3796:	ef 90       	pop	r14
    3798:	df 90       	pop	r13
    379a:	cf 90       	pop	r12
    379c:	bf 90       	pop	r11
    379e:	af 90       	pop	r10
    37a0:	08 95       	ret

000037a2 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    37a2:	cf 93       	push	r28
    37a4:	df 93       	push	r29
    37a6:	00 d0       	rcall	.+0      	; 0x37a8 <vTaskDelete+0x6>
    37a8:	00 d0       	rcall	.+0      	; 0x37aa <vTaskDelete+0x8>
    37aa:	cd b7       	in	r28, 0x3d	; 61
    37ac:	de b7       	in	r29, 0x3e	; 62
    37ae:	9c 83       	std	Y+4, r25	; 0x04
    37b0:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    37b2:	0f b6       	in	r0, 0x3f	; 63
    37b4:	f8 94       	cli
    37b6:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    37b8:	8b 81       	ldd	r24, Y+3	; 0x03
    37ba:	9c 81       	ldd	r25, Y+4	; 0x04
    37bc:	89 2b       	or	r24, r25
    37be:	29 f4       	brne	.+10     	; 0x37ca <vTaskDelete+0x28>
    37c0:	80 91 fa 04 	lds	r24, 0x04FA
    37c4:	90 91 fb 04 	lds	r25, 0x04FB
    37c8:	02 c0       	rjmp	.+4      	; 0x37ce <vTaskDelete+0x2c>
    37ca:	8b 81       	ldd	r24, Y+3	; 0x03
    37cc:	9c 81       	ldd	r25, Y+4	; 0x04
    37ce:	9a 83       	std	Y+2, r25	; 0x02
    37d0:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    37d2:	89 81       	ldd	r24, Y+1	; 0x01
    37d4:	9a 81       	ldd	r25, Y+2	; 0x02
    37d6:	02 96       	adiw	r24, 0x02	; 2
    37d8:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    37dc:	89 81       	ldd	r24, Y+1	; 0x01
    37de:	9a 81       	ldd	r25, Y+2	; 0x02
    37e0:	fc 01       	movw	r30, r24
    37e2:	84 89       	ldd	r24, Z+20	; 0x14
    37e4:	95 89       	ldd	r25, Z+21	; 0x15
    37e6:	89 2b       	or	r24, r25
    37e8:	29 f0       	breq	.+10     	; 0x37f4 <vTaskDelete+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    37ea:	89 81       	ldd	r24, Y+1	; 0x01
    37ec:	9a 81       	ldd	r25, Y+2	; 0x02
    37ee:	0c 96       	adiw	r24, 0x0c	; 12
    37f0:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    37f4:	89 81       	ldd	r24, Y+1	; 0x01
    37f6:	9a 81       	ldd	r25, Y+2	; 0x02
    37f8:	02 96       	adiw	r24, 0x02	; 2
    37fa:	bc 01       	movw	r22, r24
    37fc:	8f e3       	ldi	r24, 0x3F	; 63
    37fe:	95 e0       	ldi	r25, 0x05	; 5
    3800:	0e 94 27 10 	call	0x204e	; 0x204e <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    3804:	80 91 48 05 	lds	r24, 0x0548
    3808:	8f 5f       	subi	r24, 0xFF	; 255
    380a:	80 93 48 05 	sts	0x0548, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    380e:	80 91 51 05 	lds	r24, 0x0551
    3812:	8f 5f       	subi	r24, 0xFF	; 255
    3814:	80 93 51 05 	sts	0x0551, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    3818:	0f 90       	pop	r0
    381a:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    381c:	80 91 4d 05 	lds	r24, 0x054D
    3820:	88 23       	and	r24, r24
    3822:	99 f0       	breq	.+38     	; 0x384a <vTaskDelete+0xa8>
		{
			if( pxTCB == pxCurrentTCB )
    3824:	80 91 fa 04 	lds	r24, 0x04FA
    3828:	90 91 fb 04 	lds	r25, 0x04FB
    382c:	29 81       	ldd	r18, Y+1	; 0x01
    382e:	3a 81       	ldd	r19, Y+2	; 0x02
    3830:	28 17       	cp	r18, r24
    3832:	39 07       	cpc	r19, r25
    3834:	19 f4       	brne	.+6      	; 0x383c <vTaskDelete+0x9a>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    3836:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortYield>
    383a:	07 c0       	rjmp	.+14     	; 0x384a <vTaskDelete+0xa8>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    383c:	0f b6       	in	r0, 0x3f	; 63
    383e:	f8 94       	cli
    3840:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    3842:	0e 94 e1 22 	call	0x45c2	; 0x45c2 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    3846:	0f 90       	pop	r0
    3848:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    384a:	0f 90       	pop	r0
    384c:	0f 90       	pop	r0
    384e:	0f 90       	pop	r0
    3850:	0f 90       	pop	r0
    3852:	df 91       	pop	r29
    3854:	cf 91       	pop	r28
    3856:	08 95       	ret

00003858 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    3858:	cf 93       	push	r28
    385a:	df 93       	push	r29
    385c:	cd b7       	in	r28, 0x3d	; 61
    385e:	de b7       	in	r29, 0x3e	; 62
    3860:	2a 97       	sbiw	r28, 0x0a	; 10
    3862:	0f b6       	in	r0, 0x3f	; 63
    3864:	f8 94       	cli
    3866:	de bf       	out	0x3e, r29	; 62
    3868:	0f be       	out	0x3f, r0	; 63
    386a:	cd bf       	out	0x3d, r28	; 61
    386c:	98 87       	std	Y+8, r25	; 0x08
    386e:	8f 83       	std	Y+7, r24	; 0x07
    3870:	7a 87       	std	Y+10, r23	; 0x0a
    3872:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    3874:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    3876:	0e 94 22 1d 	call	0x3a44	; 0x3a44 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    387a:	80 91 4a 05 	lds	r24, 0x054A
    387e:	90 91 4b 05 	lds	r25, 0x054B
    3882:	9b 83       	std	Y+3, r25	; 0x03
    3884:	8a 83       	std	Y+2, r24	; 0x02

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3886:	8f 81       	ldd	r24, Y+7	; 0x07
    3888:	98 85       	ldd	r25, Y+8	; 0x08
    388a:	fc 01       	movw	r30, r24
    388c:	20 81       	ld	r18, Z
    388e:	31 81       	ldd	r19, Z+1	; 0x01
    3890:	89 85       	ldd	r24, Y+9	; 0x09
    3892:	9a 85       	ldd	r25, Y+10	; 0x0a
    3894:	82 0f       	add	r24, r18
    3896:	93 1f       	adc	r25, r19
    3898:	9d 83       	std	Y+5, r25	; 0x05
    389a:	8c 83       	std	Y+4, r24	; 0x04

			if( xConstTickCount < *pxPreviousWakeTime )
    389c:	8f 81       	ldd	r24, Y+7	; 0x07
    389e:	98 85       	ldd	r25, Y+8	; 0x08
    38a0:	fc 01       	movw	r30, r24
    38a2:	20 81       	ld	r18, Z
    38a4:	31 81       	ldd	r19, Z+1	; 0x01
    38a6:	8a 81       	ldd	r24, Y+2	; 0x02
    38a8:	9b 81       	ldd	r25, Y+3	; 0x03
    38aa:	82 17       	cp	r24, r18
    38ac:	93 07       	cpc	r25, r19
    38ae:	a0 f4       	brcc	.+40     	; 0x38d8 <vTaskDelayUntil+0x80>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    38b0:	8f 81       	ldd	r24, Y+7	; 0x07
    38b2:	98 85       	ldd	r25, Y+8	; 0x08
    38b4:	fc 01       	movw	r30, r24
    38b6:	20 81       	ld	r18, Z
    38b8:	31 81       	ldd	r19, Z+1	; 0x01
    38ba:	8c 81       	ldd	r24, Y+4	; 0x04
    38bc:	9d 81       	ldd	r25, Y+5	; 0x05
    38be:	82 17       	cp	r24, r18
    38c0:	93 07       	cpc	r25, r19
    38c2:	e8 f4       	brcc	.+58     	; 0x38fe <vTaskDelayUntil+0xa6>
    38c4:	2c 81       	ldd	r18, Y+4	; 0x04
    38c6:	3d 81       	ldd	r19, Y+5	; 0x05
    38c8:	8a 81       	ldd	r24, Y+2	; 0x02
    38ca:	9b 81       	ldd	r25, Y+3	; 0x03
    38cc:	82 17       	cp	r24, r18
    38ce:	93 07       	cpc	r25, r19
    38d0:	b0 f4       	brcc	.+44     	; 0x38fe <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    38d2:	81 e0       	ldi	r24, 0x01	; 1
    38d4:	89 83       	std	Y+1, r24	; 0x01
    38d6:	13 c0       	rjmp	.+38     	; 0x38fe <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    38d8:	8f 81       	ldd	r24, Y+7	; 0x07
    38da:	98 85       	ldd	r25, Y+8	; 0x08
    38dc:	fc 01       	movw	r30, r24
    38de:	20 81       	ld	r18, Z
    38e0:	31 81       	ldd	r19, Z+1	; 0x01
    38e2:	8c 81       	ldd	r24, Y+4	; 0x04
    38e4:	9d 81       	ldd	r25, Y+5	; 0x05
    38e6:	82 17       	cp	r24, r18
    38e8:	93 07       	cpc	r25, r19
    38ea:	38 f0       	brcs	.+14     	; 0x38fa <vTaskDelayUntil+0xa2>
    38ec:	2c 81       	ldd	r18, Y+4	; 0x04
    38ee:	3d 81       	ldd	r19, Y+5	; 0x05
    38f0:	8a 81       	ldd	r24, Y+2	; 0x02
    38f2:	9b 81       	ldd	r25, Y+3	; 0x03
    38f4:	82 17       	cp	r24, r18
    38f6:	93 07       	cpc	r25, r19
    38f8:	10 f4       	brcc	.+4      	; 0x38fe <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    38fa:	81 e0       	ldi	r24, 0x01	; 1
    38fc:	89 83       	std	Y+1, r24	; 0x01
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    38fe:	8f 81       	ldd	r24, Y+7	; 0x07
    3900:	98 85       	ldd	r25, Y+8	; 0x08
    3902:	2c 81       	ldd	r18, Y+4	; 0x04
    3904:	3d 81       	ldd	r19, Y+5	; 0x05
    3906:	fc 01       	movw	r30, r24
    3908:	31 83       	std	Z+1, r19	; 0x01
    390a:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
    390c:	89 81       	ldd	r24, Y+1	; 0x01
    390e:	88 23       	and	r24, r24
    3910:	59 f0       	breq	.+22     	; 0x3928 <vTaskDelayUntil+0xd0>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3912:	80 91 fa 04 	lds	r24, 0x04FA
    3916:	90 91 fb 04 	lds	r25, 0x04FB
    391a:	02 96       	adiw	r24, 0x02	; 2
    391c:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3920:	8c 81       	ldd	r24, Y+4	; 0x04
    3922:	9d 81       	ldd	r25, Y+5	; 0x05
    3924:	0e 94 3d 22 	call	0x447a	; 0x447a <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    3928:	0e 94 2e 1d 	call	0x3a5c	; 0x3a5c <xTaskResumeAll>
    392c:	8e 83       	std	Y+6, r24	; 0x06

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    392e:	8e 81       	ldd	r24, Y+6	; 0x06
    3930:	88 23       	and	r24, r24
    3932:	11 f4       	brne	.+4      	; 0x3938 <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
    3934:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3938:	2a 96       	adiw	r28, 0x0a	; 10
    393a:	0f b6       	in	r0, 0x3f	; 63
    393c:	f8 94       	cli
    393e:	de bf       	out	0x3e, r29	; 62
    3940:	0f be       	out	0x3f, r0	; 63
    3942:	cd bf       	out	0x3d, r28	; 61
    3944:	df 91       	pop	r29
    3946:	cf 91       	pop	r28
    3948:	08 95       	ret

0000394a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    394a:	cf 93       	push	r28
    394c:	df 93       	push	r29
    394e:	00 d0       	rcall	.+0      	; 0x3950 <vTaskDelay+0x6>
    3950:	00 d0       	rcall	.+0      	; 0x3952 <vTaskDelay+0x8>
    3952:	1f 92       	push	r1
    3954:	cd b7       	in	r28, 0x3d	; 61
    3956:	de b7       	in	r29, 0x3e	; 62
    3958:	9d 83       	std	Y+5, r25	; 0x05
    395a:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    395c:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    395e:	8c 81       	ldd	r24, Y+4	; 0x04
    3960:	9d 81       	ldd	r25, Y+5	; 0x05
    3962:	89 2b       	or	r24, r25
    3964:	d1 f0       	breq	.+52     	; 0x399a <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    3966:	0e 94 22 1d 	call	0x3a44	; 0x3a44 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    396a:	20 91 4a 05 	lds	r18, 0x054A
    396e:	30 91 4b 05 	lds	r19, 0x054B
    3972:	8c 81       	ldd	r24, Y+4	; 0x04
    3974:	9d 81       	ldd	r25, Y+5	; 0x05
    3976:	82 0f       	add	r24, r18
    3978:	93 1f       	adc	r25, r19
    397a:	9b 83       	std	Y+3, r25	; 0x03
    397c:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    397e:	80 91 fa 04 	lds	r24, 0x04FA
    3982:	90 91 fb 04 	lds	r25, 0x04FB
    3986:	02 96       	adiw	r24, 0x02	; 2
    3988:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    398c:	8a 81       	ldd	r24, Y+2	; 0x02
    398e:	9b 81       	ldd	r25, Y+3	; 0x03
    3990:	0e 94 3d 22 	call	0x447a	; 0x447a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3994:	0e 94 2e 1d 	call	0x3a5c	; 0x3a5c <xTaskResumeAll>
    3998:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    399a:	89 81       	ldd	r24, Y+1	; 0x01
    399c:	88 23       	and	r24, r24
    399e:	11 f4       	brne	.+4      	; 0x39a4 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    39a0:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    39a4:	0f 90       	pop	r0
    39a6:	0f 90       	pop	r0
    39a8:	0f 90       	pop	r0
    39aa:	0f 90       	pop	r0
    39ac:	0f 90       	pop	r0
    39ae:	df 91       	pop	r29
    39b0:	cf 91       	pop	r28
    39b2:	08 95       	ret

000039b4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    39b4:	af 92       	push	r10
    39b6:	bf 92       	push	r11
    39b8:	cf 92       	push	r12
    39ba:	df 92       	push	r13
    39bc:	ef 92       	push	r14
    39be:	ff 92       	push	r15
    39c0:	0f 93       	push	r16
    39c2:	cf 93       	push	r28
    39c4:	df 93       	push	r29
    39c6:	1f 92       	push	r1
    39c8:	cd b7       	in	r28, 0x3d	; 61
    39ca:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    39cc:	a1 2c       	mov	r10, r1
    39ce:	b1 2c       	mov	r11, r1
    39d0:	c1 2c       	mov	r12, r1
    39d2:	d1 2c       	mov	r13, r1
    39d4:	e1 2c       	mov	r14, r1
    39d6:	f1 2c       	mov	r15, r1
    39d8:	00 e0       	ldi	r16, 0x00	; 0
    39da:	20 e0       	ldi	r18, 0x00	; 0
    39dc:	30 e0       	ldi	r19, 0x00	; 0
    39de:	44 e6       	ldi	r20, 0x64	; 100
    39e0:	50 e0       	ldi	r21, 0x00	; 0
    39e2:	68 e0       	ldi	r22, 0x08	; 8
    39e4:	71 e0       	ldi	r23, 0x01	; 1
    39e6:	8c e2       	ldi	r24, 0x2C	; 44
    39e8:	91 e2       	ldi	r25, 0x21	; 33
    39ea:	0e 94 eb 1a 	call	0x35d6	; 0x35d6 <xTaskGenericCreate>
    39ee:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    39f0:	89 81       	ldd	r24, Y+1	; 0x01
    39f2:	81 30       	cpi	r24, 0x01	; 1
    39f4:	81 f4       	brne	.+32     	; 0x3a16 <vTaskStartScheduler+0x62>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    39f6:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    39f8:	8f ef       	ldi	r24, 0xFF	; 255
    39fa:	9f ef       	ldi	r25, 0xFF	; 255
    39fc:	90 93 53 05 	sts	0x0553, r25
    3a00:	80 93 52 05 	sts	0x0552, r24
		xSchedulerRunning = pdTRUE;
    3a04:	81 e0       	ldi	r24, 0x01	; 1
    3a06:	80 93 4d 05 	sts	0x054D, r24
		xTickCount = ( TickType_t ) 0U;
    3a0a:	10 92 4b 05 	sts	0x054B, r1
    3a0e:	10 92 4a 05 	sts	0x054A, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    3a12:	0e 94 ec 12 	call	0x25d8	; 0x25d8 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    3a16:	0f 90       	pop	r0
    3a18:	df 91       	pop	r29
    3a1a:	cf 91       	pop	r28
    3a1c:	0f 91       	pop	r16
    3a1e:	ff 90       	pop	r15
    3a20:	ef 90       	pop	r14
    3a22:	df 90       	pop	r13
    3a24:	cf 90       	pop	r12
    3a26:	bf 90       	pop	r11
    3a28:	af 90       	pop	r10
    3a2a:	08 95       	ret

00003a2c <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3a2c:	cf 93       	push	r28
    3a2e:	df 93       	push	r29
    3a30:	cd b7       	in	r28, 0x3d	; 61
    3a32:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    3a34:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    3a36:	10 92 4d 05 	sts	0x054D, r1
	vPortEndScheduler();
    3a3a:	0e 94 21 13 	call	0x2642	; 0x2642 <vPortEndScheduler>
}
    3a3e:	df 91       	pop	r29
    3a40:	cf 91       	pop	r28
    3a42:	08 95       	ret

00003a44 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3a44:	cf 93       	push	r28
    3a46:	df 93       	push	r29
    3a48:	cd b7       	in	r28, 0x3d	; 61
    3a4a:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    3a4c:	80 91 54 05 	lds	r24, 0x0554
    3a50:	8f 5f       	subi	r24, 0xFF	; 255
    3a52:	80 93 54 05 	sts	0x0554, r24
}
    3a56:	df 91       	pop	r29
    3a58:	cf 91       	pop	r28
    3a5a:	08 95       	ret

00003a5c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3a5c:	cf 93       	push	r28
    3a5e:	df 93       	push	r29
    3a60:	00 d0       	rcall	.+0      	; 0x3a62 <xTaskResumeAll+0x6>
    3a62:	1f 92       	push	r1
    3a64:	cd b7       	in	r28, 0x3d	; 61
    3a66:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    3a68:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    3a6a:	0f b6       	in	r0, 0x3f	; 63
    3a6c:	f8 94       	cli
    3a6e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    3a70:	80 91 54 05 	lds	r24, 0x0554
    3a74:	81 50       	subi	r24, 0x01	; 1
    3a76:	80 93 54 05 	sts	0x0554, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3a7a:	80 91 54 05 	lds	r24, 0x0554
    3a7e:	88 23       	and	r24, r24
    3a80:	09 f0       	breq	.+2      	; 0x3a84 <xTaskResumeAll+0x28>
    3a82:	71 c0       	rjmp	.+226    	; 0x3b66 <xTaskResumeAll+0x10a>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3a84:	80 91 49 05 	lds	r24, 0x0549
    3a88:	88 23       	and	r24, r24
    3a8a:	09 f4       	brne	.+2      	; 0x3a8e <xTaskResumeAll+0x32>
    3a8c:	6c c0       	rjmp	.+216    	; 0x3b66 <xTaskResumeAll+0x10a>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3a8e:	49 c0       	rjmp	.+146    	; 0x3b22 <xTaskResumeAll+0xc6>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    3a90:	80 91 3b 05 	lds	r24, 0x053B
    3a94:	90 91 3c 05 	lds	r25, 0x053C
    3a98:	fc 01       	movw	r30, r24
    3a9a:	86 81       	ldd	r24, Z+6	; 0x06
    3a9c:	97 81       	ldd	r25, Z+7	; 0x07
    3a9e:	9b 83       	std	Y+3, r25	; 0x03
    3aa0:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3aa2:	8a 81       	ldd	r24, Y+2	; 0x02
    3aa4:	9b 81       	ldd	r25, Y+3	; 0x03
    3aa6:	0c 96       	adiw	r24, 0x0c	; 12
    3aa8:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3aac:	8a 81       	ldd	r24, Y+2	; 0x02
    3aae:	9b 81       	ldd	r25, Y+3	; 0x03
    3ab0:	02 96       	adiw	r24, 0x02	; 2
    3ab2:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3ab6:	8a 81       	ldd	r24, Y+2	; 0x02
    3ab8:	9b 81       	ldd	r25, Y+3	; 0x03
    3aba:	fc 01       	movw	r30, r24
    3abc:	96 89       	ldd	r25, Z+22	; 0x16
    3abe:	80 91 4c 05 	lds	r24, 0x054C
    3ac2:	89 17       	cp	r24, r25
    3ac4:	30 f4       	brcc	.+12     	; 0x3ad2 <xTaskResumeAll+0x76>
    3ac6:	8a 81       	ldd	r24, Y+2	; 0x02
    3ac8:	9b 81       	ldd	r25, Y+3	; 0x03
    3aca:	fc 01       	movw	r30, r24
    3acc:	86 89       	ldd	r24, Z+22	; 0x16
    3ace:	80 93 4c 05 	sts	0x054C, r24
    3ad2:	8a 81       	ldd	r24, Y+2	; 0x02
    3ad4:	9b 81       	ldd	r25, Y+3	; 0x03
    3ad6:	ac 01       	movw	r20, r24
    3ad8:	4e 5f       	subi	r20, 0xFE	; 254
    3ada:	5f 4f       	sbci	r21, 0xFF	; 255
    3adc:	8a 81       	ldd	r24, Y+2	; 0x02
    3ade:	9b 81       	ldd	r25, Y+3	; 0x03
    3ae0:	fc 01       	movw	r30, r24
    3ae2:	86 89       	ldd	r24, Z+22	; 0x16
    3ae4:	28 2f       	mov	r18, r24
    3ae6:	30 e0       	ldi	r19, 0x00	; 0
    3ae8:	c9 01       	movw	r24, r18
    3aea:	88 0f       	add	r24, r24
    3aec:	99 1f       	adc	r25, r25
    3aee:	88 0f       	add	r24, r24
    3af0:	99 1f       	adc	r25, r25
    3af2:	88 0f       	add	r24, r24
    3af4:	99 1f       	adc	r25, r25
    3af6:	82 0f       	add	r24, r18
    3af8:	93 1f       	adc	r25, r19
    3afa:	84 50       	subi	r24, 0x04	; 4
    3afc:	9b 4f       	sbci	r25, 0xFB	; 251
    3afe:	ba 01       	movw	r22, r20
    3b00:	0e 94 27 10 	call	0x204e	; 0x204e <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3b04:	8a 81       	ldd	r24, Y+2	; 0x02
    3b06:	9b 81       	ldd	r25, Y+3	; 0x03
    3b08:	fc 01       	movw	r30, r24
    3b0a:	26 89       	ldd	r18, Z+22	; 0x16
    3b0c:	80 91 fa 04 	lds	r24, 0x04FA
    3b10:	90 91 fb 04 	lds	r25, 0x04FB
    3b14:	fc 01       	movw	r30, r24
    3b16:	86 89       	ldd	r24, Z+22	; 0x16
    3b18:	28 17       	cp	r18, r24
    3b1a:	18 f0       	brcs	.+6      	; 0x3b22 <xTaskResumeAll+0xc6>
					{
						xYieldPending = pdTRUE;
    3b1c:	81 e0       	ldi	r24, 0x01	; 1
    3b1e:	80 93 4f 05 	sts	0x054F, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3b22:	80 91 36 05 	lds	r24, 0x0536
    3b26:	88 23       	and	r24, r24
    3b28:	09 f0       	breq	.+2      	; 0x3b2c <xTaskResumeAll+0xd0>
    3b2a:	b2 cf       	rjmp	.-156    	; 0x3a90 <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    3b2c:	80 91 4e 05 	lds	r24, 0x054E
    3b30:	88 23       	and	r24, r24
    3b32:	89 f0       	breq	.+34     	; 0x3b56 <xTaskResumeAll+0xfa>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    3b34:	0c c0       	rjmp	.+24     	; 0x3b4e <xTaskResumeAll+0xf2>
					{
						if( xTaskIncrementTick() != pdFALSE )
    3b36:	0e 94 f1 1d 	call	0x3be2	; 0x3be2 <xTaskIncrementTick>
    3b3a:	88 23       	and	r24, r24
    3b3c:	19 f0       	breq	.+6      	; 0x3b44 <xTaskResumeAll+0xe8>
						{
							xYieldPending = pdTRUE;
    3b3e:	81 e0       	ldi	r24, 0x01	; 1
    3b40:	80 93 4f 05 	sts	0x054F, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    3b44:	80 91 4e 05 	lds	r24, 0x054E
    3b48:	81 50       	subi	r24, 0x01	; 1
    3b4a:	80 93 4e 05 	sts	0x054E, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    3b4e:	80 91 4e 05 	lds	r24, 0x054E
    3b52:	88 23       	and	r24, r24
    3b54:	81 f7       	brne	.-32     	; 0x3b36 <xTaskResumeAll+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    3b56:	80 91 4f 05 	lds	r24, 0x054F
    3b5a:	81 30       	cpi	r24, 0x01	; 1
    3b5c:	21 f4       	brne	.+8      	; 0x3b66 <xTaskResumeAll+0x10a>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    3b5e:	81 e0       	ldi	r24, 0x01	; 1
    3b60:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    3b62:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    3b66:	0f 90       	pop	r0
    3b68:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3b6a:	89 81       	ldd	r24, Y+1	; 0x01
}
    3b6c:	0f 90       	pop	r0
    3b6e:	0f 90       	pop	r0
    3b70:	0f 90       	pop	r0
    3b72:	df 91       	pop	r29
    3b74:	cf 91       	pop	r28
    3b76:	08 95       	ret

00003b78 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3b78:	cf 93       	push	r28
    3b7a:	df 93       	push	r29
    3b7c:	00 d0       	rcall	.+0      	; 0x3b7e <xTaskGetTickCount+0x6>
    3b7e:	cd b7       	in	r28, 0x3d	; 61
    3b80:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    3b82:	0f b6       	in	r0, 0x3f	; 63
    3b84:	f8 94       	cli
    3b86:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3b88:	80 91 4a 05 	lds	r24, 0x054A
    3b8c:	90 91 4b 05 	lds	r25, 0x054B
    3b90:	9a 83       	std	Y+2, r25	; 0x02
    3b92:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    3b94:	0f 90       	pop	r0
    3b96:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3b98:	89 81       	ldd	r24, Y+1	; 0x01
    3b9a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3b9c:	0f 90       	pop	r0
    3b9e:	0f 90       	pop	r0
    3ba0:	df 91       	pop	r29
    3ba2:	cf 91       	pop	r28
    3ba4:	08 95       	ret

00003ba6 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3ba6:	cf 93       	push	r28
    3ba8:	df 93       	push	r29
    3baa:	00 d0       	rcall	.+0      	; 0x3bac <xTaskGetTickCountFromISR+0x6>
    3bac:	1f 92       	push	r1
    3bae:	cd b7       	in	r28, 0x3d	; 61
    3bb0:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    3bb2:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    3bb4:	80 91 4a 05 	lds	r24, 0x054A
    3bb8:	90 91 4b 05 	lds	r25, 0x054B
    3bbc:	9b 83       	std	Y+3, r25	; 0x03
    3bbe:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3bc0:	8a 81       	ldd	r24, Y+2	; 0x02
    3bc2:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3bc4:	0f 90       	pop	r0
    3bc6:	0f 90       	pop	r0
    3bc8:	0f 90       	pop	r0
    3bca:	df 91       	pop	r29
    3bcc:	cf 91       	pop	r28
    3bce:	08 95       	ret

00003bd0 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3bd0:	cf 93       	push	r28
    3bd2:	df 93       	push	r29
    3bd4:	cd b7       	in	r28, 0x3d	; 61
    3bd6:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    3bd8:	80 91 49 05 	lds	r24, 0x0549
}
    3bdc:	df 91       	pop	r29
    3bde:	cf 91       	pop	r28
    3be0:	08 95       	ret

00003be2 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3be2:	cf 93       	push	r28
    3be4:	df 93       	push	r29
    3be6:	cd b7       	in	r28, 0x3d	; 61
    3be8:	de b7       	in	r29, 0x3e	; 62
    3bea:	29 97       	sbiw	r28, 0x09	; 9
    3bec:	0f b6       	in	r0, 0x3f	; 63
    3bee:	f8 94       	cli
    3bf0:	de bf       	out	0x3e, r29	; 62
    3bf2:	0f be       	out	0x3f, r0	; 63
    3bf4:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    3bf6:	19 82       	std	Y+1, r1	; 0x01

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3bf8:	80 91 54 05 	lds	r24, 0x0554
    3bfc:	88 23       	and	r24, r24
    3bfe:	09 f0       	breq	.+2      	; 0x3c02 <xTaskIncrementTick+0x20>
    3c00:	c9 c0       	rjmp	.+402    	; 0x3d94 <xTaskIncrementTick+0x1b2>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    3c02:	80 91 4a 05 	lds	r24, 0x054A
    3c06:	90 91 4b 05 	lds	r25, 0x054B
    3c0a:	01 96       	adiw	r24, 0x01	; 1
    3c0c:	90 93 4b 05 	sts	0x054B, r25
    3c10:	80 93 4a 05 	sts	0x054A, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    3c14:	80 91 4a 05 	lds	r24, 0x054A
    3c18:	90 91 4b 05 	lds	r25, 0x054B
    3c1c:	9b 83       	std	Y+3, r25	; 0x03
    3c1e:	8a 83       	std	Y+2, r24	; 0x02

			if( xConstTickCount == ( TickType_t ) 0U )
    3c20:	8a 81       	ldd	r24, Y+2	; 0x02
    3c22:	9b 81       	ldd	r25, Y+3	; 0x03
    3c24:	89 2b       	or	r24, r25
    3c26:	d9 f4       	brne	.+54     	; 0x3c5e <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    3c28:	80 91 32 05 	lds	r24, 0x0532
    3c2c:	90 91 33 05 	lds	r25, 0x0533
    3c30:	9d 83       	std	Y+5, r25	; 0x05
    3c32:	8c 83       	std	Y+4, r24	; 0x04
    3c34:	80 91 34 05 	lds	r24, 0x0534
    3c38:	90 91 35 05 	lds	r25, 0x0535
    3c3c:	90 93 33 05 	sts	0x0533, r25
    3c40:	80 93 32 05 	sts	0x0532, r24
    3c44:	8c 81       	ldd	r24, Y+4	; 0x04
    3c46:	9d 81       	ldd	r25, Y+5	; 0x05
    3c48:	90 93 35 05 	sts	0x0535, r25
    3c4c:	80 93 34 05 	sts	0x0534, r24
    3c50:	80 91 50 05 	lds	r24, 0x0550
    3c54:	8f 5f       	subi	r24, 0xFF	; 255
    3c56:	80 93 50 05 	sts	0x0550, r24
    3c5a:	0e 94 e1 22 	call	0x45c2	; 0x45c2 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    3c5e:	80 91 52 05 	lds	r24, 0x0552
    3c62:	90 91 53 05 	lds	r25, 0x0553
    3c66:	2a 81       	ldd	r18, Y+2	; 0x02
    3c68:	3b 81       	ldd	r19, Y+3	; 0x03
    3c6a:	28 17       	cp	r18, r24
    3c6c:	39 07       	cpc	r19, r25
    3c6e:	08 f4       	brcc	.+2      	; 0x3c72 <xTaskIncrementTick+0x90>
    3c70:	77 c0       	rjmp	.+238    	; 0x3d60 <xTaskIncrementTick+0x17e>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3c72:	80 91 32 05 	lds	r24, 0x0532
    3c76:	90 91 33 05 	lds	r25, 0x0533
    3c7a:	fc 01       	movw	r30, r24
    3c7c:	80 81       	ld	r24, Z
    3c7e:	88 23       	and	r24, r24
    3c80:	39 f4       	brne	.+14     	; 0x3c90 <xTaskIncrementTick+0xae>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    3c82:	8f ef       	ldi	r24, 0xFF	; 255
    3c84:	9f ef       	ldi	r25, 0xFF	; 255
    3c86:	90 93 53 05 	sts	0x0553, r25
    3c8a:	80 93 52 05 	sts	0x0552, r24
						break;
    3c8e:	68 c0       	rjmp	.+208    	; 0x3d60 <xTaskIncrementTick+0x17e>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    3c90:	80 91 32 05 	lds	r24, 0x0532
    3c94:	90 91 33 05 	lds	r25, 0x0533
    3c98:	fc 01       	movw	r30, r24
    3c9a:	85 81       	ldd	r24, Z+5	; 0x05
    3c9c:	96 81       	ldd	r25, Z+6	; 0x06
    3c9e:	fc 01       	movw	r30, r24
    3ca0:	86 81       	ldd	r24, Z+6	; 0x06
    3ca2:	97 81       	ldd	r25, Z+7	; 0x07
    3ca4:	9f 83       	std	Y+7, r25	; 0x07
    3ca6:	8e 83       	std	Y+6, r24	; 0x06
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    3ca8:	8e 81       	ldd	r24, Y+6	; 0x06
    3caa:	9f 81       	ldd	r25, Y+7	; 0x07
    3cac:	fc 01       	movw	r30, r24
    3cae:	82 81       	ldd	r24, Z+2	; 0x02
    3cb0:	93 81       	ldd	r25, Z+3	; 0x03
    3cb2:	99 87       	std	Y+9, r25	; 0x09
    3cb4:	88 87       	std	Y+8, r24	; 0x08

						if( xConstTickCount < xItemValue )
    3cb6:	2a 81       	ldd	r18, Y+2	; 0x02
    3cb8:	3b 81       	ldd	r19, Y+3	; 0x03
    3cba:	88 85       	ldd	r24, Y+8	; 0x08
    3cbc:	99 85       	ldd	r25, Y+9	; 0x09
    3cbe:	28 17       	cp	r18, r24
    3cc0:	39 07       	cpc	r19, r25
    3cc2:	38 f4       	brcc	.+14     	; 0x3cd2 <xTaskIncrementTick+0xf0>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    3cc4:	88 85       	ldd	r24, Y+8	; 0x08
    3cc6:	99 85       	ldd	r25, Y+9	; 0x09
    3cc8:	90 93 53 05 	sts	0x0553, r25
    3ccc:	80 93 52 05 	sts	0x0552, r24
							break;
    3cd0:	47 c0       	rjmp	.+142    	; 0x3d60 <xTaskIncrementTick+0x17e>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3cd2:	8e 81       	ldd	r24, Y+6	; 0x06
    3cd4:	9f 81       	ldd	r25, Y+7	; 0x07
    3cd6:	02 96       	adiw	r24, 0x02	; 2
    3cd8:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3cdc:	8e 81       	ldd	r24, Y+6	; 0x06
    3cde:	9f 81       	ldd	r25, Y+7	; 0x07
    3ce0:	fc 01       	movw	r30, r24
    3ce2:	84 89       	ldd	r24, Z+20	; 0x14
    3ce4:	95 89       	ldd	r25, Z+21	; 0x15
    3ce6:	89 2b       	or	r24, r25
    3ce8:	29 f0       	breq	.+10     	; 0x3cf4 <xTaskIncrementTick+0x112>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3cea:	8e 81       	ldd	r24, Y+6	; 0x06
    3cec:	9f 81       	ldd	r25, Y+7	; 0x07
    3cee:	0c 96       	adiw	r24, 0x0c	; 12
    3cf0:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    3cf4:	8e 81       	ldd	r24, Y+6	; 0x06
    3cf6:	9f 81       	ldd	r25, Y+7	; 0x07
    3cf8:	fc 01       	movw	r30, r24
    3cfa:	96 89       	ldd	r25, Z+22	; 0x16
    3cfc:	80 91 4c 05 	lds	r24, 0x054C
    3d00:	89 17       	cp	r24, r25
    3d02:	30 f4       	brcc	.+12     	; 0x3d10 <xTaskIncrementTick+0x12e>
    3d04:	8e 81       	ldd	r24, Y+6	; 0x06
    3d06:	9f 81       	ldd	r25, Y+7	; 0x07
    3d08:	fc 01       	movw	r30, r24
    3d0a:	86 89       	ldd	r24, Z+22	; 0x16
    3d0c:	80 93 4c 05 	sts	0x054C, r24
    3d10:	8e 81       	ldd	r24, Y+6	; 0x06
    3d12:	9f 81       	ldd	r25, Y+7	; 0x07
    3d14:	ac 01       	movw	r20, r24
    3d16:	4e 5f       	subi	r20, 0xFE	; 254
    3d18:	5f 4f       	sbci	r21, 0xFF	; 255
    3d1a:	8e 81       	ldd	r24, Y+6	; 0x06
    3d1c:	9f 81       	ldd	r25, Y+7	; 0x07
    3d1e:	fc 01       	movw	r30, r24
    3d20:	86 89       	ldd	r24, Z+22	; 0x16
    3d22:	28 2f       	mov	r18, r24
    3d24:	30 e0       	ldi	r19, 0x00	; 0
    3d26:	c9 01       	movw	r24, r18
    3d28:	88 0f       	add	r24, r24
    3d2a:	99 1f       	adc	r25, r25
    3d2c:	88 0f       	add	r24, r24
    3d2e:	99 1f       	adc	r25, r25
    3d30:	88 0f       	add	r24, r24
    3d32:	99 1f       	adc	r25, r25
    3d34:	82 0f       	add	r24, r18
    3d36:	93 1f       	adc	r25, r19
    3d38:	84 50       	subi	r24, 0x04	; 4
    3d3a:	9b 4f       	sbci	r25, 0xFB	; 251
    3d3c:	ba 01       	movw	r22, r20
    3d3e:	0e 94 27 10 	call	0x204e	; 0x204e <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3d42:	8e 81       	ldd	r24, Y+6	; 0x06
    3d44:	9f 81       	ldd	r25, Y+7	; 0x07
    3d46:	fc 01       	movw	r30, r24
    3d48:	26 89       	ldd	r18, Z+22	; 0x16
    3d4a:	80 91 fa 04 	lds	r24, 0x04FA
    3d4e:	90 91 fb 04 	lds	r25, 0x04FB
    3d52:	fc 01       	movw	r30, r24
    3d54:	86 89       	ldd	r24, Z+22	; 0x16
    3d56:	28 17       	cp	r18, r24
    3d58:	10 f0       	brcs	.+4      	; 0x3d5e <xTaskIncrementTick+0x17c>
							{
								xSwitchRequired = pdTRUE;
    3d5a:	81 e0       	ldi	r24, 0x01	; 1
    3d5c:	89 83       	std	Y+1, r24	; 0x01
								mtCOVERAGE_TEST_MARKER();
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
    3d5e:	89 cf       	rjmp	.-238    	; 0x3c72 <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3d60:	80 91 fa 04 	lds	r24, 0x04FA
    3d64:	90 91 fb 04 	lds	r25, 0x04FB
    3d68:	fc 01       	movw	r30, r24
    3d6a:	86 89       	ldd	r24, Z+22	; 0x16
    3d6c:	28 2f       	mov	r18, r24
    3d6e:	30 e0       	ldi	r19, 0x00	; 0
    3d70:	c9 01       	movw	r24, r18
    3d72:	88 0f       	add	r24, r24
    3d74:	99 1f       	adc	r25, r25
    3d76:	88 0f       	add	r24, r24
    3d78:	99 1f       	adc	r25, r25
    3d7a:	88 0f       	add	r24, r24
    3d7c:	99 1f       	adc	r25, r25
    3d7e:	82 0f       	add	r24, r18
    3d80:	93 1f       	adc	r25, r19
    3d82:	84 50       	subi	r24, 0x04	; 4
    3d84:	9b 4f       	sbci	r25, 0xFB	; 251
    3d86:	fc 01       	movw	r30, r24
    3d88:	80 81       	ld	r24, Z
    3d8a:	82 30       	cpi	r24, 0x02	; 2
    3d8c:	40 f0       	brcs	.+16     	; 0x3d9e <xTaskIncrementTick+0x1bc>
			{
				xSwitchRequired = pdTRUE;
    3d8e:	81 e0       	ldi	r24, 0x01	; 1
    3d90:	89 83       	std	Y+1, r24	; 0x01
    3d92:	05 c0       	rjmp	.+10     	; 0x3d9e <xTaskIncrementTick+0x1bc>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    3d94:	80 91 4e 05 	lds	r24, 0x054E
    3d98:	8f 5f       	subi	r24, 0xFF	; 255
    3d9a:	80 93 4e 05 	sts	0x054E, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    3d9e:	80 91 4f 05 	lds	r24, 0x054F
    3da2:	88 23       	and	r24, r24
    3da4:	11 f0       	breq	.+4      	; 0x3daa <xTaskIncrementTick+0x1c8>
		{
			xSwitchRequired = pdTRUE;
    3da6:	81 e0       	ldi	r24, 0x01	; 1
    3da8:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    3daa:	89 81       	ldd	r24, Y+1	; 0x01
}
    3dac:	29 96       	adiw	r28, 0x09	; 9
    3dae:	0f b6       	in	r0, 0x3f	; 63
    3db0:	f8 94       	cli
    3db2:	de bf       	out	0x3e, r29	; 62
    3db4:	0f be       	out	0x3f, r0	; 63
    3db6:	cd bf       	out	0x3d, r28	; 61
    3db8:	df 91       	pop	r29
    3dba:	cf 91       	pop	r28
    3dbc:	08 95       	ret

00003dbe <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3dbe:	cf 93       	push	r28
    3dc0:	df 93       	push	r29
    3dc2:	00 d0       	rcall	.+0      	; 0x3dc4 <vTaskSwitchContext+0x6>
    3dc4:	cd b7       	in	r28, 0x3d	; 61
    3dc6:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3dc8:	80 91 54 05 	lds	r24, 0x0554
    3dcc:	88 23       	and	r24, r24
    3dce:	21 f0       	breq	.+8      	; 0x3dd8 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    3dd0:	81 e0       	ldi	r24, 0x01	; 1
    3dd2:	80 93 4f 05 	sts	0x054F, r24
    3dd6:	5d c0       	rjmp	.+186    	; 0x3e92 <vTaskSwitchContext+0xd4>
	}
	else
	{
		xYieldPending = pdFALSE;
    3dd8:	10 92 4f 05 	sts	0x054F, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    3ddc:	05 c0       	rjmp	.+10     	; 0x3de8 <vTaskSwitchContext+0x2a>
    3dde:	80 91 4c 05 	lds	r24, 0x054C
    3de2:	81 50       	subi	r24, 0x01	; 1
    3de4:	80 93 4c 05 	sts	0x054C, r24
    3de8:	80 91 4c 05 	lds	r24, 0x054C
    3dec:	28 2f       	mov	r18, r24
    3dee:	30 e0       	ldi	r19, 0x00	; 0
    3df0:	c9 01       	movw	r24, r18
    3df2:	88 0f       	add	r24, r24
    3df4:	99 1f       	adc	r25, r25
    3df6:	88 0f       	add	r24, r24
    3df8:	99 1f       	adc	r25, r25
    3dfa:	88 0f       	add	r24, r24
    3dfc:	99 1f       	adc	r25, r25
    3dfe:	82 0f       	add	r24, r18
    3e00:	93 1f       	adc	r25, r19
    3e02:	84 50       	subi	r24, 0x04	; 4
    3e04:	9b 4f       	sbci	r25, 0xFB	; 251
    3e06:	fc 01       	movw	r30, r24
    3e08:	80 81       	ld	r24, Z
    3e0a:	88 23       	and	r24, r24
    3e0c:	41 f3       	breq	.-48     	; 0x3dde <vTaskSwitchContext+0x20>
    3e0e:	80 91 4c 05 	lds	r24, 0x054C
    3e12:	28 2f       	mov	r18, r24
    3e14:	30 e0       	ldi	r19, 0x00	; 0
    3e16:	c9 01       	movw	r24, r18
    3e18:	88 0f       	add	r24, r24
    3e1a:	99 1f       	adc	r25, r25
    3e1c:	88 0f       	add	r24, r24
    3e1e:	99 1f       	adc	r25, r25
    3e20:	88 0f       	add	r24, r24
    3e22:	99 1f       	adc	r25, r25
    3e24:	82 0f       	add	r24, r18
    3e26:	93 1f       	adc	r25, r19
    3e28:	84 50       	subi	r24, 0x04	; 4
    3e2a:	9b 4f       	sbci	r25, 0xFB	; 251
    3e2c:	9a 83       	std	Y+2, r25	; 0x02
    3e2e:	89 83       	std	Y+1, r24	; 0x01
    3e30:	89 81       	ldd	r24, Y+1	; 0x01
    3e32:	9a 81       	ldd	r25, Y+2	; 0x02
    3e34:	fc 01       	movw	r30, r24
    3e36:	81 81       	ldd	r24, Z+1	; 0x01
    3e38:	92 81       	ldd	r25, Z+2	; 0x02
    3e3a:	fc 01       	movw	r30, r24
    3e3c:	22 81       	ldd	r18, Z+2	; 0x02
    3e3e:	33 81       	ldd	r19, Z+3	; 0x03
    3e40:	89 81       	ldd	r24, Y+1	; 0x01
    3e42:	9a 81       	ldd	r25, Y+2	; 0x02
    3e44:	fc 01       	movw	r30, r24
    3e46:	32 83       	std	Z+2, r19	; 0x02
    3e48:	21 83       	std	Z+1, r18	; 0x01
    3e4a:	89 81       	ldd	r24, Y+1	; 0x01
    3e4c:	9a 81       	ldd	r25, Y+2	; 0x02
    3e4e:	fc 01       	movw	r30, r24
    3e50:	21 81       	ldd	r18, Z+1	; 0x01
    3e52:	32 81       	ldd	r19, Z+2	; 0x02
    3e54:	89 81       	ldd	r24, Y+1	; 0x01
    3e56:	9a 81       	ldd	r25, Y+2	; 0x02
    3e58:	03 96       	adiw	r24, 0x03	; 3
    3e5a:	28 17       	cp	r18, r24
    3e5c:	39 07       	cpc	r19, r25
    3e5e:	69 f4       	brne	.+26     	; 0x3e7a <vTaskSwitchContext+0xbc>
    3e60:	89 81       	ldd	r24, Y+1	; 0x01
    3e62:	9a 81       	ldd	r25, Y+2	; 0x02
    3e64:	fc 01       	movw	r30, r24
    3e66:	81 81       	ldd	r24, Z+1	; 0x01
    3e68:	92 81       	ldd	r25, Z+2	; 0x02
    3e6a:	fc 01       	movw	r30, r24
    3e6c:	22 81       	ldd	r18, Z+2	; 0x02
    3e6e:	33 81       	ldd	r19, Z+3	; 0x03
    3e70:	89 81       	ldd	r24, Y+1	; 0x01
    3e72:	9a 81       	ldd	r25, Y+2	; 0x02
    3e74:	fc 01       	movw	r30, r24
    3e76:	32 83       	std	Z+2, r19	; 0x02
    3e78:	21 83       	std	Z+1, r18	; 0x01
    3e7a:	89 81       	ldd	r24, Y+1	; 0x01
    3e7c:	9a 81       	ldd	r25, Y+2	; 0x02
    3e7e:	fc 01       	movw	r30, r24
    3e80:	81 81       	ldd	r24, Z+1	; 0x01
    3e82:	92 81       	ldd	r25, Z+2	; 0x02
    3e84:	fc 01       	movw	r30, r24
    3e86:	86 81       	ldd	r24, Z+6	; 0x06
    3e88:	97 81       	ldd	r25, Z+7	; 0x07
    3e8a:	90 93 fb 04 	sts	0x04FB, r25
    3e8e:	80 93 fa 04 	sts	0x04FA, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3e92:	0f 90       	pop	r0
    3e94:	0f 90       	pop	r0
    3e96:	df 91       	pop	r29
    3e98:	cf 91       	pop	r28
    3e9a:	08 95       	ret

00003e9c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    3e9c:	cf 93       	push	r28
    3e9e:	df 93       	push	r29
    3ea0:	00 d0       	rcall	.+0      	; 0x3ea2 <vTaskPlaceOnEventList+0x6>
    3ea2:	00 d0       	rcall	.+0      	; 0x3ea4 <vTaskPlaceOnEventList+0x8>
    3ea4:	00 d0       	rcall	.+0      	; 0x3ea6 <vTaskPlaceOnEventList+0xa>
    3ea6:	cd b7       	in	r28, 0x3d	; 61
    3ea8:	de b7       	in	r29, 0x3e	; 62
    3eaa:	9c 83       	std	Y+4, r25	; 0x04
    3eac:	8b 83       	std	Y+3, r24	; 0x03
    3eae:	7e 83       	std	Y+6, r23	; 0x06
    3eb0:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3eb2:	80 91 fa 04 	lds	r24, 0x04FA
    3eb6:	90 91 fb 04 	lds	r25, 0x04FB
    3eba:	9c 01       	movw	r18, r24
    3ebc:	24 5f       	subi	r18, 0xF4	; 244
    3ebe:	3f 4f       	sbci	r19, 0xFF	; 255
    3ec0:	8b 81       	ldd	r24, Y+3	; 0x03
    3ec2:	9c 81       	ldd	r25, Y+4	; 0x04
    3ec4:	b9 01       	movw	r22, r18
    3ec6:	0e 94 75 10 	call	0x20ea	; 0x20ea <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3eca:	80 91 fa 04 	lds	r24, 0x04FA
    3ece:	90 91 fb 04 	lds	r25, 0x04FB
    3ed2:	02 96       	adiw	r24, 0x02	; 2
    3ed4:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    3ed8:	20 91 4a 05 	lds	r18, 0x054A
    3edc:	30 91 4b 05 	lds	r19, 0x054B
    3ee0:	8d 81       	ldd	r24, Y+5	; 0x05
    3ee2:	9e 81       	ldd	r25, Y+6	; 0x06
    3ee4:	82 0f       	add	r24, r18
    3ee6:	93 1f       	adc	r25, r19
    3ee8:	9a 83       	std	Y+2, r25	; 0x02
    3eea:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3eec:	89 81       	ldd	r24, Y+1	; 0x01
    3eee:	9a 81       	ldd	r25, Y+2	; 0x02
    3ef0:	0e 94 3d 22 	call	0x447a	; 0x447a <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3ef4:	26 96       	adiw	r28, 0x06	; 6
    3ef6:	0f b6       	in	r0, 0x3f	; 63
    3ef8:	f8 94       	cli
    3efa:	de bf       	out	0x3e, r29	; 62
    3efc:	0f be       	out	0x3f, r0	; 63
    3efe:	cd bf       	out	0x3d, r28	; 61
    3f00:	df 91       	pop	r29
    3f02:	cf 91       	pop	r28
    3f04:	08 95       	ret

00003f06 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    3f06:	cf 93       	push	r28
    3f08:	df 93       	push	r29
    3f0a:	cd b7       	in	r28, 0x3d	; 61
    3f0c:	de b7       	in	r29, 0x3e	; 62
    3f0e:	28 97       	sbiw	r28, 0x08	; 8
    3f10:	0f b6       	in	r0, 0x3f	; 63
    3f12:	f8 94       	cli
    3f14:	de bf       	out	0x3e, r29	; 62
    3f16:	0f be       	out	0x3f, r0	; 63
    3f18:	cd bf       	out	0x3d, r28	; 61
    3f1a:	9c 83       	std	Y+4, r25	; 0x04
    3f1c:	8b 83       	std	Y+3, r24	; 0x03
    3f1e:	7e 83       	std	Y+6, r23	; 0x06
    3f20:	6d 83       	std	Y+5, r22	; 0x05
    3f22:	58 87       	std	Y+8, r21	; 0x08
    3f24:	4f 83       	std	Y+7, r20	; 0x07
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3f26:	80 91 fa 04 	lds	r24, 0x04FA
    3f2a:	90 91 fb 04 	lds	r25, 0x04FB
    3f2e:	2d 81       	ldd	r18, Y+5	; 0x05
    3f30:	3e 81       	ldd	r19, Y+6	; 0x06
    3f32:	30 68       	ori	r19, 0x80	; 128
    3f34:	fc 01       	movw	r30, r24
    3f36:	35 87       	std	Z+13, r19	; 0x0d
    3f38:	24 87       	std	Z+12, r18	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3f3a:	80 91 fa 04 	lds	r24, 0x04FA
    3f3e:	90 91 fb 04 	lds	r25, 0x04FB
    3f42:	9c 01       	movw	r18, r24
    3f44:	24 5f       	subi	r18, 0xF4	; 244
    3f46:	3f 4f       	sbci	r19, 0xFF	; 255
    3f48:	8b 81       	ldd	r24, Y+3	; 0x03
    3f4a:	9c 81       	ldd	r25, Y+4	; 0x04
    3f4c:	b9 01       	movw	r22, r18
    3f4e:	0e 94 27 10 	call	0x204e	; 0x204e <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3f52:	80 91 fa 04 	lds	r24, 0x04FA
    3f56:	90 91 fb 04 	lds	r25, 0x04FB
    3f5a:	02 96       	adiw	r24, 0x02	; 2
    3f5c:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    3f60:	20 91 4a 05 	lds	r18, 0x054A
    3f64:	30 91 4b 05 	lds	r19, 0x054B
    3f68:	8f 81       	ldd	r24, Y+7	; 0x07
    3f6a:	98 85       	ldd	r25, Y+8	; 0x08
    3f6c:	82 0f       	add	r24, r18
    3f6e:	93 1f       	adc	r25, r19
    3f70:	9a 83       	std	Y+2, r25	; 0x02
    3f72:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3f74:	89 81       	ldd	r24, Y+1	; 0x01
    3f76:	9a 81       	ldd	r25, Y+2	; 0x02
    3f78:	0e 94 3d 22 	call	0x447a	; 0x447a <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3f7c:	28 96       	adiw	r28, 0x08	; 8
    3f7e:	0f b6       	in	r0, 0x3f	; 63
    3f80:	f8 94       	cli
    3f82:	de bf       	out	0x3e, r29	; 62
    3f84:	0f be       	out	0x3f, r0	; 63
    3f86:	cd bf       	out	0x3d, r28	; 61
    3f88:	df 91       	pop	r29
    3f8a:	cf 91       	pop	r28
    3f8c:	08 95       	ret

00003f8e <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3f8e:	cf 93       	push	r28
    3f90:	df 93       	push	r29
    3f92:	00 d0       	rcall	.+0      	; 0x3f94 <xTaskRemoveFromEventList+0x6>
    3f94:	00 d0       	rcall	.+0      	; 0x3f96 <xTaskRemoveFromEventList+0x8>
    3f96:	1f 92       	push	r1
    3f98:	cd b7       	in	r28, 0x3d	; 61
    3f9a:	de b7       	in	r29, 0x3e	; 62
    3f9c:	9d 83       	std	Y+5, r25	; 0x05
    3f9e:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3fa0:	8c 81       	ldd	r24, Y+4	; 0x04
    3fa2:	9d 81       	ldd	r25, Y+5	; 0x05
    3fa4:	fc 01       	movw	r30, r24
    3fa6:	85 81       	ldd	r24, Z+5	; 0x05
    3fa8:	96 81       	ldd	r25, Z+6	; 0x06
    3faa:	fc 01       	movw	r30, r24
    3fac:	86 81       	ldd	r24, Z+6	; 0x06
    3fae:	97 81       	ldd	r25, Z+7	; 0x07
    3fb0:	9b 83       	std	Y+3, r25	; 0x03
    3fb2:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3fb4:	8a 81       	ldd	r24, Y+2	; 0x02
    3fb6:	9b 81       	ldd	r25, Y+3	; 0x03
    3fb8:	0c 96       	adiw	r24, 0x0c	; 12
    3fba:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3fbe:	80 91 54 05 	lds	r24, 0x0554
    3fc2:	88 23       	and	r24, r24
    3fc4:	69 f5       	brne	.+90     	; 0x4020 <xTaskRemoveFromEventList+0x92>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3fc6:	8a 81       	ldd	r24, Y+2	; 0x02
    3fc8:	9b 81       	ldd	r25, Y+3	; 0x03
    3fca:	02 96       	adiw	r24, 0x02	; 2
    3fcc:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    3fd0:	8a 81       	ldd	r24, Y+2	; 0x02
    3fd2:	9b 81       	ldd	r25, Y+3	; 0x03
    3fd4:	fc 01       	movw	r30, r24
    3fd6:	96 89       	ldd	r25, Z+22	; 0x16
    3fd8:	80 91 4c 05 	lds	r24, 0x054C
    3fdc:	89 17       	cp	r24, r25
    3fde:	30 f4       	brcc	.+12     	; 0x3fec <xTaskRemoveFromEventList+0x5e>
    3fe0:	8a 81       	ldd	r24, Y+2	; 0x02
    3fe2:	9b 81       	ldd	r25, Y+3	; 0x03
    3fe4:	fc 01       	movw	r30, r24
    3fe6:	86 89       	ldd	r24, Z+22	; 0x16
    3fe8:	80 93 4c 05 	sts	0x054C, r24
    3fec:	8a 81       	ldd	r24, Y+2	; 0x02
    3fee:	9b 81       	ldd	r25, Y+3	; 0x03
    3ff0:	ac 01       	movw	r20, r24
    3ff2:	4e 5f       	subi	r20, 0xFE	; 254
    3ff4:	5f 4f       	sbci	r21, 0xFF	; 255
    3ff6:	8a 81       	ldd	r24, Y+2	; 0x02
    3ff8:	9b 81       	ldd	r25, Y+3	; 0x03
    3ffa:	fc 01       	movw	r30, r24
    3ffc:	86 89       	ldd	r24, Z+22	; 0x16
    3ffe:	28 2f       	mov	r18, r24
    4000:	30 e0       	ldi	r19, 0x00	; 0
    4002:	c9 01       	movw	r24, r18
    4004:	88 0f       	add	r24, r24
    4006:	99 1f       	adc	r25, r25
    4008:	88 0f       	add	r24, r24
    400a:	99 1f       	adc	r25, r25
    400c:	88 0f       	add	r24, r24
    400e:	99 1f       	adc	r25, r25
    4010:	82 0f       	add	r24, r18
    4012:	93 1f       	adc	r25, r19
    4014:	84 50       	subi	r24, 0x04	; 4
    4016:	9b 4f       	sbci	r25, 0xFB	; 251
    4018:	ba 01       	movw	r22, r20
    401a:	0e 94 27 10 	call	0x204e	; 0x204e <vListInsertEnd>
    401e:	08 c0       	rjmp	.+16     	; 0x4030 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4020:	8a 81       	ldd	r24, Y+2	; 0x02
    4022:	9b 81       	ldd	r25, Y+3	; 0x03
    4024:	0c 96       	adiw	r24, 0x0c	; 12
    4026:	bc 01       	movw	r22, r24
    4028:	86 e3       	ldi	r24, 0x36	; 54
    402a:	95 e0       	ldi	r25, 0x05	; 5
    402c:	0e 94 27 10 	call	0x204e	; 0x204e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4030:	8a 81       	ldd	r24, Y+2	; 0x02
    4032:	9b 81       	ldd	r25, Y+3	; 0x03
    4034:	fc 01       	movw	r30, r24
    4036:	26 89       	ldd	r18, Z+22	; 0x16
    4038:	80 91 fa 04 	lds	r24, 0x04FA
    403c:	90 91 fb 04 	lds	r25, 0x04FB
    4040:	fc 01       	movw	r30, r24
    4042:	86 89       	ldd	r24, Z+22	; 0x16
    4044:	82 17       	cp	r24, r18
    4046:	30 f4       	brcc	.+12     	; 0x4054 <xTaskRemoveFromEventList+0xc6>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    4048:	81 e0       	ldi	r24, 0x01	; 1
    404a:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    404c:	81 e0       	ldi	r24, 0x01	; 1
    404e:	80 93 4f 05 	sts	0x054F, r24
    4052:	01 c0       	rjmp	.+2      	; 0x4056 <xTaskRemoveFromEventList+0xc8>
	}
	else
	{
		xReturn = pdFALSE;
    4054:	19 82       	std	Y+1, r1	; 0x01
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    4056:	89 81       	ldd	r24, Y+1	; 0x01
}
    4058:	0f 90       	pop	r0
    405a:	0f 90       	pop	r0
    405c:	0f 90       	pop	r0
    405e:	0f 90       	pop	r0
    4060:	0f 90       	pop	r0
    4062:	df 91       	pop	r29
    4064:	cf 91       	pop	r28
    4066:	08 95       	ret

00004068 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    4068:	cf 93       	push	r28
    406a:	df 93       	push	r29
    406c:	cd b7       	in	r28, 0x3d	; 61
    406e:	de b7       	in	r29, 0x3e	; 62
    4070:	27 97       	sbiw	r28, 0x07	; 7
    4072:	0f b6       	in	r0, 0x3f	; 63
    4074:	f8 94       	cli
    4076:	de bf       	out	0x3e, r29	; 62
    4078:	0f be       	out	0x3f, r0	; 63
    407a:	cd bf       	out	0x3d, r28	; 61
    407c:	9d 83       	std	Y+5, r25	; 0x05
    407e:	8c 83       	std	Y+4, r24	; 0x04
    4080:	7f 83       	std	Y+7, r23	; 0x07
    4082:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4084:	8e 81       	ldd	r24, Y+6	; 0x06
    4086:	9f 81       	ldd	r25, Y+7	; 0x07
    4088:	9c 01       	movw	r18, r24
    408a:	30 68       	ori	r19, 0x80	; 128
    408c:	8c 81       	ldd	r24, Y+4	; 0x04
    408e:	9d 81       	ldd	r25, Y+5	; 0x05
    4090:	fc 01       	movw	r30, r24
    4092:	31 83       	std	Z+1, r19	; 0x01
    4094:	20 83       	st	Z, r18

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    4096:	8c 81       	ldd	r24, Y+4	; 0x04
    4098:	9d 81       	ldd	r25, Y+5	; 0x05
    409a:	fc 01       	movw	r30, r24
    409c:	86 81       	ldd	r24, Z+6	; 0x06
    409e:	97 81       	ldd	r25, Z+7	; 0x07
    40a0:	9b 83       	std	Y+3, r25	; 0x03
    40a2:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    40a4:	8c 81       	ldd	r24, Y+4	; 0x04
    40a6:	9d 81       	ldd	r25, Y+5	; 0x05
    40a8:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    40ac:	8a 81       	ldd	r24, Y+2	; 0x02
    40ae:	9b 81       	ldd	r25, Y+3	; 0x03
    40b0:	02 96       	adiw	r24, 0x02	; 2
    40b2:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    40b6:	8a 81       	ldd	r24, Y+2	; 0x02
    40b8:	9b 81       	ldd	r25, Y+3	; 0x03
    40ba:	fc 01       	movw	r30, r24
    40bc:	96 89       	ldd	r25, Z+22	; 0x16
    40be:	80 91 4c 05 	lds	r24, 0x054C
    40c2:	89 17       	cp	r24, r25
    40c4:	30 f4       	brcc	.+12     	; 0x40d2 <xTaskRemoveFromUnorderedEventList+0x6a>
    40c6:	8a 81       	ldd	r24, Y+2	; 0x02
    40c8:	9b 81       	ldd	r25, Y+3	; 0x03
    40ca:	fc 01       	movw	r30, r24
    40cc:	86 89       	ldd	r24, Z+22	; 0x16
    40ce:	80 93 4c 05 	sts	0x054C, r24
    40d2:	8a 81       	ldd	r24, Y+2	; 0x02
    40d4:	9b 81       	ldd	r25, Y+3	; 0x03
    40d6:	ac 01       	movw	r20, r24
    40d8:	4e 5f       	subi	r20, 0xFE	; 254
    40da:	5f 4f       	sbci	r21, 0xFF	; 255
    40dc:	8a 81       	ldd	r24, Y+2	; 0x02
    40de:	9b 81       	ldd	r25, Y+3	; 0x03
    40e0:	fc 01       	movw	r30, r24
    40e2:	86 89       	ldd	r24, Z+22	; 0x16
    40e4:	28 2f       	mov	r18, r24
    40e6:	30 e0       	ldi	r19, 0x00	; 0
    40e8:	c9 01       	movw	r24, r18
    40ea:	88 0f       	add	r24, r24
    40ec:	99 1f       	adc	r25, r25
    40ee:	88 0f       	add	r24, r24
    40f0:	99 1f       	adc	r25, r25
    40f2:	88 0f       	add	r24, r24
    40f4:	99 1f       	adc	r25, r25
    40f6:	82 0f       	add	r24, r18
    40f8:	93 1f       	adc	r25, r19
    40fa:	84 50       	subi	r24, 0x04	; 4
    40fc:	9b 4f       	sbci	r25, 0xFB	; 251
    40fe:	ba 01       	movw	r22, r20
    4100:	0e 94 27 10 	call	0x204e	; 0x204e <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4104:	8a 81       	ldd	r24, Y+2	; 0x02
    4106:	9b 81       	ldd	r25, Y+3	; 0x03
    4108:	fc 01       	movw	r30, r24
    410a:	26 89       	ldd	r18, Z+22	; 0x16
    410c:	80 91 fa 04 	lds	r24, 0x04FA
    4110:	90 91 fb 04 	lds	r25, 0x04FB
    4114:	fc 01       	movw	r30, r24
    4116:	86 89       	ldd	r24, Z+22	; 0x16
    4118:	82 17       	cp	r24, r18
    411a:	30 f4       	brcc	.+12     	; 0x4128 <xTaskRemoveFromUnorderedEventList+0xc0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    411c:	81 e0       	ldi	r24, 0x01	; 1
    411e:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    4120:	81 e0       	ldi	r24, 0x01	; 1
    4122:	80 93 4f 05 	sts	0x054F, r24
    4126:	01 c0       	rjmp	.+2      	; 0x412a <xTaskRemoveFromUnorderedEventList+0xc2>
	}
	else
	{
		xReturn = pdFALSE;
    4128:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    412a:	89 81       	ldd	r24, Y+1	; 0x01
}
    412c:	27 96       	adiw	r28, 0x07	; 7
    412e:	0f b6       	in	r0, 0x3f	; 63
    4130:	f8 94       	cli
    4132:	de bf       	out	0x3e, r29	; 62
    4134:	0f be       	out	0x3f, r0	; 63
    4136:	cd bf       	out	0x3d, r28	; 61
    4138:	df 91       	pop	r29
    413a:	cf 91       	pop	r28
    413c:	08 95       	ret

0000413e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    413e:	cf 93       	push	r28
    4140:	df 93       	push	r29
    4142:	00 d0       	rcall	.+0      	; 0x4144 <vTaskSetTimeOutState+0x6>
    4144:	cd b7       	in	r28, 0x3d	; 61
    4146:	de b7       	in	r29, 0x3e	; 62
    4148:	9a 83       	std	Y+2, r25	; 0x02
    414a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    414c:	20 91 50 05 	lds	r18, 0x0550
    4150:	89 81       	ldd	r24, Y+1	; 0x01
    4152:	9a 81       	ldd	r25, Y+2	; 0x02
    4154:	fc 01       	movw	r30, r24
    4156:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    4158:	20 91 4a 05 	lds	r18, 0x054A
    415c:	30 91 4b 05 	lds	r19, 0x054B
    4160:	89 81       	ldd	r24, Y+1	; 0x01
    4162:	9a 81       	ldd	r25, Y+2	; 0x02
    4164:	fc 01       	movw	r30, r24
    4166:	32 83       	std	Z+2, r19	; 0x02
    4168:	21 83       	std	Z+1, r18	; 0x01
}
    416a:	0f 90       	pop	r0
    416c:	0f 90       	pop	r0
    416e:	df 91       	pop	r29
    4170:	cf 91       	pop	r28
    4172:	08 95       	ret

00004174 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    4174:	cf 93       	push	r28
    4176:	df 93       	push	r29
    4178:	cd b7       	in	r28, 0x3d	; 61
    417a:	de b7       	in	r29, 0x3e	; 62
    417c:	27 97       	sbiw	r28, 0x07	; 7
    417e:	0f b6       	in	r0, 0x3f	; 63
    4180:	f8 94       	cli
    4182:	de bf       	out	0x3e, r29	; 62
    4184:	0f be       	out	0x3f, r0	; 63
    4186:	cd bf       	out	0x3d, r28	; 61
    4188:	9d 83       	std	Y+5, r25	; 0x05
    418a:	8c 83       	std	Y+4, r24	; 0x04
    418c:	7f 83       	std	Y+7, r23	; 0x07
    418e:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4190:	0f b6       	in	r0, 0x3f	; 63
    4192:	f8 94       	cli
    4194:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    4196:	80 91 4a 05 	lds	r24, 0x054A
    419a:	90 91 4b 05 	lds	r25, 0x054B
    419e:	9b 83       	std	Y+3, r25	; 0x03
    41a0:	8a 83       	std	Y+2, r24	; 0x02
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    41a2:	8c 81       	ldd	r24, Y+4	; 0x04
    41a4:	9d 81       	ldd	r25, Y+5	; 0x05
    41a6:	fc 01       	movw	r30, r24
    41a8:	90 81       	ld	r25, Z
    41aa:	80 91 50 05 	lds	r24, 0x0550
    41ae:	98 17       	cp	r25, r24
    41b0:	69 f0       	breq	.+26     	; 0x41cc <xTaskCheckForTimeOut+0x58>
    41b2:	8c 81       	ldd	r24, Y+4	; 0x04
    41b4:	9d 81       	ldd	r25, Y+5	; 0x05
    41b6:	fc 01       	movw	r30, r24
    41b8:	21 81       	ldd	r18, Z+1	; 0x01
    41ba:	32 81       	ldd	r19, Z+2	; 0x02
    41bc:	8a 81       	ldd	r24, Y+2	; 0x02
    41be:	9b 81       	ldd	r25, Y+3	; 0x03
    41c0:	82 17       	cp	r24, r18
    41c2:	93 07       	cpc	r25, r19
    41c4:	18 f0       	brcs	.+6      	; 0x41cc <xTaskCheckForTimeOut+0x58>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    41c6:	81 e0       	ldi	r24, 0x01	; 1
    41c8:	89 83       	std	Y+1, r24	; 0x01
    41ca:	30 c0       	rjmp	.+96     	; 0x422c <xTaskCheckForTimeOut+0xb8>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    41cc:	8c 81       	ldd	r24, Y+4	; 0x04
    41ce:	9d 81       	ldd	r25, Y+5	; 0x05
    41d0:	fc 01       	movw	r30, r24
    41d2:	81 81       	ldd	r24, Z+1	; 0x01
    41d4:	92 81       	ldd	r25, Z+2	; 0x02
    41d6:	2a 81       	ldd	r18, Y+2	; 0x02
    41d8:	3b 81       	ldd	r19, Y+3	; 0x03
    41da:	28 1b       	sub	r18, r24
    41dc:	39 0b       	sbc	r19, r25
    41de:	8e 81       	ldd	r24, Y+6	; 0x06
    41e0:	9f 81       	ldd	r25, Y+7	; 0x07
    41e2:	fc 01       	movw	r30, r24
    41e4:	80 81       	ld	r24, Z
    41e6:	91 81       	ldd	r25, Z+1	; 0x01
    41e8:	28 17       	cp	r18, r24
    41ea:	39 07       	cpc	r19, r25
    41ec:	e8 f4       	brcc	.+58     	; 0x4228 <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    41ee:	8e 81       	ldd	r24, Y+6	; 0x06
    41f0:	9f 81       	ldd	r25, Y+7	; 0x07
    41f2:	fc 01       	movw	r30, r24
    41f4:	20 81       	ld	r18, Z
    41f6:	31 81       	ldd	r19, Z+1	; 0x01
    41f8:	8c 81       	ldd	r24, Y+4	; 0x04
    41fa:	9d 81       	ldd	r25, Y+5	; 0x05
    41fc:	fc 01       	movw	r30, r24
    41fe:	41 81       	ldd	r20, Z+1	; 0x01
    4200:	52 81       	ldd	r21, Z+2	; 0x02
    4202:	8a 81       	ldd	r24, Y+2	; 0x02
    4204:	9b 81       	ldd	r25, Y+3	; 0x03
    4206:	ba 01       	movw	r22, r20
    4208:	68 1b       	sub	r22, r24
    420a:	79 0b       	sbc	r23, r25
    420c:	cb 01       	movw	r24, r22
    420e:	28 0f       	add	r18, r24
    4210:	39 1f       	adc	r19, r25
    4212:	8e 81       	ldd	r24, Y+6	; 0x06
    4214:	9f 81       	ldd	r25, Y+7	; 0x07
    4216:	fc 01       	movw	r30, r24
    4218:	31 83       	std	Z+1, r19	; 0x01
    421a:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    421c:	8c 81       	ldd	r24, Y+4	; 0x04
    421e:	9d 81       	ldd	r25, Y+5	; 0x05
    4220:	0e 94 9f 20 	call	0x413e	; 0x413e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    4224:	19 82       	std	Y+1, r1	; 0x01
    4226:	02 c0       	rjmp	.+4      	; 0x422c <xTaskCheckForTimeOut+0xb8>
		}
		else
		{
			xReturn = pdTRUE;
    4228:	81 e0       	ldi	r24, 0x01	; 1
    422a:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    422c:	0f 90       	pop	r0
    422e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4230:	89 81       	ldd	r24, Y+1	; 0x01
}
    4232:	27 96       	adiw	r28, 0x07	; 7
    4234:	0f b6       	in	r0, 0x3f	; 63
    4236:	f8 94       	cli
    4238:	de bf       	out	0x3e, r29	; 62
    423a:	0f be       	out	0x3f, r0	; 63
    423c:	cd bf       	out	0x3d, r28	; 61
    423e:	df 91       	pop	r29
    4240:	cf 91       	pop	r28
    4242:	08 95       	ret

00004244 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4244:	cf 93       	push	r28
    4246:	df 93       	push	r29
    4248:	cd b7       	in	r28, 0x3d	; 61
    424a:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    424c:	81 e0       	ldi	r24, 0x01	; 1
    424e:	80 93 4f 05 	sts	0x054F, r24
}
    4252:	df 91       	pop	r29
    4254:	cf 91       	pop	r28
    4256:	08 95       	ret

00004258 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4258:	cf 93       	push	r28
    425a:	df 93       	push	r29
    425c:	00 d0       	rcall	.+0      	; 0x425e <prvIdleTask+0x6>
    425e:	cd b7       	in	r28, 0x3d	; 61
    4260:	de b7       	in	r29, 0x3e	; 62
    4262:	9a 83       	std	Y+2, r25	; 0x02
    4264:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    4266:	0e 94 fd 21 	call	0x43fa	; 0x43fa <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    426a:	80 91 fc 04 	lds	r24, 0x04FC
    426e:	82 30       	cpi	r24, 0x02	; 2
    4270:	10 f0       	brcs	.+4      	; 0x4276 <prvIdleTask+0x1e>
			{
				taskYIELD();
    4272:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortYield>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    4276:	f7 cf       	rjmp	.-18     	; 0x4266 <prvIdleTask+0xe>

00004278 <prvInitialiseTCBVariables>:

#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4278:	0f 93       	push	r16
    427a:	1f 93       	push	r17
    427c:	cf 93       	push	r28
    427e:	df 93       	push	r29
    4280:	cd b7       	in	r28, 0x3d	; 61
    4282:	de b7       	in	r29, 0x3e	; 62
    4284:	2a 97       	sbiw	r28, 0x0a	; 10
    4286:	0f b6       	in	r0, 0x3f	; 63
    4288:	f8 94       	cli
    428a:	de bf       	out	0x3e, r29	; 62
    428c:	0f be       	out	0x3f, r0	; 63
    428e:	cd bf       	out	0x3d, r28	; 61
    4290:	9b 83       	std	Y+3, r25	; 0x03
    4292:	8a 83       	std	Y+2, r24	; 0x02
    4294:	7d 83       	std	Y+5, r23	; 0x05
    4296:	6c 83       	std	Y+4, r22	; 0x04
    4298:	4e 83       	std	Y+6, r20	; 0x06
    429a:	38 87       	std	Y+8, r19	; 0x08
    429c:	2f 83       	std	Y+7, r18	; 0x07
    429e:	1a 87       	std	Y+10, r17	; 0x0a
    42a0:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    42a2:	19 82       	std	Y+1, r1	; 0x01
    42a4:	22 c0       	rjmp	.+68     	; 0x42ea <prvInitialiseTCBVariables+0x72>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    42a6:	89 81       	ldd	r24, Y+1	; 0x01
    42a8:	88 2f       	mov	r24, r24
    42aa:	90 e0       	ldi	r25, 0x00	; 0
    42ac:	29 81       	ldd	r18, Y+1	; 0x01
    42ae:	22 2f       	mov	r18, r18
    42b0:	30 e0       	ldi	r19, 0x00	; 0
    42b2:	4c 81       	ldd	r20, Y+4	; 0x04
    42b4:	5d 81       	ldd	r21, Y+5	; 0x05
    42b6:	24 0f       	add	r18, r20
    42b8:	35 1f       	adc	r19, r21
    42ba:	f9 01       	movw	r30, r18
    42bc:	40 81       	ld	r20, Z
    42be:	2a 81       	ldd	r18, Y+2	; 0x02
    42c0:	3b 81       	ldd	r19, Y+3	; 0x03
    42c2:	82 0f       	add	r24, r18
    42c4:	93 1f       	adc	r25, r19
    42c6:	49 96       	adiw	r24, 0x19	; 25
    42c8:	fc 01       	movw	r30, r24
    42ca:	40 83       	st	Z, r20

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    42cc:	89 81       	ldd	r24, Y+1	; 0x01
    42ce:	88 2f       	mov	r24, r24
    42d0:	90 e0       	ldi	r25, 0x00	; 0
    42d2:	2c 81       	ldd	r18, Y+4	; 0x04
    42d4:	3d 81       	ldd	r19, Y+5	; 0x05
    42d6:	82 0f       	add	r24, r18
    42d8:	93 1f       	adc	r25, r19
    42da:	fc 01       	movw	r30, r24
    42dc:	80 81       	ld	r24, Z
    42de:	88 23       	and	r24, r24
    42e0:	09 f4       	brne	.+2      	; 0x42e4 <prvInitialiseTCBVariables+0x6c>
		{
			break;
    42e2:	06 c0       	rjmp	.+12     	; 0x42f0 <prvInitialiseTCBVariables+0x78>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    42e4:	89 81       	ldd	r24, Y+1	; 0x01
    42e6:	8f 5f       	subi	r24, 0xFF	; 255
    42e8:	89 83       	std	Y+1, r24	; 0x01
    42ea:	89 81       	ldd	r24, Y+1	; 0x01
    42ec:	88 30       	cpi	r24, 0x08	; 8
    42ee:	d8 f2       	brcs	.-74     	; 0x42a6 <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    42f0:	8a 81       	ldd	r24, Y+2	; 0x02
    42f2:	9b 81       	ldd	r25, Y+3	; 0x03
    42f4:	fc 01       	movw	r30, r24
    42f6:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    42f8:	8e 81       	ldd	r24, Y+6	; 0x06
    42fa:	84 30       	cpi	r24, 0x04	; 4
    42fc:	10 f0       	brcs	.+4      	; 0x4302 <prvInitialiseTCBVariables+0x8a>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    42fe:	83 e0       	ldi	r24, 0x03	; 3
    4300:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    4302:	8a 81       	ldd	r24, Y+2	; 0x02
    4304:	9b 81       	ldd	r25, Y+3	; 0x03
    4306:	2e 81       	ldd	r18, Y+6	; 0x06
    4308:	fc 01       	movw	r30, r24
    430a:	26 8b       	std	Z+22, r18	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    430c:	8a 81       	ldd	r24, Y+2	; 0x02
    430e:	9b 81       	ldd	r25, Y+3	; 0x03
    4310:	02 96       	adiw	r24, 0x02	; 2
    4312:	0e 94 16 10 	call	0x202c	; 0x202c <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    4316:	8a 81       	ldd	r24, Y+2	; 0x02
    4318:	9b 81       	ldd	r25, Y+3	; 0x03
    431a:	0c 96       	adiw	r24, 0x0c	; 12
    431c:	0e 94 16 10 	call	0x202c	; 0x202c <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    4320:	8a 81       	ldd	r24, Y+2	; 0x02
    4322:	9b 81       	ldd	r25, Y+3	; 0x03
    4324:	2a 81       	ldd	r18, Y+2	; 0x02
    4326:	3b 81       	ldd	r19, Y+3	; 0x03
    4328:	fc 01       	movw	r30, r24
    432a:	31 87       	std	Z+9, r19	; 0x09
    432c:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    432e:	8e 81       	ldd	r24, Y+6	; 0x06
    4330:	88 2f       	mov	r24, r24
    4332:	90 e0       	ldi	r25, 0x00	; 0
    4334:	24 e0       	ldi	r18, 0x04	; 4
    4336:	30 e0       	ldi	r19, 0x00	; 0
    4338:	28 1b       	sub	r18, r24
    433a:	39 0b       	sbc	r19, r25
    433c:	8a 81       	ldd	r24, Y+2	; 0x02
    433e:	9b 81       	ldd	r25, Y+3	; 0x03
    4340:	fc 01       	movw	r30, r24
    4342:	35 87       	std	Z+13, r19	; 0x0d
    4344:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    4346:	8a 81       	ldd	r24, Y+2	; 0x02
    4348:	9b 81       	ldd	r25, Y+3	; 0x03
    434a:	2a 81       	ldd	r18, Y+2	; 0x02
    434c:	3b 81       	ldd	r19, Y+3	; 0x03
    434e:	fc 01       	movw	r30, r24
    4350:	33 8b       	std	Z+19, r19	; 0x13
    4352:	22 8b       	std	Z+18, r18	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    4354:	8a 81       	ldd	r24, Y+2	; 0x02
    4356:	9b 81       	ldd	r25, Y+3	; 0x03
    4358:	fc 01       	movw	r30, r24
    435a:	11 a2       	std	Z+33, r1	; 0x21
    435c:	12 a2       	std	Z+34, r1	; 0x22
    435e:	13 a2       	std	Z+35, r1	; 0x23
    4360:	14 a2       	std	Z+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
    4362:	8a 81       	ldd	r24, Y+2	; 0x02
    4364:	9b 81       	ldd	r25, Y+3	; 0x03
    4366:	fc 01       	movw	r30, r24
    4368:	15 a2       	std	Z+37, r1	; 0x25
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    436a:	2a 96       	adiw	r28, 0x0a	; 10
    436c:	0f b6       	in	r0, 0x3f	; 63
    436e:	f8 94       	cli
    4370:	de bf       	out	0x3e, r29	; 62
    4372:	0f be       	out	0x3f, r0	; 63
    4374:	cd bf       	out	0x3d, r28	; 61
    4376:	df 91       	pop	r29
    4378:	cf 91       	pop	r28
    437a:	1f 91       	pop	r17
    437c:	0f 91       	pop	r16
    437e:	08 95       	ret

00004380 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4380:	cf 93       	push	r28
    4382:	df 93       	push	r29
    4384:	1f 92       	push	r1
    4386:	cd b7       	in	r28, 0x3d	; 61
    4388:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    438a:	19 82       	std	Y+1, r1	; 0x01
    438c:	13 c0       	rjmp	.+38     	; 0x43b4 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    438e:	89 81       	ldd	r24, Y+1	; 0x01
    4390:	28 2f       	mov	r18, r24
    4392:	30 e0       	ldi	r19, 0x00	; 0
    4394:	c9 01       	movw	r24, r18
    4396:	88 0f       	add	r24, r24
    4398:	99 1f       	adc	r25, r25
    439a:	88 0f       	add	r24, r24
    439c:	99 1f       	adc	r25, r25
    439e:	88 0f       	add	r24, r24
    43a0:	99 1f       	adc	r25, r25
    43a2:	82 0f       	add	r24, r18
    43a4:	93 1f       	adc	r25, r19
    43a6:	84 50       	subi	r24, 0x04	; 4
    43a8:	9b 4f       	sbci	r25, 0xFB	; 251
    43aa:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    43ae:	89 81       	ldd	r24, Y+1	; 0x01
    43b0:	8f 5f       	subi	r24, 0xFF	; 255
    43b2:	89 83       	std	Y+1, r24	; 0x01
    43b4:	89 81       	ldd	r24, Y+1	; 0x01
    43b6:	84 30       	cpi	r24, 0x04	; 4
    43b8:	50 f3       	brcs	.-44     	; 0x438e <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    43ba:	80 e2       	ldi	r24, 0x20	; 32
    43bc:	95 e0       	ldi	r25, 0x05	; 5
    43be:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    43c2:	89 e2       	ldi	r24, 0x29	; 41
    43c4:	95 e0       	ldi	r25, 0x05	; 5
    43c6:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    43ca:	86 e3       	ldi	r24, 0x36	; 54
    43cc:	95 e0       	ldi	r25, 0x05	; 5
    43ce:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    43d2:	8f e3       	ldi	r24, 0x3F	; 63
    43d4:	95 e0       	ldi	r25, 0x05	; 5
    43d6:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    43da:	80 e2       	ldi	r24, 0x20	; 32
    43dc:	95 e0       	ldi	r25, 0x05	; 5
    43de:	90 93 33 05 	sts	0x0533, r25
    43e2:	80 93 32 05 	sts	0x0532, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    43e6:	89 e2       	ldi	r24, 0x29	; 41
    43e8:	95 e0       	ldi	r25, 0x05	; 5
    43ea:	90 93 35 05 	sts	0x0535, r25
    43ee:	80 93 34 05 	sts	0x0534, r24
}
    43f2:	0f 90       	pop	r0
    43f4:	df 91       	pop	r29
    43f6:	cf 91       	pop	r28
    43f8:	08 95       	ret

000043fa <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    43fa:	cf 93       	push	r28
    43fc:	df 93       	push	r29
    43fe:	00 d0       	rcall	.+0      	; 0x4400 <prvCheckTasksWaitingTermination+0x6>
    4400:	1f 92       	push	r1
    4402:	cd b7       	in	r28, 0x3d	; 61
    4404:	de b7       	in	r29, 0x3e	; 62
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    4406:	2f c0       	rjmp	.+94     	; 0x4466 <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
    4408:	0e 94 22 1d 	call	0x3a44	; 0x3a44 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    440c:	90 91 3f 05 	lds	r25, 0x053F
    4410:	81 e0       	ldi	r24, 0x01	; 1
    4412:	99 23       	and	r25, r25
    4414:	09 f0       	breq	.+2      	; 0x4418 <prvCheckTasksWaitingTermination+0x1e>
    4416:	80 e0       	ldi	r24, 0x00	; 0
    4418:	89 83       	std	Y+1, r24	; 0x01
			}
			( void ) xTaskResumeAll();
    441a:	0e 94 2e 1d 	call	0x3a5c	; 0x3a5c <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    441e:	89 81       	ldd	r24, Y+1	; 0x01
    4420:	88 23       	and	r24, r24
    4422:	09 f5       	brne	.+66     	; 0x4466 <prvCheckTasksWaitingTermination+0x6c>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    4424:	0f b6       	in	r0, 0x3f	; 63
    4426:	f8 94       	cli
    4428:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    442a:	80 91 44 05 	lds	r24, 0x0544
    442e:	90 91 45 05 	lds	r25, 0x0545
    4432:	fc 01       	movw	r30, r24
    4434:	86 81       	ldd	r24, Z+6	; 0x06
    4436:	97 81       	ldd	r25, Z+7	; 0x07
    4438:	9b 83       	std	Y+3, r25	; 0x03
    443a:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    443c:	8a 81       	ldd	r24, Y+2	; 0x02
    443e:	9b 81       	ldd	r25, Y+3	; 0x03
    4440:	02 96       	adiw	r24, 0x02	; 2
    4442:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>
					--uxCurrentNumberOfTasks;
    4446:	80 91 49 05 	lds	r24, 0x0549
    444a:	81 50       	subi	r24, 0x01	; 1
    444c:	80 93 49 05 	sts	0x0549, r24
					--uxTasksDeleted;
    4450:	80 91 48 05 	lds	r24, 0x0548
    4454:	81 50       	subi	r24, 0x01	; 1
    4456:	80 93 48 05 	sts	0x0548, r24
				}
				taskEXIT_CRITICAL();
    445a:	0f 90       	pop	r0
    445c:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    445e:	8a 81       	ldd	r24, Y+2	; 0x02
    4460:	9b 81       	ldd	r25, Y+3	; 0x03
    4462:	0e 94 ca 22 	call	0x4594	; 0x4594 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    4466:	80 91 48 05 	lds	r24, 0x0548
    446a:	88 23       	and	r24, r24
    446c:	69 f6       	brne	.-102    	; 0x4408 <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    446e:	0f 90       	pop	r0
    4470:	0f 90       	pop	r0
    4472:	0f 90       	pop	r0
    4474:	df 91       	pop	r29
    4476:	cf 91       	pop	r28
    4478:	08 95       	ret

0000447a <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    447a:	cf 93       	push	r28
    447c:	df 93       	push	r29
    447e:	00 d0       	rcall	.+0      	; 0x4480 <prvAddCurrentTaskToDelayedList+0x6>
    4480:	cd b7       	in	r28, 0x3d	; 61
    4482:	de b7       	in	r29, 0x3e	; 62
    4484:	9a 83       	std	Y+2, r25	; 0x02
    4486:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    4488:	80 91 fa 04 	lds	r24, 0x04FA
    448c:	90 91 fb 04 	lds	r25, 0x04FB
    4490:	29 81       	ldd	r18, Y+1	; 0x01
    4492:	3a 81       	ldd	r19, Y+2	; 0x02
    4494:	fc 01       	movw	r30, r24
    4496:	33 83       	std	Z+3, r19	; 0x03
    4498:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    449a:	80 91 4a 05 	lds	r24, 0x054A
    449e:	90 91 4b 05 	lds	r25, 0x054B
    44a2:	29 81       	ldd	r18, Y+1	; 0x01
    44a4:	3a 81       	ldd	r19, Y+2	; 0x02
    44a6:	28 17       	cp	r18, r24
    44a8:	39 07       	cpc	r19, r25
    44aa:	78 f4       	brcc	.+30     	; 0x44ca <prvAddCurrentTaskToDelayedList+0x50>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    44ac:	80 91 fa 04 	lds	r24, 0x04FA
    44b0:	90 91 fb 04 	lds	r25, 0x04FB
    44b4:	9c 01       	movw	r18, r24
    44b6:	2e 5f       	subi	r18, 0xFE	; 254
    44b8:	3f 4f       	sbci	r19, 0xFF	; 255
    44ba:	80 91 34 05 	lds	r24, 0x0534
    44be:	90 91 35 05 	lds	r25, 0x0535
    44c2:	b9 01       	movw	r22, r18
    44c4:	0e 94 75 10 	call	0x20ea	; 0x20ea <vListInsert>
    44c8:	1d c0       	rjmp	.+58     	; 0x4504 <prvAddCurrentTaskToDelayedList+0x8a>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    44ca:	80 91 fa 04 	lds	r24, 0x04FA
    44ce:	90 91 fb 04 	lds	r25, 0x04FB
    44d2:	9c 01       	movw	r18, r24
    44d4:	2e 5f       	subi	r18, 0xFE	; 254
    44d6:	3f 4f       	sbci	r19, 0xFF	; 255
    44d8:	80 91 32 05 	lds	r24, 0x0532
    44dc:	90 91 33 05 	lds	r25, 0x0533
    44e0:	b9 01       	movw	r22, r18
    44e2:	0e 94 75 10 	call	0x20ea	; 0x20ea <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    44e6:	80 91 52 05 	lds	r24, 0x0552
    44ea:	90 91 53 05 	lds	r25, 0x0553
    44ee:	29 81       	ldd	r18, Y+1	; 0x01
    44f0:	3a 81       	ldd	r19, Y+2	; 0x02
    44f2:	28 17       	cp	r18, r24
    44f4:	39 07       	cpc	r19, r25
    44f6:	30 f4       	brcc	.+12     	; 0x4504 <prvAddCurrentTaskToDelayedList+0x8a>
		{
			xNextTaskUnblockTime = xTimeToWake;
    44f8:	89 81       	ldd	r24, Y+1	; 0x01
    44fa:	9a 81       	ldd	r25, Y+2	; 0x02
    44fc:	90 93 53 05 	sts	0x0553, r25
    4500:	80 93 52 05 	sts	0x0552, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    4504:	0f 90       	pop	r0
    4506:	0f 90       	pop	r0
    4508:	df 91       	pop	r29
    450a:	cf 91       	pop	r28
    450c:	08 95       	ret

0000450e <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    450e:	cf 93       	push	r28
    4510:	df 93       	push	r29
    4512:	cd b7       	in	r28, 0x3d	; 61
    4514:	de b7       	in	r29, 0x3e	; 62
    4516:	28 97       	sbiw	r28, 0x08	; 8
    4518:	0f b6       	in	r0, 0x3f	; 63
    451a:	f8 94       	cli
    451c:	de bf       	out	0x3e, r29	; 62
    451e:	0f be       	out	0x3f, r0	; 63
    4520:	cd bf       	out	0x3d, r28	; 61
    4522:	9e 83       	std	Y+6, r25	; 0x06
    4524:	8d 83       	std	Y+5, r24	; 0x05
    4526:	78 87       	std	Y+8, r23	; 0x08
    4528:	6f 83       	std	Y+7, r22	; 0x07
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    452a:	8f 81       	ldd	r24, Y+7	; 0x07
    452c:	98 85       	ldd	r25, Y+8	; 0x08
    452e:	89 2b       	or	r24, r25
    4530:	29 f4       	brne	.+10     	; 0x453c <prvAllocateTCBAndStack+0x2e>
    4532:	8d 81       	ldd	r24, Y+5	; 0x05
    4534:	9e 81       	ldd	r25, Y+6	; 0x06
    4536:	0e 94 47 14 	call	0x288e	; 0x288e <pvPortMalloc>
    453a:	02 c0       	rjmp	.+4      	; 0x4540 <prvAllocateTCBAndStack+0x32>
    453c:	8f 81       	ldd	r24, Y+7	; 0x07
    453e:	98 85       	ldd	r25, Y+8	; 0x08
    4540:	9c 83       	std	Y+4, r25	; 0x04
    4542:	8b 83       	std	Y+3, r24	; 0x03

		if( pxStack != NULL )
    4544:	8b 81       	ldd	r24, Y+3	; 0x03
    4546:	9c 81       	ldd	r25, Y+4	; 0x04
    4548:	89 2b       	or	r24, r25
    454a:	b9 f0       	breq	.+46     	; 0x457a <prvAllocateTCBAndStack+0x6c>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    454c:	86 e2       	ldi	r24, 0x26	; 38
    454e:	90 e0       	ldi	r25, 0x00	; 0
    4550:	0e 94 47 14 	call	0x288e	; 0x288e <pvPortMalloc>
    4554:	9a 83       	std	Y+2, r25	; 0x02
    4556:	89 83       	std	Y+1, r24	; 0x01

			if( pxNewTCB != NULL )
    4558:	89 81       	ldd	r24, Y+1	; 0x01
    455a:	9a 81       	ldd	r25, Y+2	; 0x02
    455c:	89 2b       	or	r24, r25
    455e:	41 f0       	breq	.+16     	; 0x4570 <prvAllocateTCBAndStack+0x62>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    4560:	89 81       	ldd	r24, Y+1	; 0x01
    4562:	9a 81       	ldd	r25, Y+2	; 0x02
    4564:	2b 81       	ldd	r18, Y+3	; 0x03
    4566:	3c 81       	ldd	r19, Y+4	; 0x04
    4568:	fc 01       	movw	r30, r24
    456a:	30 8f       	std	Z+24, r19	; 0x18
    456c:	27 8b       	std	Z+23, r18	; 0x17
    456e:	07 c0       	rjmp	.+14     	; 0x457e <prvAllocateTCBAndStack+0x70>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    4570:	8b 81       	ldd	r24, Y+3	; 0x03
    4572:	9c 81       	ldd	r25, Y+4	; 0x04
    4574:	0e 94 9c 14 	call	0x2938	; 0x2938 <vPortFree>
    4578:	02 c0       	rjmp	.+4      	; 0x457e <prvAllocateTCBAndStack+0x70>
			}
		}
		else
		{
			pxNewTCB = NULL;
    457a:	1a 82       	std	Y+2, r1	; 0x02
    457c:	19 82       	std	Y+1, r1	; 0x01
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
		}
		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
	}

	return pxNewTCB;
    457e:	89 81       	ldd	r24, Y+1	; 0x01
    4580:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4582:	28 96       	adiw	r28, 0x08	; 8
    4584:	0f b6       	in	r0, 0x3f	; 63
    4586:	f8 94       	cli
    4588:	de bf       	out	0x3e, r29	; 62
    458a:	0f be       	out	0x3f, r0	; 63
    458c:	cd bf       	out	0x3d, r28	; 61
    458e:	df 91       	pop	r29
    4590:	cf 91       	pop	r28
    4592:	08 95       	ret

00004594 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    4594:	cf 93       	push	r28
    4596:	df 93       	push	r29
    4598:	00 d0       	rcall	.+0      	; 0x459a <prvDeleteTCB+0x6>
    459a:	cd b7       	in	r28, 0x3d	; 61
    459c:	de b7       	in	r29, 0x3e	; 62
    459e:	9a 83       	std	Y+2, r25	; 0x02
    45a0:	89 83       	std	Y+1, r24	; 0x01
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
    45a2:	89 81       	ldd	r24, Y+1	; 0x01
    45a4:	9a 81       	ldd	r25, Y+2	; 0x02
    45a6:	fc 01       	movw	r30, r24
    45a8:	87 89       	ldd	r24, Z+23	; 0x17
    45aa:	90 8d       	ldd	r25, Z+24	; 0x18
    45ac:	0e 94 9c 14 	call	0x2938	; 0x2938 <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
    45b0:	89 81       	ldd	r24, Y+1	; 0x01
    45b2:	9a 81       	ldd	r25, Y+2	; 0x02
    45b4:	0e 94 9c 14 	call	0x2938	; 0x2938 <vPortFree>
	}
    45b8:	0f 90       	pop	r0
    45ba:	0f 90       	pop	r0
    45bc:	df 91       	pop	r29
    45be:	cf 91       	pop	r28
    45c0:	08 95       	ret

000045c2 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    45c2:	cf 93       	push	r28
    45c4:	df 93       	push	r29
    45c6:	00 d0       	rcall	.+0      	; 0x45c8 <prvResetNextTaskUnblockTime+0x6>
    45c8:	cd b7       	in	r28, 0x3d	; 61
    45ca:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    45cc:	80 91 32 05 	lds	r24, 0x0532
    45d0:	90 91 33 05 	lds	r25, 0x0533
    45d4:	fc 01       	movw	r30, r24
    45d6:	80 81       	ld	r24, Z
    45d8:	88 23       	and	r24, r24
    45da:	39 f4       	brne	.+14     	; 0x45ea <prvResetNextTaskUnblockTime+0x28>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    45dc:	8f ef       	ldi	r24, 0xFF	; 255
    45de:	9f ef       	ldi	r25, 0xFF	; 255
    45e0:	90 93 53 05 	sts	0x0553, r25
    45e4:	80 93 52 05 	sts	0x0552, r24
    45e8:	15 c0       	rjmp	.+42     	; 0x4614 <prvResetNextTaskUnblockTime+0x52>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    45ea:	80 91 32 05 	lds	r24, 0x0532
    45ee:	90 91 33 05 	lds	r25, 0x0533
    45f2:	fc 01       	movw	r30, r24
    45f4:	85 81       	ldd	r24, Z+5	; 0x05
    45f6:	96 81       	ldd	r25, Z+6	; 0x06
    45f8:	fc 01       	movw	r30, r24
    45fa:	86 81       	ldd	r24, Z+6	; 0x06
    45fc:	97 81       	ldd	r25, Z+7	; 0x07
    45fe:	9a 83       	std	Y+2, r25	; 0x02
    4600:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    4602:	89 81       	ldd	r24, Y+1	; 0x01
    4604:	9a 81       	ldd	r25, Y+2	; 0x02
    4606:	fc 01       	movw	r30, r24
    4608:	82 81       	ldd	r24, Z+2	; 0x02
    460a:	93 81       	ldd	r25, Z+3	; 0x03
    460c:	90 93 53 05 	sts	0x0553, r25
    4610:	80 93 52 05 	sts	0x0552, r24
	}
}
    4614:	0f 90       	pop	r0
    4616:	0f 90       	pop	r0
    4618:	df 91       	pop	r29
    461a:	cf 91       	pop	r28
    461c:	08 95       	ret

0000461e <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    461e:	cf 93       	push	r28
    4620:	df 93       	push	r29
    4622:	00 d0       	rcall	.+0      	; 0x4624 <uxTaskResetEventItemValue+0x6>
    4624:	cd b7       	in	r28, 0x3d	; 61
    4626:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4628:	80 91 fa 04 	lds	r24, 0x04FA
    462c:	90 91 fb 04 	lds	r25, 0x04FB
    4630:	fc 01       	movw	r30, r24
    4632:	84 85       	ldd	r24, Z+12	; 0x0c
    4634:	95 85       	ldd	r25, Z+13	; 0x0d
    4636:	9a 83       	std	Y+2, r25	; 0x02
    4638:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    463a:	80 91 fa 04 	lds	r24, 0x04FA
    463e:	90 91 fb 04 	lds	r25, 0x04FB
    4642:	20 91 fa 04 	lds	r18, 0x04FA
    4646:	30 91 fb 04 	lds	r19, 0x04FB
    464a:	f9 01       	movw	r30, r18
    464c:	26 89       	ldd	r18, Z+22	; 0x16
    464e:	22 2f       	mov	r18, r18
    4650:	30 e0       	ldi	r19, 0x00	; 0
    4652:	44 e0       	ldi	r20, 0x04	; 4
    4654:	50 e0       	ldi	r21, 0x00	; 0
    4656:	ba 01       	movw	r22, r20
    4658:	62 1b       	sub	r22, r18
    465a:	73 0b       	sbc	r23, r19
    465c:	9b 01       	movw	r18, r22
    465e:	fc 01       	movw	r30, r24
    4660:	35 87       	std	Z+13, r19	; 0x0d
    4662:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
    4664:	89 81       	ldd	r24, Y+1	; 0x01
    4666:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4668:	0f 90       	pop	r0
    466a:	0f 90       	pop	r0
    466c:	df 91       	pop	r29
    466e:	cf 91       	pop	r28
    4670:	08 95       	ret

00004672 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    4672:	cf 93       	push	r28
    4674:	df 93       	push	r29
    4676:	cd b7       	in	r28, 0x3d	; 61
    4678:	de b7       	in	r29, 0x3e	; 62
    467a:	29 97       	sbiw	r28, 0x09	; 9
    467c:	0f b6       	in	r0, 0x3f	; 63
    467e:	f8 94       	cli
    4680:	de bf       	out	0x3e, r29	; 62
    4682:	0f be       	out	0x3f, r0	; 63
    4684:	cd bf       	out	0x3d, r28	; 61
    4686:	8f 83       	std	Y+7, r24	; 0x07
    4688:	79 87       	std	Y+9, r23	; 0x09
    468a:	68 87       	std	Y+8, r22	; 0x08
	TickType_t xTimeToWake;
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    468c:	0f b6       	in	r0, 0x3f	; 63
    468e:	f8 94       	cli
    4690:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    4692:	80 91 fa 04 	lds	r24, 0x04FA
    4696:	90 91 fb 04 	lds	r25, 0x04FB
    469a:	fc 01       	movw	r30, r24
    469c:	81 a1       	ldd	r24, Z+33	; 0x21
    469e:	92 a1       	ldd	r25, Z+34	; 0x22
    46a0:	a3 a1       	ldd	r26, Z+35	; 0x23
    46a2:	b4 a1       	ldd	r27, Z+36	; 0x24
    46a4:	89 2b       	or	r24, r25
    46a6:	8a 2b       	or	r24, r26
    46a8:	8b 2b       	or	r24, r27
    46aa:	11 f5       	brne	.+68     	; 0x46f0 <ulTaskNotifyTake+0x7e>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    46ac:	80 91 fa 04 	lds	r24, 0x04FA
    46b0:	90 91 fb 04 	lds	r25, 0x04FB
    46b4:	21 e0       	ldi	r18, 0x01	; 1
    46b6:	fc 01       	movw	r30, r24
    46b8:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    46ba:	88 85       	ldd	r24, Y+8	; 0x08
    46bc:	99 85       	ldd	r25, Y+9	; 0x09
    46be:	89 2b       	or	r24, r25
    46c0:	b9 f0       	breq	.+46     	; 0x46f0 <ulTaskNotifyTake+0x7e>
				{
					/* The task is going to block.  First it must be removed
					from the ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    46c2:	80 91 fa 04 	lds	r24, 0x04FA
    46c6:	90 91 fb 04 	lds	r25, 0x04FB
    46ca:	02 96       	adiw	r24, 0x02	; 2
    46cc:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>
					{
							/* Calculate the time at which the task should be
							woken if the event does not occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    46d0:	20 91 4a 05 	lds	r18, 0x054A
    46d4:	30 91 4b 05 	lds	r19, 0x054B
    46d8:	88 85       	ldd	r24, Y+8	; 0x08
    46da:	99 85       	ldd	r25, Y+9	; 0x09
    46dc:	82 0f       	add	r24, r18
    46de:	93 1f       	adc	r25, r19
    46e0:	9a 83       	std	Y+2, r25	; 0x02
    46e2:	89 83       	std	Y+1, r24	; 0x01
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    46e4:	89 81       	ldd	r24, Y+1	; 0x01
    46e6:	9a 81       	ldd	r25, Y+2	; 0x02
    46e8:	0e 94 3d 22 	call	0x447a	; 0x447a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    46ec:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    46f0:	0f 90       	pop	r0
    46f2:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    46f4:	0f b6       	in	r0, 0x3f	; 63
    46f6:	f8 94       	cli
    46f8:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    46fa:	80 91 fa 04 	lds	r24, 0x04FA
    46fe:	90 91 fb 04 	lds	r25, 0x04FB
    4702:	fc 01       	movw	r30, r24
    4704:	81 a1       	ldd	r24, Z+33	; 0x21
    4706:	92 a1       	ldd	r25, Z+34	; 0x22
    4708:	a3 a1       	ldd	r26, Z+35	; 0x23
    470a:	b4 a1       	ldd	r27, Z+36	; 0x24
    470c:	8b 83       	std	Y+3, r24	; 0x03
    470e:	9c 83       	std	Y+4, r25	; 0x04
    4710:	ad 83       	std	Y+5, r26	; 0x05
    4712:	be 83       	std	Y+6, r27	; 0x06

			if( ulReturn != 0UL )
    4714:	8b 81       	ldd	r24, Y+3	; 0x03
    4716:	9c 81       	ldd	r25, Y+4	; 0x04
    4718:	ad 81       	ldd	r26, Y+5	; 0x05
    471a:	be 81       	ldd	r27, Y+6	; 0x06
    471c:	89 2b       	or	r24, r25
    471e:	8a 2b       	or	r24, r26
    4720:	8b 2b       	or	r24, r27
    4722:	f1 f0       	breq	.+60     	; 0x4760 <ulTaskNotifyTake+0xee>
			{
				if( xClearCountOnExit != pdFALSE )
    4724:	8f 81       	ldd	r24, Y+7	; 0x07
    4726:	88 23       	and	r24, r24
    4728:	51 f0       	breq	.+20     	; 0x473e <ulTaskNotifyTake+0xcc>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    472a:	80 91 fa 04 	lds	r24, 0x04FA
    472e:	90 91 fb 04 	lds	r25, 0x04FB
    4732:	fc 01       	movw	r30, r24
    4734:	11 a2       	std	Z+33, r1	; 0x21
    4736:	12 a2       	std	Z+34, r1	; 0x22
    4738:	13 a2       	std	Z+35, r1	; 0x23
    473a:	14 a2       	std	Z+36, r1	; 0x24
    473c:	11 c0       	rjmp	.+34     	; 0x4760 <ulTaskNotifyTake+0xee>
				}
				else
				{
					( pxCurrentTCB->ulNotifiedValue )--;
    473e:	20 91 fa 04 	lds	r18, 0x04FA
    4742:	30 91 fb 04 	lds	r19, 0x04FB
    4746:	f9 01       	movw	r30, r18
    4748:	81 a1       	ldd	r24, Z+33	; 0x21
    474a:	92 a1       	ldd	r25, Z+34	; 0x22
    474c:	a3 a1       	ldd	r26, Z+35	; 0x23
    474e:	b4 a1       	ldd	r27, Z+36	; 0x24
    4750:	01 97       	sbiw	r24, 0x01	; 1
    4752:	a1 09       	sbc	r26, r1
    4754:	b1 09       	sbc	r27, r1
    4756:	f9 01       	movw	r30, r18
    4758:	81 a3       	std	Z+33, r24	; 0x21
    475a:	92 a3       	std	Z+34, r25	; 0x22
    475c:	a3 a3       	std	Z+35, r26	; 0x23
    475e:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    4760:	80 91 fa 04 	lds	r24, 0x04FA
    4764:	90 91 fb 04 	lds	r25, 0x04FB
    4768:	fc 01       	movw	r30, r24
    476a:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    476c:	0f 90       	pop	r0
    476e:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    4770:	8b 81       	ldd	r24, Y+3	; 0x03
    4772:	9c 81       	ldd	r25, Y+4	; 0x04
    4774:	ad 81       	ldd	r26, Y+5	; 0x05
    4776:	be 81       	ldd	r27, Y+6	; 0x06
	}
    4778:	bc 01       	movw	r22, r24
    477a:	cd 01       	movw	r24, r26
    477c:	29 96       	adiw	r28, 0x09	; 9
    477e:	0f b6       	in	r0, 0x3f	; 63
    4780:	f8 94       	cli
    4782:	de bf       	out	0x3e, r29	; 62
    4784:	0f be       	out	0x3f, r0	; 63
    4786:	cd bf       	out	0x3d, r28	; 61
    4788:	df 91       	pop	r29
    478a:	cf 91       	pop	r28
    478c:	08 95       	ret

0000478e <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    478e:	ef 92       	push	r14
    4790:	ff 92       	push	r15
    4792:	0f 93       	push	r16
    4794:	1f 93       	push	r17
    4796:	cf 93       	push	r28
    4798:	df 93       	push	r29
    479a:	cd b7       	in	r28, 0x3d	; 61
    479c:	de b7       	in	r29, 0x3e	; 62
    479e:	2f 97       	sbiw	r28, 0x0f	; 15
    47a0:	0f b6       	in	r0, 0x3f	; 63
    47a2:	f8 94       	cli
    47a4:	de bf       	out	0x3e, r29	; 62
    47a6:	0f be       	out	0x3f, r0	; 63
    47a8:	cd bf       	out	0x3d, r28	; 61
    47aa:	6c 83       	std	Y+4, r22	; 0x04
    47ac:	7d 83       	std	Y+5, r23	; 0x05
    47ae:	8e 83       	std	Y+6, r24	; 0x06
    47b0:	9f 83       	std	Y+7, r25	; 0x07
    47b2:	28 87       	std	Y+8, r18	; 0x08
    47b4:	39 87       	std	Y+9, r19	; 0x09
    47b6:	4a 87       	std	Y+10, r20	; 0x0a
    47b8:	5b 87       	std	Y+11, r21	; 0x0b
    47ba:	1d 87       	std	Y+13, r17	; 0x0d
    47bc:	0c 87       	std	Y+12, r16	; 0x0c
    47be:	ff 86       	std	Y+15, r15	; 0x0f
    47c0:	ee 86       	std	Y+14, r14	; 0x0e
	TickType_t xTimeToWake;
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    47c2:	0f b6       	in	r0, 0x3f	; 63
    47c4:	f8 94       	cli
    47c6:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->eNotifyState != eNotified )
    47c8:	80 91 fa 04 	lds	r24, 0x04FA
    47cc:	90 91 fb 04 	lds	r25, 0x04FB
    47d0:	fc 01       	movw	r30, r24
    47d2:	85 a1       	ldd	r24, Z+37	; 0x25
    47d4:	82 30       	cpi	r24, 0x02	; 2
    47d6:	e1 f1       	breq	.+120    	; 0x4850 <xTaskNotifyWait+0xc2>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    47d8:	60 91 fa 04 	lds	r22, 0x04FA
    47dc:	70 91 fb 04 	lds	r23, 0x04FB
    47e0:	fb 01       	movw	r30, r22
    47e2:	21 a1       	ldd	r18, Z+33	; 0x21
    47e4:	32 a1       	ldd	r19, Z+34	; 0x22
    47e6:	43 a1       	ldd	r20, Z+35	; 0x23
    47e8:	54 a1       	ldd	r21, Z+36	; 0x24
    47ea:	8c 81       	ldd	r24, Y+4	; 0x04
    47ec:	9d 81       	ldd	r25, Y+5	; 0x05
    47ee:	ae 81       	ldd	r26, Y+6	; 0x06
    47f0:	bf 81       	ldd	r27, Y+7	; 0x07
    47f2:	80 95       	com	r24
    47f4:	90 95       	com	r25
    47f6:	a0 95       	com	r26
    47f8:	b0 95       	com	r27
    47fa:	82 23       	and	r24, r18
    47fc:	93 23       	and	r25, r19
    47fe:	a4 23       	and	r26, r20
    4800:	b5 23       	and	r27, r21
    4802:	fb 01       	movw	r30, r22
    4804:	81 a3       	std	Z+33, r24	; 0x21
    4806:	92 a3       	std	Z+34, r25	; 0x22
    4808:	a3 a3       	std	Z+35, r26	; 0x23
    480a:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    480c:	80 91 fa 04 	lds	r24, 0x04FA
    4810:	90 91 fb 04 	lds	r25, 0x04FB
    4814:	21 e0       	ldi	r18, 0x01	; 1
    4816:	fc 01       	movw	r30, r24
    4818:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    481a:	8e 85       	ldd	r24, Y+14	; 0x0e
    481c:	9f 85       	ldd	r25, Y+15	; 0x0f
    481e:	89 2b       	or	r24, r25
    4820:	b9 f0       	breq	.+46     	; 0x4850 <xTaskNotifyWait+0xc2>
				{
					/* The task is going to block.  First it must be removed
					from the	ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4822:	80 91 fa 04 	lds	r24, 0x04FA
    4826:	90 91 fb 04 	lds	r25, 0x04FB
    482a:	02 96       	adiw	r24, 0x02	; 2
    482c:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>
					{
							/* Calculate the time at which the task should be
							woken if the event does not occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    4830:	20 91 4a 05 	lds	r18, 0x054A
    4834:	30 91 4b 05 	lds	r19, 0x054B
    4838:	8e 85       	ldd	r24, Y+14	; 0x0e
    483a:	9f 85       	ldd	r25, Y+15	; 0x0f
    483c:	82 0f       	add	r24, r18
    483e:	93 1f       	adc	r25, r19
    4840:	9b 83       	std	Y+3, r25	; 0x03
    4842:	8a 83       	std	Y+2, r24	; 0x02
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    4844:	8a 81       	ldd	r24, Y+2	; 0x02
    4846:	9b 81       	ldd	r25, Y+3	; 0x03
    4848:	0e 94 3d 22 	call	0x447a	; 0x447a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    484c:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4850:	0f 90       	pop	r0
    4852:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4854:	0f b6       	in	r0, 0x3f	; 63
    4856:	f8 94       	cli
    4858:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    485a:	8c 85       	ldd	r24, Y+12	; 0x0c
    485c:	9d 85       	ldd	r25, Y+13	; 0x0d
    485e:	89 2b       	or	r24, r25
    4860:	81 f0       	breq	.+32     	; 0x4882 <xTaskNotifyWait+0xf4>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    4862:	80 91 fa 04 	lds	r24, 0x04FA
    4866:	90 91 fb 04 	lds	r25, 0x04FB
    486a:	fc 01       	movw	r30, r24
    486c:	81 a1       	ldd	r24, Z+33	; 0x21
    486e:	92 a1       	ldd	r25, Z+34	; 0x22
    4870:	a3 a1       	ldd	r26, Z+35	; 0x23
    4872:	b4 a1       	ldd	r27, Z+36	; 0x24
    4874:	2c 85       	ldd	r18, Y+12	; 0x0c
    4876:	3d 85       	ldd	r19, Y+13	; 0x0d
    4878:	f9 01       	movw	r30, r18
    487a:	80 83       	st	Z, r24
    487c:	91 83       	std	Z+1, r25	; 0x01
    487e:	a2 83       	std	Z+2, r26	; 0x02
    4880:	b3 83       	std	Z+3, r27	; 0x03

			/* If eNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
    4882:	80 91 fa 04 	lds	r24, 0x04FA
    4886:	90 91 fb 04 	lds	r25, 0x04FB
    488a:	fc 01       	movw	r30, r24
    488c:	85 a1       	ldd	r24, Z+37	; 0x25
    488e:	81 30       	cpi	r24, 0x01	; 1
    4890:	11 f4       	brne	.+4      	; 0x4896 <xTaskNotifyWait+0x108>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4892:	19 82       	std	Y+1, r1	; 0x01
    4894:	1c c0       	rjmp	.+56     	; 0x48ce <xTaskNotifyWait+0x140>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    4896:	60 91 fa 04 	lds	r22, 0x04FA
    489a:	70 91 fb 04 	lds	r23, 0x04FB
    489e:	fb 01       	movw	r30, r22
    48a0:	21 a1       	ldd	r18, Z+33	; 0x21
    48a2:	32 a1       	ldd	r19, Z+34	; 0x22
    48a4:	43 a1       	ldd	r20, Z+35	; 0x23
    48a6:	54 a1       	ldd	r21, Z+36	; 0x24
    48a8:	88 85       	ldd	r24, Y+8	; 0x08
    48aa:	99 85       	ldd	r25, Y+9	; 0x09
    48ac:	aa 85       	ldd	r26, Y+10	; 0x0a
    48ae:	bb 85       	ldd	r27, Y+11	; 0x0b
    48b0:	80 95       	com	r24
    48b2:	90 95       	com	r25
    48b4:	a0 95       	com	r26
    48b6:	b0 95       	com	r27
    48b8:	82 23       	and	r24, r18
    48ba:	93 23       	and	r25, r19
    48bc:	a4 23       	and	r26, r20
    48be:	b5 23       	and	r27, r21
    48c0:	fb 01       	movw	r30, r22
    48c2:	81 a3       	std	Z+33, r24	; 0x21
    48c4:	92 a3       	std	Z+34, r25	; 0x22
    48c6:	a3 a3       	std	Z+35, r26	; 0x23
    48c8:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    48ca:	81 e0       	ldi	r24, 0x01	; 1
    48cc:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    48ce:	80 91 fa 04 	lds	r24, 0x04FA
    48d2:	90 91 fb 04 	lds	r25, 0x04FB
    48d6:	fc 01       	movw	r30, r24
    48d8:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    48da:	0f 90       	pop	r0
    48dc:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    48de:	89 81       	ldd	r24, Y+1	; 0x01
	}
    48e0:	2f 96       	adiw	r28, 0x0f	; 15
    48e2:	0f b6       	in	r0, 0x3f	; 63
    48e4:	f8 94       	cli
    48e6:	de bf       	out	0x3e, r29	; 62
    48e8:	0f be       	out	0x3f, r0	; 63
    48ea:	cd bf       	out	0x3d, r28	; 61
    48ec:	df 91       	pop	r29
    48ee:	cf 91       	pop	r28
    48f0:	1f 91       	pop	r17
    48f2:	0f 91       	pop	r16
    48f4:	ff 90       	pop	r15
    48f6:	ef 90       	pop	r14
    48f8:	08 95       	ret

000048fa <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    48fa:	0f 93       	push	r16
    48fc:	1f 93       	push	r17
    48fe:	cf 93       	push	r28
    4900:	df 93       	push	r29
    4902:	cd b7       	in	r28, 0x3d	; 61
    4904:	de b7       	in	r29, 0x3e	; 62
    4906:	2d 97       	sbiw	r28, 0x0d	; 13
    4908:	0f b6       	in	r0, 0x3f	; 63
    490a:	f8 94       	cli
    490c:	de bf       	out	0x3e, r29	; 62
    490e:	0f be       	out	0x3f, r0	; 63
    4910:	cd bf       	out	0x3d, r28	; 61
    4912:	9e 83       	std	Y+6, r25	; 0x06
    4914:	8d 83       	std	Y+5, r24	; 0x05
    4916:	4f 83       	std	Y+7, r20	; 0x07
    4918:	58 87       	std	Y+8, r21	; 0x08
    491a:	69 87       	std	Y+9, r22	; 0x09
    491c:	7a 87       	std	Y+10, r23	; 0x0a
    491e:	2b 87       	std	Y+11, r18	; 0x0b
    4920:	1d 87       	std	Y+13, r17	; 0x0d
    4922:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    4924:	81 e0       	ldi	r24, 0x01	; 1
    4926:	89 83       	std	Y+1, r24	; 0x01

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
    4928:	8d 81       	ldd	r24, Y+5	; 0x05
    492a:	9e 81       	ldd	r25, Y+6	; 0x06
    492c:	9b 83       	std	Y+3, r25	; 0x03
    492e:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    4930:	0f b6       	in	r0, 0x3f	; 63
    4932:	f8 94       	cli
    4934:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    4936:	8c 85       	ldd	r24, Y+12	; 0x0c
    4938:	9d 85       	ldd	r25, Y+13	; 0x0d
    493a:	89 2b       	or	r24, r25
    493c:	71 f0       	breq	.+28     	; 0x495a <xTaskGenericNotify+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    493e:	8a 81       	ldd	r24, Y+2	; 0x02
    4940:	9b 81       	ldd	r25, Y+3	; 0x03
    4942:	fc 01       	movw	r30, r24
    4944:	81 a1       	ldd	r24, Z+33	; 0x21
    4946:	92 a1       	ldd	r25, Z+34	; 0x22
    4948:	a3 a1       	ldd	r26, Z+35	; 0x23
    494a:	b4 a1       	ldd	r27, Z+36	; 0x24
    494c:	2c 85       	ldd	r18, Y+12	; 0x0c
    494e:	3d 85       	ldd	r19, Y+13	; 0x0d
    4950:	f9 01       	movw	r30, r18
    4952:	80 83       	st	Z, r24
    4954:	91 83       	std	Z+1, r25	; 0x01
    4956:	a2 83       	std	Z+2, r26	; 0x02
    4958:	b3 83       	std	Z+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    495a:	8a 81       	ldd	r24, Y+2	; 0x02
    495c:	9b 81       	ldd	r25, Y+3	; 0x03
    495e:	fc 01       	movw	r30, r24
    4960:	85 a1       	ldd	r24, Z+37	; 0x25
    4962:	8c 83       	std	Y+4, r24	; 0x04

			pxTCB->eNotifyState = eNotified;
    4964:	8a 81       	ldd	r24, Y+2	; 0x02
    4966:	9b 81       	ldd	r25, Y+3	; 0x03
    4968:	22 e0       	ldi	r18, 0x02	; 2
    496a:	fc 01       	movw	r30, r24
    496c:	25 a3       	std	Z+37, r18	; 0x25

			switch( eAction )
    496e:	8b 85       	ldd	r24, Y+11	; 0x0b
    4970:	88 2f       	mov	r24, r24
    4972:	90 e0       	ldi	r25, 0x00	; 0
    4974:	82 30       	cpi	r24, 0x02	; 2
    4976:	91 05       	cpc	r25, r1
    4978:	31 f1       	breq	.+76     	; 0x49c6 <xTaskGenericNotify+0xcc>
    497a:	83 30       	cpi	r24, 0x03	; 3
    497c:	91 05       	cpc	r25, r1
    497e:	34 f4       	brge	.+12     	; 0x498c <xTaskGenericNotify+0x92>
    4980:	00 97       	sbiw	r24, 0x00	; 0
    4982:	09 f4       	brne	.+2      	; 0x4986 <xTaskGenericNotify+0x8c>
    4984:	4f c0       	rjmp	.+158    	; 0x4a24 <xTaskGenericNotify+0x12a>
    4986:	01 97       	sbiw	r24, 0x01	; 1
    4988:	39 f0       	breq	.+14     	; 0x4998 <xTaskGenericNotify+0x9e>
    498a:	4d c0       	rjmp	.+154    	; 0x4a26 <xTaskGenericNotify+0x12c>
    498c:	83 30       	cpi	r24, 0x03	; 3
    498e:	91 05       	cpc	r25, r1
    4990:	61 f1       	breq	.+88     	; 0x49ea <xTaskGenericNotify+0xf0>
    4992:	04 97       	sbiw	r24, 0x04	; 4
    4994:	b1 f1       	breq	.+108    	; 0x4a02 <xTaskGenericNotify+0x108>
    4996:	47 c0       	rjmp	.+142    	; 0x4a26 <xTaskGenericNotify+0x12c>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4998:	8a 81       	ldd	r24, Y+2	; 0x02
    499a:	9b 81       	ldd	r25, Y+3	; 0x03
    499c:	fc 01       	movw	r30, r24
    499e:	21 a1       	ldd	r18, Z+33	; 0x21
    49a0:	32 a1       	ldd	r19, Z+34	; 0x22
    49a2:	43 a1       	ldd	r20, Z+35	; 0x23
    49a4:	54 a1       	ldd	r21, Z+36	; 0x24
    49a6:	8f 81       	ldd	r24, Y+7	; 0x07
    49a8:	98 85       	ldd	r25, Y+8	; 0x08
    49aa:	a9 85       	ldd	r26, Y+9	; 0x09
    49ac:	ba 85       	ldd	r27, Y+10	; 0x0a
    49ae:	82 2b       	or	r24, r18
    49b0:	93 2b       	or	r25, r19
    49b2:	a4 2b       	or	r26, r20
    49b4:	b5 2b       	or	r27, r21
    49b6:	2a 81       	ldd	r18, Y+2	; 0x02
    49b8:	3b 81       	ldd	r19, Y+3	; 0x03
    49ba:	f9 01       	movw	r30, r18
    49bc:	81 a3       	std	Z+33, r24	; 0x21
    49be:	92 a3       	std	Z+34, r25	; 0x22
    49c0:	a3 a3       	std	Z+35, r26	; 0x23
    49c2:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    49c4:	30 c0       	rjmp	.+96     	; 0x4a26 <xTaskGenericNotify+0x12c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    49c6:	8a 81       	ldd	r24, Y+2	; 0x02
    49c8:	9b 81       	ldd	r25, Y+3	; 0x03
    49ca:	fc 01       	movw	r30, r24
    49cc:	81 a1       	ldd	r24, Z+33	; 0x21
    49ce:	92 a1       	ldd	r25, Z+34	; 0x22
    49d0:	a3 a1       	ldd	r26, Z+35	; 0x23
    49d2:	b4 a1       	ldd	r27, Z+36	; 0x24
    49d4:	01 96       	adiw	r24, 0x01	; 1
    49d6:	a1 1d       	adc	r26, r1
    49d8:	b1 1d       	adc	r27, r1
    49da:	2a 81       	ldd	r18, Y+2	; 0x02
    49dc:	3b 81       	ldd	r19, Y+3	; 0x03
    49de:	f9 01       	movw	r30, r18
    49e0:	81 a3       	std	Z+33, r24	; 0x21
    49e2:	92 a3       	std	Z+34, r25	; 0x22
    49e4:	a3 a3       	std	Z+35, r26	; 0x23
    49e6:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    49e8:	1e c0       	rjmp	.+60     	; 0x4a26 <xTaskGenericNotify+0x12c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    49ea:	2a 81       	ldd	r18, Y+2	; 0x02
    49ec:	3b 81       	ldd	r19, Y+3	; 0x03
    49ee:	8f 81       	ldd	r24, Y+7	; 0x07
    49f0:	98 85       	ldd	r25, Y+8	; 0x08
    49f2:	a9 85       	ldd	r26, Y+9	; 0x09
    49f4:	ba 85       	ldd	r27, Y+10	; 0x0a
    49f6:	f9 01       	movw	r30, r18
    49f8:	81 a3       	std	Z+33, r24	; 0x21
    49fa:	92 a3       	std	Z+34, r25	; 0x22
    49fc:	a3 a3       	std	Z+35, r26	; 0x23
    49fe:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    4a00:	12 c0       	rjmp	.+36     	; 0x4a26 <xTaskGenericNotify+0x12c>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    4a02:	8c 81       	ldd	r24, Y+4	; 0x04
    4a04:	82 30       	cpi	r24, 0x02	; 2
    4a06:	61 f0       	breq	.+24     	; 0x4a20 <xTaskGenericNotify+0x126>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4a08:	2a 81       	ldd	r18, Y+2	; 0x02
    4a0a:	3b 81       	ldd	r19, Y+3	; 0x03
    4a0c:	8f 81       	ldd	r24, Y+7	; 0x07
    4a0e:	98 85       	ldd	r25, Y+8	; 0x08
    4a10:	a9 85       	ldd	r26, Y+9	; 0x09
    4a12:	ba 85       	ldd	r27, Y+10	; 0x0a
    4a14:	f9 01       	movw	r30, r18
    4a16:	81 a3       	std	Z+33, r24	; 0x21
    4a18:	92 a3       	std	Z+34, r25	; 0x22
    4a1a:	a3 a3       	std	Z+35, r26	; 0x23
    4a1c:	b4 a3       	std	Z+36, r27	; 0x24
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    4a1e:	03 c0       	rjmp	.+6      	; 0x4a26 <xTaskGenericNotify+0x12c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4a20:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    4a22:	01 c0       	rjmp	.+2      	; 0x4a26 <xTaskGenericNotify+0x12c>

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
    4a24:	00 00       	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    4a26:	8c 81       	ldd	r24, Y+4	; 0x04
    4a28:	81 30       	cpi	r24, 0x01	; 1
    4a2a:	d1 f5       	brne	.+116    	; 0x4aa0 <xTaskGenericNotify+0x1a6>
			{
				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    4a2c:	8a 81       	ldd	r24, Y+2	; 0x02
    4a2e:	9b 81       	ldd	r25, Y+3	; 0x03
    4a30:	02 96       	adiw	r24, 0x02	; 2
    4a32:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    4a36:	8a 81       	ldd	r24, Y+2	; 0x02
    4a38:	9b 81       	ldd	r25, Y+3	; 0x03
    4a3a:	fc 01       	movw	r30, r24
    4a3c:	96 89       	ldd	r25, Z+22	; 0x16
    4a3e:	80 91 4c 05 	lds	r24, 0x054C
    4a42:	89 17       	cp	r24, r25
    4a44:	30 f4       	brcc	.+12     	; 0x4a52 <xTaskGenericNotify+0x158>
    4a46:	8a 81       	ldd	r24, Y+2	; 0x02
    4a48:	9b 81       	ldd	r25, Y+3	; 0x03
    4a4a:	fc 01       	movw	r30, r24
    4a4c:	86 89       	ldd	r24, Z+22	; 0x16
    4a4e:	80 93 4c 05 	sts	0x054C, r24
    4a52:	8a 81       	ldd	r24, Y+2	; 0x02
    4a54:	9b 81       	ldd	r25, Y+3	; 0x03
    4a56:	ac 01       	movw	r20, r24
    4a58:	4e 5f       	subi	r20, 0xFE	; 254
    4a5a:	5f 4f       	sbci	r21, 0xFF	; 255
    4a5c:	8a 81       	ldd	r24, Y+2	; 0x02
    4a5e:	9b 81       	ldd	r25, Y+3	; 0x03
    4a60:	fc 01       	movw	r30, r24
    4a62:	86 89       	ldd	r24, Z+22	; 0x16
    4a64:	28 2f       	mov	r18, r24
    4a66:	30 e0       	ldi	r19, 0x00	; 0
    4a68:	c9 01       	movw	r24, r18
    4a6a:	88 0f       	add	r24, r24
    4a6c:	99 1f       	adc	r25, r25
    4a6e:	88 0f       	add	r24, r24
    4a70:	99 1f       	adc	r25, r25
    4a72:	88 0f       	add	r24, r24
    4a74:	99 1f       	adc	r25, r25
    4a76:	82 0f       	add	r24, r18
    4a78:	93 1f       	adc	r25, r19
    4a7a:	84 50       	subi	r24, 0x04	; 4
    4a7c:	9b 4f       	sbci	r25, 0xFB	; 251
    4a7e:	ba 01       	movw	r22, r20
    4a80:	0e 94 27 10 	call	0x204e	; 0x204e <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4a84:	8a 81       	ldd	r24, Y+2	; 0x02
    4a86:	9b 81       	ldd	r25, Y+3	; 0x03
    4a88:	fc 01       	movw	r30, r24
    4a8a:	26 89       	ldd	r18, Z+22	; 0x16
    4a8c:	80 91 fa 04 	lds	r24, 0x04FA
    4a90:	90 91 fb 04 	lds	r25, 0x04FB
    4a94:	fc 01       	movw	r30, r24
    4a96:	86 89       	ldd	r24, Z+22	; 0x16
    4a98:	82 17       	cp	r24, r18
    4a9a:	10 f4       	brcc	.+4      	; 0x4aa0 <xTaskGenericNotify+0x1a6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    4a9c:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4aa0:	0f 90       	pop	r0
    4aa2:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4aa4:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4aa6:	2d 96       	adiw	r28, 0x0d	; 13
    4aa8:	0f b6       	in	r0, 0x3f	; 63
    4aaa:	f8 94       	cli
    4aac:	de bf       	out	0x3e, r29	; 62
    4aae:	0f be       	out	0x3f, r0	; 63
    4ab0:	cd bf       	out	0x3d, r28	; 61
    4ab2:	df 91       	pop	r29
    4ab4:	cf 91       	pop	r28
    4ab6:	1f 91       	pop	r17
    4ab8:	0f 91       	pop	r16
    4aba:	08 95       	ret

00004abc <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4abc:	ef 92       	push	r14
    4abe:	ff 92       	push	r15
    4ac0:	0f 93       	push	r16
    4ac2:	1f 93       	push	r17
    4ac4:	cf 93       	push	r28
    4ac6:	df 93       	push	r29
    4ac8:	cd b7       	in	r28, 0x3d	; 61
    4aca:	de b7       	in	r29, 0x3e	; 62
    4acc:	60 97       	sbiw	r28, 0x10	; 16
    4ace:	0f b6       	in	r0, 0x3f	; 63
    4ad0:	f8 94       	cli
    4ad2:	de bf       	out	0x3e, r29	; 62
    4ad4:	0f be       	out	0x3f, r0	; 63
    4ad6:	cd bf       	out	0x3d, r28	; 61
    4ad8:	9f 83       	std	Y+7, r25	; 0x07
    4ada:	8e 83       	std	Y+6, r24	; 0x06
    4adc:	48 87       	std	Y+8, r20	; 0x08
    4ade:	59 87       	std	Y+9, r21	; 0x09
    4ae0:	6a 87       	std	Y+10, r22	; 0x0a
    4ae2:	7b 87       	std	Y+11, r23	; 0x0b
    4ae4:	2c 87       	std	Y+12, r18	; 0x0c
    4ae6:	1e 87       	std	Y+14, r17	; 0x0e
    4ae8:	0d 87       	std	Y+13, r16	; 0x0d
    4aea:	f8 8a       	std	Y+16, r15	; 0x10
    4aec:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    4aee:	81 e0       	ldi	r24, 0x01	; 1
    4af0:	89 83       	std	Y+1, r24	; 0x01
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    4af2:	8e 81       	ldd	r24, Y+6	; 0x06
    4af4:	9f 81       	ldd	r25, Y+7	; 0x07
    4af6:	9b 83       	std	Y+3, r25	; 0x03
    4af8:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4afa:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( pulPreviousNotificationValue != NULL )
    4afc:	8d 85       	ldd	r24, Y+13	; 0x0d
    4afe:	9e 85       	ldd	r25, Y+14	; 0x0e
    4b00:	89 2b       	or	r24, r25
    4b02:	71 f0       	breq	.+28     	; 0x4b20 <xTaskGenericNotifyFromISR+0x64>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4b04:	8a 81       	ldd	r24, Y+2	; 0x02
    4b06:	9b 81       	ldd	r25, Y+3	; 0x03
    4b08:	fc 01       	movw	r30, r24
    4b0a:	81 a1       	ldd	r24, Z+33	; 0x21
    4b0c:	92 a1       	ldd	r25, Z+34	; 0x22
    4b0e:	a3 a1       	ldd	r26, Z+35	; 0x23
    4b10:	b4 a1       	ldd	r27, Z+36	; 0x24
    4b12:	2d 85       	ldd	r18, Y+13	; 0x0d
    4b14:	3e 85       	ldd	r19, Y+14	; 0x0e
    4b16:	f9 01       	movw	r30, r18
    4b18:	80 83       	st	Z, r24
    4b1a:	91 83       	std	Z+1, r25	; 0x01
    4b1c:	a2 83       	std	Z+2, r26	; 0x02
    4b1e:	b3 83       	std	Z+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    4b20:	8a 81       	ldd	r24, Y+2	; 0x02
    4b22:	9b 81       	ldd	r25, Y+3	; 0x03
    4b24:	fc 01       	movw	r30, r24
    4b26:	85 a1       	ldd	r24, Z+37	; 0x25
    4b28:	8d 83       	std	Y+5, r24	; 0x05
			pxTCB->eNotifyState = eNotified;
    4b2a:	8a 81       	ldd	r24, Y+2	; 0x02
    4b2c:	9b 81       	ldd	r25, Y+3	; 0x03
    4b2e:	22 e0       	ldi	r18, 0x02	; 2
    4b30:	fc 01       	movw	r30, r24
    4b32:	25 a3       	std	Z+37, r18	; 0x25

			switch( eAction )
    4b34:	8c 85       	ldd	r24, Y+12	; 0x0c
    4b36:	88 2f       	mov	r24, r24
    4b38:	90 e0       	ldi	r25, 0x00	; 0
    4b3a:	82 30       	cpi	r24, 0x02	; 2
    4b3c:	91 05       	cpc	r25, r1
    4b3e:	31 f1       	breq	.+76     	; 0x4b8c <xTaskGenericNotifyFromISR+0xd0>
    4b40:	83 30       	cpi	r24, 0x03	; 3
    4b42:	91 05       	cpc	r25, r1
    4b44:	34 f4       	brge	.+12     	; 0x4b52 <xTaskGenericNotifyFromISR+0x96>
    4b46:	00 97       	sbiw	r24, 0x00	; 0
    4b48:	09 f4       	brne	.+2      	; 0x4b4c <xTaskGenericNotifyFromISR+0x90>
    4b4a:	4f c0       	rjmp	.+158    	; 0x4bea <xTaskGenericNotifyFromISR+0x12e>
    4b4c:	01 97       	sbiw	r24, 0x01	; 1
    4b4e:	39 f0       	breq	.+14     	; 0x4b5e <xTaskGenericNotifyFromISR+0xa2>
    4b50:	4d c0       	rjmp	.+154    	; 0x4bec <xTaskGenericNotifyFromISR+0x130>
    4b52:	83 30       	cpi	r24, 0x03	; 3
    4b54:	91 05       	cpc	r25, r1
    4b56:	61 f1       	breq	.+88     	; 0x4bb0 <xTaskGenericNotifyFromISR+0xf4>
    4b58:	04 97       	sbiw	r24, 0x04	; 4
    4b5a:	b1 f1       	breq	.+108    	; 0x4bc8 <xTaskGenericNotifyFromISR+0x10c>
    4b5c:	47 c0       	rjmp	.+142    	; 0x4bec <xTaskGenericNotifyFromISR+0x130>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4b5e:	8a 81       	ldd	r24, Y+2	; 0x02
    4b60:	9b 81       	ldd	r25, Y+3	; 0x03
    4b62:	fc 01       	movw	r30, r24
    4b64:	21 a1       	ldd	r18, Z+33	; 0x21
    4b66:	32 a1       	ldd	r19, Z+34	; 0x22
    4b68:	43 a1       	ldd	r20, Z+35	; 0x23
    4b6a:	54 a1       	ldd	r21, Z+36	; 0x24
    4b6c:	88 85       	ldd	r24, Y+8	; 0x08
    4b6e:	99 85       	ldd	r25, Y+9	; 0x09
    4b70:	aa 85       	ldd	r26, Y+10	; 0x0a
    4b72:	bb 85       	ldd	r27, Y+11	; 0x0b
    4b74:	82 2b       	or	r24, r18
    4b76:	93 2b       	or	r25, r19
    4b78:	a4 2b       	or	r26, r20
    4b7a:	b5 2b       	or	r27, r21
    4b7c:	2a 81       	ldd	r18, Y+2	; 0x02
    4b7e:	3b 81       	ldd	r19, Y+3	; 0x03
    4b80:	f9 01       	movw	r30, r18
    4b82:	81 a3       	std	Z+33, r24	; 0x21
    4b84:	92 a3       	std	Z+34, r25	; 0x22
    4b86:	a3 a3       	std	Z+35, r26	; 0x23
    4b88:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    4b8a:	30 c0       	rjmp	.+96     	; 0x4bec <xTaskGenericNotifyFromISR+0x130>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4b8c:	8a 81       	ldd	r24, Y+2	; 0x02
    4b8e:	9b 81       	ldd	r25, Y+3	; 0x03
    4b90:	fc 01       	movw	r30, r24
    4b92:	81 a1       	ldd	r24, Z+33	; 0x21
    4b94:	92 a1       	ldd	r25, Z+34	; 0x22
    4b96:	a3 a1       	ldd	r26, Z+35	; 0x23
    4b98:	b4 a1       	ldd	r27, Z+36	; 0x24
    4b9a:	01 96       	adiw	r24, 0x01	; 1
    4b9c:	a1 1d       	adc	r26, r1
    4b9e:	b1 1d       	adc	r27, r1
    4ba0:	2a 81       	ldd	r18, Y+2	; 0x02
    4ba2:	3b 81       	ldd	r19, Y+3	; 0x03
    4ba4:	f9 01       	movw	r30, r18
    4ba6:	81 a3       	std	Z+33, r24	; 0x21
    4ba8:	92 a3       	std	Z+34, r25	; 0x22
    4baa:	a3 a3       	std	Z+35, r26	; 0x23
    4bac:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    4bae:	1e c0       	rjmp	.+60     	; 0x4bec <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4bb0:	2a 81       	ldd	r18, Y+2	; 0x02
    4bb2:	3b 81       	ldd	r19, Y+3	; 0x03
    4bb4:	88 85       	ldd	r24, Y+8	; 0x08
    4bb6:	99 85       	ldd	r25, Y+9	; 0x09
    4bb8:	aa 85       	ldd	r26, Y+10	; 0x0a
    4bba:	bb 85       	ldd	r27, Y+11	; 0x0b
    4bbc:	f9 01       	movw	r30, r18
    4bbe:	81 a3       	std	Z+33, r24	; 0x21
    4bc0:	92 a3       	std	Z+34, r25	; 0x22
    4bc2:	a3 a3       	std	Z+35, r26	; 0x23
    4bc4:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    4bc6:	12 c0       	rjmp	.+36     	; 0x4bec <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    4bc8:	8d 81       	ldd	r24, Y+5	; 0x05
    4bca:	82 30       	cpi	r24, 0x02	; 2
    4bcc:	61 f0       	breq	.+24     	; 0x4be6 <xTaskGenericNotifyFromISR+0x12a>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4bce:	2a 81       	ldd	r18, Y+2	; 0x02
    4bd0:	3b 81       	ldd	r19, Y+3	; 0x03
    4bd2:	88 85       	ldd	r24, Y+8	; 0x08
    4bd4:	99 85       	ldd	r25, Y+9	; 0x09
    4bd6:	aa 85       	ldd	r26, Y+10	; 0x0a
    4bd8:	bb 85       	ldd	r27, Y+11	; 0x0b
    4bda:	f9 01       	movw	r30, r18
    4bdc:	81 a3       	std	Z+33, r24	; 0x21
    4bde:	92 a3       	std	Z+34, r25	; 0x22
    4be0:	a3 a3       	std	Z+35, r26	; 0x23
    4be2:	b4 a3       	std	Z+36, r27	; 0x24
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    4be4:	03 c0       	rjmp	.+6      	; 0x4bec <xTaskGenericNotifyFromISR+0x130>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4be6:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    4be8:	01 c0       	rjmp	.+2      	; 0x4bec <xTaskGenericNotifyFromISR+0x130>

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
    4bea:	00 00       	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    4bec:	8d 81       	ldd	r24, Y+5	; 0x05
    4bee:	81 30       	cpi	r24, 0x01	; 1
    4bf0:	09 f0       	breq	.+2      	; 0x4bf4 <xTaskGenericNotifyFromISR+0x138>
    4bf2:	4e c0       	rjmp	.+156    	; 0x4c90 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4bf4:	80 91 54 05 	lds	r24, 0x0554
    4bf8:	88 23       	and	r24, r24
    4bfa:	69 f5       	brne	.+90     	; 0x4c56 <xTaskGenericNotifyFromISR+0x19a>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    4bfc:	8a 81       	ldd	r24, Y+2	; 0x02
    4bfe:	9b 81       	ldd	r25, Y+3	; 0x03
    4c00:	02 96       	adiw	r24, 0x02	; 2
    4c02:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4c06:	8a 81       	ldd	r24, Y+2	; 0x02
    4c08:	9b 81       	ldd	r25, Y+3	; 0x03
    4c0a:	fc 01       	movw	r30, r24
    4c0c:	96 89       	ldd	r25, Z+22	; 0x16
    4c0e:	80 91 4c 05 	lds	r24, 0x054C
    4c12:	89 17       	cp	r24, r25
    4c14:	30 f4       	brcc	.+12     	; 0x4c22 <xTaskGenericNotifyFromISR+0x166>
    4c16:	8a 81       	ldd	r24, Y+2	; 0x02
    4c18:	9b 81       	ldd	r25, Y+3	; 0x03
    4c1a:	fc 01       	movw	r30, r24
    4c1c:	86 89       	ldd	r24, Z+22	; 0x16
    4c1e:	80 93 4c 05 	sts	0x054C, r24
    4c22:	8a 81       	ldd	r24, Y+2	; 0x02
    4c24:	9b 81       	ldd	r25, Y+3	; 0x03
    4c26:	ac 01       	movw	r20, r24
    4c28:	4e 5f       	subi	r20, 0xFE	; 254
    4c2a:	5f 4f       	sbci	r21, 0xFF	; 255
    4c2c:	8a 81       	ldd	r24, Y+2	; 0x02
    4c2e:	9b 81       	ldd	r25, Y+3	; 0x03
    4c30:	fc 01       	movw	r30, r24
    4c32:	86 89       	ldd	r24, Z+22	; 0x16
    4c34:	28 2f       	mov	r18, r24
    4c36:	30 e0       	ldi	r19, 0x00	; 0
    4c38:	c9 01       	movw	r24, r18
    4c3a:	88 0f       	add	r24, r24
    4c3c:	99 1f       	adc	r25, r25
    4c3e:	88 0f       	add	r24, r24
    4c40:	99 1f       	adc	r25, r25
    4c42:	88 0f       	add	r24, r24
    4c44:	99 1f       	adc	r25, r25
    4c46:	82 0f       	add	r24, r18
    4c48:	93 1f       	adc	r25, r19
    4c4a:	84 50       	subi	r24, 0x04	; 4
    4c4c:	9b 4f       	sbci	r25, 0xFB	; 251
    4c4e:	ba 01       	movw	r22, r20
    4c50:	0e 94 27 10 	call	0x204e	; 0x204e <vListInsertEnd>
    4c54:	08 c0       	rjmp	.+16     	; 0x4c66 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4c56:	8a 81       	ldd	r24, Y+2	; 0x02
    4c58:	9b 81       	ldd	r25, Y+3	; 0x03
    4c5a:	0c 96       	adiw	r24, 0x0c	; 12
    4c5c:	bc 01       	movw	r22, r24
    4c5e:	86 e3       	ldi	r24, 0x36	; 54
    4c60:	95 e0       	ldi	r25, 0x05	; 5
    4c62:	0e 94 27 10 	call	0x204e	; 0x204e <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4c66:	8a 81       	ldd	r24, Y+2	; 0x02
    4c68:	9b 81       	ldd	r25, Y+3	; 0x03
    4c6a:	fc 01       	movw	r30, r24
    4c6c:	26 89       	ldd	r18, Z+22	; 0x16
    4c6e:	80 91 fa 04 	lds	r24, 0x04FA
    4c72:	90 91 fb 04 	lds	r25, 0x04FB
    4c76:	fc 01       	movw	r30, r24
    4c78:	86 89       	ldd	r24, Z+22	; 0x16
    4c7a:	82 17       	cp	r24, r18
    4c7c:	48 f4       	brcc	.+18     	; 0x4c90 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4c7e:	8f 85       	ldd	r24, Y+15	; 0x0f
    4c80:	98 89       	ldd	r25, Y+16	; 0x10
    4c82:	89 2b       	or	r24, r25
    4c84:	29 f0       	breq	.+10     	; 0x4c90 <xTaskGenericNotifyFromISR+0x1d4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4c86:	8f 85       	ldd	r24, Y+15	; 0x0f
    4c88:	98 89       	ldd	r25, Y+16	; 0x10
    4c8a:	21 e0       	ldi	r18, 0x01	; 1
    4c8c:	fc 01       	movw	r30, r24
    4c8e:	20 83       	st	Z, r18
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    4c90:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4c92:	60 96       	adiw	r28, 0x10	; 16
    4c94:	0f b6       	in	r0, 0x3f	; 63
    4c96:	f8 94       	cli
    4c98:	de bf       	out	0x3e, r29	; 62
    4c9a:	0f be       	out	0x3f, r0	; 63
    4c9c:	cd bf       	out	0x3d, r28	; 61
    4c9e:	df 91       	pop	r29
    4ca0:	cf 91       	pop	r28
    4ca2:	1f 91       	pop	r17
    4ca4:	0f 91       	pop	r16
    4ca6:	ff 90       	pop	r15
    4ca8:	ef 90       	pop	r14
    4caa:	08 95       	ret

00004cac <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4cac:	cf 93       	push	r28
    4cae:	df 93       	push	r29
    4cb0:	cd b7       	in	r28, 0x3d	; 61
    4cb2:	de b7       	in	r29, 0x3e	; 62
    4cb4:	28 97       	sbiw	r28, 0x08	; 8
    4cb6:	0f b6       	in	r0, 0x3f	; 63
    4cb8:	f8 94       	cli
    4cba:	de bf       	out	0x3e, r29	; 62
    4cbc:	0f be       	out	0x3f, r0	; 63
    4cbe:	cd bf       	out	0x3d, r28	; 61
    4cc0:	9e 83       	std	Y+6, r25	; 0x06
    4cc2:	8d 83       	std	Y+5, r24	; 0x05
    4cc4:	78 87       	std	Y+8, r23	; 0x08
    4cc6:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    4cc8:	8d 81       	ldd	r24, Y+5	; 0x05
    4cca:	9e 81       	ldd	r25, Y+6	; 0x06
    4ccc:	9a 83       	std	Y+2, r25	; 0x02
    4cce:	89 83       	std	Y+1, r24	; 0x01

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4cd0:	1b 82       	std	Y+3, r1	; 0x03
		{
			eOriginalNotifyState = pxTCB->eNotifyState;
    4cd2:	89 81       	ldd	r24, Y+1	; 0x01
    4cd4:	9a 81       	ldd	r25, Y+2	; 0x02
    4cd6:	fc 01       	movw	r30, r24
    4cd8:	85 a1       	ldd	r24, Z+37	; 0x25
    4cda:	8c 83       	std	Y+4, r24	; 0x04
			pxTCB->eNotifyState = eNotified;
    4cdc:	89 81       	ldd	r24, Y+1	; 0x01
    4cde:	9a 81       	ldd	r25, Y+2	; 0x02
    4ce0:	22 e0       	ldi	r18, 0x02	; 2
    4ce2:	fc 01       	movw	r30, r24
    4ce4:	25 a3       	std	Z+37, r18	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    4ce6:	89 81       	ldd	r24, Y+1	; 0x01
    4ce8:	9a 81       	ldd	r25, Y+2	; 0x02
    4cea:	fc 01       	movw	r30, r24
    4cec:	81 a1       	ldd	r24, Z+33	; 0x21
    4cee:	92 a1       	ldd	r25, Z+34	; 0x22
    4cf0:	a3 a1       	ldd	r26, Z+35	; 0x23
    4cf2:	b4 a1       	ldd	r27, Z+36	; 0x24
    4cf4:	01 96       	adiw	r24, 0x01	; 1
    4cf6:	a1 1d       	adc	r26, r1
    4cf8:	b1 1d       	adc	r27, r1
    4cfa:	29 81       	ldd	r18, Y+1	; 0x01
    4cfc:	3a 81       	ldd	r19, Y+2	; 0x02
    4cfe:	f9 01       	movw	r30, r18
    4d00:	81 a3       	std	Z+33, r24	; 0x21
    4d02:	92 a3       	std	Z+34, r25	; 0x22
    4d04:	a3 a3       	std	Z+35, r26	; 0x23
    4d06:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    4d08:	8c 81       	ldd	r24, Y+4	; 0x04
    4d0a:	81 30       	cpi	r24, 0x01	; 1
    4d0c:	09 f0       	breq	.+2      	; 0x4d10 <vTaskNotifyGiveFromISR+0x64>
    4d0e:	4e c0       	rjmp	.+156    	; 0x4dac <vTaskNotifyGiveFromISR+0x100>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4d10:	80 91 54 05 	lds	r24, 0x0554
    4d14:	88 23       	and	r24, r24
    4d16:	69 f5       	brne	.+90     	; 0x4d72 <vTaskNotifyGiveFromISR+0xc6>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    4d18:	89 81       	ldd	r24, Y+1	; 0x01
    4d1a:	9a 81       	ldd	r25, Y+2	; 0x02
    4d1c:	02 96       	adiw	r24, 0x02	; 2
    4d1e:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4d22:	89 81       	ldd	r24, Y+1	; 0x01
    4d24:	9a 81       	ldd	r25, Y+2	; 0x02
    4d26:	fc 01       	movw	r30, r24
    4d28:	96 89       	ldd	r25, Z+22	; 0x16
    4d2a:	80 91 4c 05 	lds	r24, 0x054C
    4d2e:	89 17       	cp	r24, r25
    4d30:	30 f4       	brcc	.+12     	; 0x4d3e <vTaskNotifyGiveFromISR+0x92>
    4d32:	89 81       	ldd	r24, Y+1	; 0x01
    4d34:	9a 81       	ldd	r25, Y+2	; 0x02
    4d36:	fc 01       	movw	r30, r24
    4d38:	86 89       	ldd	r24, Z+22	; 0x16
    4d3a:	80 93 4c 05 	sts	0x054C, r24
    4d3e:	89 81       	ldd	r24, Y+1	; 0x01
    4d40:	9a 81       	ldd	r25, Y+2	; 0x02
    4d42:	ac 01       	movw	r20, r24
    4d44:	4e 5f       	subi	r20, 0xFE	; 254
    4d46:	5f 4f       	sbci	r21, 0xFF	; 255
    4d48:	89 81       	ldd	r24, Y+1	; 0x01
    4d4a:	9a 81       	ldd	r25, Y+2	; 0x02
    4d4c:	fc 01       	movw	r30, r24
    4d4e:	86 89       	ldd	r24, Z+22	; 0x16
    4d50:	28 2f       	mov	r18, r24
    4d52:	30 e0       	ldi	r19, 0x00	; 0
    4d54:	c9 01       	movw	r24, r18
    4d56:	88 0f       	add	r24, r24
    4d58:	99 1f       	adc	r25, r25
    4d5a:	88 0f       	add	r24, r24
    4d5c:	99 1f       	adc	r25, r25
    4d5e:	88 0f       	add	r24, r24
    4d60:	99 1f       	adc	r25, r25
    4d62:	82 0f       	add	r24, r18
    4d64:	93 1f       	adc	r25, r19
    4d66:	84 50       	subi	r24, 0x04	; 4
    4d68:	9b 4f       	sbci	r25, 0xFB	; 251
    4d6a:	ba 01       	movw	r22, r20
    4d6c:	0e 94 27 10 	call	0x204e	; 0x204e <vListInsertEnd>
    4d70:	08 c0       	rjmp	.+16     	; 0x4d82 <vTaskNotifyGiveFromISR+0xd6>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4d72:	89 81       	ldd	r24, Y+1	; 0x01
    4d74:	9a 81       	ldd	r25, Y+2	; 0x02
    4d76:	0c 96       	adiw	r24, 0x0c	; 12
    4d78:	bc 01       	movw	r22, r24
    4d7a:	86 e3       	ldi	r24, 0x36	; 54
    4d7c:	95 e0       	ldi	r25, 0x05	; 5
    4d7e:	0e 94 27 10 	call	0x204e	; 0x204e <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4d82:	89 81       	ldd	r24, Y+1	; 0x01
    4d84:	9a 81       	ldd	r25, Y+2	; 0x02
    4d86:	fc 01       	movw	r30, r24
    4d88:	26 89       	ldd	r18, Z+22	; 0x16
    4d8a:	80 91 fa 04 	lds	r24, 0x04FA
    4d8e:	90 91 fb 04 	lds	r25, 0x04FB
    4d92:	fc 01       	movw	r30, r24
    4d94:	86 89       	ldd	r24, Z+22	; 0x16
    4d96:	82 17       	cp	r24, r18
    4d98:	48 f4       	brcc	.+18     	; 0x4dac <vTaskNotifyGiveFromISR+0x100>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4d9a:	8f 81       	ldd	r24, Y+7	; 0x07
    4d9c:	98 85       	ldd	r25, Y+8	; 0x08
    4d9e:	89 2b       	or	r24, r25
    4da0:	29 f0       	breq	.+10     	; 0x4dac <vTaskNotifyGiveFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4da2:	8f 81       	ldd	r24, Y+7	; 0x07
    4da4:	98 85       	ldd	r25, Y+8	; 0x08
    4da6:	21 e0       	ldi	r18, 0x01	; 1
    4da8:	fc 01       	movw	r30, r24
    4daa:	20 83       	st	Z, r18
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    4dac:	28 96       	adiw	r28, 0x08	; 8
    4dae:	0f b6       	in	r0, 0x3f	; 63
    4db0:	f8 94       	cli
    4db2:	de bf       	out	0x3e, r29	; 62
    4db4:	0f be       	out	0x3f, r0	; 63
    4db6:	cd bf       	out	0x3d, r28	; 61
    4db8:	df 91       	pop	r29
    4dba:	cf 91       	pop	r28
    4dbc:	08 95       	ret

00004dbe <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    4dbe:	cf 93       	push	r28
    4dc0:	df 93       	push	r29
    4dc2:	00 d0       	rcall	.+0      	; 0x4dc4 <xTaskNotifyStateClear+0x6>
    4dc4:	00 d0       	rcall	.+0      	; 0x4dc6 <xTaskNotifyStateClear+0x8>
    4dc6:	1f 92       	push	r1
    4dc8:	cd b7       	in	r28, 0x3d	; 61
    4dca:	de b7       	in	r29, 0x3e	; 62
    4dcc:	9d 83       	std	Y+5, r25	; 0x05
    4dce:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		pxTCB = ( TCB_t * ) xTask;
    4dd0:	8c 81       	ldd	r24, Y+4	; 0x04
    4dd2:	9d 81       	ldd	r25, Y+5	; 0x05
    4dd4:	9b 83       	std	Y+3, r25	; 0x03
    4dd6:	8a 83       	std	Y+2, r24	; 0x02

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( pxTCB );
    4dd8:	8a 81       	ldd	r24, Y+2	; 0x02
    4dda:	9b 81       	ldd	r25, Y+3	; 0x03
    4ddc:	89 2b       	or	r24, r25
    4dde:	29 f4       	brne	.+10     	; 0x4dea <xTaskNotifyStateClear+0x2c>
    4de0:	80 91 fa 04 	lds	r24, 0x04FA
    4de4:	90 91 fb 04 	lds	r25, 0x04FB
    4de8:	02 c0       	rjmp	.+4      	; 0x4dee <xTaskNotifyStateClear+0x30>
    4dea:	8a 81       	ldd	r24, Y+2	; 0x02
    4dec:	9b 81       	ldd	r25, Y+3	; 0x03
    4dee:	9b 83       	std	Y+3, r25	; 0x03
    4df0:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    4df2:	0f b6       	in	r0, 0x3f	; 63
    4df4:	f8 94       	cli
    4df6:	0f 92       	push	r0
		{
			if( pxTCB->eNotifyState == eNotified )
    4df8:	8a 81       	ldd	r24, Y+2	; 0x02
    4dfa:	9b 81       	ldd	r25, Y+3	; 0x03
    4dfc:	fc 01       	movw	r30, r24
    4dfe:	85 a1       	ldd	r24, Z+37	; 0x25
    4e00:	82 30       	cpi	r24, 0x02	; 2
    4e02:	39 f4       	brne	.+14     	; 0x4e12 <xTaskNotifyStateClear+0x54>
			{
				pxTCB->eNotifyState = eNotWaitingNotification;
    4e04:	8a 81       	ldd	r24, Y+2	; 0x02
    4e06:	9b 81       	ldd	r25, Y+3	; 0x03
    4e08:	fc 01       	movw	r30, r24
    4e0a:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    4e0c:	81 e0       	ldi	r24, 0x01	; 1
    4e0e:	89 83       	std	Y+1, r24	; 0x01
    4e10:	01 c0       	rjmp	.+2      	; 0x4e14 <xTaskNotifyStateClear+0x56>
			}
			else
			{
				xReturn = pdFAIL;
    4e12:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    4e14:	0f 90       	pop	r0
    4e16:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4e18:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4e1a:	0f 90       	pop	r0
    4e1c:	0f 90       	pop	r0
    4e1e:	0f 90       	pop	r0
    4e20:	0f 90       	pop	r0
    4e22:	0f 90       	pop	r0
    4e24:	df 91       	pop	r29
    4e26:	cf 91       	pop	r28
    4e28:	08 95       	ret

00004e2a <config_io_pin>:

st_cmd_t heartbeat_cmd_st; //Receive command for 1 reserved heartbeat mailbox
uint64_t can_send_buffer;


void config_io_pin(uint8_t port, uint8_t port_ch, uint8_t dir){
    4e2a:	cf 93       	push	r28
    4e2c:	df 93       	push	r29
    4e2e:	00 d0       	rcall	.+0      	; 0x4e30 <config_io_pin+0x6>
    4e30:	1f 92       	push	r1
    4e32:	cd b7       	in	r28, 0x3d	; 61
    4e34:	de b7       	in	r29, 0x3e	; 62
    4e36:	89 83       	std	Y+1, r24	; 0x01
    4e38:	6a 83       	std	Y+2, r22	; 0x02
    4e3a:	4b 83       	std	Y+3, r20	; 0x03
	switch(port){
    4e3c:	89 81       	ldd	r24, Y+1	; 0x01
    4e3e:	88 2f       	mov	r24, r24
    4e40:	90 e0       	ldi	r25, 0x00	; 0
    4e42:	81 30       	cpi	r24, 0x01	; 1
    4e44:	91 05       	cpc	r25, r1
    4e46:	79 f1       	breq	.+94     	; 0x4ea6 <config_io_pin+0x7c>
    4e48:	82 30       	cpi	r24, 0x02	; 2
    4e4a:	91 05       	cpc	r25, r1
    4e4c:	09 f4       	brne	.+2      	; 0x4e50 <config_io_pin+0x26>
    4e4e:	53 c0       	rjmp	.+166    	; 0x4ef6 <config_io_pin+0xcc>
    4e50:	89 2b       	or	r24, r25
    4e52:	09 f0       	breq	.+2      	; 0x4e56 <config_io_pin+0x2c>
		break;
		case IO_PORT_D:
		DDRD ^= ((-dir) ^ DDRD) & (1 << port_ch);
		break;
		default:
		break;
    4e54:	78 c0       	rjmp	.+240    	; 0x4f46 <config_io_pin+0x11c>

void config_io_pin(uint8_t port, uint8_t port_ch, uint8_t dir){
	switch(port){
		case IO_PORT_B:
		//Crazy bit trickery that sets the port_ch bit of DDRB to dir
		DDRB ^= ((-dir) ^ DDRB) & (1 << port_ch);
    4e56:	8b 81       	ldd	r24, Y+3	; 0x03
    4e58:	88 2f       	mov	r24, r24
    4e5a:	90 e0       	ldi	r25, 0x00	; 0
    4e5c:	22 27       	eor	r18, r18
    4e5e:	33 27       	eor	r19, r19
    4e60:	28 1b       	sub	r18, r24
    4e62:	39 0b       	sbc	r19, r25
    4e64:	84 e2       	ldi	r24, 0x24	; 36
    4e66:	90 e0       	ldi	r25, 0x00	; 0
    4e68:	fc 01       	movw	r30, r24
    4e6a:	80 81       	ld	r24, Z
    4e6c:	88 2f       	mov	r24, r24
    4e6e:	90 e0       	ldi	r25, 0x00	; 0
    4e70:	28 27       	eor	r18, r24
    4e72:	39 27       	eor	r19, r25
    4e74:	8a 81       	ldd	r24, Y+2	; 0x02
    4e76:	48 2f       	mov	r20, r24
    4e78:	50 e0       	ldi	r21, 0x00	; 0
    4e7a:	81 e0       	ldi	r24, 0x01	; 1
    4e7c:	90 e0       	ldi	r25, 0x00	; 0
    4e7e:	02 c0       	rjmp	.+4      	; 0x4e84 <config_io_pin+0x5a>
    4e80:	88 0f       	add	r24, r24
    4e82:	99 1f       	adc	r25, r25
    4e84:	4a 95       	dec	r20
    4e86:	e2 f7       	brpl	.-8      	; 0x4e80 <config_io_pin+0x56>
    4e88:	a9 01       	movw	r20, r18
    4e8a:	48 23       	and	r20, r24
    4e8c:	59 23       	and	r21, r25
    4e8e:	84 e2       	ldi	r24, 0x24	; 36
    4e90:	90 e0       	ldi	r25, 0x00	; 0
    4e92:	24 e2       	ldi	r18, 0x24	; 36
    4e94:	30 e0       	ldi	r19, 0x00	; 0
    4e96:	f9 01       	movw	r30, r18
    4e98:	20 81       	ld	r18, Z
    4e9a:	32 2f       	mov	r19, r18
    4e9c:	24 2f       	mov	r18, r20
    4e9e:	23 27       	eor	r18, r19
    4ea0:	fc 01       	movw	r30, r24
    4ea2:	20 83       	st	Z, r18
		break;
    4ea4:	50 c0       	rjmp	.+160    	; 0x4f46 <config_io_pin+0x11c>
		case IO_PORT_C:
		DDRC ^= ((-dir) ^ DDRC) & (1 << port_ch);
    4ea6:	8b 81       	ldd	r24, Y+3	; 0x03
    4ea8:	88 2f       	mov	r24, r24
    4eaa:	90 e0       	ldi	r25, 0x00	; 0
    4eac:	22 27       	eor	r18, r18
    4eae:	33 27       	eor	r19, r19
    4eb0:	28 1b       	sub	r18, r24
    4eb2:	39 0b       	sbc	r19, r25
    4eb4:	87 e2       	ldi	r24, 0x27	; 39
    4eb6:	90 e0       	ldi	r25, 0x00	; 0
    4eb8:	fc 01       	movw	r30, r24
    4eba:	80 81       	ld	r24, Z
    4ebc:	88 2f       	mov	r24, r24
    4ebe:	90 e0       	ldi	r25, 0x00	; 0
    4ec0:	28 27       	eor	r18, r24
    4ec2:	39 27       	eor	r19, r25
    4ec4:	8a 81       	ldd	r24, Y+2	; 0x02
    4ec6:	48 2f       	mov	r20, r24
    4ec8:	50 e0       	ldi	r21, 0x00	; 0
    4eca:	81 e0       	ldi	r24, 0x01	; 1
    4ecc:	90 e0       	ldi	r25, 0x00	; 0
    4ece:	02 c0       	rjmp	.+4      	; 0x4ed4 <config_io_pin+0xaa>
    4ed0:	88 0f       	add	r24, r24
    4ed2:	99 1f       	adc	r25, r25
    4ed4:	4a 95       	dec	r20
    4ed6:	e2 f7       	brpl	.-8      	; 0x4ed0 <config_io_pin+0xa6>
    4ed8:	a9 01       	movw	r20, r18
    4eda:	48 23       	and	r20, r24
    4edc:	59 23       	and	r21, r25
    4ede:	87 e2       	ldi	r24, 0x27	; 39
    4ee0:	90 e0       	ldi	r25, 0x00	; 0
    4ee2:	27 e2       	ldi	r18, 0x27	; 39
    4ee4:	30 e0       	ldi	r19, 0x00	; 0
    4ee6:	f9 01       	movw	r30, r18
    4ee8:	20 81       	ld	r18, Z
    4eea:	32 2f       	mov	r19, r18
    4eec:	24 2f       	mov	r18, r20
    4eee:	23 27       	eor	r18, r19
    4ef0:	fc 01       	movw	r30, r24
    4ef2:	20 83       	st	Z, r18
		break;
    4ef4:	28 c0       	rjmp	.+80     	; 0x4f46 <config_io_pin+0x11c>
		case IO_PORT_D:
		DDRD ^= ((-dir) ^ DDRD) & (1 << port_ch);
    4ef6:	8b 81       	ldd	r24, Y+3	; 0x03
    4ef8:	88 2f       	mov	r24, r24
    4efa:	90 e0       	ldi	r25, 0x00	; 0
    4efc:	22 27       	eor	r18, r18
    4efe:	33 27       	eor	r19, r19
    4f00:	28 1b       	sub	r18, r24
    4f02:	39 0b       	sbc	r19, r25
    4f04:	8a e2       	ldi	r24, 0x2A	; 42
    4f06:	90 e0       	ldi	r25, 0x00	; 0
    4f08:	fc 01       	movw	r30, r24
    4f0a:	80 81       	ld	r24, Z
    4f0c:	88 2f       	mov	r24, r24
    4f0e:	90 e0       	ldi	r25, 0x00	; 0
    4f10:	28 27       	eor	r18, r24
    4f12:	39 27       	eor	r19, r25
    4f14:	8a 81       	ldd	r24, Y+2	; 0x02
    4f16:	48 2f       	mov	r20, r24
    4f18:	50 e0       	ldi	r21, 0x00	; 0
    4f1a:	81 e0       	ldi	r24, 0x01	; 1
    4f1c:	90 e0       	ldi	r25, 0x00	; 0
    4f1e:	02 c0       	rjmp	.+4      	; 0x4f24 <config_io_pin+0xfa>
    4f20:	88 0f       	add	r24, r24
    4f22:	99 1f       	adc	r25, r25
    4f24:	4a 95       	dec	r20
    4f26:	e2 f7       	brpl	.-8      	; 0x4f20 <config_io_pin+0xf6>
    4f28:	a9 01       	movw	r20, r18
    4f2a:	48 23       	and	r20, r24
    4f2c:	59 23       	and	r21, r25
    4f2e:	8a e2       	ldi	r24, 0x2A	; 42
    4f30:	90 e0       	ldi	r25, 0x00	; 0
    4f32:	2a e2       	ldi	r18, 0x2A	; 42
    4f34:	30 e0       	ldi	r19, 0x00	; 0
    4f36:	f9 01       	movw	r30, r18
    4f38:	20 81       	ld	r18, Z
    4f3a:	32 2f       	mov	r19, r18
    4f3c:	24 2f       	mov	r18, r20
    4f3e:	23 27       	eor	r18, r19
    4f40:	fc 01       	movw	r30, r24
    4f42:	20 83       	st	Z, r18
		break;
    4f44:	00 00       	nop
		default:
		break;
	}
}
    4f46:	0f 90       	pop	r0
    4f48:	0f 90       	pop	r0
    4f4a:	0f 90       	pop	r0
    4f4c:	df 91       	pop	r29
    4f4e:	cf 91       	pop	r28
    4f50:	08 95       	ret

00004f52 <setup_can_send>:
 * Arguments:
 *  can_send_msg: pointer to can cmd msg struct
 *  can_send_buffer: pointer to buffer to send msg_id from
 *  buffer_len: length of the buffer to send
 */
void setup_can_send(st_cmd_t *can_send_msg, uint8_t *can_send_buffer, uint8_t buffer_len, uint16_t msg_id) {
    4f52:	cf 93       	push	r28
    4f54:	df 93       	push	r29
    4f56:	cd b7       	in	r28, 0x3d	; 61
    4f58:	de b7       	in	r29, 0x3e	; 62
    4f5a:	27 97       	sbiw	r28, 0x07	; 7
    4f5c:	0f b6       	in	r0, 0x3f	; 63
    4f5e:	f8 94       	cli
    4f60:	de bf       	out	0x3e, r29	; 62
    4f62:	0f be       	out	0x3f, r0	; 63
    4f64:	cd bf       	out	0x3d, r28	; 61
    4f66:	9a 83       	std	Y+2, r25	; 0x02
    4f68:	89 83       	std	Y+1, r24	; 0x01
    4f6a:	7c 83       	std	Y+4, r23	; 0x04
    4f6c:	6b 83       	std	Y+3, r22	; 0x03
    4f6e:	4d 83       	std	Y+5, r20	; 0x05
    4f70:	3f 83       	std	Y+7, r19	; 0x07
    4f72:	2e 83       	std	Y+6, r18	; 0x06
	// Populate message object
	can_send_msg->pt_data = &can_send_buffer[0];				// Point to send buffer
    4f74:	89 81       	ldd	r24, Y+1	; 0x01
    4f76:	9a 81       	ldd	r25, Y+2	; 0x02
    4f78:	2b 81       	ldd	r18, Y+3	; 0x03
    4f7a:	3c 81       	ldd	r19, Y+4	; 0x04
    4f7c:	fc 01       	movw	r30, r24
    4f7e:	30 87       	std	Z+8, r19	; 0x08
    4f80:	27 83       	std	Z+7, r18	; 0x07
	can_send_msg->ctrl.ide = 0;									// CAN 2.0A
    4f82:	89 81       	ldd	r24, Y+1	; 0x01
    4f84:	9a 81       	ldd	r25, Y+2	; 0x02
    4f86:	fc 01       	movw	r30, r24
    4f88:	13 86       	std	Z+11, r1	; 0x0b
	can_send_msg->dlc	= buffer_len;							// Data buffer length
    4f8a:	89 81       	ldd	r24, Y+1	; 0x01
    4f8c:	9a 81       	ldd	r25, Y+2	; 0x02
    4f8e:	2d 81       	ldd	r18, Y+5	; 0x05
    4f90:	fc 01       	movw	r30, r24
    4f92:	26 83       	std	Z+6, r18	; 0x06
	can_send_msg->id.std = msg_id;								// Set the receive ID to be the state ID
    4f94:	89 81       	ldd	r24, Y+1	; 0x01
    4f96:	9a 81       	ldd	r25, Y+2	; 0x02
    4f98:	2e 81       	ldd	r18, Y+6	; 0x06
    4f9a:	3f 81       	ldd	r19, Y+7	; 0x07
    4f9c:	fc 01       	movw	r30, r24
    4f9e:	33 83       	std	Z+3, r19	; 0x03
    4fa0:	22 83       	std	Z+2, r18	; 0x02
	can_send_msg->cmd = CMD_TX_DATA;							// Send data
    4fa2:	89 81       	ldd	r24, Y+1	; 0x01
    4fa4:	9a 81       	ldd	r25, Y+2	; 0x02
    4fa6:	22 e0       	ldi	r18, 0x02	; 2
    4fa8:	fc 01       	movw	r30, r24
    4faa:	21 83       	std	Z+1, r18	; 0x01
	
	/* Wait for an open mailbox and bind msg_id to the mailbox when available*/
	while(can_cmd(can_send_msg) != CAN_CMD_ACCEPTED);
    4fac:	00 00       	nop
    4fae:	89 81       	ldd	r24, Y+1	; 0x01
    4fb0:	9a 81       	ldd	r25, Y+2	; 0x02
    4fb2:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <can_cmd>
    4fb6:	88 23       	and	r24, r24
    4fb8:	d1 f7       	brne	.-12     	; 0x4fae <setup_can_send+0x5c>
}
    4fba:	27 96       	adiw	r28, 0x07	; 7
    4fbc:	0f b6       	in	r0, 0x3f	; 63
    4fbe:	f8 94       	cli
    4fc0:	de bf       	out	0x3e, r29	; 62
    4fc2:	0f be       	out	0x3f, r0	; 63
    4fc4:	cd bf       	out	0x3d, r28	; 61
    4fc6:	df 91       	pop	r29
    4fc8:	cf 91       	pop	r28
    4fca:	08 95       	ret

00004fcc <can_tx>:
 *		buf_size, the size of the buffer
 * 
 * Returns:
 *		void	
 */
void can_tx(uint16_t id, uint8_t *buffer, uint8_t buf_size) {
    4fcc:	cf 93       	push	r28
    4fce:	df 93       	push	r29
    4fd0:	cd b7       	in	r28, 0x3d	; 61
    4fd2:	de b7       	in	r29, 0x3e	; 62
    4fd4:	61 97       	sbiw	r28, 0x11	; 17
    4fd6:	0f b6       	in	r0, 0x3f	; 63
    4fd8:	f8 94       	cli
    4fda:	de bf       	out	0x3e, r29	; 62
    4fdc:	0f be       	out	0x3f, r0	; 63
    4fde:	cd bf       	out	0x3d, r28	; 61
    4fe0:	9e 87       	std	Y+14, r25	; 0x0e
    4fe2:	8d 87       	std	Y+13, r24	; 0x0d
    4fe4:	78 8b       	std	Y+16, r23	; 0x10
    4fe6:	6f 87       	std	Y+15, r22	; 0x0f
    4fe8:	49 8b       	std	Y+17, r20	; 0x11
	
	// Message command object
	st_cmd_t can_msg;
	
	// Configure TX mailbox
	can_msg.pt_data = buffer;	// point message object to the data buffer
    4fea:	8f 85       	ldd	r24, Y+15	; 0x0f
    4fec:	98 89       	ldd	r25, Y+16	; 0x10
    4fee:	99 87       	std	Y+9, r25	; 0x09
    4ff0:	88 87       	std	Y+8, r24	; 0x08
	can_msg.ctrl.ide = 0;		// CAN 2.0A
    4ff2:	1c 86       	std	Y+12, r1	; 0x0c
	can_msg.dlc = buf_size;		// Number of data bytes (8 max) requested from remote node
    4ff4:	89 89       	ldd	r24, Y+17	; 0x11
    4ff6:	8f 83       	std	Y+7, r24	; 0x07
	can_msg.id.std = id;		// Message ID
    4ff8:	8d 85       	ldd	r24, Y+13	; 0x0d
    4ffa:	9e 85       	ldd	r25, Y+14	; 0x0e
    4ffc:	9c 83       	std	Y+4, r25	; 0x04
    4ffe:	8b 83       	std	Y+3, r24	; 0x03
	can_msg.cmd = CMD_TX_DATA;	// Transmit data command object
    5000:	82 e0       	ldi	r24, 0x02	; 2
    5002:	8a 83       	std	Y+2, r24	; 0x02

	// Wait for MOb to configure (Must re-configure MOb for every transaction) and send request
	while(can_cmd(&can_msg) != CAN_CMD_ACCEPTED);
    5004:	00 00       	nop
    5006:	ce 01       	movw	r24, r28
    5008:	01 96       	adiw	r24, 0x01	; 1
    500a:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <can_cmd>
    500e:	88 23       	and	r24, r24
    5010:	d1 f7       	brne	.-12     	; 0x5006 <can_tx+0x3a>
	
	// Wait for Tx to complete
	while(can_get_status(&can_msg) == CAN_STATUS_NOT_COMPLETED);
    5012:	00 00       	nop
    5014:	ce 01       	movw	r24, r28
    5016:	01 96       	adiw	r24, 0x01	; 1
    5018:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <can_get_status>
    501c:	81 30       	cpi	r24, 0x01	; 1
    501e:	d1 f3       	breq	.-12     	; 0x5014 <can_tx+0x48>
}
    5020:	61 96       	adiw	r28, 0x11	; 17
    5022:	0f b6       	in	r0, 0x3f	; 63
    5024:	f8 94       	cli
    5026:	de bf       	out	0x3e, r29	; 62
    5028:	0f be       	out	0x3f, r0	; 63
    502a:	cd bf       	out	0x3d, r28	; 61
    502c:	df 91       	pop	r29
    502e:	cf 91       	pop	r28
    5030:	08 95       	ret

00005032 <vLEDFlashTask>:

void vLEDFlashTask(void *pvParameters) {
    5032:	cf 93       	push	r28
    5034:	df 93       	push	r29
    5036:	00 d0       	rcall	.+0      	; 0x5038 <vLEDFlashTask+0x6>
    5038:	cd b7       	in	r28, 0x3d	; 61
    503a:	de b7       	in	r29, 0x3e	; 62
    503c:	9a 83       	std	Y+2, r25	; 0x02
    503e:	89 83       	std	Y+1, r24	; 0x01
	for(;;) {
		PORTC ^= (1 << 0);
    5040:	88 e2       	ldi	r24, 0x28	; 40
    5042:	90 e0       	ldi	r25, 0x00	; 0
    5044:	28 e2       	ldi	r18, 0x28	; 40
    5046:	30 e0       	ldi	r19, 0x00	; 0
    5048:	f9 01       	movw	r30, r18
    504a:	30 81       	ld	r19, Z
    504c:	21 e0       	ldi	r18, 0x01	; 1
    504e:	23 27       	eor	r18, r19
    5050:	fc 01       	movw	r30, r24
    5052:	20 83       	st	Z, r18
		vTaskDelay((TickType_t)500); 
    5054:	84 ef       	ldi	r24, 0xF4	; 244
    5056:	91 e0       	ldi	r25, 0x01	; 1
    5058:	0e 94 a5 1c 	call	0x394a	; 0x394a <vTaskDelay>
	}
    505c:	f1 cf       	rjmp	.-30     	; 0x5040 <vLEDFlashTask+0xe>

0000505e <vHeartbeatTask>:
}

void vHeartbeatTask(void *pvParameters) {
    505e:	cf 93       	push	r28
    5060:	df 93       	push	r29
    5062:	00 d0       	rcall	.+0      	; 0x5064 <vHeartbeatTask+0x6>
    5064:	1f 92       	push	r1
    5066:	cd b7       	in	r28, 0x3d	; 61
    5068:	de b7       	in	r29, 0x3e	; 62
    506a:	9b 83       	std	Y+3, r25	; 0x03
    506c:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t send_data = 0x01;
    506e:	81 e0       	ldi	r24, 0x01	; 1
    5070:	89 83       	std	Y+1, r24	; 0x01
	
	for(;;) {
		can_tx(FSN_HEARTBEAT_ID, &send_data, 1);
    5072:	41 e0       	ldi	r20, 0x01	; 1
    5074:	ce 01       	movw	r24, r28
    5076:	01 96       	adiw	r24, 0x01	; 1
    5078:	bc 01       	movw	r22, r24
    507a:	81 e0       	ldi	r24, 0x01	; 1
    507c:	92 e0       	ldi	r25, 0x02	; 2
    507e:	0e 94 e6 27 	call	0x4fcc	; 0x4fcc <can_tx>
		vTaskDelay((TickType_t)1); 
    5082:	81 e0       	ldi	r24, 0x01	; 1
    5084:	90 e0       	ldi	r25, 0x00	; 0
    5086:	0e 94 a5 1c 	call	0x394a	; 0x394a <vTaskDelay>
	}
    508a:	f3 cf       	rjmp	.-26     	; 0x5072 <vHeartbeatTask+0x14>

0000508c <__tablejump2__>:
    508c:	ee 0f       	add	r30, r30
    508e:	ff 1f       	adc	r31, r31
    5090:	05 90       	lpm	r0, Z+
    5092:	f4 91       	lpm	r31, Z
    5094:	e0 2d       	mov	r30, r0
    5096:	09 94       	ijmp

00005098 <memcpy>:
    5098:	fb 01       	movw	r30, r22
    509a:	dc 01       	movw	r26, r24
    509c:	02 c0       	rjmp	.+4      	; 0x50a2 <memcpy+0xa>
    509e:	01 90       	ld	r0, Z+
    50a0:	0d 92       	st	X+, r0
    50a2:	41 50       	subi	r20, 0x01	; 1
    50a4:	50 40       	sbci	r21, 0x00	; 0
    50a6:	d8 f7       	brcc	.-10     	; 0x509e <memcpy+0x6>
    50a8:	08 95       	ret

000050aa <_exit>:
    50aa:	f8 94       	cli

000050ac <__stop_program>:
    50ac:	ff cf       	rjmp	.-2      	; 0x50ac <__stop_program>
