
FrontSensorModule.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000012  00800100  00005270  00005304  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005270  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000045b  00800112  00800112  00005316  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00005316  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00005348  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000140  00000000  00000000  00005388  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002c40  00000000  00000000  000054c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b21  00000000  00000000  00008108  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000027f5  00000000  00000000  00008c29  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000c64  00000000  00000000  0000b420  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0001012d  00000000  00000000  0000c084  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000195b  00000000  00000000  0001c1b1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000018  00000000  00000000  0001db0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000544c  00000000  00000000  0001db24  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 49 00 	jmp	0x92	; 0x92 <__ctors_end>
       4:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
       8:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
       c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      10:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      14:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      18:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      1c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      20:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      24:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      28:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      2c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      30:	0c 94 07 16 	jmp	0x2c0e	; 0x2c0e <__vector_12>
      34:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      38:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      3c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      40:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      44:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      48:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      4c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      50:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      54:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      58:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      5c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      60:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      64:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      68:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      6c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      70:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      74:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      78:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      7c:	1f 06       	cpc	r1, r31
      7e:	15 07       	cpc	r17, r21
      80:	ff 07       	cpc	r31, r31
      82:	cd 08       	sbc	r12, r13
      84:	50 09       	sbc	r21, r0
      86:	e0 09       	sbc	r30, r0
      88:	7a 0a       	sbc	r7, r26
      8a:	a0 0b       	sbc	r26, r16
      8c:	d3 0c       	add	r13, r3
      8e:	10 0e       	add	r1, r16
      90:	c6 0e       	add	r12, r22

00000092 <__ctors_end>:
      92:	11 24       	eor	r1, r1
      94:	1f be       	out	0x3f, r1	; 63
      96:	cf ef       	ldi	r28, 0xFF	; 255
      98:	d0 e1       	ldi	r29, 0x10	; 16
      9a:	de bf       	out	0x3e, r29	; 62
      9c:	cd bf       	out	0x3d, r28	; 61

0000009e <__do_copy_data>:
      9e:	11 e0       	ldi	r17, 0x01	; 1
      a0:	a0 e0       	ldi	r26, 0x00	; 0
      a2:	b1 e0       	ldi	r27, 0x01	; 1
      a4:	e0 e7       	ldi	r30, 0x70	; 112
      a6:	f2 e5       	ldi	r31, 0x52	; 82
      a8:	02 c0       	rjmp	.+4      	; 0xae <__do_copy_data+0x10>
      aa:	05 90       	lpm	r0, Z+
      ac:	0d 92       	st	X+, r0
      ae:	a2 31       	cpi	r26, 0x12	; 18
      b0:	b1 07       	cpc	r27, r17
      b2:	d9 f7       	brne	.-10     	; 0xaa <__do_copy_data+0xc>

000000b4 <__do_clear_bss>:
      b4:	25 e0       	ldi	r18, 0x05	; 5
      b6:	a2 e1       	ldi	r26, 0x12	; 18
      b8:	b1 e0       	ldi	r27, 0x01	; 1
      ba:	01 c0       	rjmp	.+2      	; 0xbe <.do_clear_bss_start>

000000bc <.do_clear_bss_loop>:
      bc:	1d 92       	st	X+, r1

000000be <.do_clear_bss_start>:
      be:	ad 36       	cpi	r26, 0x6D	; 109
      c0:	b2 07       	cpc	r27, r18
      c2:	e1 f7       	brne	.-8      	; 0xbc <.do_clear_bss_loop>
      c4:	0e 94 66 11 	call	0x22cc	; 0x22cc <main>
      c8:	0c 94 36 29 	jmp	0x526c	; 0x526c <_exit>

000000cc <__bad_interrupt>:
      cc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d0 <adc_read>:
 * Read an ADC channel, blocking until conversion is complete.
 * Arguments:
 *	ch: the channel number to read
 * Returns: the result of the conversion, 8-bit
 */
uint8_t adc_read(uint8_t ch) {
      d0:	cf 93       	push	r28
      d2:	df 93       	push	r29
      d4:	1f 92       	push	r1
      d6:	cd b7       	in	r28, 0x3d	; 61
      d8:	de b7       	in	r29, 0x3e	; 62
      da:	89 83       	std	Y+1, r24	; 0x01
	// Set which channel to read. Leave all ADMUX bits as is except MUX4-0
	// Clear MUX bits
	ADMUX &= 0xE0;
      dc:	8c e7       	ldi	r24, 0x7C	; 124
      de:	90 e0       	ldi	r25, 0x00	; 0
      e0:	2c e7       	ldi	r18, 0x7C	; 124
      e2:	30 e0       	ldi	r19, 0x00	; 0
      e4:	f9 01       	movw	r30, r18
      e6:	20 81       	ld	r18, Z
      e8:	20 7e       	andi	r18, 0xE0	; 224
      ea:	fc 01       	movw	r30, r24
      ec:	20 83       	st	Z, r18
	// Guard against invalid channel
	if(ch > 12) ch = 18; // Read ground
      ee:	89 81       	ldd	r24, Y+1	; 0x01
      f0:	8d 30       	cpi	r24, 0x0D	; 13
      f2:	10 f0       	brcs	.+4      	; 0xf8 <adc_read+0x28>
      f4:	82 e1       	ldi	r24, 0x12	; 18
      f6:	89 83       	std	Y+1, r24	; 0x01
	
	// Set MUX to read channel
	ADMUX |= ch;
      f8:	8c e7       	ldi	r24, 0x7C	; 124
      fa:	90 e0       	ldi	r25, 0x00	; 0
      fc:	2c e7       	ldi	r18, 0x7C	; 124
      fe:	30 e0       	ldi	r19, 0x00	; 0
     100:	f9 01       	movw	r30, r18
     102:	30 81       	ld	r19, Z
     104:	29 81       	ldd	r18, Y+1	; 0x01
     106:	23 2b       	or	r18, r19
     108:	fc 01       	movw	r30, r24
     10a:	20 83       	st	Z, r18
	
	// Set ADC start conversion bit
	ADCSRA |= (1 << ADSC);
     10c:	8a e7       	ldi	r24, 0x7A	; 122
     10e:	90 e0       	ldi	r25, 0x00	; 0
     110:	2a e7       	ldi	r18, 0x7A	; 122
     112:	30 e0       	ldi	r19, 0x00	; 0
     114:	f9 01       	movw	r30, r18
     116:	20 81       	ld	r18, Z
     118:	20 64       	ori	r18, 0x40	; 64
     11a:	fc 01       	movw	r30, r24
     11c:	20 83       	st	Z, r18
	
	// Wait for ADCSRA bit ADSC to go low for data conversion to complete
	while(ADCSRA & (1 << ADSC));
     11e:	00 00       	nop
     120:	8a e7       	ldi	r24, 0x7A	; 122
     122:	90 e0       	ldi	r25, 0x00	; 0
     124:	fc 01       	movw	r30, r24
     126:	80 81       	ld	r24, Z
     128:	88 2f       	mov	r24, r24
     12a:	90 e0       	ldi	r25, 0x00	; 0
     12c:	80 74       	andi	r24, 0x40	; 64
     12e:	99 27       	eor	r25, r25
     130:	89 2b       	or	r24, r25
     132:	b1 f7       	brne	.-20     	; 0x120 <adc_read+0x50>
	
	// Return read value
	return ADCH;
     134:	89 e7       	ldi	r24, 0x79	; 121
     136:	90 e0       	ldi	r25, 0x00	; 0
     138:	fc 01       	movw	r30, r24
     13a:	80 81       	ld	r24, Z
}
     13c:	0f 90       	pop	r0
     13e:	df 91       	pop	r29
     140:	cf 91       	pop	r28
     142:	08 95       	ret

00000144 <config_io_pin>:
 *	port: the port to configure, IO_PORT_B, C, or D
 *  port_ch: the channel to set, 0-7
 *  dir: the direction, IO_DIR_INPUT or IO_DIR_OUTPUT
 * Returns: void
 */
void config_io_pin(uint8_t port, uint8_t port_ch, uint8_t dir) {
     144:	cf 93       	push	r28
     146:	df 93       	push	r29
     148:	00 d0       	rcall	.+0      	; 0x14a <config_io_pin+0x6>
     14a:	1f 92       	push	r1
     14c:	cd b7       	in	r28, 0x3d	; 61
     14e:	de b7       	in	r29, 0x3e	; 62
     150:	89 83       	std	Y+1, r24	; 0x01
     152:	6a 83       	std	Y+2, r22	; 0x02
     154:	4b 83       	std	Y+3, r20	; 0x03
	switch(port){
     156:	89 81       	ldd	r24, Y+1	; 0x01
     158:	88 2f       	mov	r24, r24
     15a:	90 e0       	ldi	r25, 0x00	; 0
     15c:	81 30       	cpi	r24, 0x01	; 1
     15e:	91 05       	cpc	r25, r1
     160:	79 f1       	breq	.+94     	; 0x1c0 <config_io_pin+0x7c>
     162:	82 30       	cpi	r24, 0x02	; 2
     164:	91 05       	cpc	r25, r1
     166:	09 f4       	brne	.+2      	; 0x16a <config_io_pin+0x26>
     168:	53 c0       	rjmp	.+166    	; 0x210 <config_io_pin+0xcc>
     16a:	89 2b       	or	r24, r25
     16c:	09 f0       	breq	.+2      	; 0x170 <config_io_pin+0x2c>
			break;
		case IO_PORTD:
			DDRD ^= ((-dir) ^ DDRD) & (1 << port_ch);
			break;
		default:
			break;
     16e:	78 c0       	rjmp	.+240    	; 0x260 <config_io_pin+0x11c>
void config_io_pin(uint8_t port, uint8_t port_ch, uint8_t dir) {
	switch(port){
		case IO_PORTB:
			// Crazy bit trickery that sets specific bit to value
			// without touching other bits
			DDRB ^= ((-dir) ^ DDRB) & (1 << port_ch);
     170:	8b 81       	ldd	r24, Y+3	; 0x03
     172:	88 2f       	mov	r24, r24
     174:	90 e0       	ldi	r25, 0x00	; 0
     176:	22 27       	eor	r18, r18
     178:	33 27       	eor	r19, r19
     17a:	28 1b       	sub	r18, r24
     17c:	39 0b       	sbc	r19, r25
     17e:	84 e2       	ldi	r24, 0x24	; 36
     180:	90 e0       	ldi	r25, 0x00	; 0
     182:	fc 01       	movw	r30, r24
     184:	80 81       	ld	r24, Z
     186:	88 2f       	mov	r24, r24
     188:	90 e0       	ldi	r25, 0x00	; 0
     18a:	28 27       	eor	r18, r24
     18c:	39 27       	eor	r19, r25
     18e:	8a 81       	ldd	r24, Y+2	; 0x02
     190:	48 2f       	mov	r20, r24
     192:	50 e0       	ldi	r21, 0x00	; 0
     194:	81 e0       	ldi	r24, 0x01	; 1
     196:	90 e0       	ldi	r25, 0x00	; 0
     198:	02 c0       	rjmp	.+4      	; 0x19e <config_io_pin+0x5a>
     19a:	88 0f       	add	r24, r24
     19c:	99 1f       	adc	r25, r25
     19e:	4a 95       	dec	r20
     1a0:	e2 f7       	brpl	.-8      	; 0x19a <config_io_pin+0x56>
     1a2:	a9 01       	movw	r20, r18
     1a4:	48 23       	and	r20, r24
     1a6:	59 23       	and	r21, r25
     1a8:	84 e2       	ldi	r24, 0x24	; 36
     1aa:	90 e0       	ldi	r25, 0x00	; 0
     1ac:	24 e2       	ldi	r18, 0x24	; 36
     1ae:	30 e0       	ldi	r19, 0x00	; 0
     1b0:	f9 01       	movw	r30, r18
     1b2:	20 81       	ld	r18, Z
     1b4:	32 2f       	mov	r19, r18
     1b6:	24 2f       	mov	r18, r20
     1b8:	23 27       	eor	r18, r19
     1ba:	fc 01       	movw	r30, r24
     1bc:	20 83       	st	Z, r18
			break;
     1be:	50 c0       	rjmp	.+160    	; 0x260 <config_io_pin+0x11c>
		case IO_PORTC:
			DDRC ^= ((-dir) ^ DDRC) & (1 << port_ch);
     1c0:	8b 81       	ldd	r24, Y+3	; 0x03
     1c2:	88 2f       	mov	r24, r24
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	22 27       	eor	r18, r18
     1c8:	33 27       	eor	r19, r19
     1ca:	28 1b       	sub	r18, r24
     1cc:	39 0b       	sbc	r19, r25
     1ce:	87 e2       	ldi	r24, 0x27	; 39
     1d0:	90 e0       	ldi	r25, 0x00	; 0
     1d2:	fc 01       	movw	r30, r24
     1d4:	80 81       	ld	r24, Z
     1d6:	88 2f       	mov	r24, r24
     1d8:	90 e0       	ldi	r25, 0x00	; 0
     1da:	28 27       	eor	r18, r24
     1dc:	39 27       	eor	r19, r25
     1de:	8a 81       	ldd	r24, Y+2	; 0x02
     1e0:	48 2f       	mov	r20, r24
     1e2:	50 e0       	ldi	r21, 0x00	; 0
     1e4:	81 e0       	ldi	r24, 0x01	; 1
     1e6:	90 e0       	ldi	r25, 0x00	; 0
     1e8:	02 c0       	rjmp	.+4      	; 0x1ee <config_io_pin+0xaa>
     1ea:	88 0f       	add	r24, r24
     1ec:	99 1f       	adc	r25, r25
     1ee:	4a 95       	dec	r20
     1f0:	e2 f7       	brpl	.-8      	; 0x1ea <config_io_pin+0xa6>
     1f2:	a9 01       	movw	r20, r18
     1f4:	48 23       	and	r20, r24
     1f6:	59 23       	and	r21, r25
     1f8:	87 e2       	ldi	r24, 0x27	; 39
     1fa:	90 e0       	ldi	r25, 0x00	; 0
     1fc:	27 e2       	ldi	r18, 0x27	; 39
     1fe:	30 e0       	ldi	r19, 0x00	; 0
     200:	f9 01       	movw	r30, r18
     202:	20 81       	ld	r18, Z
     204:	32 2f       	mov	r19, r18
     206:	24 2f       	mov	r18, r20
     208:	23 27       	eor	r18, r19
     20a:	fc 01       	movw	r30, r24
     20c:	20 83       	st	Z, r18
			break;
     20e:	28 c0       	rjmp	.+80     	; 0x260 <config_io_pin+0x11c>
		case IO_PORTD:
			DDRD ^= ((-dir) ^ DDRD) & (1 << port_ch);
     210:	8b 81       	ldd	r24, Y+3	; 0x03
     212:	88 2f       	mov	r24, r24
     214:	90 e0       	ldi	r25, 0x00	; 0
     216:	22 27       	eor	r18, r18
     218:	33 27       	eor	r19, r19
     21a:	28 1b       	sub	r18, r24
     21c:	39 0b       	sbc	r19, r25
     21e:	8a e2       	ldi	r24, 0x2A	; 42
     220:	90 e0       	ldi	r25, 0x00	; 0
     222:	fc 01       	movw	r30, r24
     224:	80 81       	ld	r24, Z
     226:	88 2f       	mov	r24, r24
     228:	90 e0       	ldi	r25, 0x00	; 0
     22a:	28 27       	eor	r18, r24
     22c:	39 27       	eor	r19, r25
     22e:	8a 81       	ldd	r24, Y+2	; 0x02
     230:	48 2f       	mov	r20, r24
     232:	50 e0       	ldi	r21, 0x00	; 0
     234:	81 e0       	ldi	r24, 0x01	; 1
     236:	90 e0       	ldi	r25, 0x00	; 0
     238:	02 c0       	rjmp	.+4      	; 0x23e <config_io_pin+0xfa>
     23a:	88 0f       	add	r24, r24
     23c:	99 1f       	adc	r25, r25
     23e:	4a 95       	dec	r20
     240:	e2 f7       	brpl	.-8      	; 0x23a <config_io_pin+0xf6>
     242:	a9 01       	movw	r20, r18
     244:	48 23       	and	r20, r24
     246:	59 23       	and	r21, r25
     248:	8a e2       	ldi	r24, 0x2A	; 42
     24a:	90 e0       	ldi	r25, 0x00	; 0
     24c:	2a e2       	ldi	r18, 0x2A	; 42
     24e:	30 e0       	ldi	r19, 0x00	; 0
     250:	f9 01       	movw	r30, r18
     252:	20 81       	ld	r18, Z
     254:	32 2f       	mov	r19, r18
     256:	24 2f       	mov	r18, r20
     258:	23 27       	eor	r18, r19
     25a:	fc 01       	movw	r30, r24
     25c:	20 83       	st	Z, r18
			break;
     25e:	00 00       	nop
		default:
			break;
	}
}
     260:	0f 90       	pop	r0
     262:	0f 90       	pop	r0
     264:	0f 90       	pop	r0
     266:	df 91       	pop	r29
     268:	cf 91       	pop	r28
     26a:	08 95       	ret

0000026c <set_io_pin>:
 *	port: the port to configure, IO_PORT_B, C, or D
 *  port_ch: the channel to set, 0-7
 *  val: the value, HIGH or LOW
 * Returns: void
 */
void set_io_pin(uint8_t port, uint8_t port_ch, uint8_t val) {
     26c:	cf 93       	push	r28
     26e:	df 93       	push	r29
     270:	00 d0       	rcall	.+0      	; 0x272 <set_io_pin+0x6>
     272:	1f 92       	push	r1
     274:	cd b7       	in	r28, 0x3d	; 61
     276:	de b7       	in	r29, 0x3e	; 62
     278:	89 83       	std	Y+1, r24	; 0x01
     27a:	6a 83       	std	Y+2, r22	; 0x02
     27c:	4b 83       	std	Y+3, r20	; 0x03
	switch(port){
     27e:	89 81       	ldd	r24, Y+1	; 0x01
     280:	88 2f       	mov	r24, r24
     282:	90 e0       	ldi	r25, 0x00	; 0
     284:	81 30       	cpi	r24, 0x01	; 1
     286:	91 05       	cpc	r25, r1
     288:	79 f1       	breq	.+94     	; 0x2e8 <set_io_pin+0x7c>
     28a:	82 30       	cpi	r24, 0x02	; 2
     28c:	91 05       	cpc	r25, r1
     28e:	09 f4       	brne	.+2      	; 0x292 <set_io_pin+0x26>
     290:	53 c0       	rjmp	.+166    	; 0x338 <set_io_pin+0xcc>
     292:	89 2b       	or	r24, r25
     294:	09 f0       	breq	.+2      	; 0x298 <set_io_pin+0x2c>
			break;
		case IO_PORTD:
			PORTD ^= ((-val) ^ PORTD) & (1 << port_ch);
			break;
		default:
			break;
     296:	78 c0       	rjmp	.+240    	; 0x388 <set_io_pin+0x11c>
void set_io_pin(uint8_t port, uint8_t port_ch, uint8_t val) {
	switch(port){
		case IO_PORTB:
			// Crazy bit trickery that sets specific bit to value
			// without touching other bits
			PORTB ^= ((-val) ^ PORTB) & (1 << port_ch);
     298:	8b 81       	ldd	r24, Y+3	; 0x03
     29a:	88 2f       	mov	r24, r24
     29c:	90 e0       	ldi	r25, 0x00	; 0
     29e:	22 27       	eor	r18, r18
     2a0:	33 27       	eor	r19, r19
     2a2:	28 1b       	sub	r18, r24
     2a4:	39 0b       	sbc	r19, r25
     2a6:	85 e2       	ldi	r24, 0x25	; 37
     2a8:	90 e0       	ldi	r25, 0x00	; 0
     2aa:	fc 01       	movw	r30, r24
     2ac:	80 81       	ld	r24, Z
     2ae:	88 2f       	mov	r24, r24
     2b0:	90 e0       	ldi	r25, 0x00	; 0
     2b2:	28 27       	eor	r18, r24
     2b4:	39 27       	eor	r19, r25
     2b6:	8a 81       	ldd	r24, Y+2	; 0x02
     2b8:	48 2f       	mov	r20, r24
     2ba:	50 e0       	ldi	r21, 0x00	; 0
     2bc:	81 e0       	ldi	r24, 0x01	; 1
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	02 c0       	rjmp	.+4      	; 0x2c6 <set_io_pin+0x5a>
     2c2:	88 0f       	add	r24, r24
     2c4:	99 1f       	adc	r25, r25
     2c6:	4a 95       	dec	r20
     2c8:	e2 f7       	brpl	.-8      	; 0x2c2 <set_io_pin+0x56>
     2ca:	a9 01       	movw	r20, r18
     2cc:	48 23       	and	r20, r24
     2ce:	59 23       	and	r21, r25
     2d0:	85 e2       	ldi	r24, 0x25	; 37
     2d2:	90 e0       	ldi	r25, 0x00	; 0
     2d4:	25 e2       	ldi	r18, 0x25	; 37
     2d6:	30 e0       	ldi	r19, 0x00	; 0
     2d8:	f9 01       	movw	r30, r18
     2da:	20 81       	ld	r18, Z
     2dc:	32 2f       	mov	r19, r18
     2de:	24 2f       	mov	r18, r20
     2e0:	23 27       	eor	r18, r19
     2e2:	fc 01       	movw	r30, r24
     2e4:	20 83       	st	Z, r18
			break;
     2e6:	50 c0       	rjmp	.+160    	; 0x388 <set_io_pin+0x11c>
		case IO_PORTC:
			PORTC ^= ((-val) ^ PORTC) & (1 << port_ch);
     2e8:	8b 81       	ldd	r24, Y+3	; 0x03
     2ea:	88 2f       	mov	r24, r24
     2ec:	90 e0       	ldi	r25, 0x00	; 0
     2ee:	22 27       	eor	r18, r18
     2f0:	33 27       	eor	r19, r19
     2f2:	28 1b       	sub	r18, r24
     2f4:	39 0b       	sbc	r19, r25
     2f6:	88 e2       	ldi	r24, 0x28	; 40
     2f8:	90 e0       	ldi	r25, 0x00	; 0
     2fa:	fc 01       	movw	r30, r24
     2fc:	80 81       	ld	r24, Z
     2fe:	88 2f       	mov	r24, r24
     300:	90 e0       	ldi	r25, 0x00	; 0
     302:	28 27       	eor	r18, r24
     304:	39 27       	eor	r19, r25
     306:	8a 81       	ldd	r24, Y+2	; 0x02
     308:	48 2f       	mov	r20, r24
     30a:	50 e0       	ldi	r21, 0x00	; 0
     30c:	81 e0       	ldi	r24, 0x01	; 1
     30e:	90 e0       	ldi	r25, 0x00	; 0
     310:	02 c0       	rjmp	.+4      	; 0x316 <set_io_pin+0xaa>
     312:	88 0f       	add	r24, r24
     314:	99 1f       	adc	r25, r25
     316:	4a 95       	dec	r20
     318:	e2 f7       	brpl	.-8      	; 0x312 <set_io_pin+0xa6>
     31a:	a9 01       	movw	r20, r18
     31c:	48 23       	and	r20, r24
     31e:	59 23       	and	r21, r25
     320:	88 e2       	ldi	r24, 0x28	; 40
     322:	90 e0       	ldi	r25, 0x00	; 0
     324:	28 e2       	ldi	r18, 0x28	; 40
     326:	30 e0       	ldi	r19, 0x00	; 0
     328:	f9 01       	movw	r30, r18
     32a:	20 81       	ld	r18, Z
     32c:	32 2f       	mov	r19, r18
     32e:	24 2f       	mov	r18, r20
     330:	23 27       	eor	r18, r19
     332:	fc 01       	movw	r30, r24
     334:	20 83       	st	Z, r18
			break;
     336:	28 c0       	rjmp	.+80     	; 0x388 <set_io_pin+0x11c>
		case IO_PORTD:
			PORTD ^= ((-val) ^ PORTD) & (1 << port_ch);
     338:	8b 81       	ldd	r24, Y+3	; 0x03
     33a:	88 2f       	mov	r24, r24
     33c:	90 e0       	ldi	r25, 0x00	; 0
     33e:	22 27       	eor	r18, r18
     340:	33 27       	eor	r19, r19
     342:	28 1b       	sub	r18, r24
     344:	39 0b       	sbc	r19, r25
     346:	8b e2       	ldi	r24, 0x2B	; 43
     348:	90 e0       	ldi	r25, 0x00	; 0
     34a:	fc 01       	movw	r30, r24
     34c:	80 81       	ld	r24, Z
     34e:	88 2f       	mov	r24, r24
     350:	90 e0       	ldi	r25, 0x00	; 0
     352:	28 27       	eor	r18, r24
     354:	39 27       	eor	r19, r25
     356:	8a 81       	ldd	r24, Y+2	; 0x02
     358:	48 2f       	mov	r20, r24
     35a:	50 e0       	ldi	r21, 0x00	; 0
     35c:	81 e0       	ldi	r24, 0x01	; 1
     35e:	90 e0       	ldi	r25, 0x00	; 0
     360:	02 c0       	rjmp	.+4      	; 0x366 <set_io_pin+0xfa>
     362:	88 0f       	add	r24, r24
     364:	99 1f       	adc	r25, r25
     366:	4a 95       	dec	r20
     368:	e2 f7       	brpl	.-8      	; 0x362 <set_io_pin+0xf6>
     36a:	a9 01       	movw	r20, r18
     36c:	48 23       	and	r20, r24
     36e:	59 23       	and	r21, r25
     370:	8b e2       	ldi	r24, 0x2B	; 43
     372:	90 e0       	ldi	r25, 0x00	; 0
     374:	2b e2       	ldi	r18, 0x2B	; 43
     376:	30 e0       	ldi	r19, 0x00	; 0
     378:	f9 01       	movw	r30, r18
     37a:	20 81       	ld	r18, Z
     37c:	32 2f       	mov	r19, r18
     37e:	24 2f       	mov	r18, r20
     380:	23 27       	eor	r18, r19
     382:	fc 01       	movw	r30, r24
     384:	20 83       	st	Z, r18
			break;
     386:	00 00       	nop
		default:
			break;
	}
}
     388:	0f 90       	pop	r0
     38a:	0f 90       	pop	r0
     38c:	0f 90       	pop	r0
     38e:	df 91       	pop	r29
     390:	cf 91       	pop	r28
     392:	08 95       	ret

00000394 <can_tx>:
 *		buf_size, the size of the buffer
 * 
 * Returns:
 *		void	
 */
void can_tx(uint16_t id, uint8_t *buffer, uint8_t buf_size) {
     394:	cf 93       	push	r28
     396:	df 93       	push	r29
     398:	cd b7       	in	r28, 0x3d	; 61
     39a:	de b7       	in	r29, 0x3e	; 62
     39c:	61 97       	sbiw	r28, 0x11	; 17
     39e:	0f b6       	in	r0, 0x3f	; 63
     3a0:	f8 94       	cli
     3a2:	de bf       	out	0x3e, r29	; 62
     3a4:	0f be       	out	0x3f, r0	; 63
     3a6:	cd bf       	out	0x3d, r28	; 61
     3a8:	9e 87       	std	Y+14, r25	; 0x0e
     3aa:	8d 87       	std	Y+13, r24	; 0x0d
     3ac:	78 8b       	std	Y+16, r23	; 0x10
     3ae:	6f 87       	std	Y+15, r22	; 0x0f
     3b0:	49 8b       	std	Y+17, r20	; 0x11
	
	// Message command object
	st_cmd_t can_msg;
	
	// Configure TX mailbox
	can_msg.pt_data = buffer;	// point message object to the data buffer
     3b2:	8f 85       	ldd	r24, Y+15	; 0x0f
     3b4:	98 89       	ldd	r25, Y+16	; 0x10
     3b6:	99 87       	std	Y+9, r25	; 0x09
     3b8:	88 87       	std	Y+8, r24	; 0x08
	can_msg.ctrl.ide = 0;		// CAN 2.0A
     3ba:	1c 86       	std	Y+12, r1	; 0x0c
	can_msg.dlc = buf_size;		// Number of data bytes (8 max) requested from remote node
     3bc:	89 89       	ldd	r24, Y+17	; 0x11
     3be:	8f 83       	std	Y+7, r24	; 0x07
	can_msg.id.std = id;		// Message ID
     3c0:	8d 85       	ldd	r24, Y+13	; 0x0d
     3c2:	9e 85       	ldd	r25, Y+14	; 0x0e
     3c4:	9c 83       	std	Y+4, r25	; 0x04
     3c6:	8b 83       	std	Y+3, r24	; 0x03
	can_msg.cmd = CMD_TX_DATA;	// Transmit data command object
     3c8:	82 e0       	ldi	r24, 0x02	; 2
     3ca:	8a 83       	std	Y+2, r24	; 0x02

	// Wait for MOb to configure (Must re-configure MOb for every transaction) and send request
	while(can_cmd(&can_msg) != CAN_CMD_ACCEPTED);
     3cc:	00 00       	nop
     3ce:	ce 01       	movw	r24, r28
     3d0:	01 96       	adiw	r24, 0x01	; 1
     3d2:	0e 94 a0 05 	call	0xb40	; 0xb40 <can_cmd>
     3d6:	88 23       	and	r24, r24
     3d8:	d1 f7       	brne	.-12     	; 0x3ce <can_tx+0x3a>
	
	// Wait for Tx to complete
	while(can_get_status(&can_msg) == CAN_STATUS_NOT_COMPLETED);
     3da:	00 00       	nop
     3dc:	ce 01       	movw	r24, r28
     3de:	01 96       	adiw	r24, 0x01	; 1
     3e0:	0e 94 36 10 	call	0x206c	; 0x206c <can_get_status>
     3e4:	81 30       	cpi	r24, 0x01	; 1
     3e6:	d1 f3       	breq	.-12     	; 0x3dc <can_tx+0x48>
}
     3e8:	61 96       	adiw	r28, 0x11	; 17
     3ea:	0f b6       	in	r0, 0x3f	; 63
     3ec:	f8 94       	cli
     3ee:	de bf       	out	0x3e, r29	; 62
     3f0:	0f be       	out	0x3f, r0	; 63
     3f2:	cd bf       	out	0x3d, r28	; 61
     3f4:	df 91       	pop	r29
     3f6:	cf 91       	pop	r28
     3f8:	08 95       	ret

000003fa <can_rx_sync>:
 *		buf_size, the size of the buffer
 *
 * Returns:
 *		the received array
 */
void can_rx_sync(uint16_t ID, uint8_t *buffer, uint8_t buf_size) {
     3fa:	cf 93       	push	r28
     3fc:	df 93       	push	r29
     3fe:	cd b7       	in	r28, 0x3d	; 61
     400:	de b7       	in	r29, 0x3e	; 62
     402:	61 97       	sbiw	r28, 0x11	; 17
     404:	0f b6       	in	r0, 0x3f	; 63
     406:	f8 94       	cli
     408:	de bf       	out	0x3e, r29	; 62
     40a:	0f be       	out	0x3f, r0	; 63
     40c:	cd bf       	out	0x3d, r28	; 61
     40e:	9e 87       	std	Y+14, r25	; 0x0e
     410:	8d 87       	std	Y+13, r24	; 0x0d
     412:	78 8b       	std	Y+16, r23	; 0x10
     414:	6f 87       	std	Y+15, r22	; 0x0f
     416:	49 8b       	std	Y+17, r20	; 0x11
	// Message command object
	st_cmd_t can_msg;
	
	// Configure TX mailbox
	can_msg.pt_data = buffer;			// point message object to the data buffer
     418:	8f 85       	ldd	r24, Y+15	; 0x0f
     41a:	98 89       	ldd	r25, Y+16	; 0x10
     41c:	99 87       	std	Y+9, r25	; 0x09
     41e:	88 87       	std	Y+8, r24	; 0x08
	can_msg.ctrl.ide = 0;				// CAN 2.0A
     420:	1c 86       	std	Y+12, r1	; 0x0c
	can_msg.dlc = buf_size;				// Number of data bytes (8 max) requested from remote node
     422:	89 89       	ldd	r24, Y+17	; 0x11
     424:	8f 83       	std	Y+7, r24	; 0x07
	can_msg.id.std = ID;				// Message ID
     426:	8d 85       	ldd	r24, Y+13	; 0x0d
     428:	9e 85       	ldd	r25, Y+14	; 0x0e
     42a:	9c 83       	std	Y+4, r25	; 0x04
     42c:	8b 83       	std	Y+3, r24	; 0x03
	can_msg.cmd = CMD_RX_DATA_MASKED;	// Receive data command object
     42e:	88 e0       	ldi	r24, 0x08	; 8
     430:	8a 83       	std	Y+2, r24	; 0x02

	// Wait for MOb to configure (Must re-configure MOb for every transaction) and send request
	while(can_cmd(&can_msg) != CAN_CMD_ACCEPTED);
     432:	00 00       	nop
     434:	ce 01       	movw	r24, r28
     436:	01 96       	adiw	r24, 0x01	; 1
     438:	0e 94 a0 05 	call	0xb40	; 0xb40 <can_cmd>
     43c:	88 23       	and	r24, r24
     43e:	d1 f7       	brne	.-12     	; 0x434 <can_rx_sync+0x3a>
	// Wait for Tx to complete
	while(can_get_status(&can_msg) == CAN_STATUS_NOT_COMPLETED);
     440:	00 00       	nop
     442:	ce 01       	movw	r24, r28
     444:	01 96       	adiw	r24, 0x01	; 1
     446:	0e 94 36 10 	call	0x206c	; 0x206c <can_get_status>
     44a:	81 30       	cpi	r24, 0x01	; 1
     44c:	d1 f3       	breq	.-12     	; 0x442 <can_rx_sync+0x48>
     44e:	61 96       	adiw	r28, 0x11	; 17
     450:	0f b6       	in	r0, 0x3f	; 63
     452:	f8 94       	cli
     454:	de bf       	out	0x3e, r29	; 62
     456:	0f be       	out	0x3f, r0	; 63
     458:	cd bf       	out	0x3d, r28	; 61
     45a:	df 91       	pop	r29
     45c:	cf 91       	pop	r28
     45e:	08 95       	ret

00000460 <can_clear_all_mob>:
//! @param none
//!
//! @return none
//------------------------------------------------------------------------------
void can_clear_all_mob(void)
{
     460:	cf 93       	push	r28
     462:	df 93       	push	r29
     464:	00 d0       	rcall	.+0      	; 0x466 <can_clear_all_mob+0x6>
     466:	1f 92       	push	r1
     468:	cd b7       	in	r28, 0x3d	; 61
     46a:	de b7       	in	r29, 0x3e	; 62
uint8_t  mob_number;
/*
    uint8_t  data_index;
*/

    for (mob_number = 0; mob_number < NB_MOB; mob_number++)
     46c:	19 82       	std	Y+1, r1	; 0x01
     46e:	1d c0       	rjmp	.+58     	; 0x4aa <can_clear_all_mob+0x4a>
    {
        CANPAGE = (mob_number << 4);    //! Page index
     470:	8d ee       	ldi	r24, 0xED	; 237
     472:	90 e0       	ldi	r25, 0x00	; 0
     474:	29 81       	ldd	r18, Y+1	; 0x01
     476:	22 95       	swap	r18
     478:	20 7f       	andi	r18, 0xF0	; 240
     47a:	fc 01       	movw	r30, r24
     47c:	20 83       	st	Z, r18
        Can_clear_mob();                //! All MOb Registers=0
     47e:	8e ee       	ldi	r24, 0xEE	; 238
     480:	90 e0       	ldi	r25, 0x00	; 0
     482:	9b 83       	std	Y+3, r25	; 0x03
     484:	8a 83       	std	Y+2, r24	; 0x02
     486:	09 c0       	rjmp	.+18     	; 0x49a <can_clear_all_mob+0x3a>
     488:	8a 81       	ldd	r24, Y+2	; 0x02
     48a:	9b 81       	ldd	r25, Y+3	; 0x03
     48c:	fc 01       	movw	r30, r24
     48e:	10 82       	st	Z, r1
     490:	8a 81       	ldd	r24, Y+2	; 0x02
     492:	9b 81       	ldd	r25, Y+3	; 0x03
     494:	01 96       	adiw	r24, 0x01	; 1
     496:	9b 83       	std	Y+3, r25	; 0x03
     498:	8a 83       	std	Y+2, r24	; 0x02
     49a:	8a 81       	ldd	r24, Y+2	; 0x02
     49c:	9b 81       	ldd	r25, Y+3	; 0x03
     49e:	88 3f       	cpi	r24, 0xF8	; 248
     4a0:	91 05       	cpc	r25, r1
     4a2:	90 f3       	brcs	.-28     	; 0x488 <can_clear_all_mob+0x28>
uint8_t  mob_number;
/*
    uint8_t  data_index;
*/

    for (mob_number = 0; mob_number < NB_MOB; mob_number++)
     4a4:	89 81       	ldd	r24, Y+1	; 0x01
     4a6:	8f 5f       	subi	r24, 0xFF	; 255
     4a8:	89 83       	std	Y+1, r24	; 0x01
     4aa:	89 81       	ldd	r24, Y+1	; 0x01
     4ac:	86 30       	cpi	r24, 0x06	; 6
     4ae:	00 f3       	brcs	.-64     	; 0x470 <can_clear_all_mob+0x10>
        {
            CANMSG = 0;                 //! MOb data FIFO
        }
*/
    }
}
     4b0:	0f 90       	pop	r0
     4b2:	0f 90       	pop	r0
     4b4:	0f 90       	pop	r0
     4b6:	df 91       	pop	r29
     4b8:	cf 91       	pop	r28
     4ba:	08 95       	ret

000004bc <can_get_mob_free>:
//! @return Handle of MOb.
//!          - MOb[0] upto MOb[LAST_MOB_NB]
//!          - 0xFF if no MOb
//------------------------------------------------------------------------------
uint8_t can_get_mob_free(void)
{
     4bc:	cf 93       	push	r28
     4be:	df 93       	push	r29
     4c0:	00 d0       	rcall	.+0      	; 0x4c2 <can_get_mob_free+0x6>
     4c2:	cd b7       	in	r28, 0x3d	; 61
     4c4:	de b7       	in	r29, 0x3e	; 62
    uint8_t mob_number, page_saved;

    page_saved = CANPAGE;
     4c6:	8d ee       	ldi	r24, 0xED	; 237
     4c8:	90 e0       	ldi	r25, 0x00	; 0
     4ca:	fc 01       	movw	r30, r24
     4cc:	80 81       	ld	r24, Z
     4ce:	8a 83       	std	Y+2, r24	; 0x02
    for (mob_number = 0; mob_number < NB_MOB; mob_number++)
     4d0:	19 82       	std	Y+1, r1	; 0x01
     4d2:	1b c0       	rjmp	.+54     	; 0x50a <can_get_mob_free+0x4e>
    {
        Can_set_mob(mob_number);
     4d4:	8d ee       	ldi	r24, 0xED	; 237
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	29 81       	ldd	r18, Y+1	; 0x01
     4da:	22 95       	swap	r18
     4dc:	20 7f       	andi	r18, 0xF0	; 240
     4de:	fc 01       	movw	r30, r24
     4e0:	20 83       	st	Z, r18
        if ((CANCDMOB & 0xC0) == 0x00) //! Disable configuration
     4e2:	8f ee       	ldi	r24, 0xEF	; 239
     4e4:	90 e0       	ldi	r25, 0x00	; 0
     4e6:	fc 01       	movw	r30, r24
     4e8:	80 81       	ld	r24, Z
     4ea:	88 2f       	mov	r24, r24
     4ec:	90 e0       	ldi	r25, 0x00	; 0
     4ee:	80 7c       	andi	r24, 0xC0	; 192
     4f0:	99 27       	eor	r25, r25
     4f2:	89 2b       	or	r24, r25
     4f4:	39 f4       	brne	.+14     	; 0x504 <can_get_mob_free+0x48>
        {
            CANPAGE = page_saved;
     4f6:	8d ee       	ldi	r24, 0xED	; 237
     4f8:	90 e0       	ldi	r25, 0x00	; 0
     4fa:	2a 81       	ldd	r18, Y+2	; 0x02
     4fc:	fc 01       	movw	r30, r24
     4fe:	20 83       	st	Z, r18
            return (mob_number);
     500:	89 81       	ldd	r24, Y+1	; 0x01
     502:	0c c0       	rjmp	.+24     	; 0x51c <can_get_mob_free+0x60>
uint8_t can_get_mob_free(void)
{
    uint8_t mob_number, page_saved;

    page_saved = CANPAGE;
    for (mob_number = 0; mob_number < NB_MOB; mob_number++)
     504:	89 81       	ldd	r24, Y+1	; 0x01
     506:	8f 5f       	subi	r24, 0xFF	; 255
     508:	89 83       	std	Y+1, r24	; 0x01
     50a:	89 81       	ldd	r24, Y+1	; 0x01
     50c:	86 30       	cpi	r24, 0x06	; 6
     50e:	10 f3       	brcs	.-60     	; 0x4d4 <can_get_mob_free+0x18>
        {
            CANPAGE = page_saved;
            return (mob_number);
        }
    }
    CANPAGE = page_saved;
     510:	8d ee       	ldi	r24, 0xED	; 237
     512:	90 e0       	ldi	r25, 0x00	; 0
     514:	2a 81       	ldd	r18, Y+2	; 0x02
     516:	fc 01       	movw	r30, r24
     518:	20 83       	st	Z, r18
    return (NO_MOB);
     51a:	8f ef       	ldi	r24, 0xFF	; 255
}
     51c:	0f 90       	pop	r0
     51e:	0f 90       	pop	r0
     520:	df 91       	pop	r29
     522:	cf 91       	pop	r28
     524:	08 95       	ret

00000526 <can_get_mob_status>:
//!          -  MOB_CRC_ERROR
//!          -  MOB_STUFF_ERROR
//!          -  MOB_BIT_ERROR
//------------------------------------------------------------------------------
uint8_t can_get_mob_status(void)
{
     526:	cf 93       	push	r28
     528:	df 93       	push	r29
     52a:	00 d0       	rcall	.+0      	; 0x52c <can_get_mob_status+0x6>
     52c:	cd b7       	in	r28, 0x3d	; 61
     52e:	de b7       	in	r29, 0x3e	; 62
    uint8_t mob_status, canstmob_copy;

    // Test if MOb ENABLE or DISABLE
    if ((CANCDMOB & 0xC0) == 0x00) {return(MOB_DISABLE);}
     530:	8f ee       	ldi	r24, 0xEF	; 239
     532:	90 e0       	ldi	r25, 0x00	; 0
     534:	fc 01       	movw	r30, r24
     536:	80 81       	ld	r24, Z
     538:	88 2f       	mov	r24, r24
     53a:	90 e0       	ldi	r25, 0x00	; 0
     53c:	80 7c       	andi	r24, 0xC0	; 192
     53e:	99 27       	eor	r25, r25
     540:	89 2b       	or	r24, r25
     542:	11 f4       	brne	.+4      	; 0x548 <can_get_mob_status+0x22>
     544:	8f ef       	ldi	r24, 0xFF	; 255
     546:	1c c0       	rjmp	.+56     	; 0x580 <can_get_mob_status+0x5a>

    canstmob_copy = CANSTMOB; // Copy for test integrity
     548:	8e ee       	ldi	r24, 0xEE	; 238
     54a:	90 e0       	ldi	r25, 0x00	; 0
     54c:	fc 01       	movw	r30, r24
     54e:	80 81       	ld	r24, Z
     550:	89 83       	std	Y+1, r24	; 0x01

    // If MOb is ENABLE, test if MOb is COMPLETED
    // - MOb Status = 0x20 then MOB_RX_COMPLETED
    // - MOb Status = 0x40 then MOB_TX_COMPLETED
    // - MOb Status = 0xA0 then MOB_RX_COMPLETED_DLCW
    mob_status = canstmob_copy & ((1<<DLCW)|(1<<TXOK)|(1<<RXOK));
     552:	89 81       	ldd	r24, Y+1	; 0x01
     554:	80 7e       	andi	r24, 0xE0	; 224
     556:	8a 83       	std	Y+2, r24	; 0x02
    if ( (mob_status==MOB_RX_COMPLETED) ||   \
     558:	8a 81       	ldd	r24, Y+2	; 0x02
     55a:	80 32       	cpi	r24, 0x20	; 32
     55c:	31 f0       	breq	.+12     	; 0x56a <can_get_mob_status+0x44>
     55e:	8a 81       	ldd	r24, Y+2	; 0x02
     560:	80 34       	cpi	r24, 0x40	; 64
     562:	19 f0       	breq	.+6      	; 0x56a <can_get_mob_status+0x44>
         (mob_status==MOB_TX_COMPLETED) ||   \
     564:	8a 81       	ldd	r24, Y+2	; 0x02
     566:	80 3a       	cpi	r24, 0xA0	; 160
     568:	11 f4       	brne	.+4      	; 0x56e <can_get_mob_status+0x48>
         (mob_status==MOB_RX_COMPLETED_DLCW) ) { return(mob_status); }
     56a:	8a 81       	ldd	r24, Y+2	; 0x02
     56c:	09 c0       	rjmp	.+18     	; 0x580 <can_get_mob_status+0x5a>
    // - MOb Status bit_0 = MOB_ACK_ERROR
    // - MOb Status bit_1 = MOB_FORM_ERROR
    // - MOb Status bit_2 = MOB_CRC_ERROR
    // - MOb Status bit_3 = MOB_STUFF_ERROR
    // - MOb Status bit_4 = MOB_BIT_ERROR
    mob_status = canstmob_copy & ERR_MOB_MSK;
     56e:	89 81       	ldd	r24, Y+1	; 0x01
     570:	8f 71       	andi	r24, 0x1F	; 31
     572:	8a 83       	std	Y+2, r24	; 0x02
    if (mob_status != 0) { return(mob_status); }
     574:	8a 81       	ldd	r24, Y+2	; 0x02
     576:	88 23       	and	r24, r24
     578:	11 f0       	breq	.+4      	; 0x57e <can_get_mob_status+0x58>
     57a:	8a 81       	ldd	r24, Y+2	; 0x02
     57c:	01 c0       	rjmp	.+2      	; 0x580 <can_get_mob_status+0x5a>

    // If CANSTMOB = 0 then MOB_NOT_COMPLETED
    return(MOB_NOT_COMPLETED);
     57e:	80 e0       	ldi	r24, 0x00	; 0
}
     580:	0f 90       	pop	r0
     582:	0f 90       	pop	r0
     584:	df 91       	pop	r29
     586:	cf 91       	pop	r28
     588:	08 95       	ret

0000058a <can_get_data>:
//! @param CAN message data address.
//!
//! @return none.
//------------------------------------------------------------------------------
void can_get_data(uint8_t* p_can_message_data)
{
     58a:	cf 93       	push	r28
     58c:	df 93       	push	r29
     58e:	00 d0       	rcall	.+0      	; 0x590 <can_get_data+0x6>
     590:	1f 92       	push	r1
     592:	cd b7       	in	r28, 0x3d	; 61
     594:	de b7       	in	r29, 0x3e	; 62
     596:	9b 83       	std	Y+3, r25	; 0x03
     598:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data_index;

    for (data_index = 0; data_index < (Can_get_dlc()); data_index++)
     59a:	19 82       	std	Y+1, r1	; 0x01
     59c:	10 c0       	rjmp	.+32     	; 0x5be <can_get_data+0x34>
    {
        *(p_can_message_data + data_index) = CANMSG;
     59e:	89 81       	ldd	r24, Y+1	; 0x01
     5a0:	88 2f       	mov	r24, r24
     5a2:	90 e0       	ldi	r25, 0x00	; 0
     5a4:	2a 81       	ldd	r18, Y+2	; 0x02
     5a6:	3b 81       	ldd	r19, Y+3	; 0x03
     5a8:	82 0f       	add	r24, r18
     5aa:	93 1f       	adc	r25, r19
     5ac:	2a ef       	ldi	r18, 0xFA	; 250
     5ae:	30 e0       	ldi	r19, 0x00	; 0
     5b0:	f9 01       	movw	r30, r18
     5b2:	20 81       	ld	r18, Z
     5b4:	fc 01       	movw	r30, r24
     5b6:	20 83       	st	Z, r18
//------------------------------------------------------------------------------
void can_get_data(uint8_t* p_can_message_data)
{
    uint8_t data_index;

    for (data_index = 0; data_index < (Can_get_dlc()); data_index++)
     5b8:	89 81       	ldd	r24, Y+1	; 0x01
     5ba:	8f 5f       	subi	r24, 0xFF	; 255
     5bc:	89 83       	std	Y+1, r24	; 0x01
     5be:	89 81       	ldd	r24, Y+1	; 0x01
     5c0:	28 2f       	mov	r18, r24
     5c2:	30 e0       	ldi	r19, 0x00	; 0
     5c4:	8f ee       	ldi	r24, 0xEF	; 239
     5c6:	90 e0       	ldi	r25, 0x00	; 0
     5c8:	fc 01       	movw	r30, r24
     5ca:	80 81       	ld	r24, Z
     5cc:	88 2f       	mov	r24, r24
     5ce:	90 e0       	ldi	r25, 0x00	; 0
     5d0:	8f 70       	andi	r24, 0x0F	; 15
     5d2:	99 27       	eor	r25, r25
     5d4:	28 17       	cp	r18, r24
     5d6:	39 07       	cpc	r19, r25
     5d8:	14 f3       	brlt	.-60     	; 0x59e <can_get_data+0x14>
    {
        *(p_can_message_data + data_index) = CANMSG;
    }
}
     5da:	0f 90       	pop	r0
     5dc:	0f 90       	pop	r0
     5de:	0f 90       	pop	r0
     5e0:	df 91       	pop	r29
     5e2:	cf 91       	pop	r28
     5e4:	08 95       	ret

000005e6 <can_auto_baudrate>:
//! @return Baudrate Status
//!         ==0: research of bit timing configuration failed
//!         ==1: baudrate performed
//------------------------------------------------------------------------------
uint8_t can_auto_baudrate (uint8_t mode)
{
     5e6:	cf 93       	push	r28
     5e8:	df 93       	push	r29
     5ea:	cd b7       	in	r28, 0x3d	; 61
     5ec:	de b7       	in	r29, 0x3e	; 62
     5ee:	62 97       	sbiw	r28, 0x12	; 18
     5f0:	0f b6       	in	r0, 0x3f	; 63
     5f2:	f8 94       	cli
     5f4:	de bf       	out	0x3e, r29	; 62
     5f6:	0f be       	out	0x3f, r0	; 63
     5f8:	cd bf       	out	0x3d, r28	; 61
     5fa:	8a 8b       	std	Y+18, r24	; 0x12
    uint8_t  u8_temp0;                               //! Temporary variable
    uint8_t  brp, prs, ntq, phs1, phs2;              //! Bit timing segment variables
    uint8_t  phs1_inc;                               //! Computing needed
    uint8_t  bt_not_found, wait_for_rx, evaluate;    //! Keys for "while()" loops
    uint8_t  try_conf;                               //! Key for configurate CAN
    uint8_t  ovrtim_flag=0;                          //! Timer overflow count
     5fc:	1c 86       	std	Y+12, r1	; 0x0c
    uint16_t conf_index;                             //! Count of bit timing configuration tried
    uint8_t  bt_performed;                           //! Return flag

    //! --- Default setting
    phs1_inc = evaluate = 0;
     5fe:	1a 86       	std	Y+10, r1	; 0x0a
     600:	8a 85       	ldd	r24, Y+10	; 0x0a
     602:	8f 83       	std	Y+7, r24	; 0x07
    bt_performed = 0;
     604:	1f 86       	std	Y+15, r1	; 0x0f
    conf_index = 0;
     606:	1e 86       	std	Y+14, r1	; 0x0e
     608:	1d 86       	std	Y+13, r1	; 0x0d
    bt_not_found = 1;
     60a:	81 e0       	ldi	r24, 0x01	; 1
     60c:	88 87       	std	Y+8, r24	; 0x08

    //! --- Init segment variables with MIN values if mode=0
    //!     or init segment variables with CANBTx if mode=1
    if (mode==0)
     60e:	8a 89       	ldd	r24, Y+18	; 0x12
     610:	88 23       	and	r24, r24
     612:	b1 f4       	brne	.+44     	; 0x640 <can_auto_baudrate+0x5a>
    {
        brp  = BRP_MIN;
     614:	81 e0       	ldi	r24, 0x01	; 1
     616:	8a 83       	std	Y+2, r24	; 0x02
        ntq  = NTQ_MIN;
     618:	88 e0       	ldi	r24, 0x08	; 8
     61a:	8c 83       	std	Y+4, r24	; 0x04
        phs1 = PHS1_MIN;
     61c:	82 e0       	ldi	r24, 0x02	; 2
     61e:	8d 83       	std	Y+5, r24	; 0x05
        phs2 = PHS2_MIN;
     620:	82 e0       	ldi	r24, 0x02	; 2
     622:	8e 83       	std	Y+6, r24	; 0x06
        prs  = ntq - ( phs1 + phs2 + 1 );
     624:	9d 81       	ldd	r25, Y+5	; 0x05
     626:	8e 81       	ldd	r24, Y+6	; 0x06
     628:	89 0f       	add	r24, r25
     62a:	9c 81       	ldd	r25, Y+4	; 0x04
     62c:	29 2f       	mov	r18, r25
     62e:	28 1b       	sub	r18, r24
     630:	82 2f       	mov	r24, r18
     632:	81 50       	subi	r24, 0x01	; 1
     634:	8b 83       	std	Y+3, r24	; 0x03
        try_conf = 1;       //! Try this configuration
     636:	81 e0       	ldi	r24, 0x01	; 1
     638:	8b 87       	std	Y+11, r24	; 0x0b
        wait_for_rx = 1;    //! Enable "while (wait_for_rx ..." loop
     63a:	81 e0       	ldi	r24, 0x01	; 1
     63c:	89 87       	std	Y+9, r24	; 0x09
     63e:	92 c0       	rjmp	.+292    	; 0x764 <can_auto_baudrate+0x17e>
    }
    else //! mode = 1
    {
        brp  = Max ((((CANBT1 &  BRP_MSK) >> 1) +1) , BRP_MIN );
     640:	82 ee       	ldi	r24, 0xE2	; 226
     642:	90 e0       	ldi	r25, 0x00	; 0
     644:	fc 01       	movw	r30, r24
     646:	80 81       	ld	r24, Z
     648:	88 2f       	mov	r24, r24
     64a:	90 e0       	ldi	r25, 0x00	; 0
     64c:	8e 77       	andi	r24, 0x7E	; 126
     64e:	99 27       	eor	r25, r25
     650:	95 95       	asr	r25
     652:	87 95       	ror	r24
     654:	01 96       	adiw	r24, 0x01	; 1
     656:	02 97       	sbiw	r24, 0x02	; 2
     658:	64 f0       	brlt	.+24     	; 0x672 <can_auto_baudrate+0x8c>
     65a:	82 ee       	ldi	r24, 0xE2	; 226
     65c:	90 e0       	ldi	r25, 0x00	; 0
     65e:	fc 01       	movw	r30, r24
     660:	80 81       	ld	r24, Z
     662:	88 2f       	mov	r24, r24
     664:	90 e0       	ldi	r25, 0x00	; 0
     666:	8e 77       	andi	r24, 0x7E	; 126
     668:	99 27       	eor	r25, r25
     66a:	95 95       	asr	r25
     66c:	87 95       	ror	r24
     66e:	8f 5f       	subi	r24, 0xFF	; 255
     670:	01 c0       	rjmp	.+2      	; 0x674 <can_auto_baudrate+0x8e>
     672:	81 e0       	ldi	r24, 0x01	; 1
     674:	8a 83       	std	Y+2, r24	; 0x02
        prs  = Max ((((CANBT2 &  PRS_MSK) >> 1) +1) , PRS_MIN );
     676:	83 ee       	ldi	r24, 0xE3	; 227
     678:	90 e0       	ldi	r25, 0x00	; 0
     67a:	fc 01       	movw	r30, r24
     67c:	80 81       	ld	r24, Z
     67e:	88 2f       	mov	r24, r24
     680:	90 e0       	ldi	r25, 0x00	; 0
     682:	8e 70       	andi	r24, 0x0E	; 14
     684:	99 27       	eor	r25, r25
     686:	95 95       	asr	r25
     688:	87 95       	ror	r24
     68a:	01 96       	adiw	r24, 0x01	; 1
     68c:	02 97       	sbiw	r24, 0x02	; 2
     68e:	64 f0       	brlt	.+24     	; 0x6a8 <can_auto_baudrate+0xc2>
     690:	83 ee       	ldi	r24, 0xE3	; 227
     692:	90 e0       	ldi	r25, 0x00	; 0
     694:	fc 01       	movw	r30, r24
     696:	80 81       	ld	r24, Z
     698:	88 2f       	mov	r24, r24
     69a:	90 e0       	ldi	r25, 0x00	; 0
     69c:	8e 70       	andi	r24, 0x0E	; 14
     69e:	99 27       	eor	r25, r25
     6a0:	95 95       	asr	r25
     6a2:	87 95       	ror	r24
     6a4:	8f 5f       	subi	r24, 0xFF	; 255
     6a6:	01 c0       	rjmp	.+2      	; 0x6aa <can_auto_baudrate+0xc4>
     6a8:	81 e0       	ldi	r24, 0x01	; 1
     6aa:	8b 83       	std	Y+3, r24	; 0x03
        phs1 = Max ((((CANBT3 & PHS1_MSK) >> 1) +1) , PHS1_MIN);
     6ac:	84 ee       	ldi	r24, 0xE4	; 228
     6ae:	90 e0       	ldi	r25, 0x00	; 0
     6b0:	fc 01       	movw	r30, r24
     6b2:	80 81       	ld	r24, Z
     6b4:	88 2f       	mov	r24, r24
     6b6:	90 e0       	ldi	r25, 0x00	; 0
     6b8:	8e 70       	andi	r24, 0x0E	; 14
     6ba:	99 27       	eor	r25, r25
     6bc:	95 95       	asr	r25
     6be:	87 95       	ror	r24
     6c0:	01 96       	adiw	r24, 0x01	; 1
     6c2:	03 97       	sbiw	r24, 0x03	; 3
     6c4:	64 f0       	brlt	.+24     	; 0x6de <can_auto_baudrate+0xf8>
     6c6:	84 ee       	ldi	r24, 0xE4	; 228
     6c8:	90 e0       	ldi	r25, 0x00	; 0
     6ca:	fc 01       	movw	r30, r24
     6cc:	80 81       	ld	r24, Z
     6ce:	88 2f       	mov	r24, r24
     6d0:	90 e0       	ldi	r25, 0x00	; 0
     6d2:	8e 70       	andi	r24, 0x0E	; 14
     6d4:	99 27       	eor	r25, r25
     6d6:	95 95       	asr	r25
     6d8:	87 95       	ror	r24
     6da:	8f 5f       	subi	r24, 0xFF	; 255
     6dc:	01 c0       	rjmp	.+2      	; 0x6e0 <can_auto_baudrate+0xfa>
     6de:	82 e0       	ldi	r24, 0x02	; 2
     6e0:	8d 83       	std	Y+5, r24	; 0x05
        phs2 = Max ((((CANBT3 & PHS2_MSK) >> 4) +1) , PHS2_MIN);
     6e2:	84 ee       	ldi	r24, 0xE4	; 228
     6e4:	90 e0       	ldi	r25, 0x00	; 0
     6e6:	fc 01       	movw	r30, r24
     6e8:	80 81       	ld	r24, Z
     6ea:	88 2f       	mov	r24, r24
     6ec:	90 e0       	ldi	r25, 0x00	; 0
     6ee:	80 77       	andi	r24, 0x70	; 112
     6f0:	99 27       	eor	r25, r25
     6f2:	95 95       	asr	r25
     6f4:	87 95       	ror	r24
     6f6:	95 95       	asr	r25
     6f8:	87 95       	ror	r24
     6fa:	95 95       	asr	r25
     6fc:	87 95       	ror	r24
     6fe:	95 95       	asr	r25
     700:	87 95       	ror	r24
     702:	01 96       	adiw	r24, 0x01	; 1
     704:	03 97       	sbiw	r24, 0x03	; 3
     706:	94 f0       	brlt	.+36     	; 0x72c <can_auto_baudrate+0x146>
     708:	84 ee       	ldi	r24, 0xE4	; 228
     70a:	90 e0       	ldi	r25, 0x00	; 0
     70c:	fc 01       	movw	r30, r24
     70e:	80 81       	ld	r24, Z
     710:	88 2f       	mov	r24, r24
     712:	90 e0       	ldi	r25, 0x00	; 0
     714:	80 77       	andi	r24, 0x70	; 112
     716:	99 27       	eor	r25, r25
     718:	95 95       	asr	r25
     71a:	87 95       	ror	r24
     71c:	95 95       	asr	r25
     71e:	87 95       	ror	r24
     720:	95 95       	asr	r25
     722:	87 95       	ror	r24
     724:	95 95       	asr	r25
     726:	87 95       	ror	r24
     728:	8f 5f       	subi	r24, 0xFF	; 255
     72a:	01 c0       	rjmp	.+2      	; 0x72e <can_auto_baudrate+0x148>
     72c:	82 e0       	ldi	r24, 0x02	; 2
     72e:	8e 83       	std	Y+6, r24	; 0x06
        ntq  = Max ((prs + phs1 + phs2 + 1) , NTQ_MIN);
     730:	8b 81       	ldd	r24, Y+3	; 0x03
     732:	28 2f       	mov	r18, r24
     734:	30 e0       	ldi	r19, 0x00	; 0
     736:	8d 81       	ldd	r24, Y+5	; 0x05
     738:	88 2f       	mov	r24, r24
     73a:	90 e0       	ldi	r25, 0x00	; 0
     73c:	28 0f       	add	r18, r24
     73e:	39 1f       	adc	r19, r25
     740:	8e 81       	ldd	r24, Y+6	; 0x06
     742:	88 2f       	mov	r24, r24
     744:	90 e0       	ldi	r25, 0x00	; 0
     746:	82 0f       	add	r24, r18
     748:	93 1f       	adc	r25, r19
     74a:	01 96       	adiw	r24, 0x01	; 1
     74c:	88 30       	cpi	r24, 0x08	; 8
     74e:	91 05       	cpc	r25, r1
     750:	14 f4       	brge	.+4      	; 0x756 <can_auto_baudrate+0x170>
     752:	88 e0       	ldi	r24, 0x08	; 8
     754:	90 e0       	ldi	r25, 0x00	; 0
     756:	8c 83       	std	Y+4, r24	; 0x04
        phs1_inc = evaluate = 1;   //! To enter in "while (evaluate ..." loop
     758:	81 e0       	ldi	r24, 0x01	; 1
     75a:	8a 87       	std	Y+10, r24	; 0x0a
     75c:	8a 85       	ldd	r24, Y+10	; 0x0a
     75e:	8f 83       	std	Y+7, r24	; 0x07
        try_conf = 0;       //! Look for the next configuration
     760:	1b 86       	std	Y+11, r1	; 0x0b
        wait_for_rx = 0;    //! Skip "while (wait_for_rx ..." loop
     762:	19 86       	std	Y+9, r1	; 0x09
    }

    //! --- Clear all MOb's (CANMSG not cleared)
    for (u8_temp0 = 0; u8_temp0 < NB_MOB; u8_temp0++)
     764:	19 82       	std	Y+1, r1	; 0x01
     766:	1d c0       	rjmp	.+58     	; 0x7a2 <can_auto_baudrate+0x1bc>
    {
        Can_set_mob(u8_temp0);  //! Page index
     768:	8d ee       	ldi	r24, 0xED	; 237
     76a:	90 e0       	ldi	r25, 0x00	; 0
     76c:	29 81       	ldd	r18, Y+1	; 0x01
     76e:	22 95       	swap	r18
     770:	20 7f       	andi	r18, 0xF0	; 240
     772:	fc 01       	movw	r30, r24
     774:	20 83       	st	Z, r18
        Can_clear_mob();        //! All MOb Registers = 0x00
     776:	8e ee       	ldi	r24, 0xEE	; 238
     778:	90 e0       	ldi	r25, 0x00	; 0
     77a:	99 8b       	std	Y+17, r25	; 0x11
     77c:	88 8b       	std	Y+16, r24	; 0x10
     77e:	09 c0       	rjmp	.+18     	; 0x792 <can_auto_baudrate+0x1ac>
     780:	88 89       	ldd	r24, Y+16	; 0x10
     782:	99 89       	ldd	r25, Y+17	; 0x11
     784:	fc 01       	movw	r30, r24
     786:	10 82       	st	Z, r1
     788:	88 89       	ldd	r24, Y+16	; 0x10
     78a:	99 89       	ldd	r25, Y+17	; 0x11
     78c:	01 96       	adiw	r24, 0x01	; 1
     78e:	99 8b       	std	Y+17, r25	; 0x11
     790:	88 8b       	std	Y+16, r24	; 0x10
     792:	88 89       	ldd	r24, Y+16	; 0x10
     794:	99 89       	ldd	r25, Y+17	; 0x11
     796:	88 3f       	cpi	r24, 0xF8	; 248
     798:	91 05       	cpc	r25, r1
     79a:	90 f3       	brcs	.-28     	; 0x780 <can_auto_baudrate+0x19a>
        try_conf = 0;       //! Look for the next configuration
        wait_for_rx = 0;    //! Skip "while (wait_for_rx ..." loop
    }

    //! --- Clear all MOb's (CANMSG not cleared)
    for (u8_temp0 = 0; u8_temp0 < NB_MOB; u8_temp0++)
     79c:	89 81       	ldd	r24, Y+1	; 0x01
     79e:	8f 5f       	subi	r24, 0xFF	; 255
     7a0:	89 83       	std	Y+1, r24	; 0x01
     7a2:	89 81       	ldd	r24, Y+1	; 0x01
     7a4:	86 30       	cpi	r24, 0x06	; 6
     7a6:	00 f3       	brcs	.-64     	; 0x768 <can_auto_baudrate+0x182>
    {
        Can_set_mob(u8_temp0);  //! Page index
        Can_clear_mob();        //! All MOb Registers = 0x00
    }

    while (bt_not_found == 1)
     7a8:	81 c1       	rjmp	.+770    	; 0xaac <can_auto_baudrate+0x4c6>
    {
        if (try_conf == 1)
     7aa:	8b 85       	ldd	r24, Y+11	; 0x0b
     7ac:	81 30       	cpi	r24, 0x01	; 1
     7ae:	09 f0       	breq	.+2      	; 0x7b2 <can_auto_baudrate+0x1cc>
     7b0:	74 c0       	rjmp	.+232    	; 0x89a <can_auto_baudrate+0x2b4>
        {
            Can_reset();
     7b2:	88 ed       	ldi	r24, 0xD8	; 216
     7b4:	90 e0       	ldi	r25, 0x00	; 0
     7b6:	21 e0       	ldi	r18, 0x01	; 1
     7b8:	fc 01       	movw	r30, r24
     7ba:	20 83       	st	Z, r18
            conf_index++;
     7bc:	8d 85       	ldd	r24, Y+13	; 0x0d
     7be:	9e 85       	ldd	r25, Y+14	; 0x0e
     7c0:	01 96       	adiw	r24, 0x01	; 1
     7c2:	9e 87       	std	Y+14, r25	; 0x0e
     7c4:	8d 87       	std	Y+13, r24	; 0x0d
            ovrtim_flag=0;
     7c6:	1c 86       	std	Y+12, r1	; 0x0c

            //! --- CANBTx registers update (sjw = phs2/2, 3 sample points)
            CANBT1 = ((brp-1) << BRP);
     7c8:	82 ee       	ldi	r24, 0xE2	; 226
     7ca:	90 e0       	ldi	r25, 0x00	; 0
     7cc:	2a 81       	ldd	r18, Y+2	; 0x02
     7ce:	21 50       	subi	r18, 0x01	; 1
     7d0:	22 0f       	add	r18, r18
     7d2:	fc 01       	movw	r30, r24
     7d4:	20 83       	st	Z, r18
            CANBT2 = (((phs2 >> 1)-1) << SJW) |((prs-1) << PRS);
     7d6:	83 ee       	ldi	r24, 0xE3	; 227
     7d8:	90 e0       	ldi	r25, 0x00	; 0
     7da:	2e 81       	ldd	r18, Y+6	; 0x06
     7dc:	26 95       	lsr	r18
     7de:	22 2f       	mov	r18, r18
     7e0:	30 e0       	ldi	r19, 0x00	; 0
     7e2:	21 50       	subi	r18, 0x01	; 1
     7e4:	31 09       	sbc	r19, r1
     7e6:	22 0f       	add	r18, r18
     7e8:	33 1f       	adc	r19, r19
     7ea:	22 95       	swap	r18
     7ec:	32 95       	swap	r19
     7ee:	30 7f       	andi	r19, 0xF0	; 240
     7f0:	32 27       	eor	r19, r18
     7f2:	20 7f       	andi	r18, 0xF0	; 240
     7f4:	32 27       	eor	r19, r18
     7f6:	42 2f       	mov	r20, r18
     7f8:	2b 81       	ldd	r18, Y+3	; 0x03
     7fa:	22 2f       	mov	r18, r18
     7fc:	30 e0       	ldi	r19, 0x00	; 0
     7fe:	21 50       	subi	r18, 0x01	; 1
     800:	31 09       	sbc	r19, r1
     802:	22 0f       	add	r18, r18
     804:	33 1f       	adc	r19, r19
     806:	24 2b       	or	r18, r20
     808:	fc 01       	movw	r30, r24
     80a:	20 83       	st	Z, r18
            CANBT3 = (((phs2-1) << PHS2) | ((phs1-1) << PHS1) | (1<<SMP));
     80c:	84 ee       	ldi	r24, 0xE4	; 228
     80e:	90 e0       	ldi	r25, 0x00	; 0
     810:	2e 81       	ldd	r18, Y+6	; 0x06
     812:	22 2f       	mov	r18, r18
     814:	30 e0       	ldi	r19, 0x00	; 0
     816:	21 50       	subi	r18, 0x01	; 1
     818:	31 09       	sbc	r19, r1
     81a:	22 95       	swap	r18
     81c:	32 95       	swap	r19
     81e:	30 7f       	andi	r19, 0xF0	; 240
     820:	32 27       	eor	r19, r18
     822:	20 7f       	andi	r18, 0xF0	; 240
     824:	32 27       	eor	r19, r18
     826:	42 2f       	mov	r20, r18
     828:	2d 81       	ldd	r18, Y+5	; 0x05
     82a:	22 2f       	mov	r18, r18
     82c:	30 e0       	ldi	r19, 0x00	; 0
     82e:	21 50       	subi	r18, 0x01	; 1
     830:	31 09       	sbc	r19, r1
     832:	22 0f       	add	r18, r18
     834:	33 1f       	adc	r19, r19
     836:	24 2b       	or	r18, r20
     838:	21 60       	ori	r18, 0x01	; 1
     83a:	fc 01       	movw	r30, r24
     83c:	20 83       	st	Z, r18

            //! --- Set CAN-Timer - Used for time-out
            //!     There are 641 (0x281) possible evaluations. The first one provides the faster
            //!         the faster bit timing, the last one gives the slower. It is necessary to
            //!         modulate the time-out versus bit timing (0x281>>3=0x50, matching an U8).
            CANTCON = (uint8_t)(conf_index >> 3);
     83e:	85 ee       	ldi	r24, 0xE5	; 229
     840:	90 e0       	ldi	r25, 0x00	; 0
     842:	2d 85       	ldd	r18, Y+13	; 0x0d
     844:	3e 85       	ldd	r19, Y+14	; 0x0e
     846:	36 95       	lsr	r19
     848:	27 95       	ror	r18
     84a:	36 95       	lsr	r19
     84c:	27 95       	ror	r18
     84e:	36 95       	lsr	r19
     850:	27 95       	ror	r18
     852:	fc 01       	movw	r30, r24
     854:	20 83       	st	Z, r18

            //! --- MOb configuration
            Can_set_mob(MOB_0);                 //! Use MOb-0
     856:	8d ee       	ldi	r24, 0xED	; 237
     858:	90 e0       	ldi	r25, 0x00	; 0
     85a:	fc 01       	movw	r30, r24
     85c:	10 82       	st	Z, r1
            CANSTMOB = 0;                       //! Reset MOb status (undone by "Can_reset()")
     85e:	8e ee       	ldi	r24, 0xEE	; 238
     860:	90 e0       	ldi	r25, 0x00	; 0
     862:	fc 01       	movw	r30, r24
     864:	10 82       	st	Z, r1
            CANCDMOB = (MOB_Rx_ENA  << CONMOB); //! MOb 0 in receive mode
     866:	8f ee       	ldi	r24, 0xEF	; 239
     868:	90 e0       	ldi	r25, 0x00	; 0
     86a:	20 e8       	ldi	r18, 0x80	; 128
     86c:	fc 01       	movw	r30, r24
     86e:	20 83       	st	Z, r18

            //! CAN controller configuration
            CANGCON = (1<<LISTEN) | (1<<ENASTB);//! Enable CAN controller in "listen" mode
     870:	88 ed       	ldi	r24, 0xD8	; 216
     872:	90 e0       	ldi	r25, 0x00	; 0
     874:	2a e0       	ldi	r18, 0x0A	; 10
     876:	fc 01       	movw	r30, r24
     878:	20 83       	st	Z, r18
            while ((CANGSTA & (1<<ENFG)) == 0); //! Wait for Enable OK
     87a:	00 00       	nop
     87c:	89 ed       	ldi	r24, 0xD9	; 217
     87e:	90 e0       	ldi	r25, 0x00	; 0
     880:	fc 01       	movw	r30, r24
     882:	80 81       	ld	r24, Z
     884:	88 2f       	mov	r24, r24
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	84 70       	andi	r24, 0x04	; 4
     88a:	99 27       	eor	r25, r25
     88c:	89 2b       	or	r24, r25
     88e:	b1 f3       	breq	.-20     	; 0x87c <can_auto_baudrate+0x296>
            CANGIT = 0xFF;                      //! Reset General errors and OVRTIM flag
     890:	8a ed       	ldi	r24, 0xDA	; 218
     892:	90 e0       	ldi	r25, 0x00	; 0
     894:	2f ef       	ldi	r18, 0xFF	; 255
     896:	fc 01       	movw	r30, r24
     898:	20 83       	st	Z, r18
        //! --- WAIT_FOR_RX LOOP:
        //!     ================
        //!     Try to perform a CAN message reception in "LISTEN" mode without error and
        //!     before a time_out done by CAN-Timer.
        //!     Else gives the hand to "EVALUATE LOOP" to have a new set of bit timing.
        while (wait_for_rx == 1)
     89a:	68 c0       	rjmp	.+208    	; 0x96c <can_auto_baudrate+0x386>
        {
            u8_temp0 = CANSTMOB;
     89c:	8e ee       	ldi	r24, 0xEE	; 238
     89e:	90 e0       	ldi	r25, 0x00	; 0
     8a0:	fc 01       	movw	r30, r24
     8a2:	80 81       	ld	r24, Z
     8a4:	89 83       	std	Y+1, r24	; 0x01
            //! --- RxOK received ?
            if ((u8_temp0 & (1<<RXOK)) != 0)
     8a6:	89 81       	ldd	r24, Y+1	; 0x01
     8a8:	88 2f       	mov	r24, r24
     8aa:	90 e0       	ldi	r25, 0x00	; 0
     8ac:	80 72       	andi	r24, 0x20	; 32
     8ae:	99 27       	eor	r25, r25
     8b0:	89 2b       	or	r24, r25
     8b2:	f1 f0       	breq	.+60     	; 0x8f0 <can_auto_baudrate+0x30a>
            {   //! --- It is the successful output of "can_auto_baudrate" function
                wait_for_rx = 0;    //! Out of "while (wait_for_rx ..." loop
     8b4:	19 86       	std	Y+9, r1	; 0x09
                evaluate = 0;       //! Will skip "while (evaluate ..." loop
     8b6:	1a 86       	std	Y+10, r1	; 0x0a
                bt_not_found = 0;   //! Out of "while (bt_not_found ..." loop
     8b8:	18 86       	std	Y+8, r1	; 0x08
                bt_performed = 1;   //! Return flag = TRUE
     8ba:	81 e0       	ldi	r24, 0x01	; 1
     8bc:	8f 87       	std	Y+15, r24	; 0x0f
                DISABLE_MOB;        //! Disable MOb-0
     8be:	8f ee       	ldi	r24, 0xEF	; 239
     8c0:	90 e0       	ldi	r25, 0x00	; 0
     8c2:	2f ee       	ldi	r18, 0xEF	; 239
     8c4:	30 e0       	ldi	r19, 0x00	; 0
     8c6:	f9 01       	movw	r30, r18
     8c8:	20 81       	ld	r18, Z
     8ca:	2f 73       	andi	r18, 0x3F	; 63
     8cc:	fc 01       	movw	r30, r24
     8ce:	20 83       	st	Z, r18
                CANGCON = 0x00;     //! Disable CAN controller & reset "listen" mode
     8d0:	88 ed       	ldi	r24, 0xD8	; 216
     8d2:	90 e0       	ldi	r25, 0x00	; 0
     8d4:	fc 01       	movw	r30, r24
     8d6:	10 82       	st	Z, r1
                while ((CANGSTA & (1<<ENFG)) != 0); //! Wait for Disable OK
     8d8:	00 00       	nop
     8da:	89 ed       	ldi	r24, 0xD9	; 217
     8dc:	90 e0       	ldi	r25, 0x00	; 0
     8de:	fc 01       	movw	r30, r24
     8e0:	80 81       	ld	r24, Z
     8e2:	88 2f       	mov	r24, r24
     8e4:	90 e0       	ldi	r25, 0x00	; 0
     8e6:	84 70       	andi	r24, 0x04	; 4
     8e8:	99 27       	eor	r25, r25
     8ea:	89 2b       	or	r24, r25
     8ec:	b1 f7       	brne	.-20     	; 0x8da <can_auto_baudrate+0x2f4>
     8ee:	3e c0       	rjmp	.+124    	; 0x96c <can_auto_baudrate+0x386>
            }
             //! --- Else stop if any errors
             else
            {
                //! --- MOb error ?
                if ((u8_temp0 & ((1<<BERR)|(1<<SERR)|(1<<CERR)|(1<<FERR)|(1<<AERR))) !=0)
     8f0:	89 81       	ldd	r24, Y+1	; 0x01
     8f2:	88 2f       	mov	r24, r24
     8f4:	90 e0       	ldi	r25, 0x00	; 0
     8f6:	8f 71       	andi	r24, 0x1F	; 31
     8f8:	99 27       	eor	r25, r25
     8fa:	89 2b       	or	r24, r25
     8fc:	19 f0       	breq	.+6      	; 0x904 <can_auto_baudrate+0x31e>
                {
                    evaluate = 1;       //! Will enter in "while (evaluate ..." loop
     8fe:	81 e0       	ldi	r24, 0x01	; 1
     900:	8a 87       	std	Y+10, r24	; 0x0a
                    wait_for_rx = 0;    //! Out of "while (wait_for_rx ..." loop
     902:	19 86       	std	Y+9, r1	; 0x09
                }

                u8_temp0 = CANGIT;
     904:	8a ed       	ldi	r24, 0xDA	; 218
     906:	90 e0       	ldi	r25, 0x00	; 0
     908:	fc 01       	movw	r30, r24
     90a:	80 81       	ld	r24, Z
     90c:	89 83       	std	Y+1, r24	; 0x01

                //! --- Time_out reached ?
                if ((u8_temp0 & (1<<OVRTIM)) !=0 )
     90e:	89 81       	ldd	r24, Y+1	; 0x01
     910:	88 2f       	mov	r24, r24
     912:	90 e0       	ldi	r25, 0x00	; 0
     914:	80 72       	andi	r24, 0x20	; 32
     916:	99 27       	eor	r25, r25
     918:	89 2b       	or	r24, r25
     91a:	e1 f0       	breq	.+56     	; 0x954 <can_auto_baudrate+0x36e>
                {
                    if (ovrtim_flag==0)
     91c:	8c 85       	ldd	r24, Y+12	; 0x0c
     91e:	88 23       	and	r24, r24
     920:	69 f4       	brne	.+26     	; 0x93c <can_auto_baudrate+0x356>
                    {
                        //! --- First Time_out
                        CANGIT |= (1<<OVRTIM);  // Reset OVRTIM
     922:	8a ed       	ldi	r24, 0xDA	; 218
     924:	90 e0       	ldi	r25, 0x00	; 0
     926:	2a ed       	ldi	r18, 0xDA	; 218
     928:	30 e0       	ldi	r19, 0x00	; 0
     92a:	f9 01       	movw	r30, r18
     92c:	20 81       	ld	r18, Z
     92e:	20 62       	ori	r18, 0x20	; 32
     930:	fc 01       	movw	r30, r24
     932:	20 83       	st	Z, r18
                        ovrtim_flag++;
     934:	8c 85       	ldd	r24, Y+12	; 0x0c
     936:	8f 5f       	subi	r24, 0xFF	; 255
     938:	8c 87       	std	Y+12, r24	; 0x0c
     93a:	0c c0       	rjmp	.+24     	; 0x954 <can_auto_baudrate+0x36e>
                    }
                    else
                    {
                        //! --- Second Time_out
                        CANGIT |= (1<<OVRTIM);  // Reset OVRTIM
     93c:	8a ed       	ldi	r24, 0xDA	; 218
     93e:	90 e0       	ldi	r25, 0x00	; 0
     940:	2a ed       	ldi	r18, 0xDA	; 218
     942:	30 e0       	ldi	r19, 0x00	; 0
     944:	f9 01       	movw	r30, r18
     946:	20 81       	ld	r18, Z
     948:	20 62       	ori	r18, 0x20	; 32
     94a:	fc 01       	movw	r30, r24
     94c:	20 83       	st	Z, r18
                        evaluate = 1;           //! Will enter in "while (evaluate ..." loop
     94e:	81 e0       	ldi	r24, 0x01	; 1
     950:	8a 87       	std	Y+10, r24	; 0x0a
                        wait_for_rx = 0;        //! Out of "while (wait_for_rx ..." loop
     952:	19 86       	std	Y+9, r1	; 0x09
                    }
                }

                //! --- General error ?
                if ((u8_temp0 & ((1<<SERG)|(1<<CERG)|(1<<FERG)|(1<<AERG))) !=0)
     954:	89 81       	ldd	r24, Y+1	; 0x01
     956:	88 2f       	mov	r24, r24
     958:	90 e0       	ldi	r25, 0x00	; 0
     95a:	8f 70       	andi	r24, 0x0F	; 15
     95c:	99 27       	eor	r25, r25
     95e:	89 2b       	or	r24, r25
     960:	29 f0       	breq	.+10     	; 0x96c <can_auto_baudrate+0x386>
                {
                    evaluate = 1;       //! Will enter in "while (evaluate ..." loop
     962:	81 e0       	ldi	r24, 0x01	; 1
     964:	8a 87       	std	Y+10, r24	; 0x0a
                    wait_for_rx = 0;    //! Out of "while (wait_for_rx ..." loop
     966:	19 86       	std	Y+9, r1	; 0x09
                    try_conf = 1;       //! Try this configuration
     968:	81 e0       	ldi	r24, 0x01	; 1
     96a:	8b 87       	std	Y+11, r24	; 0x0b
        //! --- WAIT_FOR_RX LOOP:
        //!     ================
        //!     Try to perform a CAN message reception in "LISTEN" mode without error and
        //!     before a time_out done by CAN-Timer.
        //!     Else gives the hand to "EVALUATE LOOP" to have a new set of bit timing.
        while (wait_for_rx == 1)
     96c:	89 85       	ldd	r24, Y+9	; 0x09
     96e:	81 30       	cpi	r24, 0x01	; 1
     970:	09 f4       	brne	.+2      	; 0x974 <can_auto_baudrate+0x38e>
     972:	94 cf       	rjmp	.-216    	; 0x89c <can_auto_baudrate+0x2b6>
        //!     then Phase2=Phase1 and if Phase1>5, Phase1 can be equal to Phase2 or
        //!     Phase2+1. After this, the number of TQ is increased up to its high
        //!     limit and after it is the Prescaler. During the computing high (80%)
        //!     and low (75%) limits of sampling point location are tested. SJW and
        //!     the number of sampling points are not calculated in this loop.
        while (evaluate == 1)
     974:	97 c0       	rjmp	.+302    	; 0xaa4 <can_auto_baudrate+0x4be>
        {
            if (phs1_inc != 0) phs1++;
     976:	8f 81       	ldd	r24, Y+7	; 0x07
     978:	88 23       	and	r24, r24
     97a:	19 f0       	breq	.+6      	; 0x982 <can_auto_baudrate+0x39c>
     97c:	8d 81       	ldd	r24, Y+5	; 0x05
     97e:	8f 5f       	subi	r24, 0xFF	; 255
     980:	8d 83       	std	Y+5, r24	; 0x05
            phs1_inc = 1;
     982:	81 e0       	ldi	r24, 0x01	; 1
     984:	8f 83       	std	Y+7, r24	; 0x07

            // --- The following test takes into account the previous incrementation of phs1
            if ((phs1 > PHS1_MAX) && (phs2 >= PHS2_MAX))
     986:	8d 81       	ldd	r24, Y+5	; 0x05
     988:	89 30       	cpi	r24, 0x09	; 9
     98a:	a0 f1       	brcs	.+104    	; 0x9f4 <can_auto_baudrate+0x40e>
     98c:	8e 81       	ldd	r24, Y+6	; 0x06
     98e:	88 30       	cpi	r24, 0x08	; 8
     990:	88 f1       	brcs	.+98     	; 0x9f4 <can_auto_baudrate+0x40e>
            {
                phs1 = PHS1_MIN;
     992:	82 e0       	ldi	r24, 0x02	; 2
     994:	8d 83       	std	Y+5, r24	; 0x05
                phs2 = PHS2_MIN;
     996:	82 e0       	ldi	r24, 0x02	; 2
     998:	8e 83       	std	Y+6, r24	; 0x06
                phs1_inc = 0;
     99a:	1f 82       	std	Y+7, r1	; 0x07
                if (ntq != NTQ_MAX) ntq++;
     99c:	8c 81       	ldd	r24, Y+4	; 0x04
     99e:	89 31       	cpi	r24, 0x19	; 25
     9a0:	21 f0       	breq	.+8      	; 0x9aa <can_auto_baudrate+0x3c4>
     9a2:	8c 81       	ldd	r24, Y+4	; 0x04
     9a4:	8f 5f       	subi	r24, 0xFF	; 255
     9a6:	8c 83       	std	Y+4, r24	; 0x04
     9a8:	24 c0       	rjmp	.+72     	; 0x9f2 <can_auto_baudrate+0x40c>
                else
                {
                    ntq = NTQ_MIN;
     9aa:	88 e0       	ldi	r24, 0x08	; 8
     9ac:	8c 83       	std	Y+4, r24	; 0x04
                    if (brp != BRP_MAX) brp++;
     9ae:	8a 81       	ldd	r24, Y+2	; 0x02
     9b0:	80 34       	cpi	r24, 0x40	; 64
     9b2:	21 f0       	breq	.+8      	; 0x9bc <can_auto_baudrate+0x3d6>
     9b4:	8a 81       	ldd	r24, Y+2	; 0x02
     9b6:	8f 5f       	subi	r24, 0xFF	; 255
     9b8:	8a 83       	std	Y+2, r24	; 0x02
     9ba:	1b c0       	rjmp	.+54     	; 0x9f2 <can_auto_baudrate+0x40c>
                    else
                    {
                        //! --- It is the failing of "can_auto_baudrate" function
                        evaluate = 0;       //! Out of "while (evaluate ..." loop
     9bc:	1a 86       	std	Y+10, r1	; 0x0a
                        bt_performed = 0;   //! Return flag = FALSE
     9be:	1f 86       	std	Y+15, r1	; 0x0f
                        bt_not_found = 0;   //! Out of "while (bt_not_found ..." loop
     9c0:	18 86       	std	Y+8, r1	; 0x08
                        DISABLE_MOB;        //! Disable MOb-0
     9c2:	8f ee       	ldi	r24, 0xEF	; 239
     9c4:	90 e0       	ldi	r25, 0x00	; 0
     9c6:	2f ee       	ldi	r18, 0xEF	; 239
     9c8:	30 e0       	ldi	r19, 0x00	; 0
     9ca:	f9 01       	movw	r30, r18
     9cc:	20 81       	ld	r18, Z
     9ce:	2f 73       	andi	r18, 0x3F	; 63
     9d0:	fc 01       	movw	r30, r24
     9d2:	20 83       	st	Z, r18
                        CANGCON = 0x00;     //! Disable CAN controller & reset "listen" mode
     9d4:	88 ed       	ldi	r24, 0xD8	; 216
     9d6:	90 e0       	ldi	r25, 0x00	; 0
     9d8:	fc 01       	movw	r30, r24
     9da:	10 82       	st	Z, r1
                        while ((CANGSTA & (1<<ENFG)) != 0); //! Wait for Disable OK
     9dc:	00 00       	nop
     9de:	89 ed       	ldi	r24, 0xD9	; 217
     9e0:	90 e0       	ldi	r25, 0x00	; 0
     9e2:	fc 01       	movw	r30, r24
     9e4:	80 81       	ld	r24, Z
     9e6:	88 2f       	mov	r24, r24
     9e8:	90 e0       	ldi	r25, 0x00	; 0
     9ea:	84 70       	andi	r24, 0x04	; 4
     9ec:	99 27       	eor	r25, r25
     9ee:	89 2b       	or	r24, r25
     9f0:	b1 f7       	brne	.-20     	; 0x9de <can_auto_baudrate+0x3f8>
            if ((phs1 > PHS1_MAX) && (phs2 >= PHS2_MAX))
            {
                phs1 = PHS1_MIN;
                phs2 = PHS2_MIN;
                phs1_inc = 0;
                if (ntq != NTQ_MAX) ntq++;
     9f2:	58 c0       	rjmp	.+176    	; 0xaa4 <can_auto_baudrate+0x4be>
                }
            }
            else    // if (phs1 > PHS1_MAX ...
            {
                //! --- If psh1 > 5 then phs1 =phs2 or =phs2+1, else phs1=phs2
                if (phs1>5)
     9f4:	8d 81       	ldd	r24, Y+5	; 0x05
     9f6:	86 30       	cpi	r24, 0x06	; 6
     9f8:	80 f0       	brcs	.+32     	; 0xa1a <can_auto_baudrate+0x434>
                {
                    if (phs1>(phs2+1)) phs1=(++phs2);
     9fa:	8d 81       	ldd	r24, Y+5	; 0x05
     9fc:	28 2f       	mov	r18, r24
     9fe:	30 e0       	ldi	r19, 0x00	; 0
     a00:	8e 81       	ldd	r24, Y+6	; 0x06
     a02:	88 2f       	mov	r24, r24
     a04:	90 e0       	ldi	r25, 0x00	; 0
     a06:	01 96       	adiw	r24, 0x01	; 1
     a08:	82 17       	cp	r24, r18
     a0a:	93 07       	cpc	r25, r19
     a0c:	44 f4       	brge	.+16     	; 0xa1e <can_auto_baudrate+0x438>
     a0e:	8e 81       	ldd	r24, Y+6	; 0x06
     a10:	8f 5f       	subi	r24, 0xFF	; 255
     a12:	8e 83       	std	Y+6, r24	; 0x06
     a14:	8e 81       	ldd	r24, Y+6	; 0x06
     a16:	8d 83       	std	Y+5, r24	; 0x05
     a18:	02 c0       	rjmp	.+4      	; 0xa1e <can_auto_baudrate+0x438>
                }
                else
                {
                phs2=phs1;
     a1a:	8d 81       	ldd	r24, Y+5	; 0x05
     a1c:	8e 83       	std	Y+6, r24	; 0x06
                }
                prs = ntq - ( phs1 + phs2 + 1 );
     a1e:	9d 81       	ldd	r25, Y+5	; 0x05
     a20:	8e 81       	ldd	r24, Y+6	; 0x06
     a22:	89 0f       	add	r24, r25
     a24:	9c 81       	ldd	r25, Y+4	; 0x04
     a26:	f9 2f       	mov	r31, r25
     a28:	f8 1b       	sub	r31, r24
     a2a:	8f 2f       	mov	r24, r31
     a2c:	81 50       	subi	r24, 0x01	; 1
     a2e:	8b 83       	std	Y+3, r24	; 0x03

                //! --- Test PRS limits
                if ((prs <= PRS_MAX) && (prs >= PRS_MIN))
     a30:	8b 81       	ldd	r24, Y+3	; 0x03
     a32:	89 30       	cpi	r24, 0x09	; 9
     a34:	b8 f5       	brcc	.+110    	; 0xaa4 <can_auto_baudrate+0x4be>
     a36:	8b 81       	ldd	r24, Y+3	; 0x03
     a38:	88 23       	and	r24, r24
     a3a:	a1 f1       	breq	.+104    	; 0xaa4 <can_auto_baudrate+0x4be>
                {
                    //! --- Values  accepted if  80% >= sampling point >= 75%
                    if (((phs2<<2) >= (1+prs+phs1)) && ((phs2+phs2+phs2) <= (1+prs+phs1)))
     a3c:	8e 81       	ldd	r24, Y+6	; 0x06
     a3e:	88 2f       	mov	r24, r24
     a40:	90 e0       	ldi	r25, 0x00	; 0
     a42:	9c 01       	movw	r18, r24
     a44:	22 0f       	add	r18, r18
     a46:	33 1f       	adc	r19, r19
     a48:	22 0f       	add	r18, r18
     a4a:	33 1f       	adc	r19, r19
     a4c:	8b 81       	ldd	r24, Y+3	; 0x03
     a4e:	88 2f       	mov	r24, r24
     a50:	90 e0       	ldi	r25, 0x00	; 0
     a52:	ac 01       	movw	r20, r24
     a54:	4f 5f       	subi	r20, 0xFF	; 255
     a56:	5f 4f       	sbci	r21, 0xFF	; 255
     a58:	8d 81       	ldd	r24, Y+5	; 0x05
     a5a:	88 2f       	mov	r24, r24
     a5c:	90 e0       	ldi	r25, 0x00	; 0
     a5e:	84 0f       	add	r24, r20
     a60:	95 1f       	adc	r25, r21
     a62:	28 17       	cp	r18, r24
     a64:	39 07       	cpc	r19, r25
     a66:	f4 f0       	brlt	.+60     	; 0xaa4 <can_auto_baudrate+0x4be>
     a68:	8e 81       	ldd	r24, Y+6	; 0x06
     a6a:	28 2f       	mov	r18, r24
     a6c:	30 e0       	ldi	r19, 0x00	; 0
     a6e:	8e 81       	ldd	r24, Y+6	; 0x06
     a70:	88 2f       	mov	r24, r24
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	28 0f       	add	r18, r24
     a76:	39 1f       	adc	r19, r25
     a78:	8e 81       	ldd	r24, Y+6	; 0x06
     a7a:	88 2f       	mov	r24, r24
     a7c:	90 e0       	ldi	r25, 0x00	; 0
     a7e:	28 0f       	add	r18, r24
     a80:	39 1f       	adc	r19, r25
     a82:	8b 81       	ldd	r24, Y+3	; 0x03
     a84:	88 2f       	mov	r24, r24
     a86:	90 e0       	ldi	r25, 0x00	; 0
     a88:	ac 01       	movw	r20, r24
     a8a:	4f 5f       	subi	r20, 0xFF	; 255
     a8c:	5f 4f       	sbci	r21, 0xFF	; 255
     a8e:	8d 81       	ldd	r24, Y+5	; 0x05
     a90:	88 2f       	mov	r24, r24
     a92:	90 e0       	ldi	r25, 0x00	; 0
     a94:	84 0f       	add	r24, r20
     a96:	95 1f       	adc	r25, r21
     a98:	82 17       	cp	r24, r18
     a9a:	93 07       	cpc	r25, r19
     a9c:	1c f0       	brlt	.+6      	; 0xaa4 <can_auto_baudrate+0x4be>
                    {
                        evaluate = 0;     //! Out of "while (evaluate ..." loop &
     a9e:	1a 86       	std	Y+10, r1	; 0x0a
                        wait_for_rx = 1;  //!    new "while (bt_not_found ..." loop
     aa0:	81 e0       	ldi	r24, 0x01	; 1
     aa2:	89 87       	std	Y+9, r24	; 0x09
        //!     then Phase2=Phase1 and if Phase1>5, Phase1 can be equal to Phase2 or
        //!     Phase2+1. After this, the number of TQ is increased up to its high
        //!     limit and after it is the Prescaler. During the computing high (80%)
        //!     and low (75%) limits of sampling point location are tested. SJW and
        //!     the number of sampling points are not calculated in this loop.
        while (evaluate == 1)
     aa4:	8a 85       	ldd	r24, Y+10	; 0x0a
     aa6:	81 30       	cpi	r24, 0x01	; 1
     aa8:	09 f4       	brne	.+2      	; 0xaac <can_auto_baudrate+0x4c6>
     aaa:	65 cf       	rjmp	.-310    	; 0x976 <can_auto_baudrate+0x390>
    {
        Can_set_mob(u8_temp0);  //! Page index
        Can_clear_mob();        //! All MOb Registers = 0x00
    }

    while (bt_not_found == 1)
     aac:	88 85       	ldd	r24, Y+8	; 0x08
     aae:	81 30       	cpi	r24, 0x01	; 1
     ab0:	09 f4       	brne	.+2      	; 0xab4 <can_auto_baudrate+0x4ce>
     ab2:	7b ce       	rjmp	.-778    	; 0x7aa <can_auto_baudrate+0x1c4>
                }
            }
        } // while (evaluate ...
    } // while (bt_not_found ...

    return (bt_performed);
     ab4:	8f 85       	ldd	r24, Y+15	; 0x0f
}
     ab6:	62 96       	adiw	r28, 0x12	; 18
     ab8:	0f b6       	in	r0, 0x3f	; 63
     aba:	f8 94       	cli
     abc:	de bf       	out	0x3e, r29	; 62
     abe:	0f be       	out	0x3f, r0	; 63
     ac0:	cd bf       	out	0x3d, r28	; 61
     ac2:	df 91       	pop	r29
     ac4:	cf 91       	pop	r28
     ac6:	08 95       	ret

00000ac8 <can_fixed_baudrate>:
//!
//! @return Baudrate Status
//!         fixed = 1: baudrate performed
//------------------------------------------------------------------------------
uint8_t can_fixed_baudrate(uint8_t mode)
{
     ac8:	cf 93       	push	r28
     aca:	df 93       	push	r29
     acc:	1f 92       	push	r1
     ace:	cd b7       	in	r28, 0x3d	; 61
     ad0:	de b7       	in	r29, 0x3e	; 62
     ad2:	89 83       	std	Y+1, r24	; 0x01
    Can_reset();
     ad4:	88 ed       	ldi	r24, 0xD8	; 216
     ad6:	90 e0       	ldi	r25, 0x00	; 0
     ad8:	21 e0       	ldi	r18, 0x01	; 1
     ada:	fc 01       	movw	r30, r24
     adc:	20 83       	st	Z, r18
    Can_conf_bt();
     ade:	82 ee       	ldi	r24, 0xE2	; 226
     ae0:	90 e0       	ldi	r25, 0x00	; 0
     ae2:	26 e0       	ldi	r18, 0x06	; 6
     ae4:	fc 01       	movw	r30, r24
     ae6:	20 83       	st	Z, r18
     ae8:	83 ee       	ldi	r24, 0xE3	; 227
     aea:	90 e0       	ldi	r25, 0x00	; 0
     aec:	24 e0       	ldi	r18, 0x04	; 4
     aee:	fc 01       	movw	r30, r24
     af0:	20 83       	st	Z, r18
     af2:	84 ee       	ldi	r24, 0xE4	; 228
     af4:	90 e0       	ldi	r25, 0x00	; 0
     af6:	23 e1       	ldi	r18, 0x13	; 19
     af8:	fc 01       	movw	r30, r24
     afa:	20 83       	st	Z, r18
    return 1;
     afc:	81 e0       	ldi	r24, 0x01	; 1
     afe:	0f 90       	pop	r0
     b00:	df 91       	pop	r29
     b02:	cf 91       	pop	r28
     b04:	08 95       	ret

00000b06 <can_init>:
//!         ==0: research of bit timing configuration failed
//!         ==1: baudrate performed 
//!
//------------------------------------------------------------------------------
uint8_t can_init(uint8_t mode)
{
     b06:	cf 93       	push	r28
     b08:	df 93       	push	r29
     b0a:	1f 92       	push	r1
     b0c:	cd b7       	in	r28, 0x3d	; 61
     b0e:	de b7       	in	r29, 0x3e	; 62
     b10:	89 83       	std	Y+1, r24	; 0x01
    if ((Can_bit_timing(mode))==0) return (0);  // c.f. macro in "can_drv.h"
     b12:	89 81       	ldd	r24, Y+1	; 0x01
     b14:	0e 94 64 05 	call	0xac8	; 0xac8 <can_fixed_baudrate>
     b18:	88 23       	and	r24, r24
     b1a:	11 f4       	brne	.+4      	; 0xb20 <can_init+0x1a>
     b1c:	80 e0       	ldi	r24, 0x00	; 0
     b1e:	0c c0       	rjmp	.+24     	; 0xb38 <can_init+0x32>
    can_clear_all_mob();                        // c.f. function in "can_drv.c"
     b20:	0e 94 30 02 	call	0x460	; 0x460 <can_clear_all_mob>
    Can_enable();                               // c.f. macro in "can_drv.h" 
     b24:	88 ed       	ldi	r24, 0xD8	; 216
     b26:	90 e0       	ldi	r25, 0x00	; 0
     b28:	28 ed       	ldi	r18, 0xD8	; 216
     b2a:	30 e0       	ldi	r19, 0x00	; 0
     b2c:	f9 01       	movw	r30, r18
     b2e:	20 81       	ld	r18, Z
     b30:	22 60       	ori	r18, 0x02	; 2
     b32:	fc 01       	movw	r30, r24
     b34:	20 83       	st	Z, r18
    return (1);
     b36:	81 e0       	ldi	r24, 0x01	; 1
}
     b38:	0f 90       	pop	r0
     b3a:	df 91       	pop	r29
     b3c:	cf 91       	pop	r28
     b3e:	08 95       	ret

00000b40 <can_cmd>:
//! @return CAN_CMD_ACCEPTED - command is accepted
//!         CAN_CMD_REFUSED  - command is refused
//!
//------------------------------------------------------------------------------
uint8_t can_cmd(st_cmd_t* cmd)
{
     b40:	cf 93       	push	r28
     b42:	df 93       	push	r29
     b44:	cd b7       	in	r28, 0x3d	; 61
     b46:	de b7       	in	r29, 0x3e	; 62
     b48:	2a 97       	sbiw	r28, 0x0a	; 10
     b4a:	0f b6       	in	r0, 0x3f	; 63
     b4c:	f8 94       	cli
     b4e:	de bf       	out	0x3e, r29	; 62
     b50:	0f be       	out	0x3f, r0	; 63
     b52:	cd bf       	out	0x3d, r28	; 61
     b54:	9a 87       	std	Y+10, r25	; 0x0a
     b56:	89 87       	std	Y+9, r24	; 0x09
  uint8_t mob_handle, cpt;
  uint32_t u32_temp;
  
  if (cmd->cmd == CMD_ABORT)
     b58:	89 85       	ldd	r24, Y+9	; 0x09
     b5a:	9a 85       	ldd	r25, Y+10	; 0x0a
     b5c:	fc 01       	movw	r30, r24
     b5e:	81 81       	ldd	r24, Z+1	; 0x01
     b60:	8c 30       	cpi	r24, 0x0C	; 12
     b62:	39 f5       	brne	.+78     	; 0xbb2 <can_cmd+0x72>
  {
    if (cmd->status == MOB_PENDING)
     b64:	89 85       	ldd	r24, Y+9	; 0x09
     b66:	9a 85       	ldd	r25, Y+10	; 0x0a
     b68:	fc 01       	movw	r30, r24
     b6a:	81 85       	ldd	r24, Z+9	; 0x09
     b6c:	80 36       	cpi	r24, 0x60	; 96
     b6e:	d9 f4       	brne	.+54     	; 0xba6 <can_cmd+0x66>
    {
      // Rx or Tx not yet performed
      Can_set_mob(cmd->handle);
     b70:	8d ee       	ldi	r24, 0xED	; 237
     b72:	90 e0       	ldi	r25, 0x00	; 0
     b74:	29 85       	ldd	r18, Y+9	; 0x09
     b76:	3a 85       	ldd	r19, Y+10	; 0x0a
     b78:	f9 01       	movw	r30, r18
     b7a:	20 81       	ld	r18, Z
     b7c:	22 95       	swap	r18
     b7e:	20 7f       	andi	r18, 0xF0	; 240
     b80:	fc 01       	movw	r30, r24
     b82:	20 83       	st	Z, r18
      Can_mob_abort();
     b84:	8f ee       	ldi	r24, 0xEF	; 239
     b86:	90 e0       	ldi	r25, 0x00	; 0
     b88:	2f ee       	ldi	r18, 0xEF	; 239
     b8a:	30 e0       	ldi	r19, 0x00	; 0
     b8c:	f9 01       	movw	r30, r18
     b8e:	20 81       	ld	r18, Z
     b90:	2f 73       	andi	r18, 0x3F	; 63
     b92:	fc 01       	movw	r30, r24
     b94:	20 83       	st	Z, r18
      Can_clear_status_mob();       // To be sure !
     b96:	8e ee       	ldi	r24, 0xEE	; 238
     b98:	90 e0       	ldi	r25, 0x00	; 0
     b9a:	fc 01       	movw	r30, r24
     b9c:	10 82       	st	Z, r1
      cmd->handle = 0;
     b9e:	89 85       	ldd	r24, Y+9	; 0x09
     ba0:	9a 85       	ldd	r25, Y+10	; 0x0a
     ba2:	fc 01       	movw	r30, r24
     ba4:	10 82       	st	Z, r1
    }
    cmd->status = STATUS_CLEARED; 
     ba6:	89 85       	ldd	r24, Y+9	; 0x09
     ba8:	9a 85       	ldd	r25, Y+10	; 0x0a
     baa:	fc 01       	movw	r30, r24
     bac:	11 86       	std	Z+9, r1	; 0x09
     bae:	0c 94 2c 10 	jmp	0x2058	; 0x2058 <__stack+0xf59>
  }
  else
  {
    mob_handle = can_get_mob_free();
     bb2:	0e 94 5e 02 	call	0x4bc	; 0x4bc <can_get_mob_free>
     bb6:	8c 83       	std	Y+4, r24	; 0x04
    if (mob_handle!= NO_MOB)
     bb8:	8c 81       	ldd	r24, Y+4	; 0x04
     bba:	8f 3f       	cpi	r24, 0xFF	; 255
     bbc:	11 f4       	brne	.+4      	; 0xbc2 <can_cmd+0x82>
     bbe:	0c 94 25 10 	jmp	0x204a	; 0x204a <__stack+0xf4b>
    {
      cmd->status = MOB_PENDING; 
     bc2:	89 85       	ldd	r24, Y+9	; 0x09
     bc4:	9a 85       	ldd	r25, Y+10	; 0x0a
     bc6:	20 e6       	ldi	r18, 0x60	; 96
     bc8:	fc 01       	movw	r30, r24
     bca:	21 87       	std	Z+9, r18	; 0x09
      cmd->handle = mob_handle;
     bcc:	89 85       	ldd	r24, Y+9	; 0x09
     bce:	9a 85       	ldd	r25, Y+10	; 0x0a
     bd0:	2c 81       	ldd	r18, Y+4	; 0x04
     bd2:	fc 01       	movw	r30, r24
     bd4:	20 83       	st	Z, r18
      Can_set_mob(mob_handle);
     bd6:	8d ee       	ldi	r24, 0xED	; 237
     bd8:	90 e0       	ldi	r25, 0x00	; 0
     bda:	2c 81       	ldd	r18, Y+4	; 0x04
     bdc:	22 95       	swap	r18
     bde:	20 7f       	andi	r18, 0xF0	; 240
     be0:	fc 01       	movw	r30, r24
     be2:	20 83       	st	Z, r18
      Can_clear_mob();
     be4:	8e ee       	ldi	r24, 0xEE	; 238
     be6:	90 e0       	ldi	r25, 0x00	; 0
     be8:	9b 83       	std	Y+3, r25	; 0x03
     bea:	8a 83       	std	Y+2, r24	; 0x02
     bec:	09 c0       	rjmp	.+18     	; 0xc00 <can_cmd+0xc0>
     bee:	8a 81       	ldd	r24, Y+2	; 0x02
     bf0:	9b 81       	ldd	r25, Y+3	; 0x03
     bf2:	fc 01       	movw	r30, r24
     bf4:	10 82       	st	Z, r1
     bf6:	8a 81       	ldd	r24, Y+2	; 0x02
     bf8:	9b 81       	ldd	r25, Y+3	; 0x03
     bfa:	01 96       	adiw	r24, 0x01	; 1
     bfc:	9b 83       	std	Y+3, r25	; 0x03
     bfe:	8a 83       	std	Y+2, r24	; 0x02
     c00:	8a 81       	ldd	r24, Y+2	; 0x02
     c02:	9b 81       	ldd	r25, Y+3	; 0x03
     c04:	88 3f       	cpi	r24, 0xF8	; 248
     c06:	91 05       	cpc	r25, r1
     c08:	90 f3       	brcs	.-28     	; 0xbee <can_cmd+0xae>
          
      switch (cmd->cmd)
     c0a:	89 85       	ldd	r24, Y+9	; 0x09
     c0c:	9a 85       	ldd	r25, Y+10	; 0x0a
     c0e:	fc 01       	movw	r30, r24
     c10:	81 81       	ldd	r24, Z+1	; 0x01
     c12:	88 2f       	mov	r24, r24
     c14:	90 e0       	ldi	r25, 0x00	; 0
     c16:	09 2e       	mov	r0, r25
     c18:	00 0c       	add	r0, r0
     c1a:	aa 0b       	sbc	r26, r26
     c1c:	bb 0b       	sbc	r27, r27
     c1e:	41 e0       	ldi	r20, 0x01	; 1
     c20:	50 e0       	ldi	r21, 0x00	; 0
     c22:	2a e0       	ldi	r18, 0x0A	; 10
     c24:	30 e0       	ldi	r19, 0x00	; 0
     c26:	84 1b       	sub	r24, r20
     c28:	95 0b       	sbc	r25, r21
     c2a:	28 17       	cp	r18, r24
     c2c:	39 07       	cpc	r19, r25
     c2e:	10 f4       	brcc	.+4      	; 0xc34 <can_cmd+0xf4>
     c30:	0c 94 1f 10 	jmp	0x203e	; 0x203e <__stack+0xf3f>
     c34:	82 5c       	subi	r24, 0xC2	; 194
     c36:	9f 4f       	sbci	r25, 0xFF	; 255
     c38:	fc 01       	movw	r30, r24
     c3a:	0c 94 27 29 	jmp	0x524e	; 0x524e <__tablejump2__>
      {
        //------------      
        case CMD_TX:    
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
     c3e:	89 85       	ldd	r24, Y+9	; 0x09
     c40:	9a 85       	ldd	r25, Y+10	; 0x0a
     c42:	fc 01       	movw	r30, r24
     c44:	83 85       	ldd	r24, Z+11	; 0x0b
     c46:	88 23       	and	r24, r24
     c48:	09 f4       	brne	.+2      	; 0xc4c <can_cmd+0x10c>
     c4a:	69 c0       	rjmp	.+210    	; 0xd1e <can_cmd+0x1de>
     c4c:	83 ef       	ldi	r24, 0xF3	; 243
     c4e:	90 e0       	ldi	r25, 0x00	; 0
     c50:	29 85       	ldd	r18, Y+9	; 0x09
     c52:	3a 85       	ldd	r19, Y+10	; 0x0a
     c54:	2e 5f       	subi	r18, 0xFE	; 254
     c56:	3f 4f       	sbci	r19, 0xFF	; 255
     c58:	2d 5f       	subi	r18, 0xFD	; 253
     c5a:	3f 4f       	sbci	r19, 0xFF	; 255
     c5c:	f9 01       	movw	r30, r18
     c5e:	20 81       	ld	r18, Z
     c60:	42 2f       	mov	r20, r18
     c62:	44 0f       	add	r20, r20
     c64:	44 0f       	add	r20, r20
     c66:	44 0f       	add	r20, r20
     c68:	29 85       	ldd	r18, Y+9	; 0x09
     c6a:	3a 85       	ldd	r19, Y+10	; 0x0a
     c6c:	2e 5f       	subi	r18, 0xFE	; 254
     c6e:	3f 4f       	sbci	r19, 0xFF	; 255
     c70:	2e 5f       	subi	r18, 0xFE	; 254
     c72:	3f 4f       	sbci	r19, 0xFF	; 255
     c74:	f9 01       	movw	r30, r18
     c76:	20 81       	ld	r18, Z
     c78:	22 95       	swap	r18
     c7a:	26 95       	lsr	r18
     c7c:	27 70       	andi	r18, 0x07	; 7
     c7e:	24 0f       	add	r18, r20
     c80:	fc 01       	movw	r30, r24
     c82:	20 83       	st	Z, r18
     c84:	82 ef       	ldi	r24, 0xF2	; 242
     c86:	90 e0       	ldi	r25, 0x00	; 0
     c88:	29 85       	ldd	r18, Y+9	; 0x09
     c8a:	3a 85       	ldd	r19, Y+10	; 0x0a
     c8c:	2e 5f       	subi	r18, 0xFE	; 254
     c8e:	3f 4f       	sbci	r19, 0xFF	; 255
     c90:	2e 5f       	subi	r18, 0xFE	; 254
     c92:	3f 4f       	sbci	r19, 0xFF	; 255
     c94:	f9 01       	movw	r30, r18
     c96:	20 81       	ld	r18, Z
     c98:	42 2f       	mov	r20, r18
     c9a:	44 0f       	add	r20, r20
     c9c:	44 0f       	add	r20, r20
     c9e:	44 0f       	add	r20, r20
     ca0:	29 85       	ldd	r18, Y+9	; 0x09
     ca2:	3a 85       	ldd	r19, Y+10	; 0x0a
     ca4:	2e 5f       	subi	r18, 0xFE	; 254
     ca6:	3f 4f       	sbci	r19, 0xFF	; 255
     ca8:	2f 5f       	subi	r18, 0xFF	; 255
     caa:	3f 4f       	sbci	r19, 0xFF	; 255
     cac:	f9 01       	movw	r30, r18
     cae:	20 81       	ld	r18, Z
     cb0:	22 95       	swap	r18
     cb2:	26 95       	lsr	r18
     cb4:	27 70       	andi	r18, 0x07	; 7
     cb6:	24 0f       	add	r18, r20
     cb8:	fc 01       	movw	r30, r24
     cba:	20 83       	st	Z, r18
     cbc:	81 ef       	ldi	r24, 0xF1	; 241
     cbe:	90 e0       	ldi	r25, 0x00	; 0
     cc0:	29 85       	ldd	r18, Y+9	; 0x09
     cc2:	3a 85       	ldd	r19, Y+10	; 0x0a
     cc4:	2e 5f       	subi	r18, 0xFE	; 254
     cc6:	3f 4f       	sbci	r19, 0xFF	; 255
     cc8:	2f 5f       	subi	r18, 0xFF	; 255
     cca:	3f 4f       	sbci	r19, 0xFF	; 255
     ccc:	f9 01       	movw	r30, r18
     cce:	20 81       	ld	r18, Z
     cd0:	42 2f       	mov	r20, r18
     cd2:	44 0f       	add	r20, r20
     cd4:	44 0f       	add	r20, r20
     cd6:	44 0f       	add	r20, r20
     cd8:	29 85       	ldd	r18, Y+9	; 0x09
     cda:	3a 85       	ldd	r19, Y+10	; 0x0a
     cdc:	2e 5f       	subi	r18, 0xFE	; 254
     cde:	3f 4f       	sbci	r19, 0xFF	; 255
     ce0:	f9 01       	movw	r30, r18
     ce2:	20 81       	ld	r18, Z
     ce4:	22 95       	swap	r18
     ce6:	26 95       	lsr	r18
     ce8:	27 70       	andi	r18, 0x07	; 7
     cea:	24 0f       	add	r18, r20
     cec:	fc 01       	movw	r30, r24
     cee:	20 83       	st	Z, r18
     cf0:	80 ef       	ldi	r24, 0xF0	; 240
     cf2:	90 e0       	ldi	r25, 0x00	; 0
     cf4:	29 85       	ldd	r18, Y+9	; 0x09
     cf6:	3a 85       	ldd	r19, Y+10	; 0x0a
     cf8:	2e 5f       	subi	r18, 0xFE	; 254
     cfa:	3f 4f       	sbci	r19, 0xFF	; 255
     cfc:	f9 01       	movw	r30, r18
     cfe:	20 81       	ld	r18, Z
     d00:	22 0f       	add	r18, r18
     d02:	22 0f       	add	r18, r18
     d04:	22 0f       	add	r18, r18
     d06:	fc 01       	movw	r30, r24
     d08:	20 83       	st	Z, r18
     d0a:	8f ee       	ldi	r24, 0xEF	; 239
     d0c:	90 e0       	ldi	r25, 0x00	; 0
     d0e:	2f ee       	ldi	r18, 0xEF	; 239
     d10:	30 e0       	ldi	r19, 0x00	; 0
     d12:	f9 01       	movw	r30, r18
     d14:	20 81       	ld	r18, Z
     d16:	20 61       	ori	r18, 0x10	; 16
     d18:	fc 01       	movw	r30, r24
     d1a:	20 83       	st	Z, r18
     d1c:	30 c0       	rjmp	.+96     	; 0xd7e <can_cmd+0x23e>
          else              { Can_set_std_id(cmd->id.std);}
     d1e:	83 ef       	ldi	r24, 0xF3	; 243
     d20:	90 e0       	ldi	r25, 0x00	; 0
     d22:	29 85       	ldd	r18, Y+9	; 0x09
     d24:	3a 85       	ldd	r19, Y+10	; 0x0a
     d26:	2e 5f       	subi	r18, 0xFE	; 254
     d28:	3f 4f       	sbci	r19, 0xFF	; 255
     d2a:	2f 5f       	subi	r18, 0xFF	; 255
     d2c:	3f 4f       	sbci	r19, 0xFF	; 255
     d2e:	f9 01       	movw	r30, r18
     d30:	20 81       	ld	r18, Z
     d32:	42 2f       	mov	r20, r18
     d34:	42 95       	swap	r20
     d36:	44 0f       	add	r20, r20
     d38:	40 7e       	andi	r20, 0xE0	; 224
     d3a:	29 85       	ldd	r18, Y+9	; 0x09
     d3c:	3a 85       	ldd	r19, Y+10	; 0x0a
     d3e:	2e 5f       	subi	r18, 0xFE	; 254
     d40:	3f 4f       	sbci	r19, 0xFF	; 255
     d42:	f9 01       	movw	r30, r18
     d44:	20 81       	ld	r18, Z
     d46:	26 95       	lsr	r18
     d48:	26 95       	lsr	r18
     d4a:	26 95       	lsr	r18
     d4c:	24 0f       	add	r18, r20
     d4e:	fc 01       	movw	r30, r24
     d50:	20 83       	st	Z, r18
     d52:	82 ef       	ldi	r24, 0xF2	; 242
     d54:	90 e0       	ldi	r25, 0x00	; 0
     d56:	29 85       	ldd	r18, Y+9	; 0x09
     d58:	3a 85       	ldd	r19, Y+10	; 0x0a
     d5a:	2e 5f       	subi	r18, 0xFE	; 254
     d5c:	3f 4f       	sbci	r19, 0xFF	; 255
     d5e:	f9 01       	movw	r30, r18
     d60:	20 81       	ld	r18, Z
     d62:	22 95       	swap	r18
     d64:	22 0f       	add	r18, r18
     d66:	20 7e       	andi	r18, 0xE0	; 224
     d68:	fc 01       	movw	r30, r24
     d6a:	20 83       	st	Z, r18
     d6c:	8f ee       	ldi	r24, 0xEF	; 239
     d6e:	90 e0       	ldi	r25, 0x00	; 0
     d70:	2f ee       	ldi	r18, 0xEF	; 239
     d72:	30 e0       	ldi	r19, 0x00	; 0
     d74:	f9 01       	movw	r30, r18
     d76:	20 81       	ld	r18, Z
     d78:	2f 7e       	andi	r18, 0xEF	; 239
     d7a:	fc 01       	movw	r30, r24
     d7c:	20 83       	st	Z, r18
          for (cpt=0;cpt<cmd->dlc;cpt++) CANMSG = *(cmd->pt_data + cpt);
     d7e:	19 82       	std	Y+1, r1	; 0x01
     d80:	13 c0       	rjmp	.+38     	; 0xda8 <can_cmd+0x268>
     d82:	8a ef       	ldi	r24, 0xFA	; 250
     d84:	90 e0       	ldi	r25, 0x00	; 0
     d86:	29 85       	ldd	r18, Y+9	; 0x09
     d88:	3a 85       	ldd	r19, Y+10	; 0x0a
     d8a:	f9 01       	movw	r30, r18
     d8c:	47 81       	ldd	r20, Z+7	; 0x07
     d8e:	50 85       	ldd	r21, Z+8	; 0x08
     d90:	29 81       	ldd	r18, Y+1	; 0x01
     d92:	22 2f       	mov	r18, r18
     d94:	30 e0       	ldi	r19, 0x00	; 0
     d96:	24 0f       	add	r18, r20
     d98:	35 1f       	adc	r19, r21
     d9a:	f9 01       	movw	r30, r18
     d9c:	20 81       	ld	r18, Z
     d9e:	fc 01       	movw	r30, r24
     da0:	20 83       	st	Z, r18
     da2:	89 81       	ldd	r24, Y+1	; 0x01
     da4:	8f 5f       	subi	r24, 0xFF	; 255
     da6:	89 83       	std	Y+1, r24	; 0x01
     da8:	89 85       	ldd	r24, Y+9	; 0x09
     daa:	9a 85       	ldd	r25, Y+10	; 0x0a
     dac:	fc 01       	movw	r30, r24
     dae:	96 81       	ldd	r25, Z+6	; 0x06
     db0:	89 81       	ldd	r24, Y+1	; 0x01
     db2:	89 17       	cp	r24, r25
     db4:	30 f3       	brcs	.-52     	; 0xd82 <can_cmd+0x242>
          if (cmd->ctrl.rtr) Can_set_rtr(); 
     db6:	89 85       	ldd	r24, Y+9	; 0x09
     db8:	9a 85       	ldd	r25, Y+10	; 0x0a
     dba:	fc 01       	movw	r30, r24
     dbc:	82 85       	ldd	r24, Z+10	; 0x0a
     dbe:	88 23       	and	r24, r24
     dc0:	51 f0       	breq	.+20     	; 0xdd6 <can_cmd+0x296>
     dc2:	80 ef       	ldi	r24, 0xF0	; 240
     dc4:	90 e0       	ldi	r25, 0x00	; 0
     dc6:	20 ef       	ldi	r18, 0xF0	; 240
     dc8:	30 e0       	ldi	r19, 0x00	; 0
     dca:	f9 01       	movw	r30, r18
     dcc:	20 81       	ld	r18, Z
     dce:	24 60       	ori	r18, 0x04	; 4
     dd0:	fc 01       	movw	r30, r24
     dd2:	20 83       	st	Z, r18
     dd4:	09 c0       	rjmp	.+18     	; 0xde8 <can_cmd+0x2a8>
            else Can_clear_rtr();    
     dd6:	80 ef       	ldi	r24, 0xF0	; 240
     dd8:	90 e0       	ldi	r25, 0x00	; 0
     dda:	20 ef       	ldi	r18, 0xF0	; 240
     ddc:	30 e0       	ldi	r19, 0x00	; 0
     dde:	f9 01       	movw	r30, r18
     de0:	20 81       	ld	r18, Z
     de2:	2b 7f       	andi	r18, 0xFB	; 251
     de4:	fc 01       	movw	r30, r24
     de6:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
     de8:	8f ee       	ldi	r24, 0xEF	; 239
     dea:	90 e0       	ldi	r25, 0x00	; 0
     dec:	2f ee       	ldi	r18, 0xEF	; 239
     dee:	30 e0       	ldi	r19, 0x00	; 0
     df0:	f9 01       	movw	r30, r18
     df2:	40 81       	ld	r20, Z
     df4:	29 85       	ldd	r18, Y+9	; 0x09
     df6:	3a 85       	ldd	r19, Y+10	; 0x0a
     df8:	f9 01       	movw	r30, r18
     dfa:	26 81       	ldd	r18, Z+6	; 0x06
     dfc:	24 2b       	or	r18, r20
     dfe:	fc 01       	movw	r30, r24
     e00:	20 83       	st	Z, r18
          Can_config_tx();
     e02:	8f ee       	ldi	r24, 0xEF	; 239
     e04:	90 e0       	ldi	r25, 0x00	; 0
     e06:	2f ee       	ldi	r18, 0xEF	; 239
     e08:	30 e0       	ldi	r19, 0x00	; 0
     e0a:	f9 01       	movw	r30, r18
     e0c:	20 81       	ld	r18, Z
     e0e:	2f 73       	andi	r18, 0x3F	; 63
     e10:	fc 01       	movw	r30, r24
     e12:	20 83       	st	Z, r18
     e14:	8f ee       	ldi	r24, 0xEF	; 239
     e16:	90 e0       	ldi	r25, 0x00	; 0
     e18:	2f ee       	ldi	r18, 0xEF	; 239
     e1a:	30 e0       	ldi	r19, 0x00	; 0
     e1c:	f9 01       	movw	r30, r18
     e1e:	20 81       	ld	r18, Z
     e20:	20 64       	ori	r18, 0x40	; 64
     e22:	fc 01       	movw	r30, r24
     e24:	20 83       	st	Z, r18
          break;
     e26:	0c 94 24 10 	jmp	0x2048	; 0x2048 <__stack+0xf49>
        //------------      
        case CMD_TX_DATA:    
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
     e2a:	89 85       	ldd	r24, Y+9	; 0x09
     e2c:	9a 85       	ldd	r25, Y+10	; 0x0a
     e2e:	fc 01       	movw	r30, r24
     e30:	83 85       	ldd	r24, Z+11	; 0x0b
     e32:	88 23       	and	r24, r24
     e34:	09 f4       	brne	.+2      	; 0xe38 <can_cmd+0x2f8>
     e36:	69 c0       	rjmp	.+210    	; 0xf0a <can_cmd+0x3ca>
     e38:	83 ef       	ldi	r24, 0xF3	; 243
     e3a:	90 e0       	ldi	r25, 0x00	; 0
     e3c:	29 85       	ldd	r18, Y+9	; 0x09
     e3e:	3a 85       	ldd	r19, Y+10	; 0x0a
     e40:	2e 5f       	subi	r18, 0xFE	; 254
     e42:	3f 4f       	sbci	r19, 0xFF	; 255
     e44:	2d 5f       	subi	r18, 0xFD	; 253
     e46:	3f 4f       	sbci	r19, 0xFF	; 255
     e48:	f9 01       	movw	r30, r18
     e4a:	20 81       	ld	r18, Z
     e4c:	42 2f       	mov	r20, r18
     e4e:	44 0f       	add	r20, r20
     e50:	44 0f       	add	r20, r20
     e52:	44 0f       	add	r20, r20
     e54:	29 85       	ldd	r18, Y+9	; 0x09
     e56:	3a 85       	ldd	r19, Y+10	; 0x0a
     e58:	2e 5f       	subi	r18, 0xFE	; 254
     e5a:	3f 4f       	sbci	r19, 0xFF	; 255
     e5c:	2e 5f       	subi	r18, 0xFE	; 254
     e5e:	3f 4f       	sbci	r19, 0xFF	; 255
     e60:	f9 01       	movw	r30, r18
     e62:	20 81       	ld	r18, Z
     e64:	22 95       	swap	r18
     e66:	26 95       	lsr	r18
     e68:	27 70       	andi	r18, 0x07	; 7
     e6a:	24 0f       	add	r18, r20
     e6c:	fc 01       	movw	r30, r24
     e6e:	20 83       	st	Z, r18
     e70:	82 ef       	ldi	r24, 0xF2	; 242
     e72:	90 e0       	ldi	r25, 0x00	; 0
     e74:	29 85       	ldd	r18, Y+9	; 0x09
     e76:	3a 85       	ldd	r19, Y+10	; 0x0a
     e78:	2e 5f       	subi	r18, 0xFE	; 254
     e7a:	3f 4f       	sbci	r19, 0xFF	; 255
     e7c:	2e 5f       	subi	r18, 0xFE	; 254
     e7e:	3f 4f       	sbci	r19, 0xFF	; 255
     e80:	f9 01       	movw	r30, r18
     e82:	20 81       	ld	r18, Z
     e84:	42 2f       	mov	r20, r18
     e86:	44 0f       	add	r20, r20
     e88:	44 0f       	add	r20, r20
     e8a:	44 0f       	add	r20, r20
     e8c:	29 85       	ldd	r18, Y+9	; 0x09
     e8e:	3a 85       	ldd	r19, Y+10	; 0x0a
     e90:	2e 5f       	subi	r18, 0xFE	; 254
     e92:	3f 4f       	sbci	r19, 0xFF	; 255
     e94:	2f 5f       	subi	r18, 0xFF	; 255
     e96:	3f 4f       	sbci	r19, 0xFF	; 255
     e98:	f9 01       	movw	r30, r18
     e9a:	20 81       	ld	r18, Z
     e9c:	22 95       	swap	r18
     e9e:	26 95       	lsr	r18
     ea0:	27 70       	andi	r18, 0x07	; 7
     ea2:	24 0f       	add	r18, r20
     ea4:	fc 01       	movw	r30, r24
     ea6:	20 83       	st	Z, r18
     ea8:	81 ef       	ldi	r24, 0xF1	; 241
     eaa:	90 e0       	ldi	r25, 0x00	; 0
     eac:	29 85       	ldd	r18, Y+9	; 0x09
     eae:	3a 85       	ldd	r19, Y+10	; 0x0a
     eb0:	2e 5f       	subi	r18, 0xFE	; 254
     eb2:	3f 4f       	sbci	r19, 0xFF	; 255
     eb4:	2f 5f       	subi	r18, 0xFF	; 255
     eb6:	3f 4f       	sbci	r19, 0xFF	; 255
     eb8:	f9 01       	movw	r30, r18
     eba:	20 81       	ld	r18, Z
     ebc:	42 2f       	mov	r20, r18
     ebe:	44 0f       	add	r20, r20
     ec0:	44 0f       	add	r20, r20
     ec2:	44 0f       	add	r20, r20
     ec4:	29 85       	ldd	r18, Y+9	; 0x09
     ec6:	3a 85       	ldd	r19, Y+10	; 0x0a
     ec8:	2e 5f       	subi	r18, 0xFE	; 254
     eca:	3f 4f       	sbci	r19, 0xFF	; 255
     ecc:	f9 01       	movw	r30, r18
     ece:	20 81       	ld	r18, Z
     ed0:	22 95       	swap	r18
     ed2:	26 95       	lsr	r18
     ed4:	27 70       	andi	r18, 0x07	; 7
     ed6:	24 0f       	add	r18, r20
     ed8:	fc 01       	movw	r30, r24
     eda:	20 83       	st	Z, r18
     edc:	80 ef       	ldi	r24, 0xF0	; 240
     ede:	90 e0       	ldi	r25, 0x00	; 0
     ee0:	29 85       	ldd	r18, Y+9	; 0x09
     ee2:	3a 85       	ldd	r19, Y+10	; 0x0a
     ee4:	2e 5f       	subi	r18, 0xFE	; 254
     ee6:	3f 4f       	sbci	r19, 0xFF	; 255
     ee8:	f9 01       	movw	r30, r18
     eea:	20 81       	ld	r18, Z
     eec:	22 0f       	add	r18, r18
     eee:	22 0f       	add	r18, r18
     ef0:	22 0f       	add	r18, r18
     ef2:	fc 01       	movw	r30, r24
     ef4:	20 83       	st	Z, r18
     ef6:	8f ee       	ldi	r24, 0xEF	; 239
     ef8:	90 e0       	ldi	r25, 0x00	; 0
     efa:	2f ee       	ldi	r18, 0xEF	; 239
     efc:	30 e0       	ldi	r19, 0x00	; 0
     efe:	f9 01       	movw	r30, r18
     f00:	20 81       	ld	r18, Z
     f02:	20 61       	ori	r18, 0x10	; 16
     f04:	fc 01       	movw	r30, r24
     f06:	20 83       	st	Z, r18
     f08:	30 c0       	rjmp	.+96     	; 0xf6a <can_cmd+0x42a>
          else              { Can_set_std_id(cmd->id.std);}
     f0a:	83 ef       	ldi	r24, 0xF3	; 243
     f0c:	90 e0       	ldi	r25, 0x00	; 0
     f0e:	29 85       	ldd	r18, Y+9	; 0x09
     f10:	3a 85       	ldd	r19, Y+10	; 0x0a
     f12:	2e 5f       	subi	r18, 0xFE	; 254
     f14:	3f 4f       	sbci	r19, 0xFF	; 255
     f16:	2f 5f       	subi	r18, 0xFF	; 255
     f18:	3f 4f       	sbci	r19, 0xFF	; 255
     f1a:	f9 01       	movw	r30, r18
     f1c:	20 81       	ld	r18, Z
     f1e:	42 2f       	mov	r20, r18
     f20:	42 95       	swap	r20
     f22:	44 0f       	add	r20, r20
     f24:	40 7e       	andi	r20, 0xE0	; 224
     f26:	29 85       	ldd	r18, Y+9	; 0x09
     f28:	3a 85       	ldd	r19, Y+10	; 0x0a
     f2a:	2e 5f       	subi	r18, 0xFE	; 254
     f2c:	3f 4f       	sbci	r19, 0xFF	; 255
     f2e:	f9 01       	movw	r30, r18
     f30:	20 81       	ld	r18, Z
     f32:	26 95       	lsr	r18
     f34:	26 95       	lsr	r18
     f36:	26 95       	lsr	r18
     f38:	24 0f       	add	r18, r20
     f3a:	fc 01       	movw	r30, r24
     f3c:	20 83       	st	Z, r18
     f3e:	82 ef       	ldi	r24, 0xF2	; 242
     f40:	90 e0       	ldi	r25, 0x00	; 0
     f42:	29 85       	ldd	r18, Y+9	; 0x09
     f44:	3a 85       	ldd	r19, Y+10	; 0x0a
     f46:	2e 5f       	subi	r18, 0xFE	; 254
     f48:	3f 4f       	sbci	r19, 0xFF	; 255
     f4a:	f9 01       	movw	r30, r18
     f4c:	20 81       	ld	r18, Z
     f4e:	22 95       	swap	r18
     f50:	22 0f       	add	r18, r18
     f52:	20 7e       	andi	r18, 0xE0	; 224
     f54:	fc 01       	movw	r30, r24
     f56:	20 83       	st	Z, r18
     f58:	8f ee       	ldi	r24, 0xEF	; 239
     f5a:	90 e0       	ldi	r25, 0x00	; 0
     f5c:	2f ee       	ldi	r18, 0xEF	; 239
     f5e:	30 e0       	ldi	r19, 0x00	; 0
     f60:	f9 01       	movw	r30, r18
     f62:	20 81       	ld	r18, Z
     f64:	2f 7e       	andi	r18, 0xEF	; 239
     f66:	fc 01       	movw	r30, r24
     f68:	20 83       	st	Z, r18
          for (cpt=0;cpt<cmd->dlc;cpt++) CANMSG = *(cmd->pt_data + cpt);
     f6a:	19 82       	std	Y+1, r1	; 0x01
     f6c:	13 c0       	rjmp	.+38     	; 0xf94 <can_cmd+0x454>
     f6e:	8a ef       	ldi	r24, 0xFA	; 250
     f70:	90 e0       	ldi	r25, 0x00	; 0
     f72:	29 85       	ldd	r18, Y+9	; 0x09
     f74:	3a 85       	ldd	r19, Y+10	; 0x0a
     f76:	f9 01       	movw	r30, r18
     f78:	47 81       	ldd	r20, Z+7	; 0x07
     f7a:	50 85       	ldd	r21, Z+8	; 0x08
     f7c:	29 81       	ldd	r18, Y+1	; 0x01
     f7e:	22 2f       	mov	r18, r18
     f80:	30 e0       	ldi	r19, 0x00	; 0
     f82:	24 0f       	add	r18, r20
     f84:	35 1f       	adc	r19, r21
     f86:	f9 01       	movw	r30, r18
     f88:	20 81       	ld	r18, Z
     f8a:	fc 01       	movw	r30, r24
     f8c:	20 83       	st	Z, r18
     f8e:	89 81       	ldd	r24, Y+1	; 0x01
     f90:	8f 5f       	subi	r24, 0xFF	; 255
     f92:	89 83       	std	Y+1, r24	; 0x01
     f94:	89 85       	ldd	r24, Y+9	; 0x09
     f96:	9a 85       	ldd	r25, Y+10	; 0x0a
     f98:	fc 01       	movw	r30, r24
     f9a:	96 81       	ldd	r25, Z+6	; 0x06
     f9c:	89 81       	ldd	r24, Y+1	; 0x01
     f9e:	89 17       	cp	r24, r25
     fa0:	30 f3       	brcs	.-52     	; 0xf6e <can_cmd+0x42e>
          cmd->ctrl.rtr=0; Can_clear_rtr();
     fa2:	89 85       	ldd	r24, Y+9	; 0x09
     fa4:	9a 85       	ldd	r25, Y+10	; 0x0a
     fa6:	fc 01       	movw	r30, r24
     fa8:	12 86       	std	Z+10, r1	; 0x0a
     faa:	80 ef       	ldi	r24, 0xF0	; 240
     fac:	90 e0       	ldi	r25, 0x00	; 0
     fae:	20 ef       	ldi	r18, 0xF0	; 240
     fb0:	30 e0       	ldi	r19, 0x00	; 0
     fb2:	f9 01       	movw	r30, r18
     fb4:	20 81       	ld	r18, Z
     fb6:	2b 7f       	andi	r18, 0xFB	; 251
     fb8:	fc 01       	movw	r30, r24
     fba:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
     fbc:	8f ee       	ldi	r24, 0xEF	; 239
     fbe:	90 e0       	ldi	r25, 0x00	; 0
     fc0:	2f ee       	ldi	r18, 0xEF	; 239
     fc2:	30 e0       	ldi	r19, 0x00	; 0
     fc4:	f9 01       	movw	r30, r18
     fc6:	40 81       	ld	r20, Z
     fc8:	29 85       	ldd	r18, Y+9	; 0x09
     fca:	3a 85       	ldd	r19, Y+10	; 0x0a
     fcc:	f9 01       	movw	r30, r18
     fce:	26 81       	ldd	r18, Z+6	; 0x06
     fd0:	24 2b       	or	r18, r20
     fd2:	fc 01       	movw	r30, r24
     fd4:	20 83       	st	Z, r18
          Can_config_tx();
     fd6:	8f ee       	ldi	r24, 0xEF	; 239
     fd8:	90 e0       	ldi	r25, 0x00	; 0
     fda:	2f ee       	ldi	r18, 0xEF	; 239
     fdc:	30 e0       	ldi	r19, 0x00	; 0
     fde:	f9 01       	movw	r30, r18
     fe0:	20 81       	ld	r18, Z
     fe2:	2f 73       	andi	r18, 0x3F	; 63
     fe4:	fc 01       	movw	r30, r24
     fe6:	20 83       	st	Z, r18
     fe8:	8f ee       	ldi	r24, 0xEF	; 239
     fea:	90 e0       	ldi	r25, 0x00	; 0
     fec:	2f ee       	ldi	r18, 0xEF	; 239
     fee:	30 e0       	ldi	r19, 0x00	; 0
     ff0:	f9 01       	movw	r30, r18
     ff2:	20 81       	ld	r18, Z
     ff4:	20 64       	ori	r18, 0x40	; 64
     ff6:	fc 01       	movw	r30, r24
     ff8:	20 83       	st	Z, r18
          break;
     ffa:	0c 94 24 10 	jmp	0x2048	; 0x2048 <__stack+0xf49>
        //------------      
        case CMD_TX_REMOTE:       
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
     ffe:	89 85       	ldd	r24, Y+9	; 0x09
    1000:	9a 85       	ldd	r25, Y+10	; 0x0a
    1002:	fc 01       	movw	r30, r24
    1004:	83 85       	ldd	r24, Z+11	; 0x0b
    1006:	88 23       	and	r24, r24
    1008:	09 f4       	brne	.+2      	; 0x100c <can_cmd+0x4cc>
    100a:	69 c0       	rjmp	.+210    	; 0x10de <can_cmd+0x59e>
    100c:	83 ef       	ldi	r24, 0xF3	; 243
    100e:	90 e0       	ldi	r25, 0x00	; 0
    1010:	29 85       	ldd	r18, Y+9	; 0x09
    1012:	3a 85       	ldd	r19, Y+10	; 0x0a
    1014:	2e 5f       	subi	r18, 0xFE	; 254
    1016:	3f 4f       	sbci	r19, 0xFF	; 255
    1018:	2d 5f       	subi	r18, 0xFD	; 253
    101a:	3f 4f       	sbci	r19, 0xFF	; 255
    101c:	f9 01       	movw	r30, r18
    101e:	20 81       	ld	r18, Z
    1020:	42 2f       	mov	r20, r18
    1022:	44 0f       	add	r20, r20
    1024:	44 0f       	add	r20, r20
    1026:	44 0f       	add	r20, r20
    1028:	29 85       	ldd	r18, Y+9	; 0x09
    102a:	3a 85       	ldd	r19, Y+10	; 0x0a
    102c:	2e 5f       	subi	r18, 0xFE	; 254
    102e:	3f 4f       	sbci	r19, 0xFF	; 255
    1030:	2e 5f       	subi	r18, 0xFE	; 254
    1032:	3f 4f       	sbci	r19, 0xFF	; 255
    1034:	f9 01       	movw	r30, r18
    1036:	20 81       	ld	r18, Z
    1038:	22 95       	swap	r18
    103a:	26 95       	lsr	r18
    103c:	27 70       	andi	r18, 0x07	; 7
    103e:	24 0f       	add	r18, r20
    1040:	fc 01       	movw	r30, r24
    1042:	20 83       	st	Z, r18
    1044:	82 ef       	ldi	r24, 0xF2	; 242
    1046:	90 e0       	ldi	r25, 0x00	; 0
    1048:	29 85       	ldd	r18, Y+9	; 0x09
    104a:	3a 85       	ldd	r19, Y+10	; 0x0a
    104c:	2e 5f       	subi	r18, 0xFE	; 254
    104e:	3f 4f       	sbci	r19, 0xFF	; 255
    1050:	2e 5f       	subi	r18, 0xFE	; 254
    1052:	3f 4f       	sbci	r19, 0xFF	; 255
    1054:	f9 01       	movw	r30, r18
    1056:	20 81       	ld	r18, Z
    1058:	42 2f       	mov	r20, r18
    105a:	44 0f       	add	r20, r20
    105c:	44 0f       	add	r20, r20
    105e:	44 0f       	add	r20, r20
    1060:	29 85       	ldd	r18, Y+9	; 0x09
    1062:	3a 85       	ldd	r19, Y+10	; 0x0a
    1064:	2e 5f       	subi	r18, 0xFE	; 254
    1066:	3f 4f       	sbci	r19, 0xFF	; 255
    1068:	2f 5f       	subi	r18, 0xFF	; 255
    106a:	3f 4f       	sbci	r19, 0xFF	; 255
    106c:	f9 01       	movw	r30, r18
    106e:	20 81       	ld	r18, Z
    1070:	22 95       	swap	r18
    1072:	26 95       	lsr	r18
    1074:	27 70       	andi	r18, 0x07	; 7
    1076:	24 0f       	add	r18, r20
    1078:	fc 01       	movw	r30, r24
    107a:	20 83       	st	Z, r18
    107c:	81 ef       	ldi	r24, 0xF1	; 241
    107e:	90 e0       	ldi	r25, 0x00	; 0
    1080:	29 85       	ldd	r18, Y+9	; 0x09
    1082:	3a 85       	ldd	r19, Y+10	; 0x0a
    1084:	2e 5f       	subi	r18, 0xFE	; 254
    1086:	3f 4f       	sbci	r19, 0xFF	; 255
    1088:	2f 5f       	subi	r18, 0xFF	; 255
    108a:	3f 4f       	sbci	r19, 0xFF	; 255
    108c:	f9 01       	movw	r30, r18
    108e:	20 81       	ld	r18, Z
    1090:	42 2f       	mov	r20, r18
    1092:	44 0f       	add	r20, r20
    1094:	44 0f       	add	r20, r20
    1096:	44 0f       	add	r20, r20
    1098:	29 85       	ldd	r18, Y+9	; 0x09
    109a:	3a 85       	ldd	r19, Y+10	; 0x0a
    109c:	2e 5f       	subi	r18, 0xFE	; 254
    109e:	3f 4f       	sbci	r19, 0xFF	; 255
    10a0:	f9 01       	movw	r30, r18
    10a2:	20 81       	ld	r18, Z
    10a4:	22 95       	swap	r18
    10a6:	26 95       	lsr	r18
    10a8:	27 70       	andi	r18, 0x07	; 7
    10aa:	24 0f       	add	r18, r20
    10ac:	fc 01       	movw	r30, r24
    10ae:	20 83       	st	Z, r18
    10b0:	80 ef       	ldi	r24, 0xF0	; 240
    10b2:	90 e0       	ldi	r25, 0x00	; 0
    10b4:	29 85       	ldd	r18, Y+9	; 0x09
    10b6:	3a 85       	ldd	r19, Y+10	; 0x0a
    10b8:	2e 5f       	subi	r18, 0xFE	; 254
    10ba:	3f 4f       	sbci	r19, 0xFF	; 255
    10bc:	f9 01       	movw	r30, r18
    10be:	20 81       	ld	r18, Z
    10c0:	22 0f       	add	r18, r18
    10c2:	22 0f       	add	r18, r18
    10c4:	22 0f       	add	r18, r18
    10c6:	fc 01       	movw	r30, r24
    10c8:	20 83       	st	Z, r18
    10ca:	8f ee       	ldi	r24, 0xEF	; 239
    10cc:	90 e0       	ldi	r25, 0x00	; 0
    10ce:	2f ee       	ldi	r18, 0xEF	; 239
    10d0:	30 e0       	ldi	r19, 0x00	; 0
    10d2:	f9 01       	movw	r30, r18
    10d4:	20 81       	ld	r18, Z
    10d6:	20 61       	ori	r18, 0x10	; 16
    10d8:	fc 01       	movw	r30, r24
    10da:	20 83       	st	Z, r18
    10dc:	30 c0       	rjmp	.+96     	; 0x113e <__stack+0x3f>
          else              { Can_set_std_id(cmd->id.std);}
    10de:	83 ef       	ldi	r24, 0xF3	; 243
    10e0:	90 e0       	ldi	r25, 0x00	; 0
    10e2:	29 85       	ldd	r18, Y+9	; 0x09
    10e4:	3a 85       	ldd	r19, Y+10	; 0x0a
    10e6:	2e 5f       	subi	r18, 0xFE	; 254
    10e8:	3f 4f       	sbci	r19, 0xFF	; 255
    10ea:	2f 5f       	subi	r18, 0xFF	; 255
    10ec:	3f 4f       	sbci	r19, 0xFF	; 255
    10ee:	f9 01       	movw	r30, r18
    10f0:	20 81       	ld	r18, Z
    10f2:	42 2f       	mov	r20, r18
    10f4:	42 95       	swap	r20
    10f6:	44 0f       	add	r20, r20
    10f8:	40 7e       	andi	r20, 0xE0	; 224
    10fa:	29 85       	ldd	r18, Y+9	; 0x09
    10fc:	3a 85       	ldd	r19, Y+10	; 0x0a
    10fe:	2e 5f       	subi	r18, 0xFE	; 254
    1100:	3f 4f       	sbci	r19, 0xFF	; 255
    1102:	f9 01       	movw	r30, r18
    1104:	20 81       	ld	r18, Z
    1106:	26 95       	lsr	r18
    1108:	26 95       	lsr	r18
    110a:	26 95       	lsr	r18
    110c:	24 0f       	add	r18, r20
    110e:	fc 01       	movw	r30, r24
    1110:	20 83       	st	Z, r18
    1112:	82 ef       	ldi	r24, 0xF2	; 242
    1114:	90 e0       	ldi	r25, 0x00	; 0
    1116:	29 85       	ldd	r18, Y+9	; 0x09
    1118:	3a 85       	ldd	r19, Y+10	; 0x0a
    111a:	2e 5f       	subi	r18, 0xFE	; 254
    111c:	3f 4f       	sbci	r19, 0xFF	; 255
    111e:	f9 01       	movw	r30, r18
    1120:	20 81       	ld	r18, Z
    1122:	22 95       	swap	r18
    1124:	22 0f       	add	r18, r18
    1126:	20 7e       	andi	r18, 0xE0	; 224
    1128:	fc 01       	movw	r30, r24
    112a:	20 83       	st	Z, r18
    112c:	8f ee       	ldi	r24, 0xEF	; 239
    112e:	90 e0       	ldi	r25, 0x00	; 0
    1130:	2f ee       	ldi	r18, 0xEF	; 239
    1132:	30 e0       	ldi	r19, 0x00	; 0
    1134:	f9 01       	movw	r30, r18
    1136:	20 81       	ld	r18, Z
    1138:	2f 7e       	andi	r18, 0xEF	; 239
    113a:	fc 01       	movw	r30, r24
    113c:	20 83       	st	Z, r18
          cmd->ctrl.rtr=1; Can_set_rtr();
    113e:	89 85       	ldd	r24, Y+9	; 0x09
    1140:	9a 85       	ldd	r25, Y+10	; 0x0a
    1142:	21 e0       	ldi	r18, 0x01	; 1
    1144:	fc 01       	movw	r30, r24
    1146:	22 87       	std	Z+10, r18	; 0x0a
    1148:	80 ef       	ldi	r24, 0xF0	; 240
    114a:	90 e0       	ldi	r25, 0x00	; 0
    114c:	20 ef       	ldi	r18, 0xF0	; 240
    114e:	30 e0       	ldi	r19, 0x00	; 0
    1150:	f9 01       	movw	r30, r18
    1152:	20 81       	ld	r18, Z
    1154:	24 60       	ori	r18, 0x04	; 4
    1156:	fc 01       	movw	r30, r24
    1158:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    115a:	8f ee       	ldi	r24, 0xEF	; 239
    115c:	90 e0       	ldi	r25, 0x00	; 0
    115e:	2f ee       	ldi	r18, 0xEF	; 239
    1160:	30 e0       	ldi	r19, 0x00	; 0
    1162:	f9 01       	movw	r30, r18
    1164:	40 81       	ld	r20, Z
    1166:	29 85       	ldd	r18, Y+9	; 0x09
    1168:	3a 85       	ldd	r19, Y+10	; 0x0a
    116a:	f9 01       	movw	r30, r18
    116c:	26 81       	ldd	r18, Z+6	; 0x06
    116e:	24 2b       	or	r18, r20
    1170:	fc 01       	movw	r30, r24
    1172:	20 83       	st	Z, r18
          Can_config_tx();
    1174:	8f ee       	ldi	r24, 0xEF	; 239
    1176:	90 e0       	ldi	r25, 0x00	; 0
    1178:	2f ee       	ldi	r18, 0xEF	; 239
    117a:	30 e0       	ldi	r19, 0x00	; 0
    117c:	f9 01       	movw	r30, r18
    117e:	20 81       	ld	r18, Z
    1180:	2f 73       	andi	r18, 0x3F	; 63
    1182:	fc 01       	movw	r30, r24
    1184:	20 83       	st	Z, r18
    1186:	8f ee       	ldi	r24, 0xEF	; 239
    1188:	90 e0       	ldi	r25, 0x00	; 0
    118a:	2f ee       	ldi	r18, 0xEF	; 239
    118c:	30 e0       	ldi	r19, 0x00	; 0
    118e:	f9 01       	movw	r30, r18
    1190:	20 81       	ld	r18, Z
    1192:	20 64       	ori	r18, 0x40	; 64
    1194:	fc 01       	movw	r30, r24
    1196:	20 83       	st	Z, r18
          break;
    1198:	57 c7       	rjmp	.+3758   	; 0x2048 <__stack+0xf49>
        //------------      
        case CMD_RX:
          u32_temp=0; Can_set_ext_msk(u32_temp);
    119a:	1d 82       	std	Y+5, r1	; 0x05
    119c:	1e 82       	std	Y+6, r1	; 0x06
    119e:	1f 82       	std	Y+7, r1	; 0x07
    11a0:	18 86       	std	Y+8, r1	; 0x08
    11a2:	27 ef       	ldi	r18, 0xF7	; 247
    11a4:	30 e0       	ldi	r19, 0x00	; 0
    11a6:	ce 01       	movw	r24, r28
    11a8:	05 96       	adiw	r24, 0x05	; 5
    11aa:	03 96       	adiw	r24, 0x03	; 3
    11ac:	fc 01       	movw	r30, r24
    11ae:	80 81       	ld	r24, Z
    11b0:	48 2f       	mov	r20, r24
    11b2:	44 0f       	add	r20, r20
    11b4:	44 0f       	add	r20, r20
    11b6:	44 0f       	add	r20, r20
    11b8:	ce 01       	movw	r24, r28
    11ba:	05 96       	adiw	r24, 0x05	; 5
    11bc:	02 96       	adiw	r24, 0x02	; 2
    11be:	fc 01       	movw	r30, r24
    11c0:	80 81       	ld	r24, Z
    11c2:	82 95       	swap	r24
    11c4:	86 95       	lsr	r24
    11c6:	87 70       	andi	r24, 0x07	; 7
    11c8:	84 0f       	add	r24, r20
    11ca:	f9 01       	movw	r30, r18
    11cc:	80 83       	st	Z, r24
    11ce:	26 ef       	ldi	r18, 0xF6	; 246
    11d0:	30 e0       	ldi	r19, 0x00	; 0
    11d2:	ce 01       	movw	r24, r28
    11d4:	05 96       	adiw	r24, 0x05	; 5
    11d6:	02 96       	adiw	r24, 0x02	; 2
    11d8:	fc 01       	movw	r30, r24
    11da:	80 81       	ld	r24, Z
    11dc:	48 2f       	mov	r20, r24
    11de:	44 0f       	add	r20, r20
    11e0:	44 0f       	add	r20, r20
    11e2:	44 0f       	add	r20, r20
    11e4:	ce 01       	movw	r24, r28
    11e6:	05 96       	adiw	r24, 0x05	; 5
    11e8:	01 96       	adiw	r24, 0x01	; 1
    11ea:	fc 01       	movw	r30, r24
    11ec:	80 81       	ld	r24, Z
    11ee:	82 95       	swap	r24
    11f0:	86 95       	lsr	r24
    11f2:	87 70       	andi	r24, 0x07	; 7
    11f4:	84 0f       	add	r24, r20
    11f6:	f9 01       	movw	r30, r18
    11f8:	80 83       	st	Z, r24
    11fa:	25 ef       	ldi	r18, 0xF5	; 245
    11fc:	30 e0       	ldi	r19, 0x00	; 0
    11fe:	ce 01       	movw	r24, r28
    1200:	05 96       	adiw	r24, 0x05	; 5
    1202:	01 96       	adiw	r24, 0x01	; 1
    1204:	fc 01       	movw	r30, r24
    1206:	80 81       	ld	r24, Z
    1208:	48 2f       	mov	r20, r24
    120a:	44 0f       	add	r20, r20
    120c:	44 0f       	add	r20, r20
    120e:	44 0f       	add	r20, r20
    1210:	ce 01       	movw	r24, r28
    1212:	05 96       	adiw	r24, 0x05	; 5
    1214:	fc 01       	movw	r30, r24
    1216:	80 81       	ld	r24, Z
    1218:	82 95       	swap	r24
    121a:	86 95       	lsr	r24
    121c:	87 70       	andi	r24, 0x07	; 7
    121e:	84 0f       	add	r24, r20
    1220:	f9 01       	movw	r30, r18
    1222:	80 83       	st	Z, r24
    1224:	84 ef       	ldi	r24, 0xF4	; 244
    1226:	90 e0       	ldi	r25, 0x00	; 0
    1228:	9e 01       	movw	r18, r28
    122a:	2b 5f       	subi	r18, 0xFB	; 251
    122c:	3f 4f       	sbci	r19, 0xFF	; 255
    122e:	f9 01       	movw	r30, r18
    1230:	20 81       	ld	r18, Z
    1232:	22 0f       	add	r18, r18
    1234:	22 0f       	add	r18, r18
    1236:	22 0f       	add	r18, r18
    1238:	fc 01       	movw	r30, r24
    123a:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    123c:	8f ee       	ldi	r24, 0xEF	; 239
    123e:	90 e0       	ldi	r25, 0x00	; 0
    1240:	2f ee       	ldi	r18, 0xEF	; 239
    1242:	30 e0       	ldi	r19, 0x00	; 0
    1244:	f9 01       	movw	r30, r18
    1246:	40 81       	ld	r20, Z
    1248:	29 85       	ldd	r18, Y+9	; 0x09
    124a:	3a 85       	ldd	r19, Y+10	; 0x0a
    124c:	f9 01       	movw	r30, r18
    124e:	26 81       	ldd	r18, Z+6	; 0x06
    1250:	24 2b       	or	r18, r20
    1252:	fc 01       	movw	r30, r24
    1254:	20 83       	st	Z, r18
          Can_clear_rtrmsk();
    1256:	84 ef       	ldi	r24, 0xF4	; 244
    1258:	90 e0       	ldi	r25, 0x00	; 0
    125a:	24 ef       	ldi	r18, 0xF4	; 244
    125c:	30 e0       	ldi	r19, 0x00	; 0
    125e:	f9 01       	movw	r30, r18
    1260:	20 81       	ld	r18, Z
    1262:	2b 7f       	andi	r18, 0xFB	; 251
    1264:	fc 01       	movw	r30, r24
    1266:	20 83       	st	Z, r18
          Can_clear_idemsk();
    1268:	84 ef       	ldi	r24, 0xF4	; 244
    126a:	90 e0       	ldi	r25, 0x00	; 0
    126c:	24 ef       	ldi	r18, 0xF4	; 244
    126e:	30 e0       	ldi	r19, 0x00	; 0
    1270:	f9 01       	movw	r30, r18
    1272:	20 81       	ld	r18, Z
    1274:	2e 7f       	andi	r18, 0xFE	; 254
    1276:	fc 01       	movw	r30, r24
    1278:	20 83       	st	Z, r18
          Can_config_rx();       
    127a:	8f ee       	ldi	r24, 0xEF	; 239
    127c:	90 e0       	ldi	r25, 0x00	; 0
    127e:	2f ee       	ldi	r18, 0xEF	; 239
    1280:	30 e0       	ldi	r19, 0x00	; 0
    1282:	f9 01       	movw	r30, r18
    1284:	20 81       	ld	r18, Z
    1286:	2f 73       	andi	r18, 0x3F	; 63
    1288:	fc 01       	movw	r30, r24
    128a:	20 83       	st	Z, r18
    128c:	8f ee       	ldi	r24, 0xEF	; 239
    128e:	90 e0       	ldi	r25, 0x00	; 0
    1290:	2f ee       	ldi	r18, 0xEF	; 239
    1292:	30 e0       	ldi	r19, 0x00	; 0
    1294:	f9 01       	movw	r30, r18
    1296:	20 81       	ld	r18, Z
    1298:	20 68       	ori	r18, 0x80	; 128
    129a:	fc 01       	movw	r30, r24
    129c:	20 83       	st	Z, r18
          break;
    129e:	d4 c6       	rjmp	.+3496   	; 0x2048 <__stack+0xf49>
        //------------      
        case CMD_RX_DATA:
          u32_temp=0; Can_set_ext_msk(u32_temp);
    12a0:	1d 82       	std	Y+5, r1	; 0x05
    12a2:	1e 82       	std	Y+6, r1	; 0x06
    12a4:	1f 82       	std	Y+7, r1	; 0x07
    12a6:	18 86       	std	Y+8, r1	; 0x08
    12a8:	27 ef       	ldi	r18, 0xF7	; 247
    12aa:	30 e0       	ldi	r19, 0x00	; 0
    12ac:	ce 01       	movw	r24, r28
    12ae:	05 96       	adiw	r24, 0x05	; 5
    12b0:	03 96       	adiw	r24, 0x03	; 3
    12b2:	fc 01       	movw	r30, r24
    12b4:	80 81       	ld	r24, Z
    12b6:	48 2f       	mov	r20, r24
    12b8:	44 0f       	add	r20, r20
    12ba:	44 0f       	add	r20, r20
    12bc:	44 0f       	add	r20, r20
    12be:	ce 01       	movw	r24, r28
    12c0:	05 96       	adiw	r24, 0x05	; 5
    12c2:	02 96       	adiw	r24, 0x02	; 2
    12c4:	fc 01       	movw	r30, r24
    12c6:	80 81       	ld	r24, Z
    12c8:	82 95       	swap	r24
    12ca:	86 95       	lsr	r24
    12cc:	87 70       	andi	r24, 0x07	; 7
    12ce:	84 0f       	add	r24, r20
    12d0:	f9 01       	movw	r30, r18
    12d2:	80 83       	st	Z, r24
    12d4:	26 ef       	ldi	r18, 0xF6	; 246
    12d6:	30 e0       	ldi	r19, 0x00	; 0
    12d8:	ce 01       	movw	r24, r28
    12da:	05 96       	adiw	r24, 0x05	; 5
    12dc:	02 96       	adiw	r24, 0x02	; 2
    12de:	fc 01       	movw	r30, r24
    12e0:	80 81       	ld	r24, Z
    12e2:	48 2f       	mov	r20, r24
    12e4:	44 0f       	add	r20, r20
    12e6:	44 0f       	add	r20, r20
    12e8:	44 0f       	add	r20, r20
    12ea:	ce 01       	movw	r24, r28
    12ec:	05 96       	adiw	r24, 0x05	; 5
    12ee:	01 96       	adiw	r24, 0x01	; 1
    12f0:	fc 01       	movw	r30, r24
    12f2:	80 81       	ld	r24, Z
    12f4:	82 95       	swap	r24
    12f6:	86 95       	lsr	r24
    12f8:	87 70       	andi	r24, 0x07	; 7
    12fa:	84 0f       	add	r24, r20
    12fc:	f9 01       	movw	r30, r18
    12fe:	80 83       	st	Z, r24
    1300:	25 ef       	ldi	r18, 0xF5	; 245
    1302:	30 e0       	ldi	r19, 0x00	; 0
    1304:	ce 01       	movw	r24, r28
    1306:	05 96       	adiw	r24, 0x05	; 5
    1308:	01 96       	adiw	r24, 0x01	; 1
    130a:	fc 01       	movw	r30, r24
    130c:	80 81       	ld	r24, Z
    130e:	48 2f       	mov	r20, r24
    1310:	44 0f       	add	r20, r20
    1312:	44 0f       	add	r20, r20
    1314:	44 0f       	add	r20, r20
    1316:	ce 01       	movw	r24, r28
    1318:	05 96       	adiw	r24, 0x05	; 5
    131a:	fc 01       	movw	r30, r24
    131c:	80 81       	ld	r24, Z
    131e:	82 95       	swap	r24
    1320:	86 95       	lsr	r24
    1322:	87 70       	andi	r24, 0x07	; 7
    1324:	84 0f       	add	r24, r20
    1326:	f9 01       	movw	r30, r18
    1328:	80 83       	st	Z, r24
    132a:	84 ef       	ldi	r24, 0xF4	; 244
    132c:	90 e0       	ldi	r25, 0x00	; 0
    132e:	9e 01       	movw	r18, r28
    1330:	2b 5f       	subi	r18, 0xFB	; 251
    1332:	3f 4f       	sbci	r19, 0xFF	; 255
    1334:	f9 01       	movw	r30, r18
    1336:	20 81       	ld	r18, Z
    1338:	22 0f       	add	r18, r18
    133a:	22 0f       	add	r18, r18
    133c:	22 0f       	add	r18, r18
    133e:	fc 01       	movw	r30, r24
    1340:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    1342:	8f ee       	ldi	r24, 0xEF	; 239
    1344:	90 e0       	ldi	r25, 0x00	; 0
    1346:	2f ee       	ldi	r18, 0xEF	; 239
    1348:	30 e0       	ldi	r19, 0x00	; 0
    134a:	f9 01       	movw	r30, r18
    134c:	40 81       	ld	r20, Z
    134e:	29 85       	ldd	r18, Y+9	; 0x09
    1350:	3a 85       	ldd	r19, Y+10	; 0x0a
    1352:	f9 01       	movw	r30, r18
    1354:	26 81       	ldd	r18, Z+6	; 0x06
    1356:	24 2b       	or	r18, r20
    1358:	fc 01       	movw	r30, r24
    135a:	20 83       	st	Z, r18
          cmd->ctrl.rtr=0; Can_set_rtrmsk(); Can_clear_rtr();
    135c:	89 85       	ldd	r24, Y+9	; 0x09
    135e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1360:	fc 01       	movw	r30, r24
    1362:	12 86       	std	Z+10, r1	; 0x0a
    1364:	84 ef       	ldi	r24, 0xF4	; 244
    1366:	90 e0       	ldi	r25, 0x00	; 0
    1368:	24 ef       	ldi	r18, 0xF4	; 244
    136a:	30 e0       	ldi	r19, 0x00	; 0
    136c:	f9 01       	movw	r30, r18
    136e:	20 81       	ld	r18, Z
    1370:	24 60       	ori	r18, 0x04	; 4
    1372:	fc 01       	movw	r30, r24
    1374:	20 83       	st	Z, r18
    1376:	80 ef       	ldi	r24, 0xF0	; 240
    1378:	90 e0       	ldi	r25, 0x00	; 0
    137a:	20 ef       	ldi	r18, 0xF0	; 240
    137c:	30 e0       	ldi	r19, 0x00	; 0
    137e:	f9 01       	movw	r30, r18
    1380:	20 81       	ld	r18, Z
    1382:	2b 7f       	andi	r18, 0xFB	; 251
    1384:	fc 01       	movw	r30, r24
    1386:	20 83       	st	Z, r18
          Can_clear_idemsk();
    1388:	84 ef       	ldi	r24, 0xF4	; 244
    138a:	90 e0       	ldi	r25, 0x00	; 0
    138c:	24 ef       	ldi	r18, 0xF4	; 244
    138e:	30 e0       	ldi	r19, 0x00	; 0
    1390:	f9 01       	movw	r30, r18
    1392:	20 81       	ld	r18, Z
    1394:	2e 7f       	andi	r18, 0xFE	; 254
    1396:	fc 01       	movw	r30, r24
    1398:	20 83       	st	Z, r18
          Can_config_rx();       
    139a:	8f ee       	ldi	r24, 0xEF	; 239
    139c:	90 e0       	ldi	r25, 0x00	; 0
    139e:	2f ee       	ldi	r18, 0xEF	; 239
    13a0:	30 e0       	ldi	r19, 0x00	; 0
    13a2:	f9 01       	movw	r30, r18
    13a4:	20 81       	ld	r18, Z
    13a6:	2f 73       	andi	r18, 0x3F	; 63
    13a8:	fc 01       	movw	r30, r24
    13aa:	20 83       	st	Z, r18
    13ac:	8f ee       	ldi	r24, 0xEF	; 239
    13ae:	90 e0       	ldi	r25, 0x00	; 0
    13b0:	2f ee       	ldi	r18, 0xEF	; 239
    13b2:	30 e0       	ldi	r19, 0x00	; 0
    13b4:	f9 01       	movw	r30, r18
    13b6:	20 81       	ld	r18, Z
    13b8:	20 68       	ori	r18, 0x80	; 128
    13ba:	fc 01       	movw	r30, r24
    13bc:	20 83       	st	Z, r18
          break;
    13be:	44 c6       	rjmp	.+3208   	; 0x2048 <__stack+0xf49>
        //------------      
        case CMD_RX_REMOTE:
          u32_temp=0; Can_set_ext_msk(u32_temp);
    13c0:	1d 82       	std	Y+5, r1	; 0x05
    13c2:	1e 82       	std	Y+6, r1	; 0x06
    13c4:	1f 82       	std	Y+7, r1	; 0x07
    13c6:	18 86       	std	Y+8, r1	; 0x08
    13c8:	27 ef       	ldi	r18, 0xF7	; 247
    13ca:	30 e0       	ldi	r19, 0x00	; 0
    13cc:	ce 01       	movw	r24, r28
    13ce:	05 96       	adiw	r24, 0x05	; 5
    13d0:	03 96       	adiw	r24, 0x03	; 3
    13d2:	fc 01       	movw	r30, r24
    13d4:	80 81       	ld	r24, Z
    13d6:	48 2f       	mov	r20, r24
    13d8:	44 0f       	add	r20, r20
    13da:	44 0f       	add	r20, r20
    13dc:	44 0f       	add	r20, r20
    13de:	ce 01       	movw	r24, r28
    13e0:	05 96       	adiw	r24, 0x05	; 5
    13e2:	02 96       	adiw	r24, 0x02	; 2
    13e4:	fc 01       	movw	r30, r24
    13e6:	80 81       	ld	r24, Z
    13e8:	82 95       	swap	r24
    13ea:	86 95       	lsr	r24
    13ec:	87 70       	andi	r24, 0x07	; 7
    13ee:	84 0f       	add	r24, r20
    13f0:	f9 01       	movw	r30, r18
    13f2:	80 83       	st	Z, r24
    13f4:	26 ef       	ldi	r18, 0xF6	; 246
    13f6:	30 e0       	ldi	r19, 0x00	; 0
    13f8:	ce 01       	movw	r24, r28
    13fa:	05 96       	adiw	r24, 0x05	; 5
    13fc:	02 96       	adiw	r24, 0x02	; 2
    13fe:	fc 01       	movw	r30, r24
    1400:	80 81       	ld	r24, Z
    1402:	48 2f       	mov	r20, r24
    1404:	44 0f       	add	r20, r20
    1406:	44 0f       	add	r20, r20
    1408:	44 0f       	add	r20, r20
    140a:	ce 01       	movw	r24, r28
    140c:	05 96       	adiw	r24, 0x05	; 5
    140e:	01 96       	adiw	r24, 0x01	; 1
    1410:	fc 01       	movw	r30, r24
    1412:	80 81       	ld	r24, Z
    1414:	82 95       	swap	r24
    1416:	86 95       	lsr	r24
    1418:	87 70       	andi	r24, 0x07	; 7
    141a:	84 0f       	add	r24, r20
    141c:	f9 01       	movw	r30, r18
    141e:	80 83       	st	Z, r24
    1420:	25 ef       	ldi	r18, 0xF5	; 245
    1422:	30 e0       	ldi	r19, 0x00	; 0
    1424:	ce 01       	movw	r24, r28
    1426:	05 96       	adiw	r24, 0x05	; 5
    1428:	01 96       	adiw	r24, 0x01	; 1
    142a:	fc 01       	movw	r30, r24
    142c:	80 81       	ld	r24, Z
    142e:	48 2f       	mov	r20, r24
    1430:	44 0f       	add	r20, r20
    1432:	44 0f       	add	r20, r20
    1434:	44 0f       	add	r20, r20
    1436:	ce 01       	movw	r24, r28
    1438:	05 96       	adiw	r24, 0x05	; 5
    143a:	fc 01       	movw	r30, r24
    143c:	80 81       	ld	r24, Z
    143e:	82 95       	swap	r24
    1440:	86 95       	lsr	r24
    1442:	87 70       	andi	r24, 0x07	; 7
    1444:	84 0f       	add	r24, r20
    1446:	f9 01       	movw	r30, r18
    1448:	80 83       	st	Z, r24
    144a:	84 ef       	ldi	r24, 0xF4	; 244
    144c:	90 e0       	ldi	r25, 0x00	; 0
    144e:	9e 01       	movw	r18, r28
    1450:	2b 5f       	subi	r18, 0xFB	; 251
    1452:	3f 4f       	sbci	r19, 0xFF	; 255
    1454:	f9 01       	movw	r30, r18
    1456:	20 81       	ld	r18, Z
    1458:	22 0f       	add	r18, r18
    145a:	22 0f       	add	r18, r18
    145c:	22 0f       	add	r18, r18
    145e:	fc 01       	movw	r30, r24
    1460:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    1462:	8f ee       	ldi	r24, 0xEF	; 239
    1464:	90 e0       	ldi	r25, 0x00	; 0
    1466:	2f ee       	ldi	r18, 0xEF	; 239
    1468:	30 e0       	ldi	r19, 0x00	; 0
    146a:	f9 01       	movw	r30, r18
    146c:	40 81       	ld	r20, Z
    146e:	29 85       	ldd	r18, Y+9	; 0x09
    1470:	3a 85       	ldd	r19, Y+10	; 0x0a
    1472:	f9 01       	movw	r30, r18
    1474:	26 81       	ldd	r18, Z+6	; 0x06
    1476:	24 2b       	or	r18, r20
    1478:	fc 01       	movw	r30, r24
    147a:	20 83       	st	Z, r18
          cmd->ctrl.rtr=1; Can_set_rtrmsk(); Can_set_rtr();
    147c:	89 85       	ldd	r24, Y+9	; 0x09
    147e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1480:	21 e0       	ldi	r18, 0x01	; 1
    1482:	fc 01       	movw	r30, r24
    1484:	22 87       	std	Z+10, r18	; 0x0a
    1486:	84 ef       	ldi	r24, 0xF4	; 244
    1488:	90 e0       	ldi	r25, 0x00	; 0
    148a:	24 ef       	ldi	r18, 0xF4	; 244
    148c:	30 e0       	ldi	r19, 0x00	; 0
    148e:	f9 01       	movw	r30, r18
    1490:	20 81       	ld	r18, Z
    1492:	24 60       	ori	r18, 0x04	; 4
    1494:	fc 01       	movw	r30, r24
    1496:	20 83       	st	Z, r18
    1498:	80 ef       	ldi	r24, 0xF0	; 240
    149a:	90 e0       	ldi	r25, 0x00	; 0
    149c:	20 ef       	ldi	r18, 0xF0	; 240
    149e:	30 e0       	ldi	r19, 0x00	; 0
    14a0:	f9 01       	movw	r30, r18
    14a2:	20 81       	ld	r18, Z
    14a4:	24 60       	ori	r18, 0x04	; 4
    14a6:	fc 01       	movw	r30, r24
    14a8:	20 83       	st	Z, r18
          Can_clear_rplv();
    14aa:	8f ee       	ldi	r24, 0xEF	; 239
    14ac:	90 e0       	ldi	r25, 0x00	; 0
    14ae:	2f ee       	ldi	r18, 0xEF	; 239
    14b0:	30 e0       	ldi	r19, 0x00	; 0
    14b2:	f9 01       	movw	r30, r18
    14b4:	20 81       	ld	r18, Z
    14b6:	2f 7d       	andi	r18, 0xDF	; 223
    14b8:	fc 01       	movw	r30, r24
    14ba:	20 83       	st	Z, r18
          Can_clear_idemsk();
    14bc:	84 ef       	ldi	r24, 0xF4	; 244
    14be:	90 e0       	ldi	r25, 0x00	; 0
    14c0:	24 ef       	ldi	r18, 0xF4	; 244
    14c2:	30 e0       	ldi	r19, 0x00	; 0
    14c4:	f9 01       	movw	r30, r18
    14c6:	20 81       	ld	r18, Z
    14c8:	2e 7f       	andi	r18, 0xFE	; 254
    14ca:	fc 01       	movw	r30, r24
    14cc:	20 83       	st	Z, r18
          Can_config_rx();       
    14ce:	8f ee       	ldi	r24, 0xEF	; 239
    14d0:	90 e0       	ldi	r25, 0x00	; 0
    14d2:	2f ee       	ldi	r18, 0xEF	; 239
    14d4:	30 e0       	ldi	r19, 0x00	; 0
    14d6:	f9 01       	movw	r30, r18
    14d8:	20 81       	ld	r18, Z
    14da:	2f 73       	andi	r18, 0x3F	; 63
    14dc:	fc 01       	movw	r30, r24
    14de:	20 83       	st	Z, r18
    14e0:	8f ee       	ldi	r24, 0xEF	; 239
    14e2:	90 e0       	ldi	r25, 0x00	; 0
    14e4:	2f ee       	ldi	r18, 0xEF	; 239
    14e6:	30 e0       	ldi	r19, 0x00	; 0
    14e8:	f9 01       	movw	r30, r18
    14ea:	20 81       	ld	r18, Z
    14ec:	20 68       	ori	r18, 0x80	; 128
    14ee:	fc 01       	movw	r30, r24
    14f0:	20 83       	st	Z, r18
          break;
    14f2:	aa c5       	rjmp	.+2900   	; 0x2048 <__stack+0xf49>
        //------------      
        case CMD_RX_MASKED:
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
    14f4:	89 85       	ldd	r24, Y+9	; 0x09
    14f6:	9a 85       	ldd	r25, Y+10	; 0x0a
    14f8:	fc 01       	movw	r30, r24
    14fa:	83 85       	ldd	r24, Z+11	; 0x0b
    14fc:	88 23       	and	r24, r24
    14fe:	09 f4       	brne	.+2      	; 0x1502 <__stack+0x403>
    1500:	69 c0       	rjmp	.+210    	; 0x15d4 <__stack+0x4d5>
    1502:	83 ef       	ldi	r24, 0xF3	; 243
    1504:	90 e0       	ldi	r25, 0x00	; 0
    1506:	29 85       	ldd	r18, Y+9	; 0x09
    1508:	3a 85       	ldd	r19, Y+10	; 0x0a
    150a:	2e 5f       	subi	r18, 0xFE	; 254
    150c:	3f 4f       	sbci	r19, 0xFF	; 255
    150e:	2d 5f       	subi	r18, 0xFD	; 253
    1510:	3f 4f       	sbci	r19, 0xFF	; 255
    1512:	f9 01       	movw	r30, r18
    1514:	20 81       	ld	r18, Z
    1516:	42 2f       	mov	r20, r18
    1518:	44 0f       	add	r20, r20
    151a:	44 0f       	add	r20, r20
    151c:	44 0f       	add	r20, r20
    151e:	29 85       	ldd	r18, Y+9	; 0x09
    1520:	3a 85       	ldd	r19, Y+10	; 0x0a
    1522:	2e 5f       	subi	r18, 0xFE	; 254
    1524:	3f 4f       	sbci	r19, 0xFF	; 255
    1526:	2e 5f       	subi	r18, 0xFE	; 254
    1528:	3f 4f       	sbci	r19, 0xFF	; 255
    152a:	f9 01       	movw	r30, r18
    152c:	20 81       	ld	r18, Z
    152e:	22 95       	swap	r18
    1530:	26 95       	lsr	r18
    1532:	27 70       	andi	r18, 0x07	; 7
    1534:	24 0f       	add	r18, r20
    1536:	fc 01       	movw	r30, r24
    1538:	20 83       	st	Z, r18
    153a:	82 ef       	ldi	r24, 0xF2	; 242
    153c:	90 e0       	ldi	r25, 0x00	; 0
    153e:	29 85       	ldd	r18, Y+9	; 0x09
    1540:	3a 85       	ldd	r19, Y+10	; 0x0a
    1542:	2e 5f       	subi	r18, 0xFE	; 254
    1544:	3f 4f       	sbci	r19, 0xFF	; 255
    1546:	2e 5f       	subi	r18, 0xFE	; 254
    1548:	3f 4f       	sbci	r19, 0xFF	; 255
    154a:	f9 01       	movw	r30, r18
    154c:	20 81       	ld	r18, Z
    154e:	42 2f       	mov	r20, r18
    1550:	44 0f       	add	r20, r20
    1552:	44 0f       	add	r20, r20
    1554:	44 0f       	add	r20, r20
    1556:	29 85       	ldd	r18, Y+9	; 0x09
    1558:	3a 85       	ldd	r19, Y+10	; 0x0a
    155a:	2e 5f       	subi	r18, 0xFE	; 254
    155c:	3f 4f       	sbci	r19, 0xFF	; 255
    155e:	2f 5f       	subi	r18, 0xFF	; 255
    1560:	3f 4f       	sbci	r19, 0xFF	; 255
    1562:	f9 01       	movw	r30, r18
    1564:	20 81       	ld	r18, Z
    1566:	22 95       	swap	r18
    1568:	26 95       	lsr	r18
    156a:	27 70       	andi	r18, 0x07	; 7
    156c:	24 0f       	add	r18, r20
    156e:	fc 01       	movw	r30, r24
    1570:	20 83       	st	Z, r18
    1572:	81 ef       	ldi	r24, 0xF1	; 241
    1574:	90 e0       	ldi	r25, 0x00	; 0
    1576:	29 85       	ldd	r18, Y+9	; 0x09
    1578:	3a 85       	ldd	r19, Y+10	; 0x0a
    157a:	2e 5f       	subi	r18, 0xFE	; 254
    157c:	3f 4f       	sbci	r19, 0xFF	; 255
    157e:	2f 5f       	subi	r18, 0xFF	; 255
    1580:	3f 4f       	sbci	r19, 0xFF	; 255
    1582:	f9 01       	movw	r30, r18
    1584:	20 81       	ld	r18, Z
    1586:	42 2f       	mov	r20, r18
    1588:	44 0f       	add	r20, r20
    158a:	44 0f       	add	r20, r20
    158c:	44 0f       	add	r20, r20
    158e:	29 85       	ldd	r18, Y+9	; 0x09
    1590:	3a 85       	ldd	r19, Y+10	; 0x0a
    1592:	2e 5f       	subi	r18, 0xFE	; 254
    1594:	3f 4f       	sbci	r19, 0xFF	; 255
    1596:	f9 01       	movw	r30, r18
    1598:	20 81       	ld	r18, Z
    159a:	22 95       	swap	r18
    159c:	26 95       	lsr	r18
    159e:	27 70       	andi	r18, 0x07	; 7
    15a0:	24 0f       	add	r18, r20
    15a2:	fc 01       	movw	r30, r24
    15a4:	20 83       	st	Z, r18
    15a6:	80 ef       	ldi	r24, 0xF0	; 240
    15a8:	90 e0       	ldi	r25, 0x00	; 0
    15aa:	29 85       	ldd	r18, Y+9	; 0x09
    15ac:	3a 85       	ldd	r19, Y+10	; 0x0a
    15ae:	2e 5f       	subi	r18, 0xFE	; 254
    15b0:	3f 4f       	sbci	r19, 0xFF	; 255
    15b2:	f9 01       	movw	r30, r18
    15b4:	20 81       	ld	r18, Z
    15b6:	22 0f       	add	r18, r18
    15b8:	22 0f       	add	r18, r18
    15ba:	22 0f       	add	r18, r18
    15bc:	fc 01       	movw	r30, r24
    15be:	20 83       	st	Z, r18
    15c0:	8f ee       	ldi	r24, 0xEF	; 239
    15c2:	90 e0       	ldi	r25, 0x00	; 0
    15c4:	2f ee       	ldi	r18, 0xEF	; 239
    15c6:	30 e0       	ldi	r19, 0x00	; 0
    15c8:	f9 01       	movw	r30, r18
    15ca:	20 81       	ld	r18, Z
    15cc:	20 61       	ori	r18, 0x10	; 16
    15ce:	fc 01       	movw	r30, r24
    15d0:	20 83       	st	Z, r18
    15d2:	30 c0       	rjmp	.+96     	; 0x1634 <__stack+0x535>
          else              { Can_set_std_id(cmd->id.std);}
    15d4:	83 ef       	ldi	r24, 0xF3	; 243
    15d6:	90 e0       	ldi	r25, 0x00	; 0
    15d8:	29 85       	ldd	r18, Y+9	; 0x09
    15da:	3a 85       	ldd	r19, Y+10	; 0x0a
    15dc:	2e 5f       	subi	r18, 0xFE	; 254
    15de:	3f 4f       	sbci	r19, 0xFF	; 255
    15e0:	2f 5f       	subi	r18, 0xFF	; 255
    15e2:	3f 4f       	sbci	r19, 0xFF	; 255
    15e4:	f9 01       	movw	r30, r18
    15e6:	20 81       	ld	r18, Z
    15e8:	42 2f       	mov	r20, r18
    15ea:	42 95       	swap	r20
    15ec:	44 0f       	add	r20, r20
    15ee:	40 7e       	andi	r20, 0xE0	; 224
    15f0:	29 85       	ldd	r18, Y+9	; 0x09
    15f2:	3a 85       	ldd	r19, Y+10	; 0x0a
    15f4:	2e 5f       	subi	r18, 0xFE	; 254
    15f6:	3f 4f       	sbci	r19, 0xFF	; 255
    15f8:	f9 01       	movw	r30, r18
    15fa:	20 81       	ld	r18, Z
    15fc:	26 95       	lsr	r18
    15fe:	26 95       	lsr	r18
    1600:	26 95       	lsr	r18
    1602:	24 0f       	add	r18, r20
    1604:	fc 01       	movw	r30, r24
    1606:	20 83       	st	Z, r18
    1608:	82 ef       	ldi	r24, 0xF2	; 242
    160a:	90 e0       	ldi	r25, 0x00	; 0
    160c:	29 85       	ldd	r18, Y+9	; 0x09
    160e:	3a 85       	ldd	r19, Y+10	; 0x0a
    1610:	2e 5f       	subi	r18, 0xFE	; 254
    1612:	3f 4f       	sbci	r19, 0xFF	; 255
    1614:	f9 01       	movw	r30, r18
    1616:	20 81       	ld	r18, Z
    1618:	22 95       	swap	r18
    161a:	22 0f       	add	r18, r18
    161c:	20 7e       	andi	r18, 0xE0	; 224
    161e:	fc 01       	movw	r30, r24
    1620:	20 83       	st	Z, r18
    1622:	8f ee       	ldi	r24, 0xEF	; 239
    1624:	90 e0       	ldi	r25, 0x00	; 0
    1626:	2f ee       	ldi	r18, 0xEF	; 239
    1628:	30 e0       	ldi	r19, 0x00	; 0
    162a:	f9 01       	movw	r30, r18
    162c:	20 81       	ld	r18, Z
    162e:	2f 7e       	andi	r18, 0xEF	; 239
    1630:	fc 01       	movw	r30, r24
    1632:	20 83       	st	Z, r18
          u32_temp=~0; Can_set_ext_msk(u32_temp);
    1634:	8f ef       	ldi	r24, 0xFF	; 255
    1636:	9f ef       	ldi	r25, 0xFF	; 255
    1638:	dc 01       	movw	r26, r24
    163a:	8d 83       	std	Y+5, r24	; 0x05
    163c:	9e 83       	std	Y+6, r25	; 0x06
    163e:	af 83       	std	Y+7, r26	; 0x07
    1640:	b8 87       	std	Y+8, r27	; 0x08
    1642:	27 ef       	ldi	r18, 0xF7	; 247
    1644:	30 e0       	ldi	r19, 0x00	; 0
    1646:	ce 01       	movw	r24, r28
    1648:	05 96       	adiw	r24, 0x05	; 5
    164a:	03 96       	adiw	r24, 0x03	; 3
    164c:	fc 01       	movw	r30, r24
    164e:	80 81       	ld	r24, Z
    1650:	48 2f       	mov	r20, r24
    1652:	44 0f       	add	r20, r20
    1654:	44 0f       	add	r20, r20
    1656:	44 0f       	add	r20, r20
    1658:	ce 01       	movw	r24, r28
    165a:	05 96       	adiw	r24, 0x05	; 5
    165c:	02 96       	adiw	r24, 0x02	; 2
    165e:	fc 01       	movw	r30, r24
    1660:	80 81       	ld	r24, Z
    1662:	82 95       	swap	r24
    1664:	86 95       	lsr	r24
    1666:	87 70       	andi	r24, 0x07	; 7
    1668:	84 0f       	add	r24, r20
    166a:	f9 01       	movw	r30, r18
    166c:	80 83       	st	Z, r24
    166e:	26 ef       	ldi	r18, 0xF6	; 246
    1670:	30 e0       	ldi	r19, 0x00	; 0
    1672:	ce 01       	movw	r24, r28
    1674:	05 96       	adiw	r24, 0x05	; 5
    1676:	02 96       	adiw	r24, 0x02	; 2
    1678:	fc 01       	movw	r30, r24
    167a:	80 81       	ld	r24, Z
    167c:	48 2f       	mov	r20, r24
    167e:	44 0f       	add	r20, r20
    1680:	44 0f       	add	r20, r20
    1682:	44 0f       	add	r20, r20
    1684:	ce 01       	movw	r24, r28
    1686:	05 96       	adiw	r24, 0x05	; 5
    1688:	01 96       	adiw	r24, 0x01	; 1
    168a:	fc 01       	movw	r30, r24
    168c:	80 81       	ld	r24, Z
    168e:	82 95       	swap	r24
    1690:	86 95       	lsr	r24
    1692:	87 70       	andi	r24, 0x07	; 7
    1694:	84 0f       	add	r24, r20
    1696:	f9 01       	movw	r30, r18
    1698:	80 83       	st	Z, r24
    169a:	25 ef       	ldi	r18, 0xF5	; 245
    169c:	30 e0       	ldi	r19, 0x00	; 0
    169e:	ce 01       	movw	r24, r28
    16a0:	05 96       	adiw	r24, 0x05	; 5
    16a2:	01 96       	adiw	r24, 0x01	; 1
    16a4:	fc 01       	movw	r30, r24
    16a6:	80 81       	ld	r24, Z
    16a8:	48 2f       	mov	r20, r24
    16aa:	44 0f       	add	r20, r20
    16ac:	44 0f       	add	r20, r20
    16ae:	44 0f       	add	r20, r20
    16b0:	ce 01       	movw	r24, r28
    16b2:	05 96       	adiw	r24, 0x05	; 5
    16b4:	fc 01       	movw	r30, r24
    16b6:	80 81       	ld	r24, Z
    16b8:	82 95       	swap	r24
    16ba:	86 95       	lsr	r24
    16bc:	87 70       	andi	r24, 0x07	; 7
    16be:	84 0f       	add	r24, r20
    16c0:	f9 01       	movw	r30, r18
    16c2:	80 83       	st	Z, r24
    16c4:	84 ef       	ldi	r24, 0xF4	; 244
    16c6:	90 e0       	ldi	r25, 0x00	; 0
    16c8:	9e 01       	movw	r18, r28
    16ca:	2b 5f       	subi	r18, 0xFB	; 251
    16cc:	3f 4f       	sbci	r19, 0xFF	; 255
    16ce:	f9 01       	movw	r30, r18
    16d0:	20 81       	ld	r18, Z
    16d2:	22 0f       	add	r18, r18
    16d4:	22 0f       	add	r18, r18
    16d6:	22 0f       	add	r18, r18
    16d8:	fc 01       	movw	r30, r24
    16da:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    16dc:	8f ee       	ldi	r24, 0xEF	; 239
    16de:	90 e0       	ldi	r25, 0x00	; 0
    16e0:	2f ee       	ldi	r18, 0xEF	; 239
    16e2:	30 e0       	ldi	r19, 0x00	; 0
    16e4:	f9 01       	movw	r30, r18
    16e6:	40 81       	ld	r20, Z
    16e8:	29 85       	ldd	r18, Y+9	; 0x09
    16ea:	3a 85       	ldd	r19, Y+10	; 0x0a
    16ec:	f9 01       	movw	r30, r18
    16ee:	26 81       	ldd	r18, Z+6	; 0x06
    16f0:	24 2b       	or	r18, r20
    16f2:	fc 01       	movw	r30, r24
    16f4:	20 83       	st	Z, r18
          Can_clear_rtrmsk();
    16f6:	84 ef       	ldi	r24, 0xF4	; 244
    16f8:	90 e0       	ldi	r25, 0x00	; 0
    16fa:	24 ef       	ldi	r18, 0xF4	; 244
    16fc:	30 e0       	ldi	r19, 0x00	; 0
    16fe:	f9 01       	movw	r30, r18
    1700:	20 81       	ld	r18, Z
    1702:	2b 7f       	andi	r18, 0xFB	; 251
    1704:	fc 01       	movw	r30, r24
    1706:	20 83       	st	Z, r18
          Can_set_idemsk();
    1708:	84 ef       	ldi	r24, 0xF4	; 244
    170a:	90 e0       	ldi	r25, 0x00	; 0
    170c:	24 ef       	ldi	r18, 0xF4	; 244
    170e:	30 e0       	ldi	r19, 0x00	; 0
    1710:	f9 01       	movw	r30, r18
    1712:	20 81       	ld	r18, Z
    1714:	21 60       	ori	r18, 0x01	; 1
    1716:	fc 01       	movw	r30, r24
    1718:	20 83       	st	Z, r18
          Can_config_rx();       
    171a:	8f ee       	ldi	r24, 0xEF	; 239
    171c:	90 e0       	ldi	r25, 0x00	; 0
    171e:	2f ee       	ldi	r18, 0xEF	; 239
    1720:	30 e0       	ldi	r19, 0x00	; 0
    1722:	f9 01       	movw	r30, r18
    1724:	20 81       	ld	r18, Z
    1726:	2f 73       	andi	r18, 0x3F	; 63
    1728:	fc 01       	movw	r30, r24
    172a:	20 83       	st	Z, r18
    172c:	8f ee       	ldi	r24, 0xEF	; 239
    172e:	90 e0       	ldi	r25, 0x00	; 0
    1730:	2f ee       	ldi	r18, 0xEF	; 239
    1732:	30 e0       	ldi	r19, 0x00	; 0
    1734:	f9 01       	movw	r30, r18
    1736:	20 81       	ld	r18, Z
    1738:	20 68       	ori	r18, 0x80	; 128
    173a:	fc 01       	movw	r30, r24
    173c:	20 83       	st	Z, r18
          break;
    173e:	84 c4       	rjmp	.+2312   	; 0x2048 <__stack+0xf49>
        //------------      
        case CMD_RX_DATA_MASKED:
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
    1740:	89 85       	ldd	r24, Y+9	; 0x09
    1742:	9a 85       	ldd	r25, Y+10	; 0x0a
    1744:	fc 01       	movw	r30, r24
    1746:	83 85       	ldd	r24, Z+11	; 0x0b
    1748:	88 23       	and	r24, r24
    174a:	09 f4       	brne	.+2      	; 0x174e <__stack+0x64f>
    174c:	69 c0       	rjmp	.+210    	; 0x1820 <__stack+0x721>
    174e:	83 ef       	ldi	r24, 0xF3	; 243
    1750:	90 e0       	ldi	r25, 0x00	; 0
    1752:	29 85       	ldd	r18, Y+9	; 0x09
    1754:	3a 85       	ldd	r19, Y+10	; 0x0a
    1756:	2e 5f       	subi	r18, 0xFE	; 254
    1758:	3f 4f       	sbci	r19, 0xFF	; 255
    175a:	2d 5f       	subi	r18, 0xFD	; 253
    175c:	3f 4f       	sbci	r19, 0xFF	; 255
    175e:	f9 01       	movw	r30, r18
    1760:	20 81       	ld	r18, Z
    1762:	42 2f       	mov	r20, r18
    1764:	44 0f       	add	r20, r20
    1766:	44 0f       	add	r20, r20
    1768:	44 0f       	add	r20, r20
    176a:	29 85       	ldd	r18, Y+9	; 0x09
    176c:	3a 85       	ldd	r19, Y+10	; 0x0a
    176e:	2e 5f       	subi	r18, 0xFE	; 254
    1770:	3f 4f       	sbci	r19, 0xFF	; 255
    1772:	2e 5f       	subi	r18, 0xFE	; 254
    1774:	3f 4f       	sbci	r19, 0xFF	; 255
    1776:	f9 01       	movw	r30, r18
    1778:	20 81       	ld	r18, Z
    177a:	22 95       	swap	r18
    177c:	26 95       	lsr	r18
    177e:	27 70       	andi	r18, 0x07	; 7
    1780:	24 0f       	add	r18, r20
    1782:	fc 01       	movw	r30, r24
    1784:	20 83       	st	Z, r18
    1786:	82 ef       	ldi	r24, 0xF2	; 242
    1788:	90 e0       	ldi	r25, 0x00	; 0
    178a:	29 85       	ldd	r18, Y+9	; 0x09
    178c:	3a 85       	ldd	r19, Y+10	; 0x0a
    178e:	2e 5f       	subi	r18, 0xFE	; 254
    1790:	3f 4f       	sbci	r19, 0xFF	; 255
    1792:	2e 5f       	subi	r18, 0xFE	; 254
    1794:	3f 4f       	sbci	r19, 0xFF	; 255
    1796:	f9 01       	movw	r30, r18
    1798:	20 81       	ld	r18, Z
    179a:	42 2f       	mov	r20, r18
    179c:	44 0f       	add	r20, r20
    179e:	44 0f       	add	r20, r20
    17a0:	44 0f       	add	r20, r20
    17a2:	29 85       	ldd	r18, Y+9	; 0x09
    17a4:	3a 85       	ldd	r19, Y+10	; 0x0a
    17a6:	2e 5f       	subi	r18, 0xFE	; 254
    17a8:	3f 4f       	sbci	r19, 0xFF	; 255
    17aa:	2f 5f       	subi	r18, 0xFF	; 255
    17ac:	3f 4f       	sbci	r19, 0xFF	; 255
    17ae:	f9 01       	movw	r30, r18
    17b0:	20 81       	ld	r18, Z
    17b2:	22 95       	swap	r18
    17b4:	26 95       	lsr	r18
    17b6:	27 70       	andi	r18, 0x07	; 7
    17b8:	24 0f       	add	r18, r20
    17ba:	fc 01       	movw	r30, r24
    17bc:	20 83       	st	Z, r18
    17be:	81 ef       	ldi	r24, 0xF1	; 241
    17c0:	90 e0       	ldi	r25, 0x00	; 0
    17c2:	29 85       	ldd	r18, Y+9	; 0x09
    17c4:	3a 85       	ldd	r19, Y+10	; 0x0a
    17c6:	2e 5f       	subi	r18, 0xFE	; 254
    17c8:	3f 4f       	sbci	r19, 0xFF	; 255
    17ca:	2f 5f       	subi	r18, 0xFF	; 255
    17cc:	3f 4f       	sbci	r19, 0xFF	; 255
    17ce:	f9 01       	movw	r30, r18
    17d0:	20 81       	ld	r18, Z
    17d2:	42 2f       	mov	r20, r18
    17d4:	44 0f       	add	r20, r20
    17d6:	44 0f       	add	r20, r20
    17d8:	44 0f       	add	r20, r20
    17da:	29 85       	ldd	r18, Y+9	; 0x09
    17dc:	3a 85       	ldd	r19, Y+10	; 0x0a
    17de:	2e 5f       	subi	r18, 0xFE	; 254
    17e0:	3f 4f       	sbci	r19, 0xFF	; 255
    17e2:	f9 01       	movw	r30, r18
    17e4:	20 81       	ld	r18, Z
    17e6:	22 95       	swap	r18
    17e8:	26 95       	lsr	r18
    17ea:	27 70       	andi	r18, 0x07	; 7
    17ec:	24 0f       	add	r18, r20
    17ee:	fc 01       	movw	r30, r24
    17f0:	20 83       	st	Z, r18
    17f2:	80 ef       	ldi	r24, 0xF0	; 240
    17f4:	90 e0       	ldi	r25, 0x00	; 0
    17f6:	29 85       	ldd	r18, Y+9	; 0x09
    17f8:	3a 85       	ldd	r19, Y+10	; 0x0a
    17fa:	2e 5f       	subi	r18, 0xFE	; 254
    17fc:	3f 4f       	sbci	r19, 0xFF	; 255
    17fe:	f9 01       	movw	r30, r18
    1800:	20 81       	ld	r18, Z
    1802:	22 0f       	add	r18, r18
    1804:	22 0f       	add	r18, r18
    1806:	22 0f       	add	r18, r18
    1808:	fc 01       	movw	r30, r24
    180a:	20 83       	st	Z, r18
    180c:	8f ee       	ldi	r24, 0xEF	; 239
    180e:	90 e0       	ldi	r25, 0x00	; 0
    1810:	2f ee       	ldi	r18, 0xEF	; 239
    1812:	30 e0       	ldi	r19, 0x00	; 0
    1814:	f9 01       	movw	r30, r18
    1816:	20 81       	ld	r18, Z
    1818:	20 61       	ori	r18, 0x10	; 16
    181a:	fc 01       	movw	r30, r24
    181c:	20 83       	st	Z, r18
    181e:	30 c0       	rjmp	.+96     	; 0x1880 <__stack+0x781>
          else              { Can_set_std_id(cmd->id.std);}
    1820:	83 ef       	ldi	r24, 0xF3	; 243
    1822:	90 e0       	ldi	r25, 0x00	; 0
    1824:	29 85       	ldd	r18, Y+9	; 0x09
    1826:	3a 85       	ldd	r19, Y+10	; 0x0a
    1828:	2e 5f       	subi	r18, 0xFE	; 254
    182a:	3f 4f       	sbci	r19, 0xFF	; 255
    182c:	2f 5f       	subi	r18, 0xFF	; 255
    182e:	3f 4f       	sbci	r19, 0xFF	; 255
    1830:	f9 01       	movw	r30, r18
    1832:	20 81       	ld	r18, Z
    1834:	42 2f       	mov	r20, r18
    1836:	42 95       	swap	r20
    1838:	44 0f       	add	r20, r20
    183a:	40 7e       	andi	r20, 0xE0	; 224
    183c:	29 85       	ldd	r18, Y+9	; 0x09
    183e:	3a 85       	ldd	r19, Y+10	; 0x0a
    1840:	2e 5f       	subi	r18, 0xFE	; 254
    1842:	3f 4f       	sbci	r19, 0xFF	; 255
    1844:	f9 01       	movw	r30, r18
    1846:	20 81       	ld	r18, Z
    1848:	26 95       	lsr	r18
    184a:	26 95       	lsr	r18
    184c:	26 95       	lsr	r18
    184e:	24 0f       	add	r18, r20
    1850:	fc 01       	movw	r30, r24
    1852:	20 83       	st	Z, r18
    1854:	82 ef       	ldi	r24, 0xF2	; 242
    1856:	90 e0       	ldi	r25, 0x00	; 0
    1858:	29 85       	ldd	r18, Y+9	; 0x09
    185a:	3a 85       	ldd	r19, Y+10	; 0x0a
    185c:	2e 5f       	subi	r18, 0xFE	; 254
    185e:	3f 4f       	sbci	r19, 0xFF	; 255
    1860:	f9 01       	movw	r30, r18
    1862:	20 81       	ld	r18, Z
    1864:	22 95       	swap	r18
    1866:	22 0f       	add	r18, r18
    1868:	20 7e       	andi	r18, 0xE0	; 224
    186a:	fc 01       	movw	r30, r24
    186c:	20 83       	st	Z, r18
    186e:	8f ee       	ldi	r24, 0xEF	; 239
    1870:	90 e0       	ldi	r25, 0x00	; 0
    1872:	2f ee       	ldi	r18, 0xEF	; 239
    1874:	30 e0       	ldi	r19, 0x00	; 0
    1876:	f9 01       	movw	r30, r18
    1878:	20 81       	ld	r18, Z
    187a:	2f 7e       	andi	r18, 0xEF	; 239
    187c:	fc 01       	movw	r30, r24
    187e:	20 83       	st	Z, r18
          u32_temp=~0; Can_set_ext_msk(u32_temp);
    1880:	8f ef       	ldi	r24, 0xFF	; 255
    1882:	9f ef       	ldi	r25, 0xFF	; 255
    1884:	dc 01       	movw	r26, r24
    1886:	8d 83       	std	Y+5, r24	; 0x05
    1888:	9e 83       	std	Y+6, r25	; 0x06
    188a:	af 83       	std	Y+7, r26	; 0x07
    188c:	b8 87       	std	Y+8, r27	; 0x08
    188e:	27 ef       	ldi	r18, 0xF7	; 247
    1890:	30 e0       	ldi	r19, 0x00	; 0
    1892:	ce 01       	movw	r24, r28
    1894:	05 96       	adiw	r24, 0x05	; 5
    1896:	03 96       	adiw	r24, 0x03	; 3
    1898:	fc 01       	movw	r30, r24
    189a:	80 81       	ld	r24, Z
    189c:	48 2f       	mov	r20, r24
    189e:	44 0f       	add	r20, r20
    18a0:	44 0f       	add	r20, r20
    18a2:	44 0f       	add	r20, r20
    18a4:	ce 01       	movw	r24, r28
    18a6:	05 96       	adiw	r24, 0x05	; 5
    18a8:	02 96       	adiw	r24, 0x02	; 2
    18aa:	fc 01       	movw	r30, r24
    18ac:	80 81       	ld	r24, Z
    18ae:	82 95       	swap	r24
    18b0:	86 95       	lsr	r24
    18b2:	87 70       	andi	r24, 0x07	; 7
    18b4:	84 0f       	add	r24, r20
    18b6:	f9 01       	movw	r30, r18
    18b8:	80 83       	st	Z, r24
    18ba:	26 ef       	ldi	r18, 0xF6	; 246
    18bc:	30 e0       	ldi	r19, 0x00	; 0
    18be:	ce 01       	movw	r24, r28
    18c0:	05 96       	adiw	r24, 0x05	; 5
    18c2:	02 96       	adiw	r24, 0x02	; 2
    18c4:	fc 01       	movw	r30, r24
    18c6:	80 81       	ld	r24, Z
    18c8:	48 2f       	mov	r20, r24
    18ca:	44 0f       	add	r20, r20
    18cc:	44 0f       	add	r20, r20
    18ce:	44 0f       	add	r20, r20
    18d0:	ce 01       	movw	r24, r28
    18d2:	05 96       	adiw	r24, 0x05	; 5
    18d4:	01 96       	adiw	r24, 0x01	; 1
    18d6:	fc 01       	movw	r30, r24
    18d8:	80 81       	ld	r24, Z
    18da:	82 95       	swap	r24
    18dc:	86 95       	lsr	r24
    18de:	87 70       	andi	r24, 0x07	; 7
    18e0:	84 0f       	add	r24, r20
    18e2:	f9 01       	movw	r30, r18
    18e4:	80 83       	st	Z, r24
    18e6:	25 ef       	ldi	r18, 0xF5	; 245
    18e8:	30 e0       	ldi	r19, 0x00	; 0
    18ea:	ce 01       	movw	r24, r28
    18ec:	05 96       	adiw	r24, 0x05	; 5
    18ee:	01 96       	adiw	r24, 0x01	; 1
    18f0:	fc 01       	movw	r30, r24
    18f2:	80 81       	ld	r24, Z
    18f4:	48 2f       	mov	r20, r24
    18f6:	44 0f       	add	r20, r20
    18f8:	44 0f       	add	r20, r20
    18fa:	44 0f       	add	r20, r20
    18fc:	ce 01       	movw	r24, r28
    18fe:	05 96       	adiw	r24, 0x05	; 5
    1900:	fc 01       	movw	r30, r24
    1902:	80 81       	ld	r24, Z
    1904:	82 95       	swap	r24
    1906:	86 95       	lsr	r24
    1908:	87 70       	andi	r24, 0x07	; 7
    190a:	84 0f       	add	r24, r20
    190c:	f9 01       	movw	r30, r18
    190e:	80 83       	st	Z, r24
    1910:	84 ef       	ldi	r24, 0xF4	; 244
    1912:	90 e0       	ldi	r25, 0x00	; 0
    1914:	9e 01       	movw	r18, r28
    1916:	2b 5f       	subi	r18, 0xFB	; 251
    1918:	3f 4f       	sbci	r19, 0xFF	; 255
    191a:	f9 01       	movw	r30, r18
    191c:	20 81       	ld	r18, Z
    191e:	22 0f       	add	r18, r18
    1920:	22 0f       	add	r18, r18
    1922:	22 0f       	add	r18, r18
    1924:	fc 01       	movw	r30, r24
    1926:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    1928:	8f ee       	ldi	r24, 0xEF	; 239
    192a:	90 e0       	ldi	r25, 0x00	; 0
    192c:	2f ee       	ldi	r18, 0xEF	; 239
    192e:	30 e0       	ldi	r19, 0x00	; 0
    1930:	f9 01       	movw	r30, r18
    1932:	40 81       	ld	r20, Z
    1934:	29 85       	ldd	r18, Y+9	; 0x09
    1936:	3a 85       	ldd	r19, Y+10	; 0x0a
    1938:	f9 01       	movw	r30, r18
    193a:	26 81       	ldd	r18, Z+6	; 0x06
    193c:	24 2b       	or	r18, r20
    193e:	fc 01       	movw	r30, r24
    1940:	20 83       	st	Z, r18
          cmd->ctrl.rtr=0; Can_set_rtrmsk(); Can_clear_rtr();
    1942:	89 85       	ldd	r24, Y+9	; 0x09
    1944:	9a 85       	ldd	r25, Y+10	; 0x0a
    1946:	fc 01       	movw	r30, r24
    1948:	12 86       	std	Z+10, r1	; 0x0a
    194a:	84 ef       	ldi	r24, 0xF4	; 244
    194c:	90 e0       	ldi	r25, 0x00	; 0
    194e:	24 ef       	ldi	r18, 0xF4	; 244
    1950:	30 e0       	ldi	r19, 0x00	; 0
    1952:	f9 01       	movw	r30, r18
    1954:	20 81       	ld	r18, Z
    1956:	24 60       	ori	r18, 0x04	; 4
    1958:	fc 01       	movw	r30, r24
    195a:	20 83       	st	Z, r18
    195c:	80 ef       	ldi	r24, 0xF0	; 240
    195e:	90 e0       	ldi	r25, 0x00	; 0
    1960:	20 ef       	ldi	r18, 0xF0	; 240
    1962:	30 e0       	ldi	r19, 0x00	; 0
    1964:	f9 01       	movw	r30, r18
    1966:	20 81       	ld	r18, Z
    1968:	2b 7f       	andi	r18, 0xFB	; 251
    196a:	fc 01       	movw	r30, r24
    196c:	20 83       	st	Z, r18
          Can_set_idemsk();
    196e:	84 ef       	ldi	r24, 0xF4	; 244
    1970:	90 e0       	ldi	r25, 0x00	; 0
    1972:	24 ef       	ldi	r18, 0xF4	; 244
    1974:	30 e0       	ldi	r19, 0x00	; 0
    1976:	f9 01       	movw	r30, r18
    1978:	20 81       	ld	r18, Z
    197a:	21 60       	ori	r18, 0x01	; 1
    197c:	fc 01       	movw	r30, r24
    197e:	20 83       	st	Z, r18
          Can_config_rx();       
    1980:	8f ee       	ldi	r24, 0xEF	; 239
    1982:	90 e0       	ldi	r25, 0x00	; 0
    1984:	2f ee       	ldi	r18, 0xEF	; 239
    1986:	30 e0       	ldi	r19, 0x00	; 0
    1988:	f9 01       	movw	r30, r18
    198a:	20 81       	ld	r18, Z
    198c:	2f 73       	andi	r18, 0x3F	; 63
    198e:	fc 01       	movw	r30, r24
    1990:	20 83       	st	Z, r18
    1992:	8f ee       	ldi	r24, 0xEF	; 239
    1994:	90 e0       	ldi	r25, 0x00	; 0
    1996:	2f ee       	ldi	r18, 0xEF	; 239
    1998:	30 e0       	ldi	r19, 0x00	; 0
    199a:	f9 01       	movw	r30, r18
    199c:	20 81       	ld	r18, Z
    199e:	20 68       	ori	r18, 0x80	; 128
    19a0:	fc 01       	movw	r30, r24
    19a2:	20 83       	st	Z, r18
          break;
    19a4:	51 c3       	rjmp	.+1698   	; 0x2048 <__stack+0xf49>
        //------------      
        case CMD_RX_REMOTE_MASKED:
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
    19a6:	89 85       	ldd	r24, Y+9	; 0x09
    19a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    19aa:	fc 01       	movw	r30, r24
    19ac:	83 85       	ldd	r24, Z+11	; 0x0b
    19ae:	88 23       	and	r24, r24
    19b0:	09 f4       	brne	.+2      	; 0x19b4 <__stack+0x8b5>
    19b2:	69 c0       	rjmp	.+210    	; 0x1a86 <__stack+0x987>
    19b4:	83 ef       	ldi	r24, 0xF3	; 243
    19b6:	90 e0       	ldi	r25, 0x00	; 0
    19b8:	29 85       	ldd	r18, Y+9	; 0x09
    19ba:	3a 85       	ldd	r19, Y+10	; 0x0a
    19bc:	2e 5f       	subi	r18, 0xFE	; 254
    19be:	3f 4f       	sbci	r19, 0xFF	; 255
    19c0:	2d 5f       	subi	r18, 0xFD	; 253
    19c2:	3f 4f       	sbci	r19, 0xFF	; 255
    19c4:	f9 01       	movw	r30, r18
    19c6:	20 81       	ld	r18, Z
    19c8:	42 2f       	mov	r20, r18
    19ca:	44 0f       	add	r20, r20
    19cc:	44 0f       	add	r20, r20
    19ce:	44 0f       	add	r20, r20
    19d0:	29 85       	ldd	r18, Y+9	; 0x09
    19d2:	3a 85       	ldd	r19, Y+10	; 0x0a
    19d4:	2e 5f       	subi	r18, 0xFE	; 254
    19d6:	3f 4f       	sbci	r19, 0xFF	; 255
    19d8:	2e 5f       	subi	r18, 0xFE	; 254
    19da:	3f 4f       	sbci	r19, 0xFF	; 255
    19dc:	f9 01       	movw	r30, r18
    19de:	20 81       	ld	r18, Z
    19e0:	22 95       	swap	r18
    19e2:	26 95       	lsr	r18
    19e4:	27 70       	andi	r18, 0x07	; 7
    19e6:	24 0f       	add	r18, r20
    19e8:	fc 01       	movw	r30, r24
    19ea:	20 83       	st	Z, r18
    19ec:	82 ef       	ldi	r24, 0xF2	; 242
    19ee:	90 e0       	ldi	r25, 0x00	; 0
    19f0:	29 85       	ldd	r18, Y+9	; 0x09
    19f2:	3a 85       	ldd	r19, Y+10	; 0x0a
    19f4:	2e 5f       	subi	r18, 0xFE	; 254
    19f6:	3f 4f       	sbci	r19, 0xFF	; 255
    19f8:	2e 5f       	subi	r18, 0xFE	; 254
    19fa:	3f 4f       	sbci	r19, 0xFF	; 255
    19fc:	f9 01       	movw	r30, r18
    19fe:	20 81       	ld	r18, Z
    1a00:	42 2f       	mov	r20, r18
    1a02:	44 0f       	add	r20, r20
    1a04:	44 0f       	add	r20, r20
    1a06:	44 0f       	add	r20, r20
    1a08:	29 85       	ldd	r18, Y+9	; 0x09
    1a0a:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a0c:	2e 5f       	subi	r18, 0xFE	; 254
    1a0e:	3f 4f       	sbci	r19, 0xFF	; 255
    1a10:	2f 5f       	subi	r18, 0xFF	; 255
    1a12:	3f 4f       	sbci	r19, 0xFF	; 255
    1a14:	f9 01       	movw	r30, r18
    1a16:	20 81       	ld	r18, Z
    1a18:	22 95       	swap	r18
    1a1a:	26 95       	lsr	r18
    1a1c:	27 70       	andi	r18, 0x07	; 7
    1a1e:	24 0f       	add	r18, r20
    1a20:	fc 01       	movw	r30, r24
    1a22:	20 83       	st	Z, r18
    1a24:	81 ef       	ldi	r24, 0xF1	; 241
    1a26:	90 e0       	ldi	r25, 0x00	; 0
    1a28:	29 85       	ldd	r18, Y+9	; 0x09
    1a2a:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a2c:	2e 5f       	subi	r18, 0xFE	; 254
    1a2e:	3f 4f       	sbci	r19, 0xFF	; 255
    1a30:	2f 5f       	subi	r18, 0xFF	; 255
    1a32:	3f 4f       	sbci	r19, 0xFF	; 255
    1a34:	f9 01       	movw	r30, r18
    1a36:	20 81       	ld	r18, Z
    1a38:	42 2f       	mov	r20, r18
    1a3a:	44 0f       	add	r20, r20
    1a3c:	44 0f       	add	r20, r20
    1a3e:	44 0f       	add	r20, r20
    1a40:	29 85       	ldd	r18, Y+9	; 0x09
    1a42:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a44:	2e 5f       	subi	r18, 0xFE	; 254
    1a46:	3f 4f       	sbci	r19, 0xFF	; 255
    1a48:	f9 01       	movw	r30, r18
    1a4a:	20 81       	ld	r18, Z
    1a4c:	22 95       	swap	r18
    1a4e:	26 95       	lsr	r18
    1a50:	27 70       	andi	r18, 0x07	; 7
    1a52:	24 0f       	add	r18, r20
    1a54:	fc 01       	movw	r30, r24
    1a56:	20 83       	st	Z, r18
    1a58:	80 ef       	ldi	r24, 0xF0	; 240
    1a5a:	90 e0       	ldi	r25, 0x00	; 0
    1a5c:	29 85       	ldd	r18, Y+9	; 0x09
    1a5e:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a60:	2e 5f       	subi	r18, 0xFE	; 254
    1a62:	3f 4f       	sbci	r19, 0xFF	; 255
    1a64:	f9 01       	movw	r30, r18
    1a66:	20 81       	ld	r18, Z
    1a68:	22 0f       	add	r18, r18
    1a6a:	22 0f       	add	r18, r18
    1a6c:	22 0f       	add	r18, r18
    1a6e:	fc 01       	movw	r30, r24
    1a70:	20 83       	st	Z, r18
    1a72:	8f ee       	ldi	r24, 0xEF	; 239
    1a74:	90 e0       	ldi	r25, 0x00	; 0
    1a76:	2f ee       	ldi	r18, 0xEF	; 239
    1a78:	30 e0       	ldi	r19, 0x00	; 0
    1a7a:	f9 01       	movw	r30, r18
    1a7c:	20 81       	ld	r18, Z
    1a7e:	20 61       	ori	r18, 0x10	; 16
    1a80:	fc 01       	movw	r30, r24
    1a82:	20 83       	st	Z, r18
    1a84:	30 c0       	rjmp	.+96     	; 0x1ae6 <__stack+0x9e7>
          else              { Can_set_std_id(cmd->id.std);}
    1a86:	83 ef       	ldi	r24, 0xF3	; 243
    1a88:	90 e0       	ldi	r25, 0x00	; 0
    1a8a:	29 85       	ldd	r18, Y+9	; 0x09
    1a8c:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a8e:	2e 5f       	subi	r18, 0xFE	; 254
    1a90:	3f 4f       	sbci	r19, 0xFF	; 255
    1a92:	2f 5f       	subi	r18, 0xFF	; 255
    1a94:	3f 4f       	sbci	r19, 0xFF	; 255
    1a96:	f9 01       	movw	r30, r18
    1a98:	20 81       	ld	r18, Z
    1a9a:	42 2f       	mov	r20, r18
    1a9c:	42 95       	swap	r20
    1a9e:	44 0f       	add	r20, r20
    1aa0:	40 7e       	andi	r20, 0xE0	; 224
    1aa2:	29 85       	ldd	r18, Y+9	; 0x09
    1aa4:	3a 85       	ldd	r19, Y+10	; 0x0a
    1aa6:	2e 5f       	subi	r18, 0xFE	; 254
    1aa8:	3f 4f       	sbci	r19, 0xFF	; 255
    1aaa:	f9 01       	movw	r30, r18
    1aac:	20 81       	ld	r18, Z
    1aae:	26 95       	lsr	r18
    1ab0:	26 95       	lsr	r18
    1ab2:	26 95       	lsr	r18
    1ab4:	24 0f       	add	r18, r20
    1ab6:	fc 01       	movw	r30, r24
    1ab8:	20 83       	st	Z, r18
    1aba:	82 ef       	ldi	r24, 0xF2	; 242
    1abc:	90 e0       	ldi	r25, 0x00	; 0
    1abe:	29 85       	ldd	r18, Y+9	; 0x09
    1ac0:	3a 85       	ldd	r19, Y+10	; 0x0a
    1ac2:	2e 5f       	subi	r18, 0xFE	; 254
    1ac4:	3f 4f       	sbci	r19, 0xFF	; 255
    1ac6:	f9 01       	movw	r30, r18
    1ac8:	20 81       	ld	r18, Z
    1aca:	22 95       	swap	r18
    1acc:	22 0f       	add	r18, r18
    1ace:	20 7e       	andi	r18, 0xE0	; 224
    1ad0:	fc 01       	movw	r30, r24
    1ad2:	20 83       	st	Z, r18
    1ad4:	8f ee       	ldi	r24, 0xEF	; 239
    1ad6:	90 e0       	ldi	r25, 0x00	; 0
    1ad8:	2f ee       	ldi	r18, 0xEF	; 239
    1ada:	30 e0       	ldi	r19, 0x00	; 0
    1adc:	f9 01       	movw	r30, r18
    1ade:	20 81       	ld	r18, Z
    1ae0:	2f 7e       	andi	r18, 0xEF	; 239
    1ae2:	fc 01       	movw	r30, r24
    1ae4:	20 83       	st	Z, r18
          u32_temp=~0; Can_set_ext_msk(u32_temp);
    1ae6:	8f ef       	ldi	r24, 0xFF	; 255
    1ae8:	9f ef       	ldi	r25, 0xFF	; 255
    1aea:	dc 01       	movw	r26, r24
    1aec:	8d 83       	std	Y+5, r24	; 0x05
    1aee:	9e 83       	std	Y+6, r25	; 0x06
    1af0:	af 83       	std	Y+7, r26	; 0x07
    1af2:	b8 87       	std	Y+8, r27	; 0x08
    1af4:	27 ef       	ldi	r18, 0xF7	; 247
    1af6:	30 e0       	ldi	r19, 0x00	; 0
    1af8:	ce 01       	movw	r24, r28
    1afa:	05 96       	adiw	r24, 0x05	; 5
    1afc:	03 96       	adiw	r24, 0x03	; 3
    1afe:	fc 01       	movw	r30, r24
    1b00:	80 81       	ld	r24, Z
    1b02:	48 2f       	mov	r20, r24
    1b04:	44 0f       	add	r20, r20
    1b06:	44 0f       	add	r20, r20
    1b08:	44 0f       	add	r20, r20
    1b0a:	ce 01       	movw	r24, r28
    1b0c:	05 96       	adiw	r24, 0x05	; 5
    1b0e:	02 96       	adiw	r24, 0x02	; 2
    1b10:	fc 01       	movw	r30, r24
    1b12:	80 81       	ld	r24, Z
    1b14:	82 95       	swap	r24
    1b16:	86 95       	lsr	r24
    1b18:	87 70       	andi	r24, 0x07	; 7
    1b1a:	84 0f       	add	r24, r20
    1b1c:	f9 01       	movw	r30, r18
    1b1e:	80 83       	st	Z, r24
    1b20:	26 ef       	ldi	r18, 0xF6	; 246
    1b22:	30 e0       	ldi	r19, 0x00	; 0
    1b24:	ce 01       	movw	r24, r28
    1b26:	05 96       	adiw	r24, 0x05	; 5
    1b28:	02 96       	adiw	r24, 0x02	; 2
    1b2a:	fc 01       	movw	r30, r24
    1b2c:	80 81       	ld	r24, Z
    1b2e:	48 2f       	mov	r20, r24
    1b30:	44 0f       	add	r20, r20
    1b32:	44 0f       	add	r20, r20
    1b34:	44 0f       	add	r20, r20
    1b36:	ce 01       	movw	r24, r28
    1b38:	05 96       	adiw	r24, 0x05	; 5
    1b3a:	01 96       	adiw	r24, 0x01	; 1
    1b3c:	fc 01       	movw	r30, r24
    1b3e:	80 81       	ld	r24, Z
    1b40:	82 95       	swap	r24
    1b42:	86 95       	lsr	r24
    1b44:	87 70       	andi	r24, 0x07	; 7
    1b46:	84 0f       	add	r24, r20
    1b48:	f9 01       	movw	r30, r18
    1b4a:	80 83       	st	Z, r24
    1b4c:	25 ef       	ldi	r18, 0xF5	; 245
    1b4e:	30 e0       	ldi	r19, 0x00	; 0
    1b50:	ce 01       	movw	r24, r28
    1b52:	05 96       	adiw	r24, 0x05	; 5
    1b54:	01 96       	adiw	r24, 0x01	; 1
    1b56:	fc 01       	movw	r30, r24
    1b58:	80 81       	ld	r24, Z
    1b5a:	48 2f       	mov	r20, r24
    1b5c:	44 0f       	add	r20, r20
    1b5e:	44 0f       	add	r20, r20
    1b60:	44 0f       	add	r20, r20
    1b62:	ce 01       	movw	r24, r28
    1b64:	05 96       	adiw	r24, 0x05	; 5
    1b66:	fc 01       	movw	r30, r24
    1b68:	80 81       	ld	r24, Z
    1b6a:	82 95       	swap	r24
    1b6c:	86 95       	lsr	r24
    1b6e:	87 70       	andi	r24, 0x07	; 7
    1b70:	84 0f       	add	r24, r20
    1b72:	f9 01       	movw	r30, r18
    1b74:	80 83       	st	Z, r24
    1b76:	84 ef       	ldi	r24, 0xF4	; 244
    1b78:	90 e0       	ldi	r25, 0x00	; 0
    1b7a:	9e 01       	movw	r18, r28
    1b7c:	2b 5f       	subi	r18, 0xFB	; 251
    1b7e:	3f 4f       	sbci	r19, 0xFF	; 255
    1b80:	f9 01       	movw	r30, r18
    1b82:	20 81       	ld	r18, Z
    1b84:	22 0f       	add	r18, r18
    1b86:	22 0f       	add	r18, r18
    1b88:	22 0f       	add	r18, r18
    1b8a:	fc 01       	movw	r30, r24
    1b8c:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    1b8e:	8f ee       	ldi	r24, 0xEF	; 239
    1b90:	90 e0       	ldi	r25, 0x00	; 0
    1b92:	2f ee       	ldi	r18, 0xEF	; 239
    1b94:	30 e0       	ldi	r19, 0x00	; 0
    1b96:	f9 01       	movw	r30, r18
    1b98:	40 81       	ld	r20, Z
    1b9a:	29 85       	ldd	r18, Y+9	; 0x09
    1b9c:	3a 85       	ldd	r19, Y+10	; 0x0a
    1b9e:	f9 01       	movw	r30, r18
    1ba0:	26 81       	ldd	r18, Z+6	; 0x06
    1ba2:	24 2b       	or	r18, r20
    1ba4:	fc 01       	movw	r30, r24
    1ba6:	20 83       	st	Z, r18
          cmd->ctrl.rtr=1; Can_set_rtrmsk(); Can_set_rtr();
    1ba8:	89 85       	ldd	r24, Y+9	; 0x09
    1baa:	9a 85       	ldd	r25, Y+10	; 0x0a
    1bac:	21 e0       	ldi	r18, 0x01	; 1
    1bae:	fc 01       	movw	r30, r24
    1bb0:	22 87       	std	Z+10, r18	; 0x0a
    1bb2:	84 ef       	ldi	r24, 0xF4	; 244
    1bb4:	90 e0       	ldi	r25, 0x00	; 0
    1bb6:	24 ef       	ldi	r18, 0xF4	; 244
    1bb8:	30 e0       	ldi	r19, 0x00	; 0
    1bba:	f9 01       	movw	r30, r18
    1bbc:	20 81       	ld	r18, Z
    1bbe:	24 60       	ori	r18, 0x04	; 4
    1bc0:	fc 01       	movw	r30, r24
    1bc2:	20 83       	st	Z, r18
    1bc4:	80 ef       	ldi	r24, 0xF0	; 240
    1bc6:	90 e0       	ldi	r25, 0x00	; 0
    1bc8:	20 ef       	ldi	r18, 0xF0	; 240
    1bca:	30 e0       	ldi	r19, 0x00	; 0
    1bcc:	f9 01       	movw	r30, r18
    1bce:	20 81       	ld	r18, Z
    1bd0:	24 60       	ori	r18, 0x04	; 4
    1bd2:	fc 01       	movw	r30, r24
    1bd4:	20 83       	st	Z, r18
          Can_clear_rplv();
    1bd6:	8f ee       	ldi	r24, 0xEF	; 239
    1bd8:	90 e0       	ldi	r25, 0x00	; 0
    1bda:	2f ee       	ldi	r18, 0xEF	; 239
    1bdc:	30 e0       	ldi	r19, 0x00	; 0
    1bde:	f9 01       	movw	r30, r18
    1be0:	20 81       	ld	r18, Z
    1be2:	2f 7d       	andi	r18, 0xDF	; 223
    1be4:	fc 01       	movw	r30, r24
    1be6:	20 83       	st	Z, r18
          Can_set_idemsk();
    1be8:	84 ef       	ldi	r24, 0xF4	; 244
    1bea:	90 e0       	ldi	r25, 0x00	; 0
    1bec:	24 ef       	ldi	r18, 0xF4	; 244
    1bee:	30 e0       	ldi	r19, 0x00	; 0
    1bf0:	f9 01       	movw	r30, r18
    1bf2:	20 81       	ld	r18, Z
    1bf4:	21 60       	ori	r18, 0x01	; 1
    1bf6:	fc 01       	movw	r30, r24
    1bf8:	20 83       	st	Z, r18
          Can_config_rx();       
    1bfa:	8f ee       	ldi	r24, 0xEF	; 239
    1bfc:	90 e0       	ldi	r25, 0x00	; 0
    1bfe:	2f ee       	ldi	r18, 0xEF	; 239
    1c00:	30 e0       	ldi	r19, 0x00	; 0
    1c02:	f9 01       	movw	r30, r18
    1c04:	20 81       	ld	r18, Z
    1c06:	2f 73       	andi	r18, 0x3F	; 63
    1c08:	fc 01       	movw	r30, r24
    1c0a:	20 83       	st	Z, r18
    1c0c:	8f ee       	ldi	r24, 0xEF	; 239
    1c0e:	90 e0       	ldi	r25, 0x00	; 0
    1c10:	2f ee       	ldi	r18, 0xEF	; 239
    1c12:	30 e0       	ldi	r19, 0x00	; 0
    1c14:	f9 01       	movw	r30, r18
    1c16:	20 81       	ld	r18, Z
    1c18:	20 68       	ori	r18, 0x80	; 128
    1c1a:	fc 01       	movw	r30, r24
    1c1c:	20 83       	st	Z, r18
          break;
    1c1e:	14 c2       	rjmp	.+1064   	; 0x2048 <__stack+0xf49>
        //------------      
        case CMD_REPLY:
          for (cpt=0;cpt<cmd->dlc;cpt++) CANMSG = *(cmd->pt_data + cpt);
    1c20:	19 82       	std	Y+1, r1	; 0x01
    1c22:	13 c0       	rjmp	.+38     	; 0x1c4a <__stack+0xb4b>
    1c24:	8a ef       	ldi	r24, 0xFA	; 250
    1c26:	90 e0       	ldi	r25, 0x00	; 0
    1c28:	29 85       	ldd	r18, Y+9	; 0x09
    1c2a:	3a 85       	ldd	r19, Y+10	; 0x0a
    1c2c:	f9 01       	movw	r30, r18
    1c2e:	47 81       	ldd	r20, Z+7	; 0x07
    1c30:	50 85       	ldd	r21, Z+8	; 0x08
    1c32:	29 81       	ldd	r18, Y+1	; 0x01
    1c34:	22 2f       	mov	r18, r18
    1c36:	30 e0       	ldi	r19, 0x00	; 0
    1c38:	24 0f       	add	r18, r20
    1c3a:	35 1f       	adc	r19, r21
    1c3c:	f9 01       	movw	r30, r18
    1c3e:	20 81       	ld	r18, Z
    1c40:	fc 01       	movw	r30, r24
    1c42:	20 83       	st	Z, r18
    1c44:	89 81       	ldd	r24, Y+1	; 0x01
    1c46:	8f 5f       	subi	r24, 0xFF	; 255
    1c48:	89 83       	std	Y+1, r24	; 0x01
    1c4a:	89 85       	ldd	r24, Y+9	; 0x09
    1c4c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c4e:	fc 01       	movw	r30, r24
    1c50:	96 81       	ldd	r25, Z+6	; 0x06
    1c52:	89 81       	ldd	r24, Y+1	; 0x01
    1c54:	89 17       	cp	r24, r25
    1c56:	30 f3       	brcs	.-52     	; 0x1c24 <__stack+0xb25>
          u32_temp=0; Can_set_ext_msk(u32_temp);
    1c58:	1d 82       	std	Y+5, r1	; 0x05
    1c5a:	1e 82       	std	Y+6, r1	; 0x06
    1c5c:	1f 82       	std	Y+7, r1	; 0x07
    1c5e:	18 86       	std	Y+8, r1	; 0x08
    1c60:	27 ef       	ldi	r18, 0xF7	; 247
    1c62:	30 e0       	ldi	r19, 0x00	; 0
    1c64:	ce 01       	movw	r24, r28
    1c66:	05 96       	adiw	r24, 0x05	; 5
    1c68:	03 96       	adiw	r24, 0x03	; 3
    1c6a:	fc 01       	movw	r30, r24
    1c6c:	80 81       	ld	r24, Z
    1c6e:	48 2f       	mov	r20, r24
    1c70:	44 0f       	add	r20, r20
    1c72:	44 0f       	add	r20, r20
    1c74:	44 0f       	add	r20, r20
    1c76:	ce 01       	movw	r24, r28
    1c78:	05 96       	adiw	r24, 0x05	; 5
    1c7a:	02 96       	adiw	r24, 0x02	; 2
    1c7c:	fc 01       	movw	r30, r24
    1c7e:	80 81       	ld	r24, Z
    1c80:	82 95       	swap	r24
    1c82:	86 95       	lsr	r24
    1c84:	87 70       	andi	r24, 0x07	; 7
    1c86:	84 0f       	add	r24, r20
    1c88:	f9 01       	movw	r30, r18
    1c8a:	80 83       	st	Z, r24
    1c8c:	26 ef       	ldi	r18, 0xF6	; 246
    1c8e:	30 e0       	ldi	r19, 0x00	; 0
    1c90:	ce 01       	movw	r24, r28
    1c92:	05 96       	adiw	r24, 0x05	; 5
    1c94:	02 96       	adiw	r24, 0x02	; 2
    1c96:	fc 01       	movw	r30, r24
    1c98:	80 81       	ld	r24, Z
    1c9a:	48 2f       	mov	r20, r24
    1c9c:	44 0f       	add	r20, r20
    1c9e:	44 0f       	add	r20, r20
    1ca0:	44 0f       	add	r20, r20
    1ca2:	ce 01       	movw	r24, r28
    1ca4:	05 96       	adiw	r24, 0x05	; 5
    1ca6:	01 96       	adiw	r24, 0x01	; 1
    1ca8:	fc 01       	movw	r30, r24
    1caa:	80 81       	ld	r24, Z
    1cac:	82 95       	swap	r24
    1cae:	86 95       	lsr	r24
    1cb0:	87 70       	andi	r24, 0x07	; 7
    1cb2:	84 0f       	add	r24, r20
    1cb4:	f9 01       	movw	r30, r18
    1cb6:	80 83       	st	Z, r24
    1cb8:	25 ef       	ldi	r18, 0xF5	; 245
    1cba:	30 e0       	ldi	r19, 0x00	; 0
    1cbc:	ce 01       	movw	r24, r28
    1cbe:	05 96       	adiw	r24, 0x05	; 5
    1cc0:	01 96       	adiw	r24, 0x01	; 1
    1cc2:	fc 01       	movw	r30, r24
    1cc4:	80 81       	ld	r24, Z
    1cc6:	48 2f       	mov	r20, r24
    1cc8:	44 0f       	add	r20, r20
    1cca:	44 0f       	add	r20, r20
    1ccc:	44 0f       	add	r20, r20
    1cce:	ce 01       	movw	r24, r28
    1cd0:	05 96       	adiw	r24, 0x05	; 5
    1cd2:	fc 01       	movw	r30, r24
    1cd4:	80 81       	ld	r24, Z
    1cd6:	82 95       	swap	r24
    1cd8:	86 95       	lsr	r24
    1cda:	87 70       	andi	r24, 0x07	; 7
    1cdc:	84 0f       	add	r24, r20
    1cde:	f9 01       	movw	r30, r18
    1ce0:	80 83       	st	Z, r24
    1ce2:	84 ef       	ldi	r24, 0xF4	; 244
    1ce4:	90 e0       	ldi	r25, 0x00	; 0
    1ce6:	9e 01       	movw	r18, r28
    1ce8:	2b 5f       	subi	r18, 0xFB	; 251
    1cea:	3f 4f       	sbci	r19, 0xFF	; 255
    1cec:	f9 01       	movw	r30, r18
    1cee:	20 81       	ld	r18, Z
    1cf0:	22 0f       	add	r18, r18
    1cf2:	22 0f       	add	r18, r18
    1cf4:	22 0f       	add	r18, r18
    1cf6:	fc 01       	movw	r30, r24
    1cf8:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    1cfa:	8f ee       	ldi	r24, 0xEF	; 239
    1cfc:	90 e0       	ldi	r25, 0x00	; 0
    1cfe:	2f ee       	ldi	r18, 0xEF	; 239
    1d00:	30 e0       	ldi	r19, 0x00	; 0
    1d02:	f9 01       	movw	r30, r18
    1d04:	40 81       	ld	r20, Z
    1d06:	29 85       	ldd	r18, Y+9	; 0x09
    1d08:	3a 85       	ldd	r19, Y+10	; 0x0a
    1d0a:	f9 01       	movw	r30, r18
    1d0c:	26 81       	ldd	r18, Z+6	; 0x06
    1d0e:	24 2b       	or	r18, r20
    1d10:	fc 01       	movw	r30, r24
    1d12:	20 83       	st	Z, r18
          cmd->ctrl.rtr=1; Can_set_rtrmsk(); Can_set_rtr();
    1d14:	89 85       	ldd	r24, Y+9	; 0x09
    1d16:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d18:	21 e0       	ldi	r18, 0x01	; 1
    1d1a:	fc 01       	movw	r30, r24
    1d1c:	22 87       	std	Z+10, r18	; 0x0a
    1d1e:	84 ef       	ldi	r24, 0xF4	; 244
    1d20:	90 e0       	ldi	r25, 0x00	; 0
    1d22:	24 ef       	ldi	r18, 0xF4	; 244
    1d24:	30 e0       	ldi	r19, 0x00	; 0
    1d26:	f9 01       	movw	r30, r18
    1d28:	20 81       	ld	r18, Z
    1d2a:	24 60       	ori	r18, 0x04	; 4
    1d2c:	fc 01       	movw	r30, r24
    1d2e:	20 83       	st	Z, r18
    1d30:	80 ef       	ldi	r24, 0xF0	; 240
    1d32:	90 e0       	ldi	r25, 0x00	; 0
    1d34:	20 ef       	ldi	r18, 0xF0	; 240
    1d36:	30 e0       	ldi	r19, 0x00	; 0
    1d38:	f9 01       	movw	r30, r18
    1d3a:	20 81       	ld	r18, Z
    1d3c:	24 60       	ori	r18, 0x04	; 4
    1d3e:	fc 01       	movw	r30, r24
    1d40:	20 83       	st	Z, r18
          Can_set_rplv();
    1d42:	8f ee       	ldi	r24, 0xEF	; 239
    1d44:	90 e0       	ldi	r25, 0x00	; 0
    1d46:	2f ee       	ldi	r18, 0xEF	; 239
    1d48:	30 e0       	ldi	r19, 0x00	; 0
    1d4a:	f9 01       	movw	r30, r18
    1d4c:	20 81       	ld	r18, Z
    1d4e:	20 62       	ori	r18, 0x20	; 32
    1d50:	fc 01       	movw	r30, r24
    1d52:	20 83       	st	Z, r18
          Can_clear_idemsk();
    1d54:	84 ef       	ldi	r24, 0xF4	; 244
    1d56:	90 e0       	ldi	r25, 0x00	; 0
    1d58:	24 ef       	ldi	r18, 0xF4	; 244
    1d5a:	30 e0       	ldi	r19, 0x00	; 0
    1d5c:	f9 01       	movw	r30, r18
    1d5e:	20 81       	ld	r18, Z
    1d60:	2e 7f       	andi	r18, 0xFE	; 254
    1d62:	fc 01       	movw	r30, r24
    1d64:	20 83       	st	Z, r18
          Can_config_rx();       
    1d66:	8f ee       	ldi	r24, 0xEF	; 239
    1d68:	90 e0       	ldi	r25, 0x00	; 0
    1d6a:	2f ee       	ldi	r18, 0xEF	; 239
    1d6c:	30 e0       	ldi	r19, 0x00	; 0
    1d6e:	f9 01       	movw	r30, r18
    1d70:	20 81       	ld	r18, Z
    1d72:	2f 73       	andi	r18, 0x3F	; 63
    1d74:	fc 01       	movw	r30, r24
    1d76:	20 83       	st	Z, r18
    1d78:	8f ee       	ldi	r24, 0xEF	; 239
    1d7a:	90 e0       	ldi	r25, 0x00	; 0
    1d7c:	2f ee       	ldi	r18, 0xEF	; 239
    1d7e:	30 e0       	ldi	r19, 0x00	; 0
    1d80:	f9 01       	movw	r30, r18
    1d82:	20 81       	ld	r18, Z
    1d84:	20 68       	ori	r18, 0x80	; 128
    1d86:	fc 01       	movw	r30, r24
    1d88:	20 83       	st	Z, r18
          break;
    1d8a:	5e c1       	rjmp	.+700    	; 0x2048 <__stack+0xf49>
        //------------      
        case CMD_REPLY_MASKED:
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
    1d8c:	89 85       	ldd	r24, Y+9	; 0x09
    1d8e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d90:	fc 01       	movw	r30, r24
    1d92:	83 85       	ldd	r24, Z+11	; 0x0b
    1d94:	88 23       	and	r24, r24
    1d96:	09 f4       	brne	.+2      	; 0x1d9a <__stack+0xc9b>
    1d98:	69 c0       	rjmp	.+210    	; 0x1e6c <__stack+0xd6d>
    1d9a:	83 ef       	ldi	r24, 0xF3	; 243
    1d9c:	90 e0       	ldi	r25, 0x00	; 0
    1d9e:	29 85       	ldd	r18, Y+9	; 0x09
    1da0:	3a 85       	ldd	r19, Y+10	; 0x0a
    1da2:	2e 5f       	subi	r18, 0xFE	; 254
    1da4:	3f 4f       	sbci	r19, 0xFF	; 255
    1da6:	2d 5f       	subi	r18, 0xFD	; 253
    1da8:	3f 4f       	sbci	r19, 0xFF	; 255
    1daa:	f9 01       	movw	r30, r18
    1dac:	20 81       	ld	r18, Z
    1dae:	42 2f       	mov	r20, r18
    1db0:	44 0f       	add	r20, r20
    1db2:	44 0f       	add	r20, r20
    1db4:	44 0f       	add	r20, r20
    1db6:	29 85       	ldd	r18, Y+9	; 0x09
    1db8:	3a 85       	ldd	r19, Y+10	; 0x0a
    1dba:	2e 5f       	subi	r18, 0xFE	; 254
    1dbc:	3f 4f       	sbci	r19, 0xFF	; 255
    1dbe:	2e 5f       	subi	r18, 0xFE	; 254
    1dc0:	3f 4f       	sbci	r19, 0xFF	; 255
    1dc2:	f9 01       	movw	r30, r18
    1dc4:	20 81       	ld	r18, Z
    1dc6:	22 95       	swap	r18
    1dc8:	26 95       	lsr	r18
    1dca:	27 70       	andi	r18, 0x07	; 7
    1dcc:	24 0f       	add	r18, r20
    1dce:	fc 01       	movw	r30, r24
    1dd0:	20 83       	st	Z, r18
    1dd2:	82 ef       	ldi	r24, 0xF2	; 242
    1dd4:	90 e0       	ldi	r25, 0x00	; 0
    1dd6:	29 85       	ldd	r18, Y+9	; 0x09
    1dd8:	3a 85       	ldd	r19, Y+10	; 0x0a
    1dda:	2e 5f       	subi	r18, 0xFE	; 254
    1ddc:	3f 4f       	sbci	r19, 0xFF	; 255
    1dde:	2e 5f       	subi	r18, 0xFE	; 254
    1de0:	3f 4f       	sbci	r19, 0xFF	; 255
    1de2:	f9 01       	movw	r30, r18
    1de4:	20 81       	ld	r18, Z
    1de6:	42 2f       	mov	r20, r18
    1de8:	44 0f       	add	r20, r20
    1dea:	44 0f       	add	r20, r20
    1dec:	44 0f       	add	r20, r20
    1dee:	29 85       	ldd	r18, Y+9	; 0x09
    1df0:	3a 85       	ldd	r19, Y+10	; 0x0a
    1df2:	2e 5f       	subi	r18, 0xFE	; 254
    1df4:	3f 4f       	sbci	r19, 0xFF	; 255
    1df6:	2f 5f       	subi	r18, 0xFF	; 255
    1df8:	3f 4f       	sbci	r19, 0xFF	; 255
    1dfa:	f9 01       	movw	r30, r18
    1dfc:	20 81       	ld	r18, Z
    1dfe:	22 95       	swap	r18
    1e00:	26 95       	lsr	r18
    1e02:	27 70       	andi	r18, 0x07	; 7
    1e04:	24 0f       	add	r18, r20
    1e06:	fc 01       	movw	r30, r24
    1e08:	20 83       	st	Z, r18
    1e0a:	81 ef       	ldi	r24, 0xF1	; 241
    1e0c:	90 e0       	ldi	r25, 0x00	; 0
    1e0e:	29 85       	ldd	r18, Y+9	; 0x09
    1e10:	3a 85       	ldd	r19, Y+10	; 0x0a
    1e12:	2e 5f       	subi	r18, 0xFE	; 254
    1e14:	3f 4f       	sbci	r19, 0xFF	; 255
    1e16:	2f 5f       	subi	r18, 0xFF	; 255
    1e18:	3f 4f       	sbci	r19, 0xFF	; 255
    1e1a:	f9 01       	movw	r30, r18
    1e1c:	20 81       	ld	r18, Z
    1e1e:	42 2f       	mov	r20, r18
    1e20:	44 0f       	add	r20, r20
    1e22:	44 0f       	add	r20, r20
    1e24:	44 0f       	add	r20, r20
    1e26:	29 85       	ldd	r18, Y+9	; 0x09
    1e28:	3a 85       	ldd	r19, Y+10	; 0x0a
    1e2a:	2e 5f       	subi	r18, 0xFE	; 254
    1e2c:	3f 4f       	sbci	r19, 0xFF	; 255
    1e2e:	f9 01       	movw	r30, r18
    1e30:	20 81       	ld	r18, Z
    1e32:	22 95       	swap	r18
    1e34:	26 95       	lsr	r18
    1e36:	27 70       	andi	r18, 0x07	; 7
    1e38:	24 0f       	add	r18, r20
    1e3a:	fc 01       	movw	r30, r24
    1e3c:	20 83       	st	Z, r18
    1e3e:	80 ef       	ldi	r24, 0xF0	; 240
    1e40:	90 e0       	ldi	r25, 0x00	; 0
    1e42:	29 85       	ldd	r18, Y+9	; 0x09
    1e44:	3a 85       	ldd	r19, Y+10	; 0x0a
    1e46:	2e 5f       	subi	r18, 0xFE	; 254
    1e48:	3f 4f       	sbci	r19, 0xFF	; 255
    1e4a:	f9 01       	movw	r30, r18
    1e4c:	20 81       	ld	r18, Z
    1e4e:	22 0f       	add	r18, r18
    1e50:	22 0f       	add	r18, r18
    1e52:	22 0f       	add	r18, r18
    1e54:	fc 01       	movw	r30, r24
    1e56:	20 83       	st	Z, r18
    1e58:	8f ee       	ldi	r24, 0xEF	; 239
    1e5a:	90 e0       	ldi	r25, 0x00	; 0
    1e5c:	2f ee       	ldi	r18, 0xEF	; 239
    1e5e:	30 e0       	ldi	r19, 0x00	; 0
    1e60:	f9 01       	movw	r30, r18
    1e62:	20 81       	ld	r18, Z
    1e64:	20 61       	ori	r18, 0x10	; 16
    1e66:	fc 01       	movw	r30, r24
    1e68:	20 83       	st	Z, r18
    1e6a:	30 c0       	rjmp	.+96     	; 0x1ecc <__stack+0xdcd>
          else              { Can_set_std_id(cmd->id.std);}
    1e6c:	83 ef       	ldi	r24, 0xF3	; 243
    1e6e:	90 e0       	ldi	r25, 0x00	; 0
    1e70:	29 85       	ldd	r18, Y+9	; 0x09
    1e72:	3a 85       	ldd	r19, Y+10	; 0x0a
    1e74:	2e 5f       	subi	r18, 0xFE	; 254
    1e76:	3f 4f       	sbci	r19, 0xFF	; 255
    1e78:	2f 5f       	subi	r18, 0xFF	; 255
    1e7a:	3f 4f       	sbci	r19, 0xFF	; 255
    1e7c:	f9 01       	movw	r30, r18
    1e7e:	20 81       	ld	r18, Z
    1e80:	42 2f       	mov	r20, r18
    1e82:	42 95       	swap	r20
    1e84:	44 0f       	add	r20, r20
    1e86:	40 7e       	andi	r20, 0xE0	; 224
    1e88:	29 85       	ldd	r18, Y+9	; 0x09
    1e8a:	3a 85       	ldd	r19, Y+10	; 0x0a
    1e8c:	2e 5f       	subi	r18, 0xFE	; 254
    1e8e:	3f 4f       	sbci	r19, 0xFF	; 255
    1e90:	f9 01       	movw	r30, r18
    1e92:	20 81       	ld	r18, Z
    1e94:	26 95       	lsr	r18
    1e96:	26 95       	lsr	r18
    1e98:	26 95       	lsr	r18
    1e9a:	24 0f       	add	r18, r20
    1e9c:	fc 01       	movw	r30, r24
    1e9e:	20 83       	st	Z, r18
    1ea0:	82 ef       	ldi	r24, 0xF2	; 242
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
    1ea4:	29 85       	ldd	r18, Y+9	; 0x09
    1ea6:	3a 85       	ldd	r19, Y+10	; 0x0a
    1ea8:	2e 5f       	subi	r18, 0xFE	; 254
    1eaa:	3f 4f       	sbci	r19, 0xFF	; 255
    1eac:	f9 01       	movw	r30, r18
    1eae:	20 81       	ld	r18, Z
    1eb0:	22 95       	swap	r18
    1eb2:	22 0f       	add	r18, r18
    1eb4:	20 7e       	andi	r18, 0xE0	; 224
    1eb6:	fc 01       	movw	r30, r24
    1eb8:	20 83       	st	Z, r18
    1eba:	8f ee       	ldi	r24, 0xEF	; 239
    1ebc:	90 e0       	ldi	r25, 0x00	; 0
    1ebe:	2f ee       	ldi	r18, 0xEF	; 239
    1ec0:	30 e0       	ldi	r19, 0x00	; 0
    1ec2:	f9 01       	movw	r30, r18
    1ec4:	20 81       	ld	r18, Z
    1ec6:	2f 7e       	andi	r18, 0xEF	; 239
    1ec8:	fc 01       	movw	r30, r24
    1eca:	20 83       	st	Z, r18
          for (cpt=0;cpt<cmd->dlc;cpt++) CANMSG = *(cmd->pt_data + cpt);
    1ecc:	19 82       	std	Y+1, r1	; 0x01
    1ece:	13 c0       	rjmp	.+38     	; 0x1ef6 <__stack+0xdf7>
    1ed0:	8a ef       	ldi	r24, 0xFA	; 250
    1ed2:	90 e0       	ldi	r25, 0x00	; 0
    1ed4:	29 85       	ldd	r18, Y+9	; 0x09
    1ed6:	3a 85       	ldd	r19, Y+10	; 0x0a
    1ed8:	f9 01       	movw	r30, r18
    1eda:	47 81       	ldd	r20, Z+7	; 0x07
    1edc:	50 85       	ldd	r21, Z+8	; 0x08
    1ede:	29 81       	ldd	r18, Y+1	; 0x01
    1ee0:	22 2f       	mov	r18, r18
    1ee2:	30 e0       	ldi	r19, 0x00	; 0
    1ee4:	24 0f       	add	r18, r20
    1ee6:	35 1f       	adc	r19, r21
    1ee8:	f9 01       	movw	r30, r18
    1eea:	20 81       	ld	r18, Z
    1eec:	fc 01       	movw	r30, r24
    1eee:	20 83       	st	Z, r18
    1ef0:	89 81       	ldd	r24, Y+1	; 0x01
    1ef2:	8f 5f       	subi	r24, 0xFF	; 255
    1ef4:	89 83       	std	Y+1, r24	; 0x01
    1ef6:	89 85       	ldd	r24, Y+9	; 0x09
    1ef8:	9a 85       	ldd	r25, Y+10	; 0x0a
    1efa:	fc 01       	movw	r30, r24
    1efc:	96 81       	ldd	r25, Z+6	; 0x06
    1efe:	89 81       	ldd	r24, Y+1	; 0x01
    1f00:	89 17       	cp	r24, r25
    1f02:	30 f3       	brcs	.-52     	; 0x1ed0 <__stack+0xdd1>
          u32_temp=~0; Can_set_ext_msk(u32_temp);
    1f04:	8f ef       	ldi	r24, 0xFF	; 255
    1f06:	9f ef       	ldi	r25, 0xFF	; 255
    1f08:	dc 01       	movw	r26, r24
    1f0a:	8d 83       	std	Y+5, r24	; 0x05
    1f0c:	9e 83       	std	Y+6, r25	; 0x06
    1f0e:	af 83       	std	Y+7, r26	; 0x07
    1f10:	b8 87       	std	Y+8, r27	; 0x08
    1f12:	27 ef       	ldi	r18, 0xF7	; 247
    1f14:	30 e0       	ldi	r19, 0x00	; 0
    1f16:	ce 01       	movw	r24, r28
    1f18:	05 96       	adiw	r24, 0x05	; 5
    1f1a:	03 96       	adiw	r24, 0x03	; 3
    1f1c:	fc 01       	movw	r30, r24
    1f1e:	80 81       	ld	r24, Z
    1f20:	48 2f       	mov	r20, r24
    1f22:	44 0f       	add	r20, r20
    1f24:	44 0f       	add	r20, r20
    1f26:	44 0f       	add	r20, r20
    1f28:	ce 01       	movw	r24, r28
    1f2a:	05 96       	adiw	r24, 0x05	; 5
    1f2c:	02 96       	adiw	r24, 0x02	; 2
    1f2e:	fc 01       	movw	r30, r24
    1f30:	80 81       	ld	r24, Z
    1f32:	82 95       	swap	r24
    1f34:	86 95       	lsr	r24
    1f36:	87 70       	andi	r24, 0x07	; 7
    1f38:	84 0f       	add	r24, r20
    1f3a:	f9 01       	movw	r30, r18
    1f3c:	80 83       	st	Z, r24
    1f3e:	26 ef       	ldi	r18, 0xF6	; 246
    1f40:	30 e0       	ldi	r19, 0x00	; 0
    1f42:	ce 01       	movw	r24, r28
    1f44:	05 96       	adiw	r24, 0x05	; 5
    1f46:	02 96       	adiw	r24, 0x02	; 2
    1f48:	fc 01       	movw	r30, r24
    1f4a:	80 81       	ld	r24, Z
    1f4c:	48 2f       	mov	r20, r24
    1f4e:	44 0f       	add	r20, r20
    1f50:	44 0f       	add	r20, r20
    1f52:	44 0f       	add	r20, r20
    1f54:	ce 01       	movw	r24, r28
    1f56:	05 96       	adiw	r24, 0x05	; 5
    1f58:	01 96       	adiw	r24, 0x01	; 1
    1f5a:	fc 01       	movw	r30, r24
    1f5c:	80 81       	ld	r24, Z
    1f5e:	82 95       	swap	r24
    1f60:	86 95       	lsr	r24
    1f62:	87 70       	andi	r24, 0x07	; 7
    1f64:	84 0f       	add	r24, r20
    1f66:	f9 01       	movw	r30, r18
    1f68:	80 83       	st	Z, r24
    1f6a:	25 ef       	ldi	r18, 0xF5	; 245
    1f6c:	30 e0       	ldi	r19, 0x00	; 0
    1f6e:	ce 01       	movw	r24, r28
    1f70:	05 96       	adiw	r24, 0x05	; 5
    1f72:	01 96       	adiw	r24, 0x01	; 1
    1f74:	fc 01       	movw	r30, r24
    1f76:	80 81       	ld	r24, Z
    1f78:	48 2f       	mov	r20, r24
    1f7a:	44 0f       	add	r20, r20
    1f7c:	44 0f       	add	r20, r20
    1f7e:	44 0f       	add	r20, r20
    1f80:	ce 01       	movw	r24, r28
    1f82:	05 96       	adiw	r24, 0x05	; 5
    1f84:	fc 01       	movw	r30, r24
    1f86:	80 81       	ld	r24, Z
    1f88:	82 95       	swap	r24
    1f8a:	86 95       	lsr	r24
    1f8c:	87 70       	andi	r24, 0x07	; 7
    1f8e:	84 0f       	add	r24, r20
    1f90:	f9 01       	movw	r30, r18
    1f92:	80 83       	st	Z, r24
    1f94:	84 ef       	ldi	r24, 0xF4	; 244
    1f96:	90 e0       	ldi	r25, 0x00	; 0
    1f98:	9e 01       	movw	r18, r28
    1f9a:	2b 5f       	subi	r18, 0xFB	; 251
    1f9c:	3f 4f       	sbci	r19, 0xFF	; 255
    1f9e:	f9 01       	movw	r30, r18
    1fa0:	20 81       	ld	r18, Z
    1fa2:	22 0f       	add	r18, r18
    1fa4:	22 0f       	add	r18, r18
    1fa6:	22 0f       	add	r18, r18
    1fa8:	fc 01       	movw	r30, r24
    1faa:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    1fac:	8f ee       	ldi	r24, 0xEF	; 239
    1fae:	90 e0       	ldi	r25, 0x00	; 0
    1fb0:	2f ee       	ldi	r18, 0xEF	; 239
    1fb2:	30 e0       	ldi	r19, 0x00	; 0
    1fb4:	f9 01       	movw	r30, r18
    1fb6:	40 81       	ld	r20, Z
    1fb8:	29 85       	ldd	r18, Y+9	; 0x09
    1fba:	3a 85       	ldd	r19, Y+10	; 0x0a
    1fbc:	f9 01       	movw	r30, r18
    1fbe:	26 81       	ldd	r18, Z+6	; 0x06
    1fc0:	24 2b       	or	r18, r20
    1fc2:	fc 01       	movw	r30, r24
    1fc4:	20 83       	st	Z, r18
          cmd->ctrl.rtr=1; Can_set_rtrmsk(); Can_set_rtr();
    1fc6:	89 85       	ldd	r24, Y+9	; 0x09
    1fc8:	9a 85       	ldd	r25, Y+10	; 0x0a
    1fca:	21 e0       	ldi	r18, 0x01	; 1
    1fcc:	fc 01       	movw	r30, r24
    1fce:	22 87       	std	Z+10, r18	; 0x0a
    1fd0:	84 ef       	ldi	r24, 0xF4	; 244
    1fd2:	90 e0       	ldi	r25, 0x00	; 0
    1fd4:	24 ef       	ldi	r18, 0xF4	; 244
    1fd6:	30 e0       	ldi	r19, 0x00	; 0
    1fd8:	f9 01       	movw	r30, r18
    1fda:	20 81       	ld	r18, Z
    1fdc:	24 60       	ori	r18, 0x04	; 4
    1fde:	fc 01       	movw	r30, r24
    1fe0:	20 83       	st	Z, r18
    1fe2:	80 ef       	ldi	r24, 0xF0	; 240
    1fe4:	90 e0       	ldi	r25, 0x00	; 0
    1fe6:	20 ef       	ldi	r18, 0xF0	; 240
    1fe8:	30 e0       	ldi	r19, 0x00	; 0
    1fea:	f9 01       	movw	r30, r18
    1fec:	20 81       	ld	r18, Z
    1fee:	24 60       	ori	r18, 0x04	; 4
    1ff0:	fc 01       	movw	r30, r24
    1ff2:	20 83       	st	Z, r18
          Can_set_rplv();
    1ff4:	8f ee       	ldi	r24, 0xEF	; 239
    1ff6:	90 e0       	ldi	r25, 0x00	; 0
    1ff8:	2f ee       	ldi	r18, 0xEF	; 239
    1ffa:	30 e0       	ldi	r19, 0x00	; 0
    1ffc:	f9 01       	movw	r30, r18
    1ffe:	20 81       	ld	r18, Z
    2000:	20 62       	ori	r18, 0x20	; 32
    2002:	fc 01       	movw	r30, r24
    2004:	20 83       	st	Z, r18
          Can_set_idemsk();
    2006:	84 ef       	ldi	r24, 0xF4	; 244
    2008:	90 e0       	ldi	r25, 0x00	; 0
    200a:	24 ef       	ldi	r18, 0xF4	; 244
    200c:	30 e0       	ldi	r19, 0x00	; 0
    200e:	f9 01       	movw	r30, r18
    2010:	20 81       	ld	r18, Z
    2012:	21 60       	ori	r18, 0x01	; 1
    2014:	fc 01       	movw	r30, r24
    2016:	20 83       	st	Z, r18
          Can_config_rx();       
    2018:	8f ee       	ldi	r24, 0xEF	; 239
    201a:	90 e0       	ldi	r25, 0x00	; 0
    201c:	2f ee       	ldi	r18, 0xEF	; 239
    201e:	30 e0       	ldi	r19, 0x00	; 0
    2020:	f9 01       	movw	r30, r18
    2022:	20 81       	ld	r18, Z
    2024:	2f 73       	andi	r18, 0x3F	; 63
    2026:	fc 01       	movw	r30, r24
    2028:	20 83       	st	Z, r18
    202a:	8f ee       	ldi	r24, 0xEF	; 239
    202c:	90 e0       	ldi	r25, 0x00	; 0
    202e:	2f ee       	ldi	r18, 0xEF	; 239
    2030:	30 e0       	ldi	r19, 0x00	; 0
    2032:	f9 01       	movw	r30, r18
    2034:	20 81       	ld	r18, Z
    2036:	20 68       	ori	r18, 0x80	; 128
    2038:	fc 01       	movw	r30, r24
    203a:	20 83       	st	Z, r18
          break;
    203c:	05 c0       	rjmp	.+10     	; 0x2048 <__stack+0xf49>
        //------------      
        default:
          // case CMD_NONE or not implemented command
          cmd->status = STATUS_CLEARED; 
    203e:	89 85       	ldd	r24, Y+9	; 0x09
    2040:	9a 85       	ldd	r25, Y+10	; 0x0a
    2042:	fc 01       	movw	r30, r24
    2044:	11 86       	std	Z+9, r1	; 0x09
          break;
    2046:	00 00       	nop
    2048:	07 c0       	rjmp	.+14     	; 0x2058 <__stack+0xf59>
        //------------      
      } // switch (cmd ...
    } // if (mob_handle ...
    else
    {
      cmd->status = MOB_NOT_REACHED;
    204a:	89 85       	ldd	r24, Y+9	; 0x09
    204c:	9a 85       	ldd	r25, Y+10	; 0x0a
    204e:	2f e1       	ldi	r18, 0x1F	; 31
    2050:	fc 01       	movw	r30, r24
    2052:	21 87       	std	Z+9, r18	; 0x09
      return CAN_CMD_REFUSED;
    2054:	8f ef       	ldi	r24, 0xFF	; 255
    2056:	01 c0       	rjmp	.+2      	; 0x205a <__stack+0xf5b>
    }
  } // else of no CMD_ABORT
  return CAN_CMD_ACCEPTED;
    2058:	80 e0       	ldi	r24, 0x00	; 0
}
    205a:	2a 96       	adiw	r28, 0x0a	; 10
    205c:	0f b6       	in	r0, 0x3f	; 63
    205e:	f8 94       	cli
    2060:	de bf       	out	0x3e, r29	; 62
    2062:	0f be       	out	0x3f, r0	; 63
    2064:	cd bf       	out	0x3d, r28	; 61
    2066:	df 91       	pop	r29
    2068:	cf 91       	pop	r28
    206a:	08 95       	ret

0000206c <can_get_status>:
//!         CAN_STATUS_ERROR         - Error in configuration or in the
//!                                    CAN communication
//!
//------------------------------------------------------------------------------
uint8_t can_get_status (st_cmd_t* cmd)
{
    206c:	cf 93       	push	r28
    206e:	df 93       	push	r29
    2070:	00 d0       	rcall	.+0      	; 0x2072 <can_get_status+0x6>
    2072:	00 d0       	rcall	.+0      	; 0x2074 <can_get_status+0x8>
    2074:	cd b7       	in	r28, 0x3d	; 61
    2076:	de b7       	in	r29, 0x3e	; 62
    2078:	9c 83       	std	Y+4, r25	; 0x04
    207a:	8b 83       	std	Y+3, r24	; 0x03
    uint8_t a_status, rtn_val;
     
    a_status = cmd->status;
    207c:	8b 81       	ldd	r24, Y+3	; 0x03
    207e:	9c 81       	ldd	r25, Y+4	; 0x04
    2080:	fc 01       	movw	r30, r24
    2082:	81 85       	ldd	r24, Z+9	; 0x09
    2084:	8a 83       	std	Y+2, r24	; 0x02
    if ((a_status==STATUS_CLEARED)||(a_status==MOB_NOT_REACHED)||(a_status==MOB_DISABLE))
    2086:	8a 81       	ldd	r24, Y+2	; 0x02
    2088:	88 23       	and	r24, r24
    208a:	31 f0       	breq	.+12     	; 0x2098 <can_get_status+0x2c>
    208c:	8a 81       	ldd	r24, Y+2	; 0x02
    208e:	8f 31       	cpi	r24, 0x1F	; 31
    2090:	19 f0       	breq	.+6      	; 0x2098 <can_get_status+0x2c>
    2092:	8a 81       	ldd	r24, Y+2	; 0x02
    2094:	8f 3f       	cpi	r24, 0xFF	; 255
    2096:	11 f4       	brne	.+4      	; 0x209c <can_get_status+0x30>
    {
        return CAN_STATUS_ERROR;
    2098:	82 e0       	ldi	r24, 0x02	; 2
    209a:	11 c1       	rjmp	.+546    	; 0x22be <can_get_status+0x252>
    }

    Can_set_mob(cmd->handle);
    209c:	8d ee       	ldi	r24, 0xED	; 237
    209e:	90 e0       	ldi	r25, 0x00	; 0
    20a0:	2b 81       	ldd	r18, Y+3	; 0x03
    20a2:	3c 81       	ldd	r19, Y+4	; 0x04
    20a4:	f9 01       	movw	r30, r18
    20a6:	20 81       	ld	r18, Z
    20a8:	22 95       	swap	r18
    20aa:	20 7f       	andi	r18, 0xF0	; 240
    20ac:	fc 01       	movw	r30, r24
    20ae:	20 83       	st	Z, r18
    a_status = can_get_mob_status();
    20b0:	0e 94 93 02 	call	0x526	; 0x526 <can_get_mob_status>
    20b4:	8a 83       	std	Y+2, r24	; 0x02
    
    switch (a_status)
    20b6:	8a 81       	ldd	r24, Y+2	; 0x02
    20b8:	88 2f       	mov	r24, r24
    20ba:	90 e0       	ldi	r25, 0x00	; 0
    20bc:	80 32       	cpi	r24, 0x20	; 32
    20be:	91 05       	cpc	r25, r1
    20c0:	89 f0       	breq	.+34     	; 0x20e4 <can_get_status+0x78>
    20c2:	81 32       	cpi	r24, 0x21	; 33
    20c4:	91 05       	cpc	r25, r1
    20c6:	1c f4       	brge	.+6      	; 0x20ce <can_get_status+0x62>
    20c8:	89 2b       	or	r24, r25
    20ca:	49 f0       	breq	.+18     	; 0x20de <can_get_status+0x72>
    20cc:	e2 c0       	rjmp	.+452    	; 0x2292 <can_get_status+0x226>
    20ce:	80 34       	cpi	r24, 0x40	; 64
    20d0:	91 05       	cpc	r25, r1
    20d2:	09 f4       	brne	.+2      	; 0x20d6 <can_get_status+0x6a>
    20d4:	ca c0       	rjmp	.+404    	; 0x226a <can_get_status+0x1fe>
    20d6:	80 3a       	cpi	r24, 0xA0	; 160
    20d8:	91 05       	cpc	r25, r1
    20da:	21 f0       	breq	.+8      	; 0x20e4 <can_get_status+0x78>
    20dc:	da c0       	rjmp	.+436    	; 0x2292 <can_get_status+0x226>
    {
        case MOB_NOT_COMPLETED:
            // cmd->status not updated
            rtn_val = CAN_STATUS_NOT_COMPLETED;
    20de:	81 e0       	ldi	r24, 0x01	; 1
    20e0:	89 83       	std	Y+1, r24	; 0x01
            break;
    20e2:	ec c0       	rjmp	.+472    	; 0x22bc <can_get_status+0x250>
        //---------------      
        case MOB_RX_COMPLETED:     
        case MOB_RX_COMPLETED_DLCW:
            cmd->dlc = Can_get_dlc();
    20e4:	8f ee       	ldi	r24, 0xEF	; 239
    20e6:	90 e0       	ldi	r25, 0x00	; 0
    20e8:	fc 01       	movw	r30, r24
    20ea:	80 81       	ld	r24, Z
    20ec:	28 2f       	mov	r18, r24
    20ee:	2f 70       	andi	r18, 0x0F	; 15
    20f0:	8b 81       	ldd	r24, Y+3	; 0x03
    20f2:	9c 81       	ldd	r25, Y+4	; 0x04
    20f4:	fc 01       	movw	r30, r24
    20f6:	26 83       	std	Z+6, r18	; 0x06
            can_get_data(cmd->pt_data);
    20f8:	8b 81       	ldd	r24, Y+3	; 0x03
    20fa:	9c 81       	ldd	r25, Y+4	; 0x04
    20fc:	fc 01       	movw	r30, r24
    20fe:	87 81       	ldd	r24, Z+7	; 0x07
    2100:	90 85       	ldd	r25, Z+8	; 0x08
    2102:	0e 94 c5 02 	call	0x58a	; 0x58a <can_get_data>
            cmd->ctrl.rtr = Can_get_rtr();
    2106:	80 ef       	ldi	r24, 0xF0	; 240
    2108:	90 e0       	ldi	r25, 0x00	; 0
    210a:	fc 01       	movw	r30, r24
    210c:	80 81       	ld	r24, Z
    210e:	88 2f       	mov	r24, r24
    2110:	90 e0       	ldi	r25, 0x00	; 0
    2112:	84 70       	andi	r24, 0x04	; 4
    2114:	99 27       	eor	r25, r25
    2116:	95 95       	asr	r25
    2118:	87 95       	ror	r24
    211a:	95 95       	asr	r25
    211c:	87 95       	ror	r24
    211e:	28 2f       	mov	r18, r24
    2120:	8b 81       	ldd	r24, Y+3	; 0x03
    2122:	9c 81       	ldd	r25, Y+4	; 0x04
    2124:	fc 01       	movw	r30, r24
    2126:	22 87       	std	Z+10, r18	; 0x0a
            if (Can_get_ide()) // if extended frame
    2128:	8f ee       	ldi	r24, 0xEF	; 239
    212a:	90 e0       	ldi	r25, 0x00	; 0
    212c:	fc 01       	movw	r30, r24
    212e:	80 81       	ld	r24, Z
    2130:	88 2f       	mov	r24, r24
    2132:	90 e0       	ldi	r25, 0x00	; 0
    2134:	80 71       	andi	r24, 0x10	; 16
    2136:	99 27       	eor	r25, r25
    2138:	95 95       	asr	r25
    213a:	87 95       	ror	r24
    213c:	95 95       	asr	r25
    213e:	87 95       	ror	r24
    2140:	95 95       	asr	r25
    2142:	87 95       	ror	r24
    2144:	95 95       	asr	r25
    2146:	87 95       	ror	r24
    2148:	89 2b       	or	r24, r25
    214a:	09 f4       	brne	.+2      	; 0x214e <can_get_status+0xe2>
    214c:	54 c0       	rjmp	.+168    	; 0x21f6 <can_get_status+0x18a>
            {
                cmd->ctrl.ide = 1; // extended frame
    214e:	8b 81       	ldd	r24, Y+3	; 0x03
    2150:	9c 81       	ldd	r25, Y+4	; 0x04
    2152:	21 e0       	ldi	r18, 0x01	; 1
    2154:	fc 01       	movw	r30, r24
    2156:	23 87       	std	Z+11, r18	; 0x0b
                Can_get_ext_id(cmd->id.ext);
    2158:	8b 81       	ldd	r24, Y+3	; 0x03
    215a:	9c 81       	ldd	r25, Y+4	; 0x04
    215c:	02 96       	adiw	r24, 0x02	; 2
    215e:	03 96       	adiw	r24, 0x03	; 3
    2160:	23 ef       	ldi	r18, 0xF3	; 243
    2162:	30 e0       	ldi	r19, 0x00	; 0
    2164:	f9 01       	movw	r30, r18
    2166:	20 81       	ld	r18, Z
    2168:	26 95       	lsr	r18
    216a:	26 95       	lsr	r18
    216c:	26 95       	lsr	r18
    216e:	fc 01       	movw	r30, r24
    2170:	20 83       	st	Z, r18
    2172:	8b 81       	ldd	r24, Y+3	; 0x03
    2174:	9c 81       	ldd	r25, Y+4	; 0x04
    2176:	02 96       	adiw	r24, 0x02	; 2
    2178:	02 96       	adiw	r24, 0x02	; 2
    217a:	22 ef       	ldi	r18, 0xF2	; 242
    217c:	30 e0       	ldi	r19, 0x00	; 0
    217e:	f9 01       	movw	r30, r18
    2180:	20 81       	ld	r18, Z
    2182:	42 2f       	mov	r20, r18
    2184:	46 95       	lsr	r20
    2186:	46 95       	lsr	r20
    2188:	46 95       	lsr	r20
    218a:	23 ef       	ldi	r18, 0xF3	; 243
    218c:	30 e0       	ldi	r19, 0x00	; 0
    218e:	f9 01       	movw	r30, r18
    2190:	20 81       	ld	r18, Z
    2192:	22 95       	swap	r18
    2194:	22 0f       	add	r18, r18
    2196:	20 7e       	andi	r18, 0xE0	; 224
    2198:	24 0f       	add	r18, r20
    219a:	fc 01       	movw	r30, r24
    219c:	20 83       	st	Z, r18
    219e:	8b 81       	ldd	r24, Y+3	; 0x03
    21a0:	9c 81       	ldd	r25, Y+4	; 0x04
    21a2:	02 96       	adiw	r24, 0x02	; 2
    21a4:	01 96       	adiw	r24, 0x01	; 1
    21a6:	21 ef       	ldi	r18, 0xF1	; 241
    21a8:	30 e0       	ldi	r19, 0x00	; 0
    21aa:	f9 01       	movw	r30, r18
    21ac:	20 81       	ld	r18, Z
    21ae:	42 2f       	mov	r20, r18
    21b0:	46 95       	lsr	r20
    21b2:	46 95       	lsr	r20
    21b4:	46 95       	lsr	r20
    21b6:	22 ef       	ldi	r18, 0xF2	; 242
    21b8:	30 e0       	ldi	r19, 0x00	; 0
    21ba:	f9 01       	movw	r30, r18
    21bc:	20 81       	ld	r18, Z
    21be:	22 95       	swap	r18
    21c0:	22 0f       	add	r18, r18
    21c2:	20 7e       	andi	r18, 0xE0	; 224
    21c4:	24 0f       	add	r18, r20
    21c6:	fc 01       	movw	r30, r24
    21c8:	20 83       	st	Z, r18
    21ca:	8b 81       	ldd	r24, Y+3	; 0x03
    21cc:	9c 81       	ldd	r25, Y+4	; 0x04
    21ce:	02 96       	adiw	r24, 0x02	; 2
    21d0:	20 ef       	ldi	r18, 0xF0	; 240
    21d2:	30 e0       	ldi	r19, 0x00	; 0
    21d4:	f9 01       	movw	r30, r18
    21d6:	20 81       	ld	r18, Z
    21d8:	42 2f       	mov	r20, r18
    21da:	46 95       	lsr	r20
    21dc:	46 95       	lsr	r20
    21de:	46 95       	lsr	r20
    21e0:	21 ef       	ldi	r18, 0xF1	; 241
    21e2:	30 e0       	ldi	r19, 0x00	; 0
    21e4:	f9 01       	movw	r30, r18
    21e6:	20 81       	ld	r18, Z
    21e8:	22 95       	swap	r18
    21ea:	22 0f       	add	r18, r18
    21ec:	20 7e       	andi	r18, 0xE0	; 224
    21ee:	24 0f       	add	r18, r20
    21f0:	fc 01       	movw	r30, r24
    21f2:	20 83       	st	Z, r18
    21f4:	26 c0       	rjmp	.+76     	; 0x2242 <can_get_status+0x1d6>
            }
            else // else standard frame
                {
                    cmd->ctrl.ide = 0;
    21f6:	8b 81       	ldd	r24, Y+3	; 0x03
    21f8:	9c 81       	ldd	r25, Y+4	; 0x04
    21fa:	fc 01       	movw	r30, r24
    21fc:	13 86       	std	Z+11, r1	; 0x0b
                    Can_get_std_id(cmd->id.std);
    21fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2200:	9c 81       	ldd	r25, Y+4	; 0x04
    2202:	02 96       	adiw	r24, 0x02	; 2
    2204:	01 96       	adiw	r24, 0x01	; 1
    2206:	23 ef       	ldi	r18, 0xF3	; 243
    2208:	30 e0       	ldi	r19, 0x00	; 0
    220a:	f9 01       	movw	r30, r18
    220c:	20 81       	ld	r18, Z
    220e:	22 95       	swap	r18
    2210:	26 95       	lsr	r18
    2212:	27 70       	andi	r18, 0x07	; 7
    2214:	fc 01       	movw	r30, r24
    2216:	20 83       	st	Z, r18
    2218:	8b 81       	ldd	r24, Y+3	; 0x03
    221a:	9c 81       	ldd	r25, Y+4	; 0x04
    221c:	02 96       	adiw	r24, 0x02	; 2
    221e:	22 ef       	ldi	r18, 0xF2	; 242
    2220:	30 e0       	ldi	r19, 0x00	; 0
    2222:	f9 01       	movw	r30, r18
    2224:	20 81       	ld	r18, Z
    2226:	42 2f       	mov	r20, r18
    2228:	42 95       	swap	r20
    222a:	46 95       	lsr	r20
    222c:	47 70       	andi	r20, 0x07	; 7
    222e:	23 ef       	ldi	r18, 0xF3	; 243
    2230:	30 e0       	ldi	r19, 0x00	; 0
    2232:	f9 01       	movw	r30, r18
    2234:	20 81       	ld	r18, Z
    2236:	22 0f       	add	r18, r18
    2238:	22 0f       	add	r18, r18
    223a:	22 0f       	add	r18, r18
    223c:	24 0f       	add	r18, r20
    223e:	fc 01       	movw	r30, r24
    2240:	20 83       	st	Z, r18
                }
            // Status field of descriptor: 0x20 if Rx completed
            // Status field of descriptor: 0xA0 if Rx completed with DLCWarning    
            cmd->status = a_status;
    2242:	8b 81       	ldd	r24, Y+3	; 0x03
    2244:	9c 81       	ldd	r25, Y+4	; 0x04
    2246:	2a 81       	ldd	r18, Y+2	; 0x02
    2248:	fc 01       	movw	r30, r24
    224a:	21 87       	std	Z+9, r18	; 0x09
            Can_mob_abort();        // Freed the MOB
    224c:	8f ee       	ldi	r24, 0xEF	; 239
    224e:	90 e0       	ldi	r25, 0x00	; 0
    2250:	2f ee       	ldi	r18, 0xEF	; 239
    2252:	30 e0       	ldi	r19, 0x00	; 0
    2254:	f9 01       	movw	r30, r18
    2256:	20 81       	ld	r18, Z
    2258:	2f 73       	andi	r18, 0x3F	; 63
    225a:	fc 01       	movw	r30, r24
    225c:	20 83       	st	Z, r18
            Can_clear_status_mob(); //   and reset MOb status
    225e:	8e ee       	ldi	r24, 0xEE	; 238
    2260:	90 e0       	ldi	r25, 0x00	; 0
    2262:	fc 01       	movw	r30, r24
    2264:	10 82       	st	Z, r1
            rtn_val = CAN_STATUS_COMPLETED;
    2266:	19 82       	std	Y+1, r1	; 0x01
            break;
    2268:	29 c0       	rjmp	.+82     	; 0x22bc <can_get_status+0x250>
        //---------------      
        case MOB_TX_COMPLETED:     
            // Status field of descriptor: 0x40 if Tx completed
            cmd->status = a_status;
    226a:	8b 81       	ldd	r24, Y+3	; 0x03
    226c:	9c 81       	ldd	r25, Y+4	; 0x04
    226e:	2a 81       	ldd	r18, Y+2	; 0x02
    2270:	fc 01       	movw	r30, r24
    2272:	21 87       	std	Z+9, r18	; 0x09
            Can_mob_abort();        // Freed the MOB
    2274:	8f ee       	ldi	r24, 0xEF	; 239
    2276:	90 e0       	ldi	r25, 0x00	; 0
    2278:	2f ee       	ldi	r18, 0xEF	; 239
    227a:	30 e0       	ldi	r19, 0x00	; 0
    227c:	f9 01       	movw	r30, r18
    227e:	20 81       	ld	r18, Z
    2280:	2f 73       	andi	r18, 0x3F	; 63
    2282:	fc 01       	movw	r30, r24
    2284:	20 83       	st	Z, r18
            Can_clear_status_mob(); //   and reset MOb status
    2286:	8e ee       	ldi	r24, 0xEE	; 238
    2288:	90 e0       	ldi	r25, 0x00	; 0
    228a:	fc 01       	movw	r30, r24
    228c:	10 82       	st	Z, r1
            rtn_val = CAN_STATUS_COMPLETED;
    228e:	19 82       	std	Y+1, r1	; 0x01
            break;
    2290:	15 c0       	rjmp	.+42     	; 0x22bc <can_get_status+0x250>
        //---------------      
        default:
            // Status field of descriptor: (bin)000b.scfa if MOb error
            cmd->status = a_status;
    2292:	8b 81       	ldd	r24, Y+3	; 0x03
    2294:	9c 81       	ldd	r25, Y+4	; 0x04
    2296:	2a 81       	ldd	r18, Y+2	; 0x02
    2298:	fc 01       	movw	r30, r24
    229a:	21 87       	std	Z+9, r18	; 0x09
            Can_mob_abort();        // Freed the MOB
    229c:	8f ee       	ldi	r24, 0xEF	; 239
    229e:	90 e0       	ldi	r25, 0x00	; 0
    22a0:	2f ee       	ldi	r18, 0xEF	; 239
    22a2:	30 e0       	ldi	r19, 0x00	; 0
    22a4:	f9 01       	movw	r30, r18
    22a6:	20 81       	ld	r18, Z
    22a8:	2f 73       	andi	r18, 0x3F	; 63
    22aa:	fc 01       	movw	r30, r24
    22ac:	20 83       	st	Z, r18
            Can_clear_status_mob(); //   and reset MOb status
    22ae:	8e ee       	ldi	r24, 0xEE	; 238
    22b0:	90 e0       	ldi	r25, 0x00	; 0
    22b2:	fc 01       	movw	r30, r24
    22b4:	10 82       	st	Z, r1
            rtn_val = CAN_STATUS_ERROR;
    22b6:	82 e0       	ldi	r24, 0x02	; 2
    22b8:	89 83       	std	Y+1, r24	; 0x01
            break;
    22ba:	00 00       	nop
             
    } // switch (a_status...
 
    return (rtn_val);
    22bc:	89 81       	ldd	r24, Y+1	; 0x01
}
    22be:	0f 90       	pop	r0
    22c0:	0f 90       	pop	r0
    22c2:	0f 90       	pop	r0
    22c4:	0f 90       	pop	r0
    22c6:	df 91       	pop	r29
    22c8:	cf 91       	pop	r28
    22ca:	08 95       	ret

000022cc <main>:

#define mainMCU_STATUS_TASK_PRIORITY	1
#define mainHEARTBEAT_TASK_PRIORITY		2

int main(void)
{	
    22cc:	af 92       	push	r10
    22ce:	bf 92       	push	r11
    22d0:	cf 92       	push	r12
    22d2:	df 92       	push	r13
    22d4:	ef 92       	push	r14
    22d6:	ff 92       	push	r15
    22d8:	0f 93       	push	r16
    22da:	cf 93       	push	r28
    22dc:	df 93       	push	r29
    22de:	cd b7       	in	r28, 0x3d	; 61
    22e0:	de b7       	in	r29, 0x3e	; 62
	// Initialize CAN with fixed baud rate, as defined in can_config.h
	can_init(1);
    22e2:	81 e0       	ldi	r24, 0x01	; 1
    22e4:	0e 94 83 05 	call	0xb06	; 0xb06 <can_init>
	
	// Create the MCU status task, to blink the LED
	// Rate: 4Hz
    xTaskCreate(vMCUStatusTask, "STATUS", configMINIMAL_STACK_SIZE, 
    22e8:	a1 2c       	mov	r10, r1
    22ea:	b1 2c       	mov	r11, r1
    22ec:	c1 2c       	mov	r12, r1
    22ee:	d1 2c       	mov	r13, r1
    22f0:	e1 2c       	mov	r14, r1
    22f2:	f1 2c       	mov	r15, r1
    22f4:	01 e0       	ldi	r16, 0x01	; 1
    22f6:	20 e0       	ldi	r18, 0x00	; 0
    22f8:	30 e0       	ldi	r19, 0x00	; 0
    22fa:	44 e6       	ldi	r20, 0x64	; 100
    22fc:	50 e0       	ldi	r21, 0x00	; 0
    22fe:	60 e0       	ldi	r22, 0x00	; 0
    2300:	71 e0       	ldi	r23, 0x01	; 1
    2302:	88 ed       	ldi	r24, 0xD8	; 216
    2304:	98 e2       	ldi	r25, 0x28	; 40
    2306:	0e 94 ae 1c 	call	0x395c	; 0x395c <xTaskGenericCreate>
		NULL, mainMCU_STATUS_TASK_PRIORITY, NULL);
		
	// Create the heartbeat task, to transmit over CAN
	// Rate: 10Hz
	xTaskCreate(vHeartbeatTask, "HEART", configMINIMAL_STACK_SIZE,
    230a:	a1 2c       	mov	r10, r1
    230c:	b1 2c       	mov	r11, r1
    230e:	c1 2c       	mov	r12, r1
    2310:	d1 2c       	mov	r13, r1
    2312:	e1 2c       	mov	r14, r1
    2314:	f1 2c       	mov	r15, r1
    2316:	02 e0       	ldi	r16, 0x02	; 2
    2318:	20 e0       	ldi	r18, 0x00	; 0
    231a:	30 e0       	ldi	r19, 0x00	; 0
    231c:	44 e6       	ldi	r20, 0x64	; 100
    231e:	50 e0       	ldi	r21, 0x00	; 0
    2320:	67 e0       	ldi	r22, 0x07	; 7
    2322:	71 e0       	ldi	r23, 0x01	; 1
    2324:	86 ef       	ldi	r24, 0xF6	; 246
    2326:	98 e2       	ldi	r25, 0x28	; 40
    2328:	0e 94 ae 1c 	call	0x395c	; 0x395c <xTaskGenericCreate>
	NULL, mainHEARTBEAT_TASK_PRIORITY, NULL);
	
	// Start the scheduler
	vTaskStartScheduler();
    232c:	0e 94 9d 1e 	call	0x3d3a	; 0x3d3a <vTaskStartScheduler>
	
	// Return, the scheduler handles the rest
	return 0;
    2330:	80 e0       	ldi	r24, 0x00	; 0
    2332:	90 e0       	ldi	r25, 0x00	; 0
}
    2334:	df 91       	pop	r29
    2336:	cf 91       	pop	r28
    2338:	0f 91       	pop	r16
    233a:	ff 90       	pop	r15
    233c:	ef 90       	pop	r14
    233e:	df 90       	pop	r13
    2340:	cf 90       	pop	r12
    2342:	bf 90       	pop	r11
    2344:	af 90       	pop	r10
    2346:	08 95       	ret

00002348 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2348:	cf 93       	push	r28
    234a:	df 93       	push	r29
    234c:	00 d0       	rcall	.+0      	; 0x234e <vListInitialise+0x6>
    234e:	cd b7       	in	r28, 0x3d	; 61
    2350:	de b7       	in	r29, 0x3e	; 62
    2352:	9a 83       	std	Y+2, r25	; 0x02
    2354:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2356:	89 81       	ldd	r24, Y+1	; 0x01
    2358:	9a 81       	ldd	r25, Y+2	; 0x02
    235a:	9c 01       	movw	r18, r24
    235c:	2d 5f       	subi	r18, 0xFD	; 253
    235e:	3f 4f       	sbci	r19, 0xFF	; 255
    2360:	89 81       	ldd	r24, Y+1	; 0x01
    2362:	9a 81       	ldd	r25, Y+2	; 0x02
    2364:	fc 01       	movw	r30, r24
    2366:	32 83       	std	Z+2, r19	; 0x02
    2368:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    236a:	89 81       	ldd	r24, Y+1	; 0x01
    236c:	9a 81       	ldd	r25, Y+2	; 0x02
    236e:	2f ef       	ldi	r18, 0xFF	; 255
    2370:	3f ef       	ldi	r19, 0xFF	; 255
    2372:	fc 01       	movw	r30, r24
    2374:	34 83       	std	Z+4, r19	; 0x04
    2376:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2378:	89 81       	ldd	r24, Y+1	; 0x01
    237a:	9a 81       	ldd	r25, Y+2	; 0x02
    237c:	9c 01       	movw	r18, r24
    237e:	2d 5f       	subi	r18, 0xFD	; 253
    2380:	3f 4f       	sbci	r19, 0xFF	; 255
    2382:	89 81       	ldd	r24, Y+1	; 0x01
    2384:	9a 81       	ldd	r25, Y+2	; 0x02
    2386:	fc 01       	movw	r30, r24
    2388:	36 83       	std	Z+6, r19	; 0x06
    238a:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    238c:	89 81       	ldd	r24, Y+1	; 0x01
    238e:	9a 81       	ldd	r25, Y+2	; 0x02
    2390:	9c 01       	movw	r18, r24
    2392:	2d 5f       	subi	r18, 0xFD	; 253
    2394:	3f 4f       	sbci	r19, 0xFF	; 255
    2396:	89 81       	ldd	r24, Y+1	; 0x01
    2398:	9a 81       	ldd	r25, Y+2	; 0x02
    239a:	fc 01       	movw	r30, r24
    239c:	30 87       	std	Z+8, r19	; 0x08
    239e:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    23a0:	89 81       	ldd	r24, Y+1	; 0x01
    23a2:	9a 81       	ldd	r25, Y+2	; 0x02
    23a4:	fc 01       	movw	r30, r24
    23a6:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    23a8:	0f 90       	pop	r0
    23aa:	0f 90       	pop	r0
    23ac:	df 91       	pop	r29
    23ae:	cf 91       	pop	r28
    23b0:	08 95       	ret

000023b2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    23b2:	cf 93       	push	r28
    23b4:	df 93       	push	r29
    23b6:	00 d0       	rcall	.+0      	; 0x23b8 <vListInitialiseItem+0x6>
    23b8:	cd b7       	in	r28, 0x3d	; 61
    23ba:	de b7       	in	r29, 0x3e	; 62
    23bc:	9a 83       	std	Y+2, r25	; 0x02
    23be:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    23c0:	89 81       	ldd	r24, Y+1	; 0x01
    23c2:	9a 81       	ldd	r25, Y+2	; 0x02
    23c4:	fc 01       	movw	r30, r24
    23c6:	11 86       	std	Z+9, r1	; 0x09
    23c8:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    23ca:	0f 90       	pop	r0
    23cc:	0f 90       	pop	r0
    23ce:	df 91       	pop	r29
    23d0:	cf 91       	pop	r28
    23d2:	08 95       	ret

000023d4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    23d4:	cf 93       	push	r28
    23d6:	df 93       	push	r29
    23d8:	00 d0       	rcall	.+0      	; 0x23da <vListInsertEnd+0x6>
    23da:	00 d0       	rcall	.+0      	; 0x23dc <vListInsertEnd+0x8>
    23dc:	00 d0       	rcall	.+0      	; 0x23de <vListInsertEnd+0xa>
    23de:	cd b7       	in	r28, 0x3d	; 61
    23e0:	de b7       	in	r29, 0x3e	; 62
    23e2:	9c 83       	std	Y+4, r25	; 0x04
    23e4:	8b 83       	std	Y+3, r24	; 0x03
    23e6:	7e 83       	std	Y+6, r23	; 0x06
    23e8:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    23ea:	8b 81       	ldd	r24, Y+3	; 0x03
    23ec:	9c 81       	ldd	r25, Y+4	; 0x04
    23ee:	fc 01       	movw	r30, r24
    23f0:	81 81       	ldd	r24, Z+1	; 0x01
    23f2:	92 81       	ldd	r25, Z+2	; 0x02
    23f4:	9a 83       	std	Y+2, r25	; 0x02
    23f6:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    23f8:	8d 81       	ldd	r24, Y+5	; 0x05
    23fa:	9e 81       	ldd	r25, Y+6	; 0x06
    23fc:	29 81       	ldd	r18, Y+1	; 0x01
    23fe:	3a 81       	ldd	r19, Y+2	; 0x02
    2400:	fc 01       	movw	r30, r24
    2402:	33 83       	std	Z+3, r19	; 0x03
    2404:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2406:	89 81       	ldd	r24, Y+1	; 0x01
    2408:	9a 81       	ldd	r25, Y+2	; 0x02
    240a:	fc 01       	movw	r30, r24
    240c:	24 81       	ldd	r18, Z+4	; 0x04
    240e:	35 81       	ldd	r19, Z+5	; 0x05
    2410:	8d 81       	ldd	r24, Y+5	; 0x05
    2412:	9e 81       	ldd	r25, Y+6	; 0x06
    2414:	fc 01       	movw	r30, r24
    2416:	35 83       	std	Z+5, r19	; 0x05
    2418:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    241a:	89 81       	ldd	r24, Y+1	; 0x01
    241c:	9a 81       	ldd	r25, Y+2	; 0x02
    241e:	fc 01       	movw	r30, r24
    2420:	84 81       	ldd	r24, Z+4	; 0x04
    2422:	95 81       	ldd	r25, Z+5	; 0x05
    2424:	2d 81       	ldd	r18, Y+5	; 0x05
    2426:	3e 81       	ldd	r19, Y+6	; 0x06
    2428:	fc 01       	movw	r30, r24
    242a:	33 83       	std	Z+3, r19	; 0x03
    242c:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    242e:	89 81       	ldd	r24, Y+1	; 0x01
    2430:	9a 81       	ldd	r25, Y+2	; 0x02
    2432:	2d 81       	ldd	r18, Y+5	; 0x05
    2434:	3e 81       	ldd	r19, Y+6	; 0x06
    2436:	fc 01       	movw	r30, r24
    2438:	35 83       	std	Z+5, r19	; 0x05
    243a:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    243c:	8d 81       	ldd	r24, Y+5	; 0x05
    243e:	9e 81       	ldd	r25, Y+6	; 0x06
    2440:	2b 81       	ldd	r18, Y+3	; 0x03
    2442:	3c 81       	ldd	r19, Y+4	; 0x04
    2444:	fc 01       	movw	r30, r24
    2446:	31 87       	std	Z+9, r19	; 0x09
    2448:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    244a:	8b 81       	ldd	r24, Y+3	; 0x03
    244c:	9c 81       	ldd	r25, Y+4	; 0x04
    244e:	fc 01       	movw	r30, r24
    2450:	80 81       	ld	r24, Z
    2452:	21 e0       	ldi	r18, 0x01	; 1
    2454:	28 0f       	add	r18, r24
    2456:	8b 81       	ldd	r24, Y+3	; 0x03
    2458:	9c 81       	ldd	r25, Y+4	; 0x04
    245a:	fc 01       	movw	r30, r24
    245c:	20 83       	st	Z, r18
}
    245e:	26 96       	adiw	r28, 0x06	; 6
    2460:	0f b6       	in	r0, 0x3f	; 63
    2462:	f8 94       	cli
    2464:	de bf       	out	0x3e, r29	; 62
    2466:	0f be       	out	0x3f, r0	; 63
    2468:	cd bf       	out	0x3d, r28	; 61
    246a:	df 91       	pop	r29
    246c:	cf 91       	pop	r28
    246e:	08 95       	ret

00002470 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2470:	cf 93       	push	r28
    2472:	df 93       	push	r29
    2474:	cd b7       	in	r28, 0x3d	; 61
    2476:	de b7       	in	r29, 0x3e	; 62
    2478:	28 97       	sbiw	r28, 0x08	; 8
    247a:	0f b6       	in	r0, 0x3f	; 63
    247c:	f8 94       	cli
    247e:	de bf       	out	0x3e, r29	; 62
    2480:	0f be       	out	0x3f, r0	; 63
    2482:	cd bf       	out	0x3d, r28	; 61
    2484:	9e 83       	std	Y+6, r25	; 0x06
    2486:	8d 83       	std	Y+5, r24	; 0x05
    2488:	78 87       	std	Y+8, r23	; 0x08
    248a:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    248c:	8f 81       	ldd	r24, Y+7	; 0x07
    248e:	98 85       	ldd	r25, Y+8	; 0x08
    2490:	fc 01       	movw	r30, r24
    2492:	80 81       	ld	r24, Z
    2494:	91 81       	ldd	r25, Z+1	; 0x01
    2496:	9c 83       	std	Y+4, r25	; 0x04
    2498:	8b 83       	std	Y+3, r24	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    249a:	8b 81       	ldd	r24, Y+3	; 0x03
    249c:	9c 81       	ldd	r25, Y+4	; 0x04
    249e:	01 96       	adiw	r24, 0x01	; 1
    24a0:	41 f4       	brne	.+16     	; 0x24b2 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    24a2:	8d 81       	ldd	r24, Y+5	; 0x05
    24a4:	9e 81       	ldd	r25, Y+6	; 0x06
    24a6:	fc 01       	movw	r30, r24
    24a8:	87 81       	ldd	r24, Z+7	; 0x07
    24aa:	90 85       	ldd	r25, Z+8	; 0x08
    24ac:	9a 83       	std	Y+2, r25	; 0x02
    24ae:	89 83       	std	Y+1, r24	; 0x01
    24b0:	1a c0       	rjmp	.+52     	; 0x24e6 <vListInsert+0x76>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    24b2:	8d 81       	ldd	r24, Y+5	; 0x05
    24b4:	9e 81       	ldd	r25, Y+6	; 0x06
    24b6:	03 96       	adiw	r24, 0x03	; 3
    24b8:	9a 83       	std	Y+2, r25	; 0x02
    24ba:	89 83       	std	Y+1, r24	; 0x01
    24bc:	07 c0       	rjmp	.+14     	; 0x24cc <vListInsert+0x5c>
    24be:	89 81       	ldd	r24, Y+1	; 0x01
    24c0:	9a 81       	ldd	r25, Y+2	; 0x02
    24c2:	fc 01       	movw	r30, r24
    24c4:	82 81       	ldd	r24, Z+2	; 0x02
    24c6:	93 81       	ldd	r25, Z+3	; 0x03
    24c8:	9a 83       	std	Y+2, r25	; 0x02
    24ca:	89 83       	std	Y+1, r24	; 0x01
    24cc:	89 81       	ldd	r24, Y+1	; 0x01
    24ce:	9a 81       	ldd	r25, Y+2	; 0x02
    24d0:	fc 01       	movw	r30, r24
    24d2:	82 81       	ldd	r24, Z+2	; 0x02
    24d4:	93 81       	ldd	r25, Z+3	; 0x03
    24d6:	fc 01       	movw	r30, r24
    24d8:	20 81       	ld	r18, Z
    24da:	31 81       	ldd	r19, Z+1	; 0x01
    24dc:	8b 81       	ldd	r24, Y+3	; 0x03
    24de:	9c 81       	ldd	r25, Y+4	; 0x04
    24e0:	82 17       	cp	r24, r18
    24e2:	93 07       	cpc	r25, r19
    24e4:	60 f7       	brcc	.-40     	; 0x24be <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    24e6:	89 81       	ldd	r24, Y+1	; 0x01
    24e8:	9a 81       	ldd	r25, Y+2	; 0x02
    24ea:	fc 01       	movw	r30, r24
    24ec:	22 81       	ldd	r18, Z+2	; 0x02
    24ee:	33 81       	ldd	r19, Z+3	; 0x03
    24f0:	8f 81       	ldd	r24, Y+7	; 0x07
    24f2:	98 85       	ldd	r25, Y+8	; 0x08
    24f4:	fc 01       	movw	r30, r24
    24f6:	33 83       	std	Z+3, r19	; 0x03
    24f8:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    24fa:	8f 81       	ldd	r24, Y+7	; 0x07
    24fc:	98 85       	ldd	r25, Y+8	; 0x08
    24fe:	fc 01       	movw	r30, r24
    2500:	82 81       	ldd	r24, Z+2	; 0x02
    2502:	93 81       	ldd	r25, Z+3	; 0x03
    2504:	2f 81       	ldd	r18, Y+7	; 0x07
    2506:	38 85       	ldd	r19, Y+8	; 0x08
    2508:	fc 01       	movw	r30, r24
    250a:	35 83       	std	Z+5, r19	; 0x05
    250c:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    250e:	8f 81       	ldd	r24, Y+7	; 0x07
    2510:	98 85       	ldd	r25, Y+8	; 0x08
    2512:	29 81       	ldd	r18, Y+1	; 0x01
    2514:	3a 81       	ldd	r19, Y+2	; 0x02
    2516:	fc 01       	movw	r30, r24
    2518:	35 83       	std	Z+5, r19	; 0x05
    251a:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
    251c:	89 81       	ldd	r24, Y+1	; 0x01
    251e:	9a 81       	ldd	r25, Y+2	; 0x02
    2520:	2f 81       	ldd	r18, Y+7	; 0x07
    2522:	38 85       	ldd	r19, Y+8	; 0x08
    2524:	fc 01       	movw	r30, r24
    2526:	33 83       	std	Z+3, r19	; 0x03
    2528:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    252a:	8f 81       	ldd	r24, Y+7	; 0x07
    252c:	98 85       	ldd	r25, Y+8	; 0x08
    252e:	2d 81       	ldd	r18, Y+5	; 0x05
    2530:	3e 81       	ldd	r19, Y+6	; 0x06
    2532:	fc 01       	movw	r30, r24
    2534:	31 87       	std	Z+9, r19	; 0x09
    2536:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2538:	8d 81       	ldd	r24, Y+5	; 0x05
    253a:	9e 81       	ldd	r25, Y+6	; 0x06
    253c:	fc 01       	movw	r30, r24
    253e:	80 81       	ld	r24, Z
    2540:	21 e0       	ldi	r18, 0x01	; 1
    2542:	28 0f       	add	r18, r24
    2544:	8d 81       	ldd	r24, Y+5	; 0x05
    2546:	9e 81       	ldd	r25, Y+6	; 0x06
    2548:	fc 01       	movw	r30, r24
    254a:	20 83       	st	Z, r18
}
    254c:	28 96       	adiw	r28, 0x08	; 8
    254e:	0f b6       	in	r0, 0x3f	; 63
    2550:	f8 94       	cli
    2552:	de bf       	out	0x3e, r29	; 62
    2554:	0f be       	out	0x3f, r0	; 63
    2556:	cd bf       	out	0x3d, r28	; 61
    2558:	df 91       	pop	r29
    255a:	cf 91       	pop	r28
    255c:	08 95       	ret

0000255e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    255e:	cf 93       	push	r28
    2560:	df 93       	push	r29
    2562:	00 d0       	rcall	.+0      	; 0x2564 <uxListRemove+0x6>
    2564:	00 d0       	rcall	.+0      	; 0x2566 <uxListRemove+0x8>
    2566:	cd b7       	in	r28, 0x3d	; 61
    2568:	de b7       	in	r29, 0x3e	; 62
    256a:	9c 83       	std	Y+4, r25	; 0x04
    256c:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    256e:	8b 81       	ldd	r24, Y+3	; 0x03
    2570:	9c 81       	ldd	r25, Y+4	; 0x04
    2572:	fc 01       	movw	r30, r24
    2574:	80 85       	ldd	r24, Z+8	; 0x08
    2576:	91 85       	ldd	r25, Z+9	; 0x09
    2578:	9a 83       	std	Y+2, r25	; 0x02
    257a:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    257c:	8b 81       	ldd	r24, Y+3	; 0x03
    257e:	9c 81       	ldd	r25, Y+4	; 0x04
    2580:	fc 01       	movw	r30, r24
    2582:	82 81       	ldd	r24, Z+2	; 0x02
    2584:	93 81       	ldd	r25, Z+3	; 0x03
    2586:	2b 81       	ldd	r18, Y+3	; 0x03
    2588:	3c 81       	ldd	r19, Y+4	; 0x04
    258a:	f9 01       	movw	r30, r18
    258c:	24 81       	ldd	r18, Z+4	; 0x04
    258e:	35 81       	ldd	r19, Z+5	; 0x05
    2590:	fc 01       	movw	r30, r24
    2592:	35 83       	std	Z+5, r19	; 0x05
    2594:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2596:	8b 81       	ldd	r24, Y+3	; 0x03
    2598:	9c 81       	ldd	r25, Y+4	; 0x04
    259a:	fc 01       	movw	r30, r24
    259c:	84 81       	ldd	r24, Z+4	; 0x04
    259e:	95 81       	ldd	r25, Z+5	; 0x05
    25a0:	2b 81       	ldd	r18, Y+3	; 0x03
    25a2:	3c 81       	ldd	r19, Y+4	; 0x04
    25a4:	f9 01       	movw	r30, r18
    25a6:	22 81       	ldd	r18, Z+2	; 0x02
    25a8:	33 81       	ldd	r19, Z+3	; 0x03
    25aa:	fc 01       	movw	r30, r24
    25ac:	33 83       	std	Z+3, r19	; 0x03
    25ae:	22 83       	std	Z+2, r18	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    25b0:	89 81       	ldd	r24, Y+1	; 0x01
    25b2:	9a 81       	ldd	r25, Y+2	; 0x02
    25b4:	fc 01       	movw	r30, r24
    25b6:	21 81       	ldd	r18, Z+1	; 0x01
    25b8:	32 81       	ldd	r19, Z+2	; 0x02
    25ba:	8b 81       	ldd	r24, Y+3	; 0x03
    25bc:	9c 81       	ldd	r25, Y+4	; 0x04
    25be:	28 17       	cp	r18, r24
    25c0:	39 07       	cpc	r19, r25
    25c2:	51 f4       	brne	.+20     	; 0x25d8 <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    25c4:	8b 81       	ldd	r24, Y+3	; 0x03
    25c6:	9c 81       	ldd	r25, Y+4	; 0x04
    25c8:	fc 01       	movw	r30, r24
    25ca:	24 81       	ldd	r18, Z+4	; 0x04
    25cc:	35 81       	ldd	r19, Z+5	; 0x05
    25ce:	89 81       	ldd	r24, Y+1	; 0x01
    25d0:	9a 81       	ldd	r25, Y+2	; 0x02
    25d2:	fc 01       	movw	r30, r24
    25d4:	32 83       	std	Z+2, r19	; 0x02
    25d6:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    25d8:	8b 81       	ldd	r24, Y+3	; 0x03
    25da:	9c 81       	ldd	r25, Y+4	; 0x04
    25dc:	fc 01       	movw	r30, r24
    25de:	11 86       	std	Z+9, r1	; 0x09
    25e0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    25e2:	89 81       	ldd	r24, Y+1	; 0x01
    25e4:	9a 81       	ldd	r25, Y+2	; 0x02
    25e6:	fc 01       	movw	r30, r24
    25e8:	80 81       	ld	r24, Z
    25ea:	2f ef       	ldi	r18, 0xFF	; 255
    25ec:	28 0f       	add	r18, r24
    25ee:	89 81       	ldd	r24, Y+1	; 0x01
    25f0:	9a 81       	ldd	r25, Y+2	; 0x02
    25f2:	fc 01       	movw	r30, r24
    25f4:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    25f6:	89 81       	ldd	r24, Y+1	; 0x01
    25f8:	9a 81       	ldd	r25, Y+2	; 0x02
    25fa:	fc 01       	movw	r30, r24
    25fc:	80 81       	ld	r24, Z
}
    25fe:	0f 90       	pop	r0
    2600:	0f 90       	pop	r0
    2602:	0f 90       	pop	r0
    2604:	0f 90       	pop	r0
    2606:	df 91       	pop	r29
    2608:	cf 91       	pop	r28
    260a:	08 95       	ret

0000260c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    260c:	cf 93       	push	r28
    260e:	df 93       	push	r29
    2610:	cd b7       	in	r28, 0x3d	; 61
    2612:	de b7       	in	r29, 0x3e	; 62
    2614:	28 97       	sbiw	r28, 0x08	; 8
    2616:	0f b6       	in	r0, 0x3f	; 63
    2618:	f8 94       	cli
    261a:	de bf       	out	0x3e, r29	; 62
    261c:	0f be       	out	0x3f, r0	; 63
    261e:	cd bf       	out	0x3d, r28	; 61
    2620:	9c 83       	std	Y+4, r25	; 0x04
    2622:	8b 83       	std	Y+3, r24	; 0x03
    2624:	7e 83       	std	Y+6, r23	; 0x06
    2626:	6d 83       	std	Y+5, r22	; 0x05
    2628:	58 87       	std	Y+8, r21	; 0x08
    262a:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    262c:	8b 81       	ldd	r24, Y+3	; 0x03
    262e:	9c 81       	ldd	r25, Y+4	; 0x04
    2630:	21 e1       	ldi	r18, 0x11	; 17
    2632:	fc 01       	movw	r30, r24
    2634:	20 83       	st	Z, r18
	pxTopOfStack--;
    2636:	8b 81       	ldd	r24, Y+3	; 0x03
    2638:	9c 81       	ldd	r25, Y+4	; 0x04
    263a:	01 97       	sbiw	r24, 0x01	; 1
    263c:	9c 83       	std	Y+4, r25	; 0x04
    263e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2640:	8b 81       	ldd	r24, Y+3	; 0x03
    2642:	9c 81       	ldd	r25, Y+4	; 0x04
    2644:	22 e2       	ldi	r18, 0x22	; 34
    2646:	fc 01       	movw	r30, r24
    2648:	20 83       	st	Z, r18
	pxTopOfStack--;
    264a:	8b 81       	ldd	r24, Y+3	; 0x03
    264c:	9c 81       	ldd	r25, Y+4	; 0x04
    264e:	01 97       	sbiw	r24, 0x01	; 1
    2650:	9c 83       	std	Y+4, r25	; 0x04
    2652:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2654:	8b 81       	ldd	r24, Y+3	; 0x03
    2656:	9c 81       	ldd	r25, Y+4	; 0x04
    2658:	23 e3       	ldi	r18, 0x33	; 51
    265a:	fc 01       	movw	r30, r24
    265c:	20 83       	st	Z, r18
	pxTopOfStack--;
    265e:	8b 81       	ldd	r24, Y+3	; 0x03
    2660:	9c 81       	ldd	r25, Y+4	; 0x04
    2662:	01 97       	sbiw	r24, 0x01	; 1
    2664:	9c 83       	std	Y+4, r25	; 0x04
    2666:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    2668:	8d 81       	ldd	r24, Y+5	; 0x05
    266a:	9e 81       	ldd	r25, Y+6	; 0x06
    266c:	9a 83       	std	Y+2, r25	; 0x02
    266e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2670:	29 81       	ldd	r18, Y+1	; 0x01
    2672:	8b 81       	ldd	r24, Y+3	; 0x03
    2674:	9c 81       	ldd	r25, Y+4	; 0x04
    2676:	fc 01       	movw	r30, r24
    2678:	20 83       	st	Z, r18
	pxTopOfStack--;
    267a:	8b 81       	ldd	r24, Y+3	; 0x03
    267c:	9c 81       	ldd	r25, Y+4	; 0x04
    267e:	01 97       	sbiw	r24, 0x01	; 1
    2680:	9c 83       	std	Y+4, r25	; 0x04
    2682:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2684:	89 81       	ldd	r24, Y+1	; 0x01
    2686:	9a 81       	ldd	r25, Y+2	; 0x02
    2688:	89 2f       	mov	r24, r25
    268a:	99 27       	eor	r25, r25
    268c:	9a 83       	std	Y+2, r25	; 0x02
    268e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2690:	29 81       	ldd	r18, Y+1	; 0x01
    2692:	8b 81       	ldd	r24, Y+3	; 0x03
    2694:	9c 81       	ldd	r25, Y+4	; 0x04
    2696:	fc 01       	movw	r30, r24
    2698:	20 83       	st	Z, r18
	pxTopOfStack--;
    269a:	8b 81       	ldd	r24, Y+3	; 0x03
    269c:	9c 81       	ldd	r25, Y+4	; 0x04
    269e:	01 97       	sbiw	r24, 0x01	; 1
    26a0:	9c 83       	std	Y+4, r25	; 0x04
    26a2:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    26a4:	8b 81       	ldd	r24, Y+3	; 0x03
    26a6:	9c 81       	ldd	r25, Y+4	; 0x04
    26a8:	fc 01       	movw	r30, r24
    26aa:	10 82       	st	Z, r1
	pxTopOfStack--;
    26ac:	8b 81       	ldd	r24, Y+3	; 0x03
    26ae:	9c 81       	ldd	r25, Y+4	; 0x04
    26b0:	01 97       	sbiw	r24, 0x01	; 1
    26b2:	9c 83       	std	Y+4, r25	; 0x04
    26b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    26b6:	8b 81       	ldd	r24, Y+3	; 0x03
    26b8:	9c 81       	ldd	r25, Y+4	; 0x04
    26ba:	20 e8       	ldi	r18, 0x80	; 128
    26bc:	fc 01       	movw	r30, r24
    26be:	20 83       	st	Z, r18
	pxTopOfStack--;
    26c0:	8b 81       	ldd	r24, Y+3	; 0x03
    26c2:	9c 81       	ldd	r25, Y+4	; 0x04
    26c4:	01 97       	sbiw	r24, 0x01	; 1
    26c6:	9c 83       	std	Y+4, r25	; 0x04
    26c8:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    26ca:	8b 81       	ldd	r24, Y+3	; 0x03
    26cc:	9c 81       	ldd	r25, Y+4	; 0x04
    26ce:	fc 01       	movw	r30, r24
    26d0:	10 82       	st	Z, r1
	pxTopOfStack--;
    26d2:	8b 81       	ldd	r24, Y+3	; 0x03
    26d4:	9c 81       	ldd	r25, Y+4	; 0x04
    26d6:	01 97       	sbiw	r24, 0x01	; 1
    26d8:	9c 83       	std	Y+4, r25	; 0x04
    26da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    26dc:	8b 81       	ldd	r24, Y+3	; 0x03
    26de:	9c 81       	ldd	r25, Y+4	; 0x04
    26e0:	22 e0       	ldi	r18, 0x02	; 2
    26e2:	fc 01       	movw	r30, r24
    26e4:	20 83       	st	Z, r18
	pxTopOfStack--;
    26e6:	8b 81       	ldd	r24, Y+3	; 0x03
    26e8:	9c 81       	ldd	r25, Y+4	; 0x04
    26ea:	01 97       	sbiw	r24, 0x01	; 1
    26ec:	9c 83       	std	Y+4, r25	; 0x04
    26ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    26f0:	8b 81       	ldd	r24, Y+3	; 0x03
    26f2:	9c 81       	ldd	r25, Y+4	; 0x04
    26f4:	23 e0       	ldi	r18, 0x03	; 3
    26f6:	fc 01       	movw	r30, r24
    26f8:	20 83       	st	Z, r18
	pxTopOfStack--;
    26fa:	8b 81       	ldd	r24, Y+3	; 0x03
    26fc:	9c 81       	ldd	r25, Y+4	; 0x04
    26fe:	01 97       	sbiw	r24, 0x01	; 1
    2700:	9c 83       	std	Y+4, r25	; 0x04
    2702:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2704:	8b 81       	ldd	r24, Y+3	; 0x03
    2706:	9c 81       	ldd	r25, Y+4	; 0x04
    2708:	24 e0       	ldi	r18, 0x04	; 4
    270a:	fc 01       	movw	r30, r24
    270c:	20 83       	st	Z, r18
	pxTopOfStack--;
    270e:	8b 81       	ldd	r24, Y+3	; 0x03
    2710:	9c 81       	ldd	r25, Y+4	; 0x04
    2712:	01 97       	sbiw	r24, 0x01	; 1
    2714:	9c 83       	std	Y+4, r25	; 0x04
    2716:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2718:	8b 81       	ldd	r24, Y+3	; 0x03
    271a:	9c 81       	ldd	r25, Y+4	; 0x04
    271c:	25 e0       	ldi	r18, 0x05	; 5
    271e:	fc 01       	movw	r30, r24
    2720:	20 83       	st	Z, r18
	pxTopOfStack--;
    2722:	8b 81       	ldd	r24, Y+3	; 0x03
    2724:	9c 81       	ldd	r25, Y+4	; 0x04
    2726:	01 97       	sbiw	r24, 0x01	; 1
    2728:	9c 83       	std	Y+4, r25	; 0x04
    272a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    272c:	8b 81       	ldd	r24, Y+3	; 0x03
    272e:	9c 81       	ldd	r25, Y+4	; 0x04
    2730:	26 e0       	ldi	r18, 0x06	; 6
    2732:	fc 01       	movw	r30, r24
    2734:	20 83       	st	Z, r18
	pxTopOfStack--;
    2736:	8b 81       	ldd	r24, Y+3	; 0x03
    2738:	9c 81       	ldd	r25, Y+4	; 0x04
    273a:	01 97       	sbiw	r24, 0x01	; 1
    273c:	9c 83       	std	Y+4, r25	; 0x04
    273e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2740:	8b 81       	ldd	r24, Y+3	; 0x03
    2742:	9c 81       	ldd	r25, Y+4	; 0x04
    2744:	27 e0       	ldi	r18, 0x07	; 7
    2746:	fc 01       	movw	r30, r24
    2748:	20 83       	st	Z, r18
	pxTopOfStack--;
    274a:	8b 81       	ldd	r24, Y+3	; 0x03
    274c:	9c 81       	ldd	r25, Y+4	; 0x04
    274e:	01 97       	sbiw	r24, 0x01	; 1
    2750:	9c 83       	std	Y+4, r25	; 0x04
    2752:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2754:	8b 81       	ldd	r24, Y+3	; 0x03
    2756:	9c 81       	ldd	r25, Y+4	; 0x04
    2758:	28 e0       	ldi	r18, 0x08	; 8
    275a:	fc 01       	movw	r30, r24
    275c:	20 83       	st	Z, r18
	pxTopOfStack--;
    275e:	8b 81       	ldd	r24, Y+3	; 0x03
    2760:	9c 81       	ldd	r25, Y+4	; 0x04
    2762:	01 97       	sbiw	r24, 0x01	; 1
    2764:	9c 83       	std	Y+4, r25	; 0x04
    2766:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2768:	8b 81       	ldd	r24, Y+3	; 0x03
    276a:	9c 81       	ldd	r25, Y+4	; 0x04
    276c:	29 e0       	ldi	r18, 0x09	; 9
    276e:	fc 01       	movw	r30, r24
    2770:	20 83       	st	Z, r18
	pxTopOfStack--;
    2772:	8b 81       	ldd	r24, Y+3	; 0x03
    2774:	9c 81       	ldd	r25, Y+4	; 0x04
    2776:	01 97       	sbiw	r24, 0x01	; 1
    2778:	9c 83       	std	Y+4, r25	; 0x04
    277a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    277c:	8b 81       	ldd	r24, Y+3	; 0x03
    277e:	9c 81       	ldd	r25, Y+4	; 0x04
    2780:	20 e1       	ldi	r18, 0x10	; 16
    2782:	fc 01       	movw	r30, r24
    2784:	20 83       	st	Z, r18
	pxTopOfStack--;
    2786:	8b 81       	ldd	r24, Y+3	; 0x03
    2788:	9c 81       	ldd	r25, Y+4	; 0x04
    278a:	01 97       	sbiw	r24, 0x01	; 1
    278c:	9c 83       	std	Y+4, r25	; 0x04
    278e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2790:	8b 81       	ldd	r24, Y+3	; 0x03
    2792:	9c 81       	ldd	r25, Y+4	; 0x04
    2794:	21 e1       	ldi	r18, 0x11	; 17
    2796:	fc 01       	movw	r30, r24
    2798:	20 83       	st	Z, r18
	pxTopOfStack--;
    279a:	8b 81       	ldd	r24, Y+3	; 0x03
    279c:	9c 81       	ldd	r25, Y+4	; 0x04
    279e:	01 97       	sbiw	r24, 0x01	; 1
    27a0:	9c 83       	std	Y+4, r25	; 0x04
    27a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    27a4:	8b 81       	ldd	r24, Y+3	; 0x03
    27a6:	9c 81       	ldd	r25, Y+4	; 0x04
    27a8:	22 e1       	ldi	r18, 0x12	; 18
    27aa:	fc 01       	movw	r30, r24
    27ac:	20 83       	st	Z, r18
	pxTopOfStack--;
    27ae:	8b 81       	ldd	r24, Y+3	; 0x03
    27b0:	9c 81       	ldd	r25, Y+4	; 0x04
    27b2:	01 97       	sbiw	r24, 0x01	; 1
    27b4:	9c 83       	std	Y+4, r25	; 0x04
    27b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    27b8:	8b 81       	ldd	r24, Y+3	; 0x03
    27ba:	9c 81       	ldd	r25, Y+4	; 0x04
    27bc:	23 e1       	ldi	r18, 0x13	; 19
    27be:	fc 01       	movw	r30, r24
    27c0:	20 83       	st	Z, r18
	pxTopOfStack--;
    27c2:	8b 81       	ldd	r24, Y+3	; 0x03
    27c4:	9c 81       	ldd	r25, Y+4	; 0x04
    27c6:	01 97       	sbiw	r24, 0x01	; 1
    27c8:	9c 83       	std	Y+4, r25	; 0x04
    27ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    27cc:	8b 81       	ldd	r24, Y+3	; 0x03
    27ce:	9c 81       	ldd	r25, Y+4	; 0x04
    27d0:	24 e1       	ldi	r18, 0x14	; 20
    27d2:	fc 01       	movw	r30, r24
    27d4:	20 83       	st	Z, r18
	pxTopOfStack--;
    27d6:	8b 81       	ldd	r24, Y+3	; 0x03
    27d8:	9c 81       	ldd	r25, Y+4	; 0x04
    27da:	01 97       	sbiw	r24, 0x01	; 1
    27dc:	9c 83       	std	Y+4, r25	; 0x04
    27de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    27e0:	8b 81       	ldd	r24, Y+3	; 0x03
    27e2:	9c 81       	ldd	r25, Y+4	; 0x04
    27e4:	25 e1       	ldi	r18, 0x15	; 21
    27e6:	fc 01       	movw	r30, r24
    27e8:	20 83       	st	Z, r18
	pxTopOfStack--;
    27ea:	8b 81       	ldd	r24, Y+3	; 0x03
    27ec:	9c 81       	ldd	r25, Y+4	; 0x04
    27ee:	01 97       	sbiw	r24, 0x01	; 1
    27f0:	9c 83       	std	Y+4, r25	; 0x04
    27f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    27f4:	8b 81       	ldd	r24, Y+3	; 0x03
    27f6:	9c 81       	ldd	r25, Y+4	; 0x04
    27f8:	26 e1       	ldi	r18, 0x16	; 22
    27fa:	fc 01       	movw	r30, r24
    27fc:	20 83       	st	Z, r18
	pxTopOfStack--;
    27fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2800:	9c 81       	ldd	r25, Y+4	; 0x04
    2802:	01 97       	sbiw	r24, 0x01	; 1
    2804:	9c 83       	std	Y+4, r25	; 0x04
    2806:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2808:	8b 81       	ldd	r24, Y+3	; 0x03
    280a:	9c 81       	ldd	r25, Y+4	; 0x04
    280c:	27 e1       	ldi	r18, 0x17	; 23
    280e:	fc 01       	movw	r30, r24
    2810:	20 83       	st	Z, r18
	pxTopOfStack--;
    2812:	8b 81       	ldd	r24, Y+3	; 0x03
    2814:	9c 81       	ldd	r25, Y+4	; 0x04
    2816:	01 97       	sbiw	r24, 0x01	; 1
    2818:	9c 83       	std	Y+4, r25	; 0x04
    281a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    281c:	8b 81       	ldd	r24, Y+3	; 0x03
    281e:	9c 81       	ldd	r25, Y+4	; 0x04
    2820:	28 e1       	ldi	r18, 0x18	; 24
    2822:	fc 01       	movw	r30, r24
    2824:	20 83       	st	Z, r18
	pxTopOfStack--;
    2826:	8b 81       	ldd	r24, Y+3	; 0x03
    2828:	9c 81       	ldd	r25, Y+4	; 0x04
    282a:	01 97       	sbiw	r24, 0x01	; 1
    282c:	9c 83       	std	Y+4, r25	; 0x04
    282e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2830:	8b 81       	ldd	r24, Y+3	; 0x03
    2832:	9c 81       	ldd	r25, Y+4	; 0x04
    2834:	29 e1       	ldi	r18, 0x19	; 25
    2836:	fc 01       	movw	r30, r24
    2838:	20 83       	st	Z, r18
	pxTopOfStack--;
    283a:	8b 81       	ldd	r24, Y+3	; 0x03
    283c:	9c 81       	ldd	r25, Y+4	; 0x04
    283e:	01 97       	sbiw	r24, 0x01	; 1
    2840:	9c 83       	std	Y+4, r25	; 0x04
    2842:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2844:	8b 81       	ldd	r24, Y+3	; 0x03
    2846:	9c 81       	ldd	r25, Y+4	; 0x04
    2848:	20 e2       	ldi	r18, 0x20	; 32
    284a:	fc 01       	movw	r30, r24
    284c:	20 83       	st	Z, r18
	pxTopOfStack--;
    284e:	8b 81       	ldd	r24, Y+3	; 0x03
    2850:	9c 81       	ldd	r25, Y+4	; 0x04
    2852:	01 97       	sbiw	r24, 0x01	; 1
    2854:	9c 83       	std	Y+4, r25	; 0x04
    2856:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2858:	8b 81       	ldd	r24, Y+3	; 0x03
    285a:	9c 81       	ldd	r25, Y+4	; 0x04
    285c:	21 e2       	ldi	r18, 0x21	; 33
    285e:	fc 01       	movw	r30, r24
    2860:	20 83       	st	Z, r18
	pxTopOfStack--;
    2862:	8b 81       	ldd	r24, Y+3	; 0x03
    2864:	9c 81       	ldd	r25, Y+4	; 0x04
    2866:	01 97       	sbiw	r24, 0x01	; 1
    2868:	9c 83       	std	Y+4, r25	; 0x04
    286a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    286c:	8b 81       	ldd	r24, Y+3	; 0x03
    286e:	9c 81       	ldd	r25, Y+4	; 0x04
    2870:	22 e2       	ldi	r18, 0x22	; 34
    2872:	fc 01       	movw	r30, r24
    2874:	20 83       	st	Z, r18
	pxTopOfStack--;
    2876:	8b 81       	ldd	r24, Y+3	; 0x03
    2878:	9c 81       	ldd	r25, Y+4	; 0x04
    287a:	01 97       	sbiw	r24, 0x01	; 1
    287c:	9c 83       	std	Y+4, r25	; 0x04
    287e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2880:	8b 81       	ldd	r24, Y+3	; 0x03
    2882:	9c 81       	ldd	r25, Y+4	; 0x04
    2884:	23 e2       	ldi	r18, 0x23	; 35
    2886:	fc 01       	movw	r30, r24
    2888:	20 83       	st	Z, r18
	pxTopOfStack--;
    288a:	8b 81       	ldd	r24, Y+3	; 0x03
    288c:	9c 81       	ldd	r25, Y+4	; 0x04
    288e:	01 97       	sbiw	r24, 0x01	; 1
    2890:	9c 83       	std	Y+4, r25	; 0x04
    2892:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    2894:	8f 81       	ldd	r24, Y+7	; 0x07
    2896:	98 85       	ldd	r25, Y+8	; 0x08
    2898:	9a 83       	std	Y+2, r25	; 0x02
    289a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    289c:	29 81       	ldd	r18, Y+1	; 0x01
    289e:	8b 81       	ldd	r24, Y+3	; 0x03
    28a0:	9c 81       	ldd	r25, Y+4	; 0x04
    28a2:	fc 01       	movw	r30, r24
    28a4:	20 83       	st	Z, r18
	pxTopOfStack--;
    28a6:	8b 81       	ldd	r24, Y+3	; 0x03
    28a8:	9c 81       	ldd	r25, Y+4	; 0x04
    28aa:	01 97       	sbiw	r24, 0x01	; 1
    28ac:	9c 83       	std	Y+4, r25	; 0x04
    28ae:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    28b0:	89 81       	ldd	r24, Y+1	; 0x01
    28b2:	9a 81       	ldd	r25, Y+2	; 0x02
    28b4:	89 2f       	mov	r24, r25
    28b6:	99 27       	eor	r25, r25
    28b8:	9a 83       	std	Y+2, r25	; 0x02
    28ba:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    28bc:	29 81       	ldd	r18, Y+1	; 0x01
    28be:	8b 81       	ldd	r24, Y+3	; 0x03
    28c0:	9c 81       	ldd	r25, Y+4	; 0x04
    28c2:	fc 01       	movw	r30, r24
    28c4:	20 83       	st	Z, r18
	pxTopOfStack--;
    28c6:	8b 81       	ldd	r24, Y+3	; 0x03
    28c8:	9c 81       	ldd	r25, Y+4	; 0x04
    28ca:	01 97       	sbiw	r24, 0x01	; 1
    28cc:	9c 83       	std	Y+4, r25	; 0x04
    28ce:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    28d0:	8b 81       	ldd	r24, Y+3	; 0x03
    28d2:	9c 81       	ldd	r25, Y+4	; 0x04
    28d4:	26 e2       	ldi	r18, 0x26	; 38
    28d6:	fc 01       	movw	r30, r24
    28d8:	20 83       	st	Z, r18
	pxTopOfStack--;
    28da:	8b 81       	ldd	r24, Y+3	; 0x03
    28dc:	9c 81       	ldd	r25, Y+4	; 0x04
    28de:	01 97       	sbiw	r24, 0x01	; 1
    28e0:	9c 83       	std	Y+4, r25	; 0x04
    28e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    28e4:	8b 81       	ldd	r24, Y+3	; 0x03
    28e6:	9c 81       	ldd	r25, Y+4	; 0x04
    28e8:	27 e2       	ldi	r18, 0x27	; 39
    28ea:	fc 01       	movw	r30, r24
    28ec:	20 83       	st	Z, r18
	pxTopOfStack--;
    28ee:	8b 81       	ldd	r24, Y+3	; 0x03
    28f0:	9c 81       	ldd	r25, Y+4	; 0x04
    28f2:	01 97       	sbiw	r24, 0x01	; 1
    28f4:	9c 83       	std	Y+4, r25	; 0x04
    28f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    28f8:	8b 81       	ldd	r24, Y+3	; 0x03
    28fa:	9c 81       	ldd	r25, Y+4	; 0x04
    28fc:	28 e2       	ldi	r18, 0x28	; 40
    28fe:	fc 01       	movw	r30, r24
    2900:	20 83       	st	Z, r18
	pxTopOfStack--;
    2902:	8b 81       	ldd	r24, Y+3	; 0x03
    2904:	9c 81       	ldd	r25, Y+4	; 0x04
    2906:	01 97       	sbiw	r24, 0x01	; 1
    2908:	9c 83       	std	Y+4, r25	; 0x04
    290a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    290c:	8b 81       	ldd	r24, Y+3	; 0x03
    290e:	9c 81       	ldd	r25, Y+4	; 0x04
    2910:	29 e2       	ldi	r18, 0x29	; 41
    2912:	fc 01       	movw	r30, r24
    2914:	20 83       	st	Z, r18
	pxTopOfStack--;
    2916:	8b 81       	ldd	r24, Y+3	; 0x03
    2918:	9c 81       	ldd	r25, Y+4	; 0x04
    291a:	01 97       	sbiw	r24, 0x01	; 1
    291c:	9c 83       	std	Y+4, r25	; 0x04
    291e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2920:	8b 81       	ldd	r24, Y+3	; 0x03
    2922:	9c 81       	ldd	r25, Y+4	; 0x04
    2924:	20 e3       	ldi	r18, 0x30	; 48
    2926:	fc 01       	movw	r30, r24
    2928:	20 83       	st	Z, r18
	pxTopOfStack--;
    292a:	8b 81       	ldd	r24, Y+3	; 0x03
    292c:	9c 81       	ldd	r25, Y+4	; 0x04
    292e:	01 97       	sbiw	r24, 0x01	; 1
    2930:	9c 83       	std	Y+4, r25	; 0x04
    2932:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2934:	8b 81       	ldd	r24, Y+3	; 0x03
    2936:	9c 81       	ldd	r25, Y+4	; 0x04
    2938:	21 e3       	ldi	r18, 0x31	; 49
    293a:	fc 01       	movw	r30, r24
    293c:	20 83       	st	Z, r18
	pxTopOfStack--;
    293e:	8b 81       	ldd	r24, Y+3	; 0x03
    2940:	9c 81       	ldd	r25, Y+4	; 0x04
    2942:	01 97       	sbiw	r24, 0x01	; 1
    2944:	9c 83       	std	Y+4, r25	; 0x04
    2946:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2948:	8b 81       	ldd	r24, Y+3	; 0x03
    294a:	9c 81       	ldd	r25, Y+4	; 0x04
}
    294c:	28 96       	adiw	r28, 0x08	; 8
    294e:	0f b6       	in	r0, 0x3f	; 63
    2950:	f8 94       	cli
    2952:	de bf       	out	0x3e, r29	; 62
    2954:	0f be       	out	0x3f, r0	; 63
    2956:	cd bf       	out	0x3d, r28	; 61
    2958:	df 91       	pop	r29
    295a:	cf 91       	pop	r28
    295c:	08 95       	ret

0000295e <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    295e:	cf 93       	push	r28
    2960:	df 93       	push	r29
    2962:	cd b7       	in	r28, 0x3d	; 61
    2964:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2966:	0e 94 a1 15 	call	0x2b42	; 0x2b42 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    296a:	a0 91 fe 04 	lds	r26, 0x04FE
    296e:	b0 91 ff 04 	lds	r27, 0x04FF
    2972:	cd 91       	ld	r28, X+
    2974:	cd bf       	out	0x3d, r28	; 61
    2976:	dd 91       	ld	r29, X+
    2978:	de bf       	out	0x3e, r29	; 62
    297a:	ff 91       	pop	r31
    297c:	ef 91       	pop	r30
    297e:	df 91       	pop	r29
    2980:	cf 91       	pop	r28
    2982:	bf 91       	pop	r27
    2984:	af 91       	pop	r26
    2986:	9f 91       	pop	r25
    2988:	8f 91       	pop	r24
    298a:	7f 91       	pop	r23
    298c:	6f 91       	pop	r22
    298e:	5f 91       	pop	r21
    2990:	4f 91       	pop	r20
    2992:	3f 91       	pop	r19
    2994:	2f 91       	pop	r18
    2996:	1f 91       	pop	r17
    2998:	0f 91       	pop	r16
    299a:	ff 90       	pop	r15
    299c:	ef 90       	pop	r14
    299e:	df 90       	pop	r13
    29a0:	cf 90       	pop	r12
    29a2:	bf 90       	pop	r11
    29a4:	af 90       	pop	r10
    29a6:	9f 90       	pop	r9
    29a8:	8f 90       	pop	r8
    29aa:	7f 90       	pop	r7
    29ac:	6f 90       	pop	r6
    29ae:	5f 90       	pop	r5
    29b0:	4f 90       	pop	r4
    29b2:	3f 90       	pop	r3
    29b4:	2f 90       	pop	r2
    29b6:	1f 90       	pop	r1
    29b8:	0f 90       	pop	r0
    29ba:	0f be       	out	0x3f, r0	; 63
    29bc:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    29be:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    29c0:	81 e0       	ldi	r24, 0x01	; 1
}
    29c2:	df 91       	pop	r29
    29c4:	cf 91       	pop	r28
    29c6:	08 95       	ret

000029c8 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    29c8:	cf 93       	push	r28
    29ca:	df 93       	push	r29
    29cc:	cd b7       	in	r28, 0x3d	; 61
    29ce:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    29d0:	df 91       	pop	r29
    29d2:	cf 91       	pop	r28
    29d4:	08 95       	ret

000029d6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    29d6:	0f 92       	push	r0
    29d8:	0f b6       	in	r0, 0x3f	; 63
    29da:	f8 94       	cli
    29dc:	0f 92       	push	r0
    29de:	1f 92       	push	r1
    29e0:	11 24       	eor	r1, r1
    29e2:	2f 92       	push	r2
    29e4:	3f 92       	push	r3
    29e6:	4f 92       	push	r4
    29e8:	5f 92       	push	r5
    29ea:	6f 92       	push	r6
    29ec:	7f 92       	push	r7
    29ee:	8f 92       	push	r8
    29f0:	9f 92       	push	r9
    29f2:	af 92       	push	r10
    29f4:	bf 92       	push	r11
    29f6:	cf 92       	push	r12
    29f8:	df 92       	push	r13
    29fa:	ef 92       	push	r14
    29fc:	ff 92       	push	r15
    29fe:	0f 93       	push	r16
    2a00:	1f 93       	push	r17
    2a02:	2f 93       	push	r18
    2a04:	3f 93       	push	r19
    2a06:	4f 93       	push	r20
    2a08:	5f 93       	push	r21
    2a0a:	6f 93       	push	r22
    2a0c:	7f 93       	push	r23
    2a0e:	8f 93       	push	r24
    2a10:	9f 93       	push	r25
    2a12:	af 93       	push	r26
    2a14:	bf 93       	push	r27
    2a16:	cf 93       	push	r28
    2a18:	df 93       	push	r29
    2a1a:	ef 93       	push	r30
    2a1c:	ff 93       	push	r31
    2a1e:	a0 91 fe 04 	lds	r26, 0x04FE
    2a22:	b0 91 ff 04 	lds	r27, 0x04FF
    2a26:	0d b6       	in	r0, 0x3d	; 61
    2a28:	0d 92       	st	X+, r0
    2a2a:	0e b6       	in	r0, 0x3e	; 62
    2a2c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2a2e:	0e 94 a2 20 	call	0x4144	; 0x4144 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2a32:	a0 91 fe 04 	lds	r26, 0x04FE
    2a36:	b0 91 ff 04 	lds	r27, 0x04FF
    2a3a:	cd 91       	ld	r28, X+
    2a3c:	cd bf       	out	0x3d, r28	; 61
    2a3e:	dd 91       	ld	r29, X+
    2a40:	de bf       	out	0x3e, r29	; 62
    2a42:	ff 91       	pop	r31
    2a44:	ef 91       	pop	r30
    2a46:	df 91       	pop	r29
    2a48:	cf 91       	pop	r28
    2a4a:	bf 91       	pop	r27
    2a4c:	af 91       	pop	r26
    2a4e:	9f 91       	pop	r25
    2a50:	8f 91       	pop	r24
    2a52:	7f 91       	pop	r23
    2a54:	6f 91       	pop	r22
    2a56:	5f 91       	pop	r21
    2a58:	4f 91       	pop	r20
    2a5a:	3f 91       	pop	r19
    2a5c:	2f 91       	pop	r18
    2a5e:	1f 91       	pop	r17
    2a60:	0f 91       	pop	r16
    2a62:	ff 90       	pop	r15
    2a64:	ef 90       	pop	r14
    2a66:	df 90       	pop	r13
    2a68:	cf 90       	pop	r12
    2a6a:	bf 90       	pop	r11
    2a6c:	af 90       	pop	r10
    2a6e:	9f 90       	pop	r9
    2a70:	8f 90       	pop	r8
    2a72:	7f 90       	pop	r7
    2a74:	6f 90       	pop	r6
    2a76:	5f 90       	pop	r5
    2a78:	4f 90       	pop	r4
    2a7a:	3f 90       	pop	r3
    2a7c:	2f 90       	pop	r2
    2a7e:	1f 90       	pop	r1
    2a80:	0f 90       	pop	r0
    2a82:	0f be       	out	0x3f, r0	; 63
    2a84:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2a86:	08 95       	ret

00002a88 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2a88:	0f 92       	push	r0
    2a8a:	0f b6       	in	r0, 0x3f	; 63
    2a8c:	f8 94       	cli
    2a8e:	0f 92       	push	r0
    2a90:	1f 92       	push	r1
    2a92:	11 24       	eor	r1, r1
    2a94:	2f 92       	push	r2
    2a96:	3f 92       	push	r3
    2a98:	4f 92       	push	r4
    2a9a:	5f 92       	push	r5
    2a9c:	6f 92       	push	r6
    2a9e:	7f 92       	push	r7
    2aa0:	8f 92       	push	r8
    2aa2:	9f 92       	push	r9
    2aa4:	af 92       	push	r10
    2aa6:	bf 92       	push	r11
    2aa8:	cf 92       	push	r12
    2aaa:	df 92       	push	r13
    2aac:	ef 92       	push	r14
    2aae:	ff 92       	push	r15
    2ab0:	0f 93       	push	r16
    2ab2:	1f 93       	push	r17
    2ab4:	2f 93       	push	r18
    2ab6:	3f 93       	push	r19
    2ab8:	4f 93       	push	r20
    2aba:	5f 93       	push	r21
    2abc:	6f 93       	push	r22
    2abe:	7f 93       	push	r23
    2ac0:	8f 93       	push	r24
    2ac2:	9f 93       	push	r25
    2ac4:	af 93       	push	r26
    2ac6:	bf 93       	push	r27
    2ac8:	cf 93       	push	r28
    2aca:	df 93       	push	r29
    2acc:	ef 93       	push	r30
    2ace:	ff 93       	push	r31
    2ad0:	a0 91 fe 04 	lds	r26, 0x04FE
    2ad4:	b0 91 ff 04 	lds	r27, 0x04FF
    2ad8:	0d b6       	in	r0, 0x3d	; 61
    2ada:	0d 92       	st	X+, r0
    2adc:	0e b6       	in	r0, 0x3e	; 62
    2ade:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2ae0:	0e 94 b4 1f 	call	0x3f68	; 0x3f68 <xTaskIncrementTick>
    2ae4:	88 23       	and	r24, r24
    2ae6:	11 f0       	breq	.+4      	; 0x2aec <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2ae8:	0e 94 a2 20 	call	0x4144	; 0x4144 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2aec:	a0 91 fe 04 	lds	r26, 0x04FE
    2af0:	b0 91 ff 04 	lds	r27, 0x04FF
    2af4:	cd 91       	ld	r28, X+
    2af6:	cd bf       	out	0x3d, r28	; 61
    2af8:	dd 91       	ld	r29, X+
    2afa:	de bf       	out	0x3e, r29	; 62
    2afc:	ff 91       	pop	r31
    2afe:	ef 91       	pop	r30
    2b00:	df 91       	pop	r29
    2b02:	cf 91       	pop	r28
    2b04:	bf 91       	pop	r27
    2b06:	af 91       	pop	r26
    2b08:	9f 91       	pop	r25
    2b0a:	8f 91       	pop	r24
    2b0c:	7f 91       	pop	r23
    2b0e:	6f 91       	pop	r22
    2b10:	5f 91       	pop	r21
    2b12:	4f 91       	pop	r20
    2b14:	3f 91       	pop	r19
    2b16:	2f 91       	pop	r18
    2b18:	1f 91       	pop	r17
    2b1a:	0f 91       	pop	r16
    2b1c:	ff 90       	pop	r15
    2b1e:	ef 90       	pop	r14
    2b20:	df 90       	pop	r13
    2b22:	cf 90       	pop	r12
    2b24:	bf 90       	pop	r11
    2b26:	af 90       	pop	r10
    2b28:	9f 90       	pop	r9
    2b2a:	8f 90       	pop	r8
    2b2c:	7f 90       	pop	r7
    2b2e:	6f 90       	pop	r6
    2b30:	5f 90       	pop	r5
    2b32:	4f 90       	pop	r4
    2b34:	3f 90       	pop	r3
    2b36:	2f 90       	pop	r2
    2b38:	1f 90       	pop	r1
    2b3a:	0f 90       	pop	r0
    2b3c:	0f be       	out	0x3f, r0	; 63
    2b3e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2b40:	08 95       	ret

00002b42 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2b42:	cf 93       	push	r28
    2b44:	df 93       	push	r29
    2b46:	00 d0       	rcall	.+0      	; 0x2b48 <prvSetupTimerInterrupt+0x6>
    2b48:	00 d0       	rcall	.+0      	; 0x2b4a <prvSetupTimerInterrupt+0x8>
    2b4a:	00 d0       	rcall	.+0      	; 0x2b4c <prvSetupTimerInterrupt+0xa>
    2b4c:	cd b7       	in	r28, 0x3d	; 61
    2b4e:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2b50:	80 e8       	ldi	r24, 0x80	; 128
    2b52:	9e e3       	ldi	r25, 0x3E	; 62
    2b54:	a0 e0       	ldi	r26, 0x00	; 0
    2b56:	b0 e0       	ldi	r27, 0x00	; 0
    2b58:	89 83       	std	Y+1, r24	; 0x01
    2b5a:	9a 83       	std	Y+2, r25	; 0x02
    2b5c:	ab 83       	std	Y+3, r26	; 0x03
    2b5e:	bc 83       	std	Y+4, r27	; 0x04

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2b60:	89 81       	ldd	r24, Y+1	; 0x01
    2b62:	9a 81       	ldd	r25, Y+2	; 0x02
    2b64:	ab 81       	ldd	r26, Y+3	; 0x03
    2b66:	bc 81       	ldd	r27, Y+4	; 0x04
    2b68:	68 94       	set
    2b6a:	15 f8       	bld	r1, 5
    2b6c:	b6 95       	lsr	r27
    2b6e:	a7 95       	ror	r26
    2b70:	97 95       	ror	r25
    2b72:	87 95       	ror	r24
    2b74:	16 94       	lsr	r1
    2b76:	d1 f7       	brne	.-12     	; 0x2b6c <prvSetupTimerInterrupt+0x2a>
    2b78:	89 83       	std	Y+1, r24	; 0x01
    2b7a:	9a 83       	std	Y+2, r25	; 0x02
    2b7c:	ab 83       	std	Y+3, r26	; 0x03
    2b7e:	bc 83       	std	Y+4, r27	; 0x04

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    2b80:	89 81       	ldd	r24, Y+1	; 0x01
    2b82:	9a 81       	ldd	r25, Y+2	; 0x02
    2b84:	ab 81       	ldd	r26, Y+3	; 0x03
    2b86:	bc 81       	ldd	r27, Y+4	; 0x04
    2b88:	01 97       	sbiw	r24, 0x01	; 1
    2b8a:	a1 09       	sbc	r26, r1
    2b8c:	b1 09       	sbc	r27, r1
    2b8e:	89 83       	std	Y+1, r24	; 0x01
    2b90:	9a 83       	std	Y+2, r25	; 0x02
    2b92:	ab 83       	std	Y+3, r26	; 0x03
    2b94:	bc 83       	std	Y+4, r27	; 0x04

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2b96:	89 81       	ldd	r24, Y+1	; 0x01
    2b98:	8d 83       	std	Y+5, r24	; 0x05
	ulCompareMatch >>= 8;
    2b9a:	89 81       	ldd	r24, Y+1	; 0x01
    2b9c:	9a 81       	ldd	r25, Y+2	; 0x02
    2b9e:	ab 81       	ldd	r26, Y+3	; 0x03
    2ba0:	bc 81       	ldd	r27, Y+4	; 0x04
    2ba2:	89 2f       	mov	r24, r25
    2ba4:	9a 2f       	mov	r25, r26
    2ba6:	ab 2f       	mov	r26, r27
    2ba8:	bb 27       	eor	r27, r27
    2baa:	89 83       	std	Y+1, r24	; 0x01
    2bac:	9a 83       	std	Y+2, r25	; 0x02
    2bae:	ab 83       	std	Y+3, r26	; 0x03
    2bb0:	bc 83       	std	Y+4, r27	; 0x04
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2bb2:	89 81       	ldd	r24, Y+1	; 0x01
    2bb4:	8e 83       	std	Y+6, r24	; 0x06
	OCR1AH = ucHighByte;
    2bb6:	89 e8       	ldi	r24, 0x89	; 137
    2bb8:	90 e0       	ldi	r25, 0x00	; 0
    2bba:	2e 81       	ldd	r18, Y+6	; 0x06
    2bbc:	fc 01       	movw	r30, r24
    2bbe:	20 83       	st	Z, r18
	OCR1AL = ucLowByte;
    2bc0:	88 e8       	ldi	r24, 0x88	; 136
    2bc2:	90 e0       	ldi	r25, 0x00	; 0
    2bc4:	2d 81       	ldd	r18, Y+5	; 0x05
    2bc6:	fc 01       	movw	r30, r24
    2bc8:	20 83       	st	Z, r18

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2bca:	8b e0       	ldi	r24, 0x0B	; 11
    2bcc:	8d 83       	std	Y+5, r24	; 0x05
	TCCR1B = ucLowByte;
    2bce:	81 e8       	ldi	r24, 0x81	; 129
    2bd0:	90 e0       	ldi	r25, 0x00	; 0
    2bd2:	2d 81       	ldd	r18, Y+5	; 0x05
    2bd4:	fc 01       	movw	r30, r24
    2bd6:	20 83       	st	Z, r18

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    2bd8:	8f e6       	ldi	r24, 0x6F	; 111
    2bda:	90 e0       	ldi	r25, 0x00	; 0
    2bdc:	fc 01       	movw	r30, r24
    2bde:	80 81       	ld	r24, Z
    2be0:	8d 83       	std	Y+5, r24	; 0x05
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2be2:	8d 81       	ldd	r24, Y+5	; 0x05
    2be4:	82 60       	ori	r24, 0x02	; 2
    2be6:	8d 83       	std	Y+5, r24	; 0x05
	TIMSK1 = ucLowByte;
    2be8:	8f e6       	ldi	r24, 0x6F	; 111
    2bea:	90 e0       	ldi	r25, 0x00	; 0
    2bec:	2d 81       	ldd	r18, Y+5	; 0x05
    2bee:	fc 01       	movw	r30, r24
    2bf0:	20 83       	st	Z, r18
	
	TCNT1 = 0;
    2bf2:	84 e8       	ldi	r24, 0x84	; 132
    2bf4:	90 e0       	ldi	r25, 0x00	; 0
    2bf6:	fc 01       	movw	r30, r24
    2bf8:	11 82       	std	Z+1, r1	; 0x01
    2bfa:	10 82       	st	Z, r1
}
    2bfc:	26 96       	adiw	r28, 0x06	; 6
    2bfe:	0f b6       	in	r0, 0x3f	; 63
    2c00:	f8 94       	cli
    2c02:	de bf       	out	0x3e, r29	; 62
    2c04:	0f be       	out	0x3f, r0	; 63
    2c06:	cd bf       	out	0x3d, r28	; 61
    2c08:	df 91       	pop	r29
    2c0a:	cf 91       	pop	r28
    2c0c:	08 95       	ret

00002c0e <__vector_12>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	ISR(TIMER1_COMPA_vect, ISR_NAKED)
	{
		vPortYieldFromTick();
    2c0e:	0e 94 44 15 	call	0x2a88	; 0x2a88 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2c12:	18 95       	reti

00002c14 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2c14:	cf 93       	push	r28
    2c16:	df 93       	push	r29
    2c18:	00 d0       	rcall	.+0      	; 0x2c1a <pvPortMalloc+0x6>
    2c1a:	00 d0       	rcall	.+0      	; 0x2c1c <pvPortMalloc+0x8>
    2c1c:	cd b7       	in	r28, 0x3d	; 61
    2c1e:	de b7       	in	r29, 0x3e	; 62
    2c20:	9c 83       	std	Y+4, r25	; 0x04
    2c22:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    2c24:	1a 82       	std	Y+2, r1	; 0x02
    2c26:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2c28:	0e 94 e5 1e 	call	0x3dca	; 0x3dca <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    2c2c:	80 91 fc 04 	lds	r24, 0x04FC
    2c30:	90 91 fd 04 	lds	r25, 0x04FD
    2c34:	89 2b       	or	r24, r25
    2c36:	31 f4       	brne	.+12     	; 0x2c44 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2c38:	83 e1       	ldi	r24, 0x13	; 19
    2c3a:	91 e0       	ldi	r25, 0x01	; 1
    2c3c:	90 93 fd 04 	sts	0x04FD, r25
    2c40:	80 93 fc 04 	sts	0x04FC, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2c44:	20 91 fa 04 	lds	r18, 0x04FA
    2c48:	30 91 fb 04 	lds	r19, 0x04FB
    2c4c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c4e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c50:	82 0f       	add	r24, r18
    2c52:	93 1f       	adc	r25, r19
    2c54:	87 3e       	cpi	r24, 0xE7	; 231
    2c56:	93 40       	sbci	r25, 0x03	; 3
    2c58:	38 f5       	brcc	.+78     	; 0x2ca8 <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    2c5a:	20 91 fa 04 	lds	r18, 0x04FA
    2c5e:	30 91 fb 04 	lds	r19, 0x04FB
    2c62:	8b 81       	ldd	r24, Y+3	; 0x03
    2c64:	9c 81       	ldd	r25, Y+4	; 0x04
    2c66:	28 0f       	add	r18, r24
    2c68:	39 1f       	adc	r19, r25
    2c6a:	80 91 fa 04 	lds	r24, 0x04FA
    2c6e:	90 91 fb 04 	lds	r25, 0x04FB
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2c72:	82 17       	cp	r24, r18
    2c74:	93 07       	cpc	r25, r19
    2c76:	c0 f4       	brcc	.+48     	; 0x2ca8 <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2c78:	20 91 fc 04 	lds	r18, 0x04FC
    2c7c:	30 91 fd 04 	lds	r19, 0x04FD
    2c80:	80 91 fa 04 	lds	r24, 0x04FA
    2c84:	90 91 fb 04 	lds	r25, 0x04FB
    2c88:	82 0f       	add	r24, r18
    2c8a:	93 1f       	adc	r25, r19
    2c8c:	9a 83       	std	Y+2, r25	; 0x02
    2c8e:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    2c90:	20 91 fa 04 	lds	r18, 0x04FA
    2c94:	30 91 fb 04 	lds	r19, 0x04FB
    2c98:	8b 81       	ldd	r24, Y+3	; 0x03
    2c9a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c9c:	82 0f       	add	r24, r18
    2c9e:	93 1f       	adc	r25, r19
    2ca0:	90 93 fb 04 	sts	0x04FB, r25
    2ca4:	80 93 fa 04 	sts	0x04FA, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2ca8:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    2cac:	89 81       	ldd	r24, Y+1	; 0x01
    2cae:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2cb0:	0f 90       	pop	r0
    2cb2:	0f 90       	pop	r0
    2cb4:	0f 90       	pop	r0
    2cb6:	0f 90       	pop	r0
    2cb8:	df 91       	pop	r29
    2cba:	cf 91       	pop	r28
    2cbc:	08 95       	ret

00002cbe <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2cbe:	cf 93       	push	r28
    2cc0:	df 93       	push	r29
    2cc2:	00 d0       	rcall	.+0      	; 0x2cc4 <vPortFree+0x6>
    2cc4:	cd b7       	in	r28, 0x3d	; 61
    2cc6:	de b7       	in	r29, 0x3e	; 62
    2cc8:	9a 83       	std	Y+2, r25	; 0x02
    2cca:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    2ccc:	0f 90       	pop	r0
    2cce:	0f 90       	pop	r0
    2cd0:	df 91       	pop	r29
    2cd2:	cf 91       	pop	r28
    2cd4:	08 95       	ret

00002cd6 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2cd6:	cf 93       	push	r28
    2cd8:	df 93       	push	r29
    2cda:	cd b7       	in	r28, 0x3d	; 61
    2cdc:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2cde:	10 92 fb 04 	sts	0x04FB, r1
    2ce2:	10 92 fa 04 	sts	0x04FA, r1
}
    2ce6:	df 91       	pop	r29
    2ce8:	cf 91       	pop	r28
    2cea:	08 95       	ret

00002cec <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2cec:	cf 93       	push	r28
    2cee:	df 93       	push	r29
    2cf0:	cd b7       	in	r28, 0x3d	; 61
    2cf2:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    2cf4:	80 91 fa 04 	lds	r24, 0x04FA
    2cf8:	90 91 fb 04 	lds	r25, 0x04FB
    2cfc:	27 ee       	ldi	r18, 0xE7	; 231
    2cfe:	33 e0       	ldi	r19, 0x03	; 3
    2d00:	a9 01       	movw	r20, r18
    2d02:	48 1b       	sub	r20, r24
    2d04:	59 0b       	sbc	r21, r25
    2d06:	ca 01       	movw	r24, r20
}
    2d08:	df 91       	pop	r29
    2d0a:	cf 91       	pop	r28
    2d0c:	08 95       	ret

00002d0e <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    2d0e:	cf 93       	push	r28
    2d10:	df 93       	push	r29
    2d12:	00 d0       	rcall	.+0      	; 0x2d14 <xQueueGenericReset+0x6>
    2d14:	00 d0       	rcall	.+0      	; 0x2d16 <xQueueGenericReset+0x8>
    2d16:	1f 92       	push	r1
    2d18:	cd b7       	in	r28, 0x3d	; 61
    2d1a:	de b7       	in	r29, 0x3e	; 62
    2d1c:	9c 83       	std	Y+4, r25	; 0x04
    2d1e:	8b 83       	std	Y+3, r24	; 0x03
    2d20:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2d22:	8b 81       	ldd	r24, Y+3	; 0x03
    2d24:	9c 81       	ldd	r25, Y+4	; 0x04
    2d26:	9a 83       	std	Y+2, r25	; 0x02
    2d28:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2d2a:	0f b6       	in	r0, 0x3f	; 63
    2d2c:	f8 94       	cli
    2d2e:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    2d30:	89 81       	ldd	r24, Y+1	; 0x01
    2d32:	9a 81       	ldd	r25, Y+2	; 0x02
    2d34:	fc 01       	movw	r30, r24
    2d36:	80 81       	ld	r24, Z
    2d38:	91 81       	ldd	r25, Z+1	; 0x01
    2d3a:	29 81       	ldd	r18, Y+1	; 0x01
    2d3c:	3a 81       	ldd	r19, Y+2	; 0x02
    2d3e:	f9 01       	movw	r30, r18
    2d40:	23 8d       	ldd	r18, Z+27	; 0x1b
    2d42:	42 2f       	mov	r20, r18
    2d44:	50 e0       	ldi	r21, 0x00	; 0
    2d46:	29 81       	ldd	r18, Y+1	; 0x01
    2d48:	3a 81       	ldd	r19, Y+2	; 0x02
    2d4a:	f9 01       	movw	r30, r18
    2d4c:	24 8d       	ldd	r18, Z+28	; 0x1c
    2d4e:	22 2f       	mov	r18, r18
    2d50:	30 e0       	ldi	r19, 0x00	; 0
    2d52:	42 9f       	mul	r20, r18
    2d54:	b0 01       	movw	r22, r0
    2d56:	43 9f       	mul	r20, r19
    2d58:	70 0d       	add	r23, r0
    2d5a:	52 9f       	mul	r21, r18
    2d5c:	70 0d       	add	r23, r0
    2d5e:	11 24       	eor	r1, r1
    2d60:	9b 01       	movw	r18, r22
    2d62:	28 0f       	add	r18, r24
    2d64:	39 1f       	adc	r19, r25
    2d66:	89 81       	ldd	r24, Y+1	; 0x01
    2d68:	9a 81       	ldd	r25, Y+2	; 0x02
    2d6a:	fc 01       	movw	r30, r24
    2d6c:	33 83       	std	Z+3, r19	; 0x03
    2d6e:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2d70:	89 81       	ldd	r24, Y+1	; 0x01
    2d72:	9a 81       	ldd	r25, Y+2	; 0x02
    2d74:	fc 01       	movw	r30, r24
    2d76:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    2d78:	89 81       	ldd	r24, Y+1	; 0x01
    2d7a:	9a 81       	ldd	r25, Y+2	; 0x02
    2d7c:	fc 01       	movw	r30, r24
    2d7e:	20 81       	ld	r18, Z
    2d80:	31 81       	ldd	r19, Z+1	; 0x01
    2d82:	89 81       	ldd	r24, Y+1	; 0x01
    2d84:	9a 81       	ldd	r25, Y+2	; 0x02
    2d86:	fc 01       	movw	r30, r24
    2d88:	35 83       	std	Z+5, r19	; 0x05
    2d8a:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    2d8c:	89 81       	ldd	r24, Y+1	; 0x01
    2d8e:	9a 81       	ldd	r25, Y+2	; 0x02
    2d90:	fc 01       	movw	r30, r24
    2d92:	80 81       	ld	r24, Z
    2d94:	91 81       	ldd	r25, Z+1	; 0x01
    2d96:	29 81       	ldd	r18, Y+1	; 0x01
    2d98:	3a 81       	ldd	r19, Y+2	; 0x02
    2d9a:	f9 01       	movw	r30, r18
    2d9c:	23 8d       	ldd	r18, Z+27	; 0x1b
    2d9e:	22 2f       	mov	r18, r18
    2da0:	30 e0       	ldi	r19, 0x00	; 0
    2da2:	a9 01       	movw	r20, r18
    2da4:	41 50       	subi	r20, 0x01	; 1
    2da6:	51 09       	sbc	r21, r1
    2da8:	29 81       	ldd	r18, Y+1	; 0x01
    2daa:	3a 81       	ldd	r19, Y+2	; 0x02
    2dac:	f9 01       	movw	r30, r18
    2dae:	24 8d       	ldd	r18, Z+28	; 0x1c
    2db0:	22 2f       	mov	r18, r18
    2db2:	30 e0       	ldi	r19, 0x00	; 0
    2db4:	42 9f       	mul	r20, r18
    2db6:	b0 01       	movw	r22, r0
    2db8:	43 9f       	mul	r20, r19
    2dba:	70 0d       	add	r23, r0
    2dbc:	52 9f       	mul	r21, r18
    2dbe:	70 0d       	add	r23, r0
    2dc0:	11 24       	eor	r1, r1
    2dc2:	9b 01       	movw	r18, r22
    2dc4:	28 0f       	add	r18, r24
    2dc6:	39 1f       	adc	r19, r25
    2dc8:	89 81       	ldd	r24, Y+1	; 0x01
    2dca:	9a 81       	ldd	r25, Y+2	; 0x02
    2dcc:	fc 01       	movw	r30, r24
    2dce:	37 83       	std	Z+7, r19	; 0x07
    2dd0:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    2dd2:	89 81       	ldd	r24, Y+1	; 0x01
    2dd4:	9a 81       	ldd	r25, Y+2	; 0x02
    2dd6:	2f ef       	ldi	r18, 0xFF	; 255
    2dd8:	fc 01       	movw	r30, r24
    2dda:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    2ddc:	89 81       	ldd	r24, Y+1	; 0x01
    2dde:	9a 81       	ldd	r25, Y+2	; 0x02
    2de0:	2f ef       	ldi	r18, 0xFF	; 255
    2de2:	fc 01       	movw	r30, r24
    2de4:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    2de6:	8d 81       	ldd	r24, Y+5	; 0x05
    2de8:	88 23       	and	r24, r24
    2dea:	81 f4       	brne	.+32     	; 0x2e0c <xQueueGenericReset+0xfe>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2dec:	89 81       	ldd	r24, Y+1	; 0x01
    2dee:	9a 81       	ldd	r25, Y+2	; 0x02
    2df0:	fc 01       	movw	r30, r24
    2df2:	80 85       	ldd	r24, Z+8	; 0x08
    2df4:	88 23       	and	r24, r24
    2df6:	a1 f0       	breq	.+40     	; 0x2e20 <xQueueGenericReset+0x112>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2df8:	89 81       	ldd	r24, Y+1	; 0x01
    2dfa:	9a 81       	ldd	r25, Y+2	; 0x02
    2dfc:	08 96       	adiw	r24, 0x08	; 8
    2dfe:	0e 94 8a 21 	call	0x4314	; 0x4314 <xTaskRemoveFromEventList>
    2e02:	81 30       	cpi	r24, 0x01	; 1
    2e04:	69 f4       	brne	.+26     	; 0x2e20 <xQueueGenericReset+0x112>
				{
					queueYIELD_IF_USING_PREEMPTION();
    2e06:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <vPortYield>
    2e0a:	0a c0       	rjmp	.+20     	; 0x2e20 <xQueueGenericReset+0x112>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2e0c:	89 81       	ldd	r24, Y+1	; 0x01
    2e0e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e10:	08 96       	adiw	r24, 0x08	; 8
    2e12:	0e 94 a4 11 	call	0x2348	; 0x2348 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    2e16:	89 81       	ldd	r24, Y+1	; 0x01
    2e18:	9a 81       	ldd	r25, Y+2	; 0x02
    2e1a:	41 96       	adiw	r24, 0x11	; 17
    2e1c:	0e 94 a4 11 	call	0x2348	; 0x2348 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    2e20:	0f 90       	pop	r0
    2e22:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    2e24:	81 e0       	ldi	r24, 0x01	; 1
}
    2e26:	0f 90       	pop	r0
    2e28:	0f 90       	pop	r0
    2e2a:	0f 90       	pop	r0
    2e2c:	0f 90       	pop	r0
    2e2e:	0f 90       	pop	r0
    2e30:	df 91       	pop	r29
    2e32:	cf 91       	pop	r28
    2e34:	08 95       	ret

00002e36 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    2e36:	cf 93       	push	r28
    2e38:	df 93       	push	r29
    2e3a:	cd b7       	in	r28, 0x3d	; 61
    2e3c:	de b7       	in	r29, 0x3e	; 62
    2e3e:	29 97       	sbiw	r28, 0x09	; 9
    2e40:	0f b6       	in	r0, 0x3f	; 63
    2e42:	f8 94       	cli
    2e44:	de bf       	out	0x3e, r29	; 62
    2e46:	0f be       	out	0x3f, r0	; 63
    2e48:	cd bf       	out	0x3d, r28	; 61
    2e4a:	8f 83       	std	Y+7, r24	; 0x07
    2e4c:	68 87       	std	Y+8, r22	; 0x08
    2e4e:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    2e50:	1c 82       	std	Y+4, r1	; 0x04
    2e52:	1b 82       	std	Y+3, r1	; 0x03
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
    2e54:	88 85       	ldd	r24, Y+8	; 0x08
    2e56:	88 23       	and	r24, r24
    2e58:	19 f4       	brne	.+6      	; 0x2e60 <xQueueGenericCreate+0x2a>
	{
		/* There is not going to be a queue storage area. */
		xQueueSizeInBytes = ( size_t ) 0;
    2e5a:	1a 82       	std	Y+2, r1	; 0x02
    2e5c:	19 82       	std	Y+1, r1	; 0x01
    2e5e:	11 c0       	rjmp	.+34     	; 0x2e82 <xQueueGenericCreate+0x4c>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2e60:	8f 81       	ldd	r24, Y+7	; 0x07
    2e62:	28 2f       	mov	r18, r24
    2e64:	30 e0       	ldi	r19, 0x00	; 0
    2e66:	88 85       	ldd	r24, Y+8	; 0x08
    2e68:	88 2f       	mov	r24, r24
    2e6a:	90 e0       	ldi	r25, 0x00	; 0
    2e6c:	28 9f       	mul	r18, r24
    2e6e:	a0 01       	movw	r20, r0
    2e70:	29 9f       	mul	r18, r25
    2e72:	50 0d       	add	r21, r0
    2e74:	38 9f       	mul	r19, r24
    2e76:	50 0d       	add	r21, r0
    2e78:	11 24       	eor	r1, r1
    2e7a:	ca 01       	movw	r24, r20
    2e7c:	01 96       	adiw	r24, 0x01	; 1
    2e7e:	9a 83       	std	Y+2, r25	; 0x02
    2e80:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    2e82:	89 81       	ldd	r24, Y+1	; 0x01
    2e84:	9a 81       	ldd	r25, Y+2	; 0x02
    2e86:	4f 96       	adiw	r24, 0x1f	; 31
    2e88:	0e 94 0a 16 	call	0x2c14	; 0x2c14 <pvPortMalloc>
    2e8c:	9e 83       	std	Y+6, r25	; 0x06
    2e8e:	8d 83       	std	Y+5, r24	; 0x05

	if( pxNewQueue != NULL )
    2e90:	8d 81       	ldd	r24, Y+5	; 0x05
    2e92:	9e 81       	ldd	r25, Y+6	; 0x06
    2e94:	89 2b       	or	r24, r25
    2e96:	41 f1       	breq	.+80     	; 0x2ee8 <xQueueGenericCreate+0xb2>
	{
		if( uxItemSize == ( UBaseType_t ) 0 )
    2e98:	88 85       	ldd	r24, Y+8	; 0x08
    2e9a:	88 23       	and	r24, r24
    2e9c:	41 f4       	brne	.+16     	; 0x2eae <xQueueGenericCreate+0x78>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    2e9e:	8d 81       	ldd	r24, Y+5	; 0x05
    2ea0:	9e 81       	ldd	r25, Y+6	; 0x06
    2ea2:	2d 81       	ldd	r18, Y+5	; 0x05
    2ea4:	3e 81       	ldd	r19, Y+6	; 0x06
    2ea6:	fc 01       	movw	r30, r24
    2ea8:	31 83       	std	Z+1, r19	; 0x01
    2eaa:	20 83       	st	Z, r18
    2eac:	0a c0       	rjmp	.+20     	; 0x2ec2 <xQueueGenericCreate+0x8c>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
    2eae:	8d 81       	ldd	r24, Y+5	; 0x05
    2eb0:	9e 81       	ldd	r25, Y+6	; 0x06
    2eb2:	9c 01       	movw	r18, r24
    2eb4:	21 5e       	subi	r18, 0xE1	; 225
    2eb6:	3f 4f       	sbci	r19, 0xFF	; 255
    2eb8:	8d 81       	ldd	r24, Y+5	; 0x05
    2eba:	9e 81       	ldd	r25, Y+6	; 0x06
    2ebc:	fc 01       	movw	r30, r24
    2ebe:	31 83       	std	Z+1, r19	; 0x01
    2ec0:	20 83       	st	Z, r18
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
    2ec2:	8d 81       	ldd	r24, Y+5	; 0x05
    2ec4:	9e 81       	ldd	r25, Y+6	; 0x06
    2ec6:	2f 81       	ldd	r18, Y+7	; 0x07
    2ec8:	fc 01       	movw	r30, r24
    2eca:	23 8f       	std	Z+27, r18	; 0x1b
		pxNewQueue->uxItemSize = uxItemSize;
    2ecc:	8d 81       	ldd	r24, Y+5	; 0x05
    2ece:	9e 81       	ldd	r25, Y+6	; 0x06
    2ed0:	28 85       	ldd	r18, Y+8	; 0x08
    2ed2:	fc 01       	movw	r30, r24
    2ed4:	24 8f       	std	Z+28, r18	; 0x1c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2ed6:	8d 81       	ldd	r24, Y+5	; 0x05
    2ed8:	9e 81       	ldd	r25, Y+6	; 0x06
    2eda:	61 e0       	ldi	r22, 0x01	; 1
    2edc:	0e 94 87 16 	call	0x2d0e	; 0x2d0e <xQueueGenericReset>
			pxNewQueue->pxQueueSetContainer = NULL;
		}
		#endif /* configUSE_QUEUE_SETS */

		traceQUEUE_CREATE( pxNewQueue );
		xReturn = pxNewQueue;
    2ee0:	8d 81       	ldd	r24, Y+5	; 0x05
    2ee2:	9e 81       	ldd	r25, Y+6	; 0x06
    2ee4:	9c 83       	std	Y+4, r25	; 0x04
    2ee6:	8b 83       	std	Y+3, r24	; 0x03
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    2ee8:	8b 81       	ldd	r24, Y+3	; 0x03
    2eea:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2eec:	29 96       	adiw	r28, 0x09	; 9
    2eee:	0f b6       	in	r0, 0x3f	; 63
    2ef0:	f8 94       	cli
    2ef2:	de bf       	out	0x3e, r29	; 62
    2ef4:	0f be       	out	0x3f, r0	; 63
    2ef6:	cd bf       	out	0x3d, r28	; 61
    2ef8:	df 91       	pop	r29
    2efa:	cf 91       	pop	r28
    2efc:	08 95       	ret

00002efe <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    2efe:	cf 93       	push	r28
    2f00:	df 93       	push	r29
    2f02:	cd b7       	in	r28, 0x3d	; 61
    2f04:	de b7       	in	r29, 0x3e	; 62
    2f06:	2e 97       	sbiw	r28, 0x0e	; 14
    2f08:	0f b6       	in	r0, 0x3f	; 63
    2f0a:	f8 94       	cli
    2f0c:	de bf       	out	0x3e, r29	; 62
    2f0e:	0f be       	out	0x3f, r0	; 63
    2f10:	cd bf       	out	0x3d, r28	; 61
    2f12:	99 87       	std	Y+9, r25	; 0x09
    2f14:	88 87       	std	Y+8, r24	; 0x08
    2f16:	7b 87       	std	Y+11, r23	; 0x0b
    2f18:	6a 87       	std	Y+10, r22	; 0x0a
    2f1a:	5d 87       	std	Y+13, r21	; 0x0d
    2f1c:	4c 87       	std	Y+12, r20	; 0x0c
    2f1e:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2f20:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2f22:	88 85       	ldd	r24, Y+8	; 0x08
    2f24:	99 85       	ldd	r25, Y+9	; 0x09
    2f26:	9b 83       	std	Y+3, r25	; 0x03
    2f28:	8a 83       	std	Y+2, r24	; 0x02
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2f2a:	0f b6       	in	r0, 0x3f	; 63
    2f2c:	f8 94       	cli
    2f2e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2f30:	8a 81       	ldd	r24, Y+2	; 0x02
    2f32:	9b 81       	ldd	r25, Y+3	; 0x03
    2f34:	fc 01       	movw	r30, r24
    2f36:	22 8d       	ldd	r18, Z+26	; 0x1a
    2f38:	8a 81       	ldd	r24, Y+2	; 0x02
    2f3a:	9b 81       	ldd	r25, Y+3	; 0x03
    2f3c:	fc 01       	movw	r30, r24
    2f3e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2f40:	28 17       	cp	r18, r24
    2f42:	18 f0       	brcs	.+6      	; 0x2f4a <xQueueGenericSend+0x4c>
    2f44:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f46:	82 30       	cpi	r24, 0x02	; 2
    2f48:	11 f5       	brne	.+68     	; 0x2f8e <xQueueGenericSend+0x90>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2f4a:	2a 85       	ldd	r18, Y+10	; 0x0a
    2f4c:	3b 85       	ldd	r19, Y+11	; 0x0b
    2f4e:	8a 81       	ldd	r24, Y+2	; 0x02
    2f50:	9b 81       	ldd	r25, Y+3	; 0x03
    2f52:	4e 85       	ldd	r20, Y+14	; 0x0e
    2f54:	b9 01       	movw	r22, r18
    2f56:	0e 94 c4 1a 	call	0x3588	; 0x3588 <prvCopyDataToQueue>
    2f5a:	8c 83       	std	Y+4, r24	; 0x04
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2f5c:	8a 81       	ldd	r24, Y+2	; 0x02
    2f5e:	9b 81       	ldd	r25, Y+3	; 0x03
    2f60:	fc 01       	movw	r30, r24
    2f62:	81 89       	ldd	r24, Z+17	; 0x11
    2f64:	88 23       	and	r24, r24
    2f66:	51 f0       	breq	.+20     	; 0x2f7c <xQueueGenericSend+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2f68:	8a 81       	ldd	r24, Y+2	; 0x02
    2f6a:	9b 81       	ldd	r25, Y+3	; 0x03
    2f6c:	41 96       	adiw	r24, 0x11	; 17
    2f6e:	0e 94 8a 21 	call	0x4314	; 0x4314 <xTaskRemoveFromEventList>
    2f72:	81 30       	cpi	r24, 0x01	; 1
    2f74:	41 f4       	brne	.+16     	; 0x2f86 <xQueueGenericSend+0x88>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2f76:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <vPortYield>
    2f7a:	05 c0       	rjmp	.+10     	; 0x2f86 <xQueueGenericSend+0x88>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    2f7c:	8c 81       	ldd	r24, Y+4	; 0x04
    2f7e:	88 23       	and	r24, r24
    2f80:	11 f0       	breq	.+4      	; 0x2f86 <xQueueGenericSend+0x88>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2f82:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2f86:	0f 90       	pop	r0
    2f88:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2f8a:	81 e0       	ldi	r24, 0x01	; 1
    2f8c:	61 c0       	rjmp	.+194    	; 0x3050 <xQueueGenericSend+0x152>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2f8e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2f90:	9d 85       	ldd	r25, Y+13	; 0x0d
    2f92:	89 2b       	or	r24, r25
    2f94:	21 f4       	brne	.+8      	; 0x2f9e <xQueueGenericSend+0xa0>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2f96:	0f 90       	pop	r0
    2f98:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2f9a:	80 e0       	ldi	r24, 0x00	; 0
    2f9c:	59 c0       	rjmp	.+178    	; 0x3050 <xQueueGenericSend+0x152>
				}
				else if( xEntryTimeSet == pdFALSE )
    2f9e:	89 81       	ldd	r24, Y+1	; 0x01
    2fa0:	88 23       	and	r24, r24
    2fa2:	31 f4       	brne	.+12     	; 0x2fb0 <xQueueGenericSend+0xb2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2fa4:	ce 01       	movw	r24, r28
    2fa6:	05 96       	adiw	r24, 0x05	; 5
    2fa8:	0e 94 62 22 	call	0x44c4	; 0x44c4 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2fac:	81 e0       	ldi	r24, 0x01	; 1
    2fae:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2fb0:	0f 90       	pop	r0
    2fb2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2fb4:	0e 94 e5 1e 	call	0x3dca	; 0x3dca <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2fb8:	0f b6       	in	r0, 0x3f	; 63
    2fba:	f8 94       	cli
    2fbc:	0f 92       	push	r0
    2fbe:	8a 81       	ldd	r24, Y+2	; 0x02
    2fc0:	9b 81       	ldd	r25, Y+3	; 0x03
    2fc2:	fc 01       	movw	r30, r24
    2fc4:	85 8d       	ldd	r24, Z+29	; 0x1d
    2fc6:	8f 3f       	cpi	r24, 0xFF	; 255
    2fc8:	21 f4       	brne	.+8      	; 0x2fd2 <xQueueGenericSend+0xd4>
    2fca:	8a 81       	ldd	r24, Y+2	; 0x02
    2fcc:	9b 81       	ldd	r25, Y+3	; 0x03
    2fce:	fc 01       	movw	r30, r24
    2fd0:	15 8e       	std	Z+29, r1	; 0x1d
    2fd2:	8a 81       	ldd	r24, Y+2	; 0x02
    2fd4:	9b 81       	ldd	r25, Y+3	; 0x03
    2fd6:	fc 01       	movw	r30, r24
    2fd8:	86 8d       	ldd	r24, Z+30	; 0x1e
    2fda:	8f 3f       	cpi	r24, 0xFF	; 255
    2fdc:	21 f4       	brne	.+8      	; 0x2fe6 <xQueueGenericSend+0xe8>
    2fde:	8a 81       	ldd	r24, Y+2	; 0x02
    2fe0:	9b 81       	ldd	r25, Y+3	; 0x03
    2fe2:	fc 01       	movw	r30, r24
    2fe4:	16 8e       	std	Z+30, r1	; 0x1e
    2fe6:	0f 90       	pop	r0
    2fe8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2fea:	9e 01       	movw	r18, r28
    2fec:	24 5f       	subi	r18, 0xF4	; 244
    2fee:	3f 4f       	sbci	r19, 0xFF	; 255
    2ff0:	ce 01       	movw	r24, r28
    2ff2:	05 96       	adiw	r24, 0x05	; 5
    2ff4:	b9 01       	movw	r22, r18
    2ff6:	0e 94 7d 22 	call	0x44fa	; 0x44fa <xTaskCheckForTimeOut>
    2ffa:	88 23       	and	r24, r24
    2ffc:	01 f5       	brne	.+64     	; 0x303e <xQueueGenericSend+0x140>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2ffe:	8a 81       	ldd	r24, Y+2	; 0x02
    3000:	9b 81       	ldd	r25, Y+3	; 0x03
    3002:	0e 94 6f 1c 	call	0x38de	; 0x38de <prvIsQueueFull>
    3006:	88 23       	and	r24, r24
    3008:	99 f0       	breq	.+38     	; 0x3030 <xQueueGenericSend+0x132>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    300a:	2c 85       	ldd	r18, Y+12	; 0x0c
    300c:	3d 85       	ldd	r19, Y+13	; 0x0d
    300e:	8a 81       	ldd	r24, Y+2	; 0x02
    3010:	9b 81       	ldd	r25, Y+3	; 0x03
    3012:	08 96       	adiw	r24, 0x08	; 8
    3014:	b9 01       	movw	r22, r18
    3016:	0e 94 11 21 	call	0x4222	; 0x4222 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    301a:	8a 81       	ldd	r24, Y+2	; 0x02
    301c:	9b 81       	ldd	r25, Y+3	; 0x03
    301e:	0e 94 d4 1b 	call	0x37a8	; 0x37a8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3022:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <xTaskResumeAll>
    3026:	88 23       	and	r24, r24
    3028:	91 f4       	brne	.+36     	; 0x304e <xQueueGenericSend+0x150>
				{
					portYIELD_WITHIN_API();
    302a:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <vPortYield>
    302e:	0f c0       	rjmp	.+30     	; 0x304e <xQueueGenericSend+0x150>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3030:	8a 81       	ldd	r24, Y+2	; 0x02
    3032:	9b 81       	ldd	r25, Y+3	; 0x03
    3034:	0e 94 d4 1b 	call	0x37a8	; 0x37a8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3038:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <xTaskResumeAll>
    303c:	76 cf       	rjmp	.-276    	; 0x2f2a <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    303e:	8a 81       	ldd	r24, Y+2	; 0x02
    3040:	9b 81       	ldd	r25, Y+3	; 0x03
    3042:	0e 94 d4 1b 	call	0x37a8	; 0x37a8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3046:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    304a:	80 e0       	ldi	r24, 0x00	; 0
    304c:	01 c0       	rjmp	.+2      	; 0x3050 <xQueueGenericSend+0x152>
		}
	}
    304e:	6d cf       	rjmp	.-294    	; 0x2f2a <xQueueGenericSend+0x2c>
}
    3050:	2e 96       	adiw	r28, 0x0e	; 14
    3052:	0f b6       	in	r0, 0x3f	; 63
    3054:	f8 94       	cli
    3056:	de bf       	out	0x3e, r29	; 62
    3058:	0f be       	out	0x3f, r0	; 63
    305a:	cd bf       	out	0x3d, r28	; 61
    305c:	df 91       	pop	r29
    305e:	cf 91       	pop	r28
    3060:	08 95       	ret

00003062 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    3062:	cf 93       	push	r28
    3064:	df 93       	push	r29
    3066:	cd b7       	in	r28, 0x3d	; 61
    3068:	de b7       	in	r29, 0x3e	; 62
    306a:	2b 97       	sbiw	r28, 0x0b	; 11
    306c:	0f b6       	in	r0, 0x3f	; 63
    306e:	f8 94       	cli
    3070:	de bf       	out	0x3e, r29	; 62
    3072:	0f be       	out	0x3f, r0	; 63
    3074:	cd bf       	out	0x3d, r28	; 61
    3076:	9e 83       	std	Y+6, r25	; 0x06
    3078:	8d 83       	std	Y+5, r24	; 0x05
    307a:	78 87       	std	Y+8, r23	; 0x08
    307c:	6f 83       	std	Y+7, r22	; 0x07
    307e:	5a 87       	std	Y+10, r21	; 0x0a
    3080:	49 87       	std	Y+9, r20	; 0x09
    3082:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3084:	8d 81       	ldd	r24, Y+5	; 0x05
    3086:	9e 81       	ldd	r25, Y+6	; 0x06
    3088:	9b 83       	std	Y+3, r25	; 0x03
    308a:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    308c:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    308e:	8a 81       	ldd	r24, Y+2	; 0x02
    3090:	9b 81       	ldd	r25, Y+3	; 0x03
    3092:	fc 01       	movw	r30, r24
    3094:	22 8d       	ldd	r18, Z+26	; 0x1a
    3096:	8a 81       	ldd	r24, Y+2	; 0x02
    3098:	9b 81       	ldd	r25, Y+3	; 0x03
    309a:	fc 01       	movw	r30, r24
    309c:	83 8d       	ldd	r24, Z+27	; 0x1b
    309e:	28 17       	cp	r18, r24
    30a0:	18 f0       	brcs	.+6      	; 0x30a8 <xQueueGenericSendFromISR+0x46>
    30a2:	8b 85       	ldd	r24, Y+11	; 0x0b
    30a4:	82 30       	cpi	r24, 0x02	; 2
    30a6:	91 f5       	brne	.+100    	; 0x310c <xQueueGenericSendFromISR+0xaa>
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    30a8:	2f 81       	ldd	r18, Y+7	; 0x07
    30aa:	38 85       	ldd	r19, Y+8	; 0x08
    30ac:	8a 81       	ldd	r24, Y+2	; 0x02
    30ae:	9b 81       	ldd	r25, Y+3	; 0x03
    30b0:	4b 85       	ldd	r20, Y+11	; 0x0b
    30b2:	b9 01       	movw	r22, r18
    30b4:	0e 94 c4 1a 	call	0x3588	; 0x3588 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    30b8:	8a 81       	ldd	r24, Y+2	; 0x02
    30ba:	9b 81       	ldd	r25, Y+3	; 0x03
    30bc:	fc 01       	movw	r30, r24
    30be:	86 8d       	ldd	r24, Z+30	; 0x1e
    30c0:	8f 3f       	cpi	r24, 0xFF	; 255
    30c2:	b9 f4       	brne	.+46     	; 0x30f2 <xQueueGenericSendFromISR+0x90>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    30c4:	8a 81       	ldd	r24, Y+2	; 0x02
    30c6:	9b 81       	ldd	r25, Y+3	; 0x03
    30c8:	fc 01       	movw	r30, r24
    30ca:	81 89       	ldd	r24, Z+17	; 0x11
    30cc:	88 23       	and	r24, r24
    30ce:	d9 f0       	breq	.+54     	; 0x3106 <xQueueGenericSendFromISR+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    30d0:	8a 81       	ldd	r24, Y+2	; 0x02
    30d2:	9b 81       	ldd	r25, Y+3	; 0x03
    30d4:	41 96       	adiw	r24, 0x11	; 17
    30d6:	0e 94 8a 21 	call	0x4314	; 0x4314 <xTaskRemoveFromEventList>
    30da:	88 23       	and	r24, r24
    30dc:	a1 f0       	breq	.+40     	; 0x3106 <xQueueGenericSendFromISR+0xa4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    30de:	89 85       	ldd	r24, Y+9	; 0x09
    30e0:	9a 85       	ldd	r25, Y+10	; 0x0a
    30e2:	89 2b       	or	r24, r25
    30e4:	81 f0       	breq	.+32     	; 0x3106 <xQueueGenericSendFromISR+0xa4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    30e6:	89 85       	ldd	r24, Y+9	; 0x09
    30e8:	9a 85       	ldd	r25, Y+10	; 0x0a
    30ea:	21 e0       	ldi	r18, 0x01	; 1
    30ec:	fc 01       	movw	r30, r24
    30ee:	20 83       	st	Z, r18
    30f0:	0a c0       	rjmp	.+20     	; 0x3106 <xQueueGenericSendFromISR+0xa4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    30f2:	8a 81       	ldd	r24, Y+2	; 0x02
    30f4:	9b 81       	ldd	r25, Y+3	; 0x03
    30f6:	fc 01       	movw	r30, r24
    30f8:	86 8d       	ldd	r24, Z+30	; 0x1e
    30fa:	8f 5f       	subi	r24, 0xFF	; 255
    30fc:	28 2f       	mov	r18, r24
    30fe:	8a 81       	ldd	r24, Y+2	; 0x02
    3100:	9b 81       	ldd	r25, Y+3	; 0x03
    3102:	fc 01       	movw	r30, r24
    3104:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    3106:	81 e0       	ldi	r24, 0x01	; 1
    3108:	89 83       	std	Y+1, r24	; 0x01
    310a:	01 c0       	rjmp	.+2      	; 0x310e <xQueueGenericSendFromISR+0xac>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    310c:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    310e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3110:	2b 96       	adiw	r28, 0x0b	; 11
    3112:	0f b6       	in	r0, 0x3f	; 63
    3114:	f8 94       	cli
    3116:	de bf       	out	0x3e, r29	; 62
    3118:	0f be       	out	0x3f, r0	; 63
    311a:	cd bf       	out	0x3d, r28	; 61
    311c:	df 91       	pop	r29
    311e:	cf 91       	pop	r28
    3120:	08 95       	ret

00003122 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3122:	cf 93       	push	r28
    3124:	df 93       	push	r29
    3126:	cd b7       	in	r28, 0x3d	; 61
    3128:	de b7       	in	r29, 0x3e	; 62
    312a:	28 97       	sbiw	r28, 0x08	; 8
    312c:	0f b6       	in	r0, 0x3f	; 63
    312e:	f8 94       	cli
    3130:	de bf       	out	0x3e, r29	; 62
    3132:	0f be       	out	0x3f, r0	; 63
    3134:	cd bf       	out	0x3d, r28	; 61
    3136:	9e 83       	std	Y+6, r25	; 0x06
    3138:	8d 83       	std	Y+5, r24	; 0x05
    313a:	78 87       	std	Y+8, r23	; 0x08
    313c:	6f 83       	std	Y+7, r22	; 0x07
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    313e:	8d 81       	ldd	r24, Y+5	; 0x05
    3140:	9e 81       	ldd	r25, Y+6	; 0x06
    3142:	9b 83       	std	Y+3, r25	; 0x03
    3144:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3146:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3148:	8a 81       	ldd	r24, Y+2	; 0x02
    314a:	9b 81       	ldd	r25, Y+3	; 0x03
    314c:	fc 01       	movw	r30, r24
    314e:	22 8d       	ldd	r18, Z+26	; 0x1a
    3150:	8a 81       	ldd	r24, Y+2	; 0x02
    3152:	9b 81       	ldd	r25, Y+3	; 0x03
    3154:	fc 01       	movw	r30, r24
    3156:	83 8d       	ldd	r24, Z+27	; 0x1b
    3158:	28 17       	cp	r18, r24
    315a:	a0 f5       	brcc	.+104    	; 0x31c4 <xQueueGiveFromISR+0xa2>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    315c:	8a 81       	ldd	r24, Y+2	; 0x02
    315e:	9b 81       	ldd	r25, Y+3	; 0x03
    3160:	fc 01       	movw	r30, r24
    3162:	82 8d       	ldd	r24, Z+26	; 0x1a
    3164:	21 e0       	ldi	r18, 0x01	; 1
    3166:	28 0f       	add	r18, r24
    3168:	8a 81       	ldd	r24, Y+2	; 0x02
    316a:	9b 81       	ldd	r25, Y+3	; 0x03
    316c:	fc 01       	movw	r30, r24
    316e:	22 8f       	std	Z+26, r18	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3170:	8a 81       	ldd	r24, Y+2	; 0x02
    3172:	9b 81       	ldd	r25, Y+3	; 0x03
    3174:	fc 01       	movw	r30, r24
    3176:	86 8d       	ldd	r24, Z+30	; 0x1e
    3178:	8f 3f       	cpi	r24, 0xFF	; 255
    317a:	b9 f4       	brne	.+46     	; 0x31aa <xQueueGiveFromISR+0x88>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    317c:	8a 81       	ldd	r24, Y+2	; 0x02
    317e:	9b 81       	ldd	r25, Y+3	; 0x03
    3180:	fc 01       	movw	r30, r24
    3182:	81 89       	ldd	r24, Z+17	; 0x11
    3184:	88 23       	and	r24, r24
    3186:	d9 f0       	breq	.+54     	; 0x31be <xQueueGiveFromISR+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3188:	8a 81       	ldd	r24, Y+2	; 0x02
    318a:	9b 81       	ldd	r25, Y+3	; 0x03
    318c:	41 96       	adiw	r24, 0x11	; 17
    318e:	0e 94 8a 21 	call	0x4314	; 0x4314 <xTaskRemoveFromEventList>
    3192:	88 23       	and	r24, r24
    3194:	a1 f0       	breq	.+40     	; 0x31be <xQueueGiveFromISR+0x9c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3196:	8f 81       	ldd	r24, Y+7	; 0x07
    3198:	98 85       	ldd	r25, Y+8	; 0x08
    319a:	89 2b       	or	r24, r25
    319c:	81 f0       	breq	.+32     	; 0x31be <xQueueGiveFromISR+0x9c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    319e:	8f 81       	ldd	r24, Y+7	; 0x07
    31a0:	98 85       	ldd	r25, Y+8	; 0x08
    31a2:	21 e0       	ldi	r18, 0x01	; 1
    31a4:	fc 01       	movw	r30, r24
    31a6:	20 83       	st	Z, r18
    31a8:	0a c0       	rjmp	.+20     	; 0x31be <xQueueGiveFromISR+0x9c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    31aa:	8a 81       	ldd	r24, Y+2	; 0x02
    31ac:	9b 81       	ldd	r25, Y+3	; 0x03
    31ae:	fc 01       	movw	r30, r24
    31b0:	86 8d       	ldd	r24, Z+30	; 0x1e
    31b2:	8f 5f       	subi	r24, 0xFF	; 255
    31b4:	28 2f       	mov	r18, r24
    31b6:	8a 81       	ldd	r24, Y+2	; 0x02
    31b8:	9b 81       	ldd	r25, Y+3	; 0x03
    31ba:	fc 01       	movw	r30, r24
    31bc:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    31be:	81 e0       	ldi	r24, 0x01	; 1
    31c0:	89 83       	std	Y+1, r24	; 0x01
    31c2:	01 c0       	rjmp	.+2      	; 0x31c6 <xQueueGiveFromISR+0xa4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    31c4:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    31c6:	89 81       	ldd	r24, Y+1	; 0x01
}
    31c8:	28 96       	adiw	r28, 0x08	; 8
    31ca:	0f b6       	in	r0, 0x3f	; 63
    31cc:	f8 94       	cli
    31ce:	de bf       	out	0x3e, r29	; 62
    31d0:	0f be       	out	0x3f, r0	; 63
    31d2:	cd bf       	out	0x3d, r28	; 61
    31d4:	df 91       	pop	r29
    31d6:	cf 91       	pop	r28
    31d8:	08 95       	ret

000031da <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    31da:	cf 93       	push	r28
    31dc:	df 93       	push	r29
    31de:	cd b7       	in	r28, 0x3d	; 61
    31e0:	de b7       	in	r29, 0x3e	; 62
    31e2:	2f 97       	sbiw	r28, 0x0f	; 15
    31e4:	0f b6       	in	r0, 0x3f	; 63
    31e6:	f8 94       	cli
    31e8:	de bf       	out	0x3e, r29	; 62
    31ea:	0f be       	out	0x3f, r0	; 63
    31ec:	cd bf       	out	0x3d, r28	; 61
    31ee:	9a 87       	std	Y+10, r25	; 0x0a
    31f0:	89 87       	std	Y+9, r24	; 0x09
    31f2:	7c 87       	std	Y+12, r23	; 0x0c
    31f4:	6b 87       	std	Y+11, r22	; 0x0b
    31f6:	5e 87       	std	Y+14, r21	; 0x0e
    31f8:	4d 87       	std	Y+13, r20	; 0x0d
    31fa:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    31fc:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    31fe:	89 85       	ldd	r24, Y+9	; 0x09
    3200:	9a 85       	ldd	r25, Y+10	; 0x0a
    3202:	9b 83       	std	Y+3, r25	; 0x03
    3204:	8a 83       	std	Y+2, r24	; 0x02
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    3206:	0f b6       	in	r0, 0x3f	; 63
    3208:	f8 94       	cli
    320a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    320c:	8a 81       	ldd	r24, Y+2	; 0x02
    320e:	9b 81       	ldd	r25, Y+3	; 0x03
    3210:	fc 01       	movw	r30, r24
    3212:	82 8d       	ldd	r24, Z+26	; 0x1a
    3214:	88 23       	and	r24, r24
    3216:	09 f4       	brne	.+2      	; 0x321a <xQueueGenericReceive+0x40>
    3218:	45 c0       	rjmp	.+138    	; 0x32a4 <xQueueGenericReceive+0xca>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    321a:	8a 81       	ldd	r24, Y+2	; 0x02
    321c:	9b 81       	ldd	r25, Y+3	; 0x03
    321e:	fc 01       	movw	r30, r24
    3220:	86 81       	ldd	r24, Z+6	; 0x06
    3222:	97 81       	ldd	r25, Z+7	; 0x07
    3224:	9d 83       	std	Y+5, r25	; 0x05
    3226:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3228:	2b 85       	ldd	r18, Y+11	; 0x0b
    322a:	3c 85       	ldd	r19, Y+12	; 0x0c
    322c:	8a 81       	ldd	r24, Y+2	; 0x02
    322e:	9b 81       	ldd	r25, Y+3	; 0x03
    3230:	b9 01       	movw	r22, r18
    3232:	0e 94 84 1b 	call	0x3708	; 0x3708 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    3236:	8f 85       	ldd	r24, Y+15	; 0x0f
    3238:	88 23       	and	r24, r24
    323a:	d1 f4       	brne	.+52     	; 0x3270 <xQueueGenericReceive+0x96>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    323c:	8a 81       	ldd	r24, Y+2	; 0x02
    323e:	9b 81       	ldd	r25, Y+3	; 0x03
    3240:	fc 01       	movw	r30, r24
    3242:	82 8d       	ldd	r24, Z+26	; 0x1a
    3244:	2f ef       	ldi	r18, 0xFF	; 255
    3246:	28 0f       	add	r18, r24
    3248:	8a 81       	ldd	r24, Y+2	; 0x02
    324a:	9b 81       	ldd	r25, Y+3	; 0x03
    324c:	fc 01       	movw	r30, r24
    324e:	22 8f       	std	Z+26, r18	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3250:	8a 81       	ldd	r24, Y+2	; 0x02
    3252:	9b 81       	ldd	r25, Y+3	; 0x03
    3254:	fc 01       	movw	r30, r24
    3256:	80 85       	ldd	r24, Z+8	; 0x08
    3258:	88 23       	and	r24, r24
    325a:	01 f1       	breq	.+64     	; 0x329c <xQueueGenericReceive+0xc2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    325c:	8a 81       	ldd	r24, Y+2	; 0x02
    325e:	9b 81       	ldd	r25, Y+3	; 0x03
    3260:	08 96       	adiw	r24, 0x08	; 8
    3262:	0e 94 8a 21 	call	0x4314	; 0x4314 <xTaskRemoveFromEventList>
    3266:	81 30       	cpi	r24, 0x01	; 1
    3268:	c9 f4       	brne	.+50     	; 0x329c <xQueueGenericReceive+0xc2>
						{
							queueYIELD_IF_USING_PREEMPTION();
    326a:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <vPortYield>
    326e:	16 c0       	rjmp	.+44     	; 0x329c <xQueueGenericReceive+0xc2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    3270:	8a 81       	ldd	r24, Y+2	; 0x02
    3272:	9b 81       	ldd	r25, Y+3	; 0x03
    3274:	2c 81       	ldd	r18, Y+4	; 0x04
    3276:	3d 81       	ldd	r19, Y+5	; 0x05
    3278:	fc 01       	movw	r30, r24
    327a:	37 83       	std	Z+7, r19	; 0x07
    327c:	26 83       	std	Z+6, r18	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    327e:	8a 81       	ldd	r24, Y+2	; 0x02
    3280:	9b 81       	ldd	r25, Y+3	; 0x03
    3282:	fc 01       	movw	r30, r24
    3284:	81 89       	ldd	r24, Z+17	; 0x11
    3286:	88 23       	and	r24, r24
    3288:	49 f0       	breq	.+18     	; 0x329c <xQueueGenericReceive+0xc2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    328a:	8a 81       	ldd	r24, Y+2	; 0x02
    328c:	9b 81       	ldd	r25, Y+3	; 0x03
    328e:	41 96       	adiw	r24, 0x11	; 17
    3290:	0e 94 8a 21 	call	0x4314	; 0x4314 <xTaskRemoveFromEventList>
    3294:	88 23       	and	r24, r24
    3296:	11 f0       	breq	.+4      	; 0x329c <xQueueGenericReceive+0xc2>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    3298:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    329c:	0f 90       	pop	r0
    329e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    32a0:	81 e0       	ldi	r24, 0x01	; 1
    32a2:	61 c0       	rjmp	.+194    	; 0x3366 <xQueueGenericReceive+0x18c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    32a4:	8d 85       	ldd	r24, Y+13	; 0x0d
    32a6:	9e 85       	ldd	r25, Y+14	; 0x0e
    32a8:	89 2b       	or	r24, r25
    32aa:	21 f4       	brne	.+8      	; 0x32b4 <xQueueGenericReceive+0xda>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    32ac:	0f 90       	pop	r0
    32ae:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    32b0:	80 e0       	ldi	r24, 0x00	; 0
    32b2:	59 c0       	rjmp	.+178    	; 0x3366 <xQueueGenericReceive+0x18c>
				}
				else if( xEntryTimeSet == pdFALSE )
    32b4:	89 81       	ldd	r24, Y+1	; 0x01
    32b6:	88 23       	and	r24, r24
    32b8:	31 f4       	brne	.+12     	; 0x32c6 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    32ba:	ce 01       	movw	r24, r28
    32bc:	06 96       	adiw	r24, 0x06	; 6
    32be:	0e 94 62 22 	call	0x44c4	; 0x44c4 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    32c2:	81 e0       	ldi	r24, 0x01	; 1
    32c4:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    32c6:	0f 90       	pop	r0
    32c8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    32ca:	0e 94 e5 1e 	call	0x3dca	; 0x3dca <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    32ce:	0f b6       	in	r0, 0x3f	; 63
    32d0:	f8 94       	cli
    32d2:	0f 92       	push	r0
    32d4:	8a 81       	ldd	r24, Y+2	; 0x02
    32d6:	9b 81       	ldd	r25, Y+3	; 0x03
    32d8:	fc 01       	movw	r30, r24
    32da:	85 8d       	ldd	r24, Z+29	; 0x1d
    32dc:	8f 3f       	cpi	r24, 0xFF	; 255
    32de:	21 f4       	brne	.+8      	; 0x32e8 <xQueueGenericReceive+0x10e>
    32e0:	8a 81       	ldd	r24, Y+2	; 0x02
    32e2:	9b 81       	ldd	r25, Y+3	; 0x03
    32e4:	fc 01       	movw	r30, r24
    32e6:	15 8e       	std	Z+29, r1	; 0x1d
    32e8:	8a 81       	ldd	r24, Y+2	; 0x02
    32ea:	9b 81       	ldd	r25, Y+3	; 0x03
    32ec:	fc 01       	movw	r30, r24
    32ee:	86 8d       	ldd	r24, Z+30	; 0x1e
    32f0:	8f 3f       	cpi	r24, 0xFF	; 255
    32f2:	21 f4       	brne	.+8      	; 0x32fc <xQueueGenericReceive+0x122>
    32f4:	8a 81       	ldd	r24, Y+2	; 0x02
    32f6:	9b 81       	ldd	r25, Y+3	; 0x03
    32f8:	fc 01       	movw	r30, r24
    32fa:	16 8e       	std	Z+30, r1	; 0x1e
    32fc:	0f 90       	pop	r0
    32fe:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3300:	9e 01       	movw	r18, r28
    3302:	23 5f       	subi	r18, 0xF3	; 243
    3304:	3f 4f       	sbci	r19, 0xFF	; 255
    3306:	ce 01       	movw	r24, r28
    3308:	06 96       	adiw	r24, 0x06	; 6
    330a:	b9 01       	movw	r22, r18
    330c:	0e 94 7d 22 	call	0x44fa	; 0x44fa <xTaskCheckForTimeOut>
    3310:	88 23       	and	r24, r24
    3312:	01 f5       	brne	.+64     	; 0x3354 <xQueueGenericReceive+0x17a>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3314:	8a 81       	ldd	r24, Y+2	; 0x02
    3316:	9b 81       	ldd	r25, Y+3	; 0x03
    3318:	0e 94 38 1c 	call	0x3870	; 0x3870 <prvIsQueueEmpty>
    331c:	88 23       	and	r24, r24
    331e:	99 f0       	breq	.+38     	; 0x3346 <xQueueGenericReceive+0x16c>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3320:	2d 85       	ldd	r18, Y+13	; 0x0d
    3322:	3e 85       	ldd	r19, Y+14	; 0x0e
    3324:	8a 81       	ldd	r24, Y+2	; 0x02
    3326:	9b 81       	ldd	r25, Y+3	; 0x03
    3328:	41 96       	adiw	r24, 0x11	; 17
    332a:	b9 01       	movw	r22, r18
    332c:	0e 94 11 21 	call	0x4222	; 0x4222 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3330:	8a 81       	ldd	r24, Y+2	; 0x02
    3332:	9b 81       	ldd	r25, Y+3	; 0x03
    3334:	0e 94 d4 1b 	call	0x37a8	; 0x37a8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3338:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <xTaskResumeAll>
    333c:	88 23       	and	r24, r24
    333e:	91 f4       	brne	.+36     	; 0x3364 <xQueueGenericReceive+0x18a>
				{
					portYIELD_WITHIN_API();
    3340:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <vPortYield>
    3344:	0f c0       	rjmp	.+30     	; 0x3364 <xQueueGenericReceive+0x18a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3346:	8a 81       	ldd	r24, Y+2	; 0x02
    3348:	9b 81       	ldd	r25, Y+3	; 0x03
    334a:	0e 94 d4 1b 	call	0x37a8	; 0x37a8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    334e:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <xTaskResumeAll>
    3352:	59 cf       	rjmp	.-334    	; 0x3206 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    3354:	8a 81       	ldd	r24, Y+2	; 0x02
    3356:	9b 81       	ldd	r25, Y+3	; 0x03
    3358:	0e 94 d4 1b 	call	0x37a8	; 0x37a8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    335c:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    3360:	80 e0       	ldi	r24, 0x00	; 0
    3362:	01 c0       	rjmp	.+2      	; 0x3366 <xQueueGenericReceive+0x18c>
		}
	}
    3364:	50 cf       	rjmp	.-352    	; 0x3206 <xQueueGenericReceive+0x2c>
}
    3366:	2f 96       	adiw	r28, 0x0f	; 15
    3368:	0f b6       	in	r0, 0x3f	; 63
    336a:	f8 94       	cli
    336c:	de bf       	out	0x3e, r29	; 62
    336e:	0f be       	out	0x3f, r0	; 63
    3370:	cd bf       	out	0x3d, r28	; 61
    3372:	df 91       	pop	r29
    3374:	cf 91       	pop	r28
    3376:	08 95       	ret

00003378 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3378:	cf 93       	push	r28
    337a:	df 93       	push	r29
    337c:	cd b7       	in	r28, 0x3d	; 61
    337e:	de b7       	in	r29, 0x3e	; 62
    3380:	2a 97       	sbiw	r28, 0x0a	; 10
    3382:	0f b6       	in	r0, 0x3f	; 63
    3384:	f8 94       	cli
    3386:	de bf       	out	0x3e, r29	; 62
    3388:	0f be       	out	0x3f, r0	; 63
    338a:	cd bf       	out	0x3d, r28	; 61
    338c:	9e 83       	std	Y+6, r25	; 0x06
    338e:	8d 83       	std	Y+5, r24	; 0x05
    3390:	78 87       	std	Y+8, r23	; 0x08
    3392:	6f 83       	std	Y+7, r22	; 0x07
    3394:	5a 87       	std	Y+10, r21	; 0x0a
    3396:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3398:	8d 81       	ldd	r24, Y+5	; 0x05
    339a:	9e 81       	ldd	r25, Y+6	; 0x06
    339c:	9b 83       	std	Y+3, r25	; 0x03
    339e:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    33a0:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    33a2:	8a 81       	ldd	r24, Y+2	; 0x02
    33a4:	9b 81       	ldd	r25, Y+3	; 0x03
    33a6:	fc 01       	movw	r30, r24
    33a8:	82 8d       	ldd	r24, Z+26	; 0x1a
    33aa:	88 23       	and	r24, r24
    33ac:	d9 f1       	breq	.+118    	; 0x3424 <xQueueReceiveFromISR+0xac>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    33ae:	2f 81       	ldd	r18, Y+7	; 0x07
    33b0:	38 85       	ldd	r19, Y+8	; 0x08
    33b2:	8a 81       	ldd	r24, Y+2	; 0x02
    33b4:	9b 81       	ldd	r25, Y+3	; 0x03
    33b6:	b9 01       	movw	r22, r18
    33b8:	0e 94 84 1b 	call	0x3708	; 0x3708 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    33bc:	8a 81       	ldd	r24, Y+2	; 0x02
    33be:	9b 81       	ldd	r25, Y+3	; 0x03
    33c0:	fc 01       	movw	r30, r24
    33c2:	82 8d       	ldd	r24, Z+26	; 0x1a
    33c4:	2f ef       	ldi	r18, 0xFF	; 255
    33c6:	28 0f       	add	r18, r24
    33c8:	8a 81       	ldd	r24, Y+2	; 0x02
    33ca:	9b 81       	ldd	r25, Y+3	; 0x03
    33cc:	fc 01       	movw	r30, r24
    33ce:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    33d0:	8a 81       	ldd	r24, Y+2	; 0x02
    33d2:	9b 81       	ldd	r25, Y+3	; 0x03
    33d4:	fc 01       	movw	r30, r24
    33d6:	85 8d       	ldd	r24, Z+29	; 0x1d
    33d8:	8f 3f       	cpi	r24, 0xFF	; 255
    33da:	b9 f4       	brne	.+46     	; 0x340a <xQueueReceiveFromISR+0x92>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    33dc:	8a 81       	ldd	r24, Y+2	; 0x02
    33de:	9b 81       	ldd	r25, Y+3	; 0x03
    33e0:	fc 01       	movw	r30, r24
    33e2:	80 85       	ldd	r24, Z+8	; 0x08
    33e4:	88 23       	and	r24, r24
    33e6:	d9 f0       	breq	.+54     	; 0x341e <xQueueReceiveFromISR+0xa6>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    33e8:	8a 81       	ldd	r24, Y+2	; 0x02
    33ea:	9b 81       	ldd	r25, Y+3	; 0x03
    33ec:	08 96       	adiw	r24, 0x08	; 8
    33ee:	0e 94 8a 21 	call	0x4314	; 0x4314 <xTaskRemoveFromEventList>
    33f2:	88 23       	and	r24, r24
    33f4:	a1 f0       	breq	.+40     	; 0x341e <xQueueReceiveFromISR+0xa6>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    33f6:	89 85       	ldd	r24, Y+9	; 0x09
    33f8:	9a 85       	ldd	r25, Y+10	; 0x0a
    33fa:	89 2b       	or	r24, r25
    33fc:	81 f0       	breq	.+32     	; 0x341e <xQueueReceiveFromISR+0xa6>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    33fe:	89 85       	ldd	r24, Y+9	; 0x09
    3400:	9a 85       	ldd	r25, Y+10	; 0x0a
    3402:	21 e0       	ldi	r18, 0x01	; 1
    3404:	fc 01       	movw	r30, r24
    3406:	20 83       	st	Z, r18
    3408:	0a c0       	rjmp	.+20     	; 0x341e <xQueueReceiveFromISR+0xa6>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    340a:	8a 81       	ldd	r24, Y+2	; 0x02
    340c:	9b 81       	ldd	r25, Y+3	; 0x03
    340e:	fc 01       	movw	r30, r24
    3410:	85 8d       	ldd	r24, Z+29	; 0x1d
    3412:	8f 5f       	subi	r24, 0xFF	; 255
    3414:	28 2f       	mov	r18, r24
    3416:	8a 81       	ldd	r24, Y+2	; 0x02
    3418:	9b 81       	ldd	r25, Y+3	; 0x03
    341a:	fc 01       	movw	r30, r24
    341c:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    341e:	81 e0       	ldi	r24, 0x01	; 1
    3420:	89 83       	std	Y+1, r24	; 0x01
    3422:	01 c0       	rjmp	.+2      	; 0x3426 <xQueueReceiveFromISR+0xae>
		}
		else
		{
			xReturn = pdFAIL;
    3424:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3426:	89 81       	ldd	r24, Y+1	; 0x01
}
    3428:	2a 96       	adiw	r28, 0x0a	; 10
    342a:	0f b6       	in	r0, 0x3f	; 63
    342c:	f8 94       	cli
    342e:	de bf       	out	0x3e, r29	; 62
    3430:	0f be       	out	0x3f, r0	; 63
    3432:	cd bf       	out	0x3d, r28	; 61
    3434:	df 91       	pop	r29
    3436:	cf 91       	pop	r28
    3438:	08 95       	ret

0000343a <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    343a:	cf 93       	push	r28
    343c:	df 93       	push	r29
    343e:	cd b7       	in	r28, 0x3d	; 61
    3440:	de b7       	in	r29, 0x3e	; 62
    3442:	2a 97       	sbiw	r28, 0x0a	; 10
    3444:	0f b6       	in	r0, 0x3f	; 63
    3446:	f8 94       	cli
    3448:	de bf       	out	0x3e, r29	; 62
    344a:	0f be       	out	0x3f, r0	; 63
    344c:	cd bf       	out	0x3d, r28	; 61
    344e:	98 87       	std	Y+8, r25	; 0x08
    3450:	8f 83       	std	Y+7, r24	; 0x07
    3452:	7a 87       	std	Y+10, r23	; 0x0a
    3454:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3456:	8f 81       	ldd	r24, Y+7	; 0x07
    3458:	98 85       	ldd	r25, Y+8	; 0x08
    345a:	9b 83       	std	Y+3, r25	; 0x03
    345c:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    345e:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3460:	8a 81       	ldd	r24, Y+2	; 0x02
    3462:	9b 81       	ldd	r25, Y+3	; 0x03
    3464:	fc 01       	movw	r30, r24
    3466:	82 8d       	ldd	r24, Z+26	; 0x1a
    3468:	88 23       	and	r24, r24
    346a:	c1 f0       	breq	.+48     	; 0x349c <xQueuePeekFromISR+0x62>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    346c:	8a 81       	ldd	r24, Y+2	; 0x02
    346e:	9b 81       	ldd	r25, Y+3	; 0x03
    3470:	fc 01       	movw	r30, r24
    3472:	86 81       	ldd	r24, Z+6	; 0x06
    3474:	97 81       	ldd	r25, Z+7	; 0x07
    3476:	9e 83       	std	Y+6, r25	; 0x06
    3478:	8d 83       	std	Y+5, r24	; 0x05
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    347a:	29 85       	ldd	r18, Y+9	; 0x09
    347c:	3a 85       	ldd	r19, Y+10	; 0x0a
    347e:	8a 81       	ldd	r24, Y+2	; 0x02
    3480:	9b 81       	ldd	r25, Y+3	; 0x03
    3482:	b9 01       	movw	r22, r18
    3484:	0e 94 84 1b 	call	0x3708	; 0x3708 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    3488:	8a 81       	ldd	r24, Y+2	; 0x02
    348a:	9b 81       	ldd	r25, Y+3	; 0x03
    348c:	2d 81       	ldd	r18, Y+5	; 0x05
    348e:	3e 81       	ldd	r19, Y+6	; 0x06
    3490:	fc 01       	movw	r30, r24
    3492:	37 83       	std	Z+7, r19	; 0x07
    3494:	26 83       	std	Z+6, r18	; 0x06

			xReturn = pdPASS;
    3496:	81 e0       	ldi	r24, 0x01	; 1
    3498:	89 83       	std	Y+1, r24	; 0x01
    349a:	01 c0       	rjmp	.+2      	; 0x349e <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
    349c:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    349e:	89 81       	ldd	r24, Y+1	; 0x01
}
    34a0:	2a 96       	adiw	r28, 0x0a	; 10
    34a2:	0f b6       	in	r0, 0x3f	; 63
    34a4:	f8 94       	cli
    34a6:	de bf       	out	0x3e, r29	; 62
    34a8:	0f be       	out	0x3f, r0	; 63
    34aa:	cd bf       	out	0x3d, r28	; 61
    34ac:	df 91       	pop	r29
    34ae:	cf 91       	pop	r28
    34b0:	08 95       	ret

000034b2 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    34b2:	cf 93       	push	r28
    34b4:	df 93       	push	r29
    34b6:	00 d0       	rcall	.+0      	; 0x34b8 <uxQueueMessagesWaiting+0x6>
    34b8:	1f 92       	push	r1
    34ba:	cd b7       	in	r28, 0x3d	; 61
    34bc:	de b7       	in	r29, 0x3e	; 62
    34be:	9b 83       	std	Y+3, r25	; 0x03
    34c0:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    34c2:	0f b6       	in	r0, 0x3f	; 63
    34c4:	f8 94       	cli
    34c6:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    34c8:	8a 81       	ldd	r24, Y+2	; 0x02
    34ca:	9b 81       	ldd	r25, Y+3	; 0x03
    34cc:	fc 01       	movw	r30, r24
    34ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    34d0:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    34d2:	0f 90       	pop	r0
    34d4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    34d6:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    34d8:	0f 90       	pop	r0
    34da:	0f 90       	pop	r0
    34dc:	0f 90       	pop	r0
    34de:	df 91       	pop	r29
    34e0:	cf 91       	pop	r28
    34e2:	08 95       	ret

000034e4 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    34e4:	cf 93       	push	r28
    34e6:	df 93       	push	r29
    34e8:	00 d0       	rcall	.+0      	; 0x34ea <uxQueueSpacesAvailable+0x6>
    34ea:	00 d0       	rcall	.+0      	; 0x34ec <uxQueueSpacesAvailable+0x8>
    34ec:	1f 92       	push	r1
    34ee:	cd b7       	in	r28, 0x3d	; 61
    34f0:	de b7       	in	r29, 0x3e	; 62
    34f2:	9d 83       	std	Y+5, r25	; 0x05
    34f4:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    34f6:	8c 81       	ldd	r24, Y+4	; 0x04
    34f8:	9d 81       	ldd	r25, Y+5	; 0x05
    34fa:	9a 83       	std	Y+2, r25	; 0x02
    34fc:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    34fe:	0f b6       	in	r0, 0x3f	; 63
    3500:	f8 94       	cli
    3502:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3504:	89 81       	ldd	r24, Y+1	; 0x01
    3506:	9a 81       	ldd	r25, Y+2	; 0x02
    3508:	fc 01       	movw	r30, r24
    350a:	23 8d       	ldd	r18, Z+27	; 0x1b
    350c:	89 81       	ldd	r24, Y+1	; 0x01
    350e:	9a 81       	ldd	r25, Y+2	; 0x02
    3510:	fc 01       	movw	r30, r24
    3512:	82 8d       	ldd	r24, Z+26	; 0x1a
    3514:	f2 2f       	mov	r31, r18
    3516:	f8 1b       	sub	r31, r24
    3518:	8f 2f       	mov	r24, r31
    351a:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    351c:	0f 90       	pop	r0
    351e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3520:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3522:	0f 90       	pop	r0
    3524:	0f 90       	pop	r0
    3526:	0f 90       	pop	r0
    3528:	0f 90       	pop	r0
    352a:	0f 90       	pop	r0
    352c:	df 91       	pop	r29
    352e:	cf 91       	pop	r28
    3530:	08 95       	ret

00003532 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    3532:	cf 93       	push	r28
    3534:	df 93       	push	r29
    3536:	00 d0       	rcall	.+0      	; 0x3538 <uxQueueMessagesWaitingFromISR+0x6>
    3538:	1f 92       	push	r1
    353a:	cd b7       	in	r28, 0x3d	; 61
    353c:	de b7       	in	r29, 0x3e	; 62
    353e:	9b 83       	std	Y+3, r25	; 0x03
    3540:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3542:	8a 81       	ldd	r24, Y+2	; 0x02
    3544:	9b 81       	ldd	r25, Y+3	; 0x03
    3546:	fc 01       	movw	r30, r24
    3548:	82 8d       	ldd	r24, Z+26	; 0x1a
    354a:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    354c:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    354e:	0f 90       	pop	r0
    3550:	0f 90       	pop	r0
    3552:	0f 90       	pop	r0
    3554:	df 91       	pop	r29
    3556:	cf 91       	pop	r28
    3558:	08 95       	ret

0000355a <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    355a:	cf 93       	push	r28
    355c:	df 93       	push	r29
    355e:	00 d0       	rcall	.+0      	; 0x3560 <vQueueDelete+0x6>
    3560:	00 d0       	rcall	.+0      	; 0x3562 <vQueueDelete+0x8>
    3562:	cd b7       	in	r28, 0x3d	; 61
    3564:	de b7       	in	r29, 0x3e	; 62
    3566:	9c 83       	std	Y+4, r25	; 0x04
    3568:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    356a:	8b 81       	ldd	r24, Y+3	; 0x03
    356c:	9c 81       	ldd	r25, Y+4	; 0x04
    356e:	9a 83       	std	Y+2, r25	; 0x02
    3570:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue );
    3572:	89 81       	ldd	r24, Y+1	; 0x01
    3574:	9a 81       	ldd	r25, Y+2	; 0x02
    3576:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <vPortFree>
}
    357a:	0f 90       	pop	r0
    357c:	0f 90       	pop	r0
    357e:	0f 90       	pop	r0
    3580:	0f 90       	pop	r0
    3582:	df 91       	pop	r29
    3584:	cf 91       	pop	r28
    3586:	08 95       	ret

00003588 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    3588:	cf 93       	push	r28
    358a:	df 93       	push	r29
    358c:	00 d0       	rcall	.+0      	; 0x358e <prvCopyDataToQueue+0x6>
    358e:	00 d0       	rcall	.+0      	; 0x3590 <prvCopyDataToQueue+0x8>
    3590:	00 d0       	rcall	.+0      	; 0x3592 <prvCopyDataToQueue+0xa>
    3592:	cd b7       	in	r28, 0x3d	; 61
    3594:	de b7       	in	r29, 0x3e	; 62
    3596:	9b 83       	std	Y+3, r25	; 0x03
    3598:	8a 83       	std	Y+2, r24	; 0x02
    359a:	7d 83       	std	Y+5, r23	; 0x05
    359c:	6c 83       	std	Y+4, r22	; 0x04
    359e:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    35a0:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    35a2:	8a 81       	ldd	r24, Y+2	; 0x02
    35a4:	9b 81       	ldd	r25, Y+3	; 0x03
    35a6:	fc 01       	movw	r30, r24
    35a8:	84 8d       	ldd	r24, Z+28	; 0x1c
    35aa:	88 23       	and	r24, r24
    35ac:	09 f4       	brne	.+2      	; 0x35b0 <prvCopyDataToQueue+0x28>
    35ae:	98 c0       	rjmp	.+304    	; 0x36e0 <prvCopyDataToQueue+0x158>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    35b0:	8e 81       	ldd	r24, Y+6	; 0x06
    35b2:	88 23       	and	r24, r24
    35b4:	d9 f5       	brne	.+118    	; 0x362c <prvCopyDataToQueue+0xa4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    35b6:	8a 81       	ldd	r24, Y+2	; 0x02
    35b8:	9b 81       	ldd	r25, Y+3	; 0x03
    35ba:	fc 01       	movw	r30, r24
    35bc:	84 8d       	ldd	r24, Z+28	; 0x1c
    35be:	48 2f       	mov	r20, r24
    35c0:	50 e0       	ldi	r21, 0x00	; 0
    35c2:	8a 81       	ldd	r24, Y+2	; 0x02
    35c4:	9b 81       	ldd	r25, Y+3	; 0x03
    35c6:	fc 01       	movw	r30, r24
    35c8:	84 81       	ldd	r24, Z+4	; 0x04
    35ca:	95 81       	ldd	r25, Z+5	; 0x05
    35cc:	2c 81       	ldd	r18, Y+4	; 0x04
    35ce:	3d 81       	ldd	r19, Y+5	; 0x05
    35d0:	b9 01       	movw	r22, r18
    35d2:	0e 94 2d 29 	call	0x525a	; 0x525a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    35d6:	8a 81       	ldd	r24, Y+2	; 0x02
    35d8:	9b 81       	ldd	r25, Y+3	; 0x03
    35da:	fc 01       	movw	r30, r24
    35dc:	24 81       	ldd	r18, Z+4	; 0x04
    35de:	35 81       	ldd	r19, Z+5	; 0x05
    35e0:	8a 81       	ldd	r24, Y+2	; 0x02
    35e2:	9b 81       	ldd	r25, Y+3	; 0x03
    35e4:	fc 01       	movw	r30, r24
    35e6:	84 8d       	ldd	r24, Z+28	; 0x1c
    35e8:	88 2f       	mov	r24, r24
    35ea:	90 e0       	ldi	r25, 0x00	; 0
    35ec:	28 0f       	add	r18, r24
    35ee:	39 1f       	adc	r19, r25
    35f0:	8a 81       	ldd	r24, Y+2	; 0x02
    35f2:	9b 81       	ldd	r25, Y+3	; 0x03
    35f4:	fc 01       	movw	r30, r24
    35f6:	35 83       	std	Z+5, r19	; 0x05
    35f8:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    35fa:	8a 81       	ldd	r24, Y+2	; 0x02
    35fc:	9b 81       	ldd	r25, Y+3	; 0x03
    35fe:	fc 01       	movw	r30, r24
    3600:	24 81       	ldd	r18, Z+4	; 0x04
    3602:	35 81       	ldd	r19, Z+5	; 0x05
    3604:	8a 81       	ldd	r24, Y+2	; 0x02
    3606:	9b 81       	ldd	r25, Y+3	; 0x03
    3608:	fc 01       	movw	r30, r24
    360a:	82 81       	ldd	r24, Z+2	; 0x02
    360c:	93 81       	ldd	r25, Z+3	; 0x03
    360e:	28 17       	cp	r18, r24
    3610:	39 07       	cpc	r19, r25
    3612:	08 f4       	brcc	.+2      	; 0x3616 <prvCopyDataToQueue+0x8e>
    3614:	65 c0       	rjmp	.+202    	; 0x36e0 <prvCopyDataToQueue+0x158>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3616:	8a 81       	ldd	r24, Y+2	; 0x02
    3618:	9b 81       	ldd	r25, Y+3	; 0x03
    361a:	fc 01       	movw	r30, r24
    361c:	20 81       	ld	r18, Z
    361e:	31 81       	ldd	r19, Z+1	; 0x01
    3620:	8a 81       	ldd	r24, Y+2	; 0x02
    3622:	9b 81       	ldd	r25, Y+3	; 0x03
    3624:	fc 01       	movw	r30, r24
    3626:	35 83       	std	Z+5, r19	; 0x05
    3628:	24 83       	std	Z+4, r18	; 0x04
    362a:	5a c0       	rjmp	.+180    	; 0x36e0 <prvCopyDataToQueue+0x158>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    362c:	8a 81       	ldd	r24, Y+2	; 0x02
    362e:	9b 81       	ldd	r25, Y+3	; 0x03
    3630:	fc 01       	movw	r30, r24
    3632:	84 8d       	ldd	r24, Z+28	; 0x1c
    3634:	48 2f       	mov	r20, r24
    3636:	50 e0       	ldi	r21, 0x00	; 0
    3638:	8a 81       	ldd	r24, Y+2	; 0x02
    363a:	9b 81       	ldd	r25, Y+3	; 0x03
    363c:	fc 01       	movw	r30, r24
    363e:	86 81       	ldd	r24, Z+6	; 0x06
    3640:	97 81       	ldd	r25, Z+7	; 0x07
    3642:	2c 81       	ldd	r18, Y+4	; 0x04
    3644:	3d 81       	ldd	r19, Y+5	; 0x05
    3646:	b9 01       	movw	r22, r18
    3648:	0e 94 2d 29 	call	0x525a	; 0x525a <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    364c:	8a 81       	ldd	r24, Y+2	; 0x02
    364e:	9b 81       	ldd	r25, Y+3	; 0x03
    3650:	fc 01       	movw	r30, r24
    3652:	26 81       	ldd	r18, Z+6	; 0x06
    3654:	37 81       	ldd	r19, Z+7	; 0x07
    3656:	8a 81       	ldd	r24, Y+2	; 0x02
    3658:	9b 81       	ldd	r25, Y+3	; 0x03
    365a:	fc 01       	movw	r30, r24
    365c:	84 8d       	ldd	r24, Z+28	; 0x1c
    365e:	88 2f       	mov	r24, r24
    3660:	90 e0       	ldi	r25, 0x00	; 0
    3662:	91 95       	neg	r25
    3664:	81 95       	neg	r24
    3666:	91 09       	sbc	r25, r1
    3668:	28 0f       	add	r18, r24
    366a:	39 1f       	adc	r19, r25
    366c:	8a 81       	ldd	r24, Y+2	; 0x02
    366e:	9b 81       	ldd	r25, Y+3	; 0x03
    3670:	fc 01       	movw	r30, r24
    3672:	37 83       	std	Z+7, r19	; 0x07
    3674:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3676:	8a 81       	ldd	r24, Y+2	; 0x02
    3678:	9b 81       	ldd	r25, Y+3	; 0x03
    367a:	fc 01       	movw	r30, r24
    367c:	26 81       	ldd	r18, Z+6	; 0x06
    367e:	37 81       	ldd	r19, Z+7	; 0x07
    3680:	8a 81       	ldd	r24, Y+2	; 0x02
    3682:	9b 81       	ldd	r25, Y+3	; 0x03
    3684:	fc 01       	movw	r30, r24
    3686:	80 81       	ld	r24, Z
    3688:	91 81       	ldd	r25, Z+1	; 0x01
    368a:	28 17       	cp	r18, r24
    368c:	39 07       	cpc	r19, r25
    368e:	a8 f4       	brcc	.+42     	; 0x36ba <prvCopyDataToQueue+0x132>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    3690:	8a 81       	ldd	r24, Y+2	; 0x02
    3692:	9b 81       	ldd	r25, Y+3	; 0x03
    3694:	fc 01       	movw	r30, r24
    3696:	22 81       	ldd	r18, Z+2	; 0x02
    3698:	33 81       	ldd	r19, Z+3	; 0x03
    369a:	8a 81       	ldd	r24, Y+2	; 0x02
    369c:	9b 81       	ldd	r25, Y+3	; 0x03
    369e:	fc 01       	movw	r30, r24
    36a0:	84 8d       	ldd	r24, Z+28	; 0x1c
    36a2:	88 2f       	mov	r24, r24
    36a4:	90 e0       	ldi	r25, 0x00	; 0
    36a6:	91 95       	neg	r25
    36a8:	81 95       	neg	r24
    36aa:	91 09       	sbc	r25, r1
    36ac:	28 0f       	add	r18, r24
    36ae:	39 1f       	adc	r19, r25
    36b0:	8a 81       	ldd	r24, Y+2	; 0x02
    36b2:	9b 81       	ldd	r25, Y+3	; 0x03
    36b4:	fc 01       	movw	r30, r24
    36b6:	37 83       	std	Z+7, r19	; 0x07
    36b8:	26 83       	std	Z+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    36ba:	8e 81       	ldd	r24, Y+6	; 0x06
    36bc:	82 30       	cpi	r24, 0x02	; 2
    36be:	81 f4       	brne	.+32     	; 0x36e0 <prvCopyDataToQueue+0x158>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    36c0:	8a 81       	ldd	r24, Y+2	; 0x02
    36c2:	9b 81       	ldd	r25, Y+3	; 0x03
    36c4:	fc 01       	movw	r30, r24
    36c6:	82 8d       	ldd	r24, Z+26	; 0x1a
    36c8:	88 23       	and	r24, r24
    36ca:	51 f0       	breq	.+20     	; 0x36e0 <prvCopyDataToQueue+0x158>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    36cc:	8a 81       	ldd	r24, Y+2	; 0x02
    36ce:	9b 81       	ldd	r25, Y+3	; 0x03
    36d0:	fc 01       	movw	r30, r24
    36d2:	82 8d       	ldd	r24, Z+26	; 0x1a
    36d4:	2f ef       	ldi	r18, 0xFF	; 255
    36d6:	28 0f       	add	r18, r24
    36d8:	8a 81       	ldd	r24, Y+2	; 0x02
    36da:	9b 81       	ldd	r25, Y+3	; 0x03
    36dc:	fc 01       	movw	r30, r24
    36de:	22 8f       	std	Z+26, r18	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    36e0:	8a 81       	ldd	r24, Y+2	; 0x02
    36e2:	9b 81       	ldd	r25, Y+3	; 0x03
    36e4:	fc 01       	movw	r30, r24
    36e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    36e8:	21 e0       	ldi	r18, 0x01	; 1
    36ea:	28 0f       	add	r18, r24
    36ec:	8a 81       	ldd	r24, Y+2	; 0x02
    36ee:	9b 81       	ldd	r25, Y+3	; 0x03
    36f0:	fc 01       	movw	r30, r24
    36f2:	22 8f       	std	Z+26, r18	; 0x1a

	return xReturn;
    36f4:	89 81       	ldd	r24, Y+1	; 0x01
}
    36f6:	26 96       	adiw	r28, 0x06	; 6
    36f8:	0f b6       	in	r0, 0x3f	; 63
    36fa:	f8 94       	cli
    36fc:	de bf       	out	0x3e, r29	; 62
    36fe:	0f be       	out	0x3f, r0	; 63
    3700:	cd bf       	out	0x3d, r28	; 61
    3702:	df 91       	pop	r29
    3704:	cf 91       	pop	r28
    3706:	08 95       	ret

00003708 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    3708:	cf 93       	push	r28
    370a:	df 93       	push	r29
    370c:	00 d0       	rcall	.+0      	; 0x370e <prvCopyDataFromQueue+0x6>
    370e:	00 d0       	rcall	.+0      	; 0x3710 <prvCopyDataFromQueue+0x8>
    3710:	cd b7       	in	r28, 0x3d	; 61
    3712:	de b7       	in	r29, 0x3e	; 62
    3714:	9a 83       	std	Y+2, r25	; 0x02
    3716:	89 83       	std	Y+1, r24	; 0x01
    3718:	7c 83       	std	Y+4, r23	; 0x04
    371a:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    371c:	89 81       	ldd	r24, Y+1	; 0x01
    371e:	9a 81       	ldd	r25, Y+2	; 0x02
    3720:	fc 01       	movw	r30, r24
    3722:	84 8d       	ldd	r24, Z+28	; 0x1c
    3724:	88 23       	and	r24, r24
    3726:	c9 f1       	breq	.+114    	; 0x379a <prvCopyDataFromQueue+0x92>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    3728:	89 81       	ldd	r24, Y+1	; 0x01
    372a:	9a 81       	ldd	r25, Y+2	; 0x02
    372c:	fc 01       	movw	r30, r24
    372e:	26 81       	ldd	r18, Z+6	; 0x06
    3730:	37 81       	ldd	r19, Z+7	; 0x07
    3732:	89 81       	ldd	r24, Y+1	; 0x01
    3734:	9a 81       	ldd	r25, Y+2	; 0x02
    3736:	fc 01       	movw	r30, r24
    3738:	84 8d       	ldd	r24, Z+28	; 0x1c
    373a:	88 2f       	mov	r24, r24
    373c:	90 e0       	ldi	r25, 0x00	; 0
    373e:	28 0f       	add	r18, r24
    3740:	39 1f       	adc	r19, r25
    3742:	89 81       	ldd	r24, Y+1	; 0x01
    3744:	9a 81       	ldd	r25, Y+2	; 0x02
    3746:	fc 01       	movw	r30, r24
    3748:	37 83       	std	Z+7, r19	; 0x07
    374a:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    374c:	89 81       	ldd	r24, Y+1	; 0x01
    374e:	9a 81       	ldd	r25, Y+2	; 0x02
    3750:	fc 01       	movw	r30, r24
    3752:	26 81       	ldd	r18, Z+6	; 0x06
    3754:	37 81       	ldd	r19, Z+7	; 0x07
    3756:	89 81       	ldd	r24, Y+1	; 0x01
    3758:	9a 81       	ldd	r25, Y+2	; 0x02
    375a:	fc 01       	movw	r30, r24
    375c:	82 81       	ldd	r24, Z+2	; 0x02
    375e:	93 81       	ldd	r25, Z+3	; 0x03
    3760:	28 17       	cp	r18, r24
    3762:	39 07       	cpc	r19, r25
    3764:	50 f0       	brcs	.+20     	; 0x377a <prvCopyDataFromQueue+0x72>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    3766:	89 81       	ldd	r24, Y+1	; 0x01
    3768:	9a 81       	ldd	r25, Y+2	; 0x02
    376a:	fc 01       	movw	r30, r24
    376c:	20 81       	ld	r18, Z
    376e:	31 81       	ldd	r19, Z+1	; 0x01
    3770:	89 81       	ldd	r24, Y+1	; 0x01
    3772:	9a 81       	ldd	r25, Y+2	; 0x02
    3774:	fc 01       	movw	r30, r24
    3776:	37 83       	std	Z+7, r19	; 0x07
    3778:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    377a:	89 81       	ldd	r24, Y+1	; 0x01
    377c:	9a 81       	ldd	r25, Y+2	; 0x02
    377e:	fc 01       	movw	r30, r24
    3780:	84 8d       	ldd	r24, Z+28	; 0x1c
    3782:	48 2f       	mov	r20, r24
    3784:	50 e0       	ldi	r21, 0x00	; 0
    3786:	89 81       	ldd	r24, Y+1	; 0x01
    3788:	9a 81       	ldd	r25, Y+2	; 0x02
    378a:	fc 01       	movw	r30, r24
    378c:	26 81       	ldd	r18, Z+6	; 0x06
    378e:	37 81       	ldd	r19, Z+7	; 0x07
    3790:	8b 81       	ldd	r24, Y+3	; 0x03
    3792:	9c 81       	ldd	r25, Y+4	; 0x04
    3794:	b9 01       	movw	r22, r18
    3796:	0e 94 2d 29 	call	0x525a	; 0x525a <memcpy>
	}
}
    379a:	0f 90       	pop	r0
    379c:	0f 90       	pop	r0
    379e:	0f 90       	pop	r0
    37a0:	0f 90       	pop	r0
    37a2:	df 91       	pop	r29
    37a4:	cf 91       	pop	r28
    37a6:	08 95       	ret

000037a8 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    37a8:	cf 93       	push	r28
    37aa:	df 93       	push	r29
    37ac:	00 d0       	rcall	.+0      	; 0x37ae <prvUnlockQueue+0x6>
    37ae:	cd b7       	in	r28, 0x3d	; 61
    37b0:	de b7       	in	r29, 0x3e	; 62
    37b2:	9a 83       	std	Y+2, r25	; 0x02
    37b4:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    37b6:	0f b6       	in	r0, 0x3f	; 63
    37b8:	f8 94       	cli
    37ba:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    37bc:	1b c0       	rjmp	.+54     	; 0x37f4 <prvUnlockQueue+0x4c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    37be:	89 81       	ldd	r24, Y+1	; 0x01
    37c0:	9a 81       	ldd	r25, Y+2	; 0x02
    37c2:	fc 01       	movw	r30, r24
    37c4:	81 89       	ldd	r24, Z+17	; 0x11
    37c6:	88 23       	and	r24, r24
    37c8:	51 f0       	breq	.+20     	; 0x37de <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    37ca:	89 81       	ldd	r24, Y+1	; 0x01
    37cc:	9a 81       	ldd	r25, Y+2	; 0x02
    37ce:	41 96       	adiw	r24, 0x11	; 17
    37d0:	0e 94 8a 21 	call	0x4314	; 0x4314 <xTaskRemoveFromEventList>
    37d4:	88 23       	and	r24, r24
    37d6:	21 f0       	breq	.+8      	; 0x37e0 <prvUnlockQueue+0x38>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    37d8:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vTaskMissedYield>
    37dc:	01 c0       	rjmp	.+2      	; 0x37e0 <prvUnlockQueue+0x38>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
    37de:	10 c0       	rjmp	.+32     	; 0x3800 <prvUnlockQueue+0x58>
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    37e0:	89 81       	ldd	r24, Y+1	; 0x01
    37e2:	9a 81       	ldd	r25, Y+2	; 0x02
    37e4:	fc 01       	movw	r30, r24
    37e6:	86 8d       	ldd	r24, Z+30	; 0x1e
    37e8:	81 50       	subi	r24, 0x01	; 1
    37ea:	28 2f       	mov	r18, r24
    37ec:	89 81       	ldd	r24, Y+1	; 0x01
    37ee:	9a 81       	ldd	r25, Y+2	; 0x02
    37f0:	fc 01       	movw	r30, r24
    37f2:	26 8f       	std	Z+30, r18	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    37f4:	89 81       	ldd	r24, Y+1	; 0x01
    37f6:	9a 81       	ldd	r25, Y+2	; 0x02
    37f8:	fc 01       	movw	r30, r24
    37fa:	86 8d       	ldd	r24, Z+30	; 0x1e
    37fc:	18 16       	cp	r1, r24
    37fe:	fc f2       	brlt	.-66     	; 0x37be <prvUnlockQueue+0x16>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3800:	89 81       	ldd	r24, Y+1	; 0x01
    3802:	9a 81       	ldd	r25, Y+2	; 0x02
    3804:	2f ef       	ldi	r18, 0xFF	; 255
    3806:	fc 01       	movw	r30, r24
    3808:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    380a:	0f 90       	pop	r0
    380c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    380e:	0f b6       	in	r0, 0x3f	; 63
    3810:	f8 94       	cli
    3812:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3814:	1b c0       	rjmp	.+54     	; 0x384c <prvUnlockQueue+0xa4>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3816:	89 81       	ldd	r24, Y+1	; 0x01
    3818:	9a 81       	ldd	r25, Y+2	; 0x02
    381a:	fc 01       	movw	r30, r24
    381c:	80 85       	ldd	r24, Z+8	; 0x08
    381e:	88 23       	and	r24, r24
    3820:	a1 f0       	breq	.+40     	; 0x384a <prvUnlockQueue+0xa2>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3822:	89 81       	ldd	r24, Y+1	; 0x01
    3824:	9a 81       	ldd	r25, Y+2	; 0x02
    3826:	08 96       	adiw	r24, 0x08	; 8
    3828:	0e 94 8a 21 	call	0x4314	; 0x4314 <xTaskRemoveFromEventList>
    382c:	88 23       	and	r24, r24
    382e:	11 f0       	breq	.+4      	; 0x3834 <prvUnlockQueue+0x8c>
				{
					vTaskMissedYield();
    3830:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    3834:	89 81       	ldd	r24, Y+1	; 0x01
    3836:	9a 81       	ldd	r25, Y+2	; 0x02
    3838:	fc 01       	movw	r30, r24
    383a:	85 8d       	ldd	r24, Z+29	; 0x1d
    383c:	81 50       	subi	r24, 0x01	; 1
    383e:	28 2f       	mov	r18, r24
    3840:	89 81       	ldd	r24, Y+1	; 0x01
    3842:	9a 81       	ldd	r25, Y+2	; 0x02
    3844:	fc 01       	movw	r30, r24
    3846:	25 8f       	std	Z+29, r18	; 0x1d
    3848:	01 c0       	rjmp	.+2      	; 0x384c <prvUnlockQueue+0xa4>
			}
			else
			{
				break;
    384a:	06 c0       	rjmp	.+12     	; 0x3858 <prvUnlockQueue+0xb0>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    384c:	89 81       	ldd	r24, Y+1	; 0x01
    384e:	9a 81       	ldd	r25, Y+2	; 0x02
    3850:	fc 01       	movw	r30, r24
    3852:	85 8d       	ldd	r24, Z+29	; 0x1d
    3854:	18 16       	cp	r1, r24
    3856:	fc f2       	brlt	.-66     	; 0x3816 <prvUnlockQueue+0x6e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    3858:	89 81       	ldd	r24, Y+1	; 0x01
    385a:	9a 81       	ldd	r25, Y+2	; 0x02
    385c:	2f ef       	ldi	r18, 0xFF	; 255
    385e:	fc 01       	movw	r30, r24
    3860:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    3862:	0f 90       	pop	r0
    3864:	0f be       	out	0x3f, r0	; 63
}
    3866:	0f 90       	pop	r0
    3868:	0f 90       	pop	r0
    386a:	df 91       	pop	r29
    386c:	cf 91       	pop	r28
    386e:	08 95       	ret

00003870 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    3870:	cf 93       	push	r28
    3872:	df 93       	push	r29
    3874:	00 d0       	rcall	.+0      	; 0x3876 <prvIsQueueEmpty+0x6>
    3876:	1f 92       	push	r1
    3878:	cd b7       	in	r28, 0x3d	; 61
    387a:	de b7       	in	r29, 0x3e	; 62
    387c:	9b 83       	std	Y+3, r25	; 0x03
    387e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3880:	0f b6       	in	r0, 0x3f	; 63
    3882:	f8 94       	cli
    3884:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3886:	8a 81       	ldd	r24, Y+2	; 0x02
    3888:	9b 81       	ldd	r25, Y+3	; 0x03
    388a:	fc 01       	movw	r30, r24
    388c:	82 8d       	ldd	r24, Z+26	; 0x1a
    388e:	88 23       	and	r24, r24
    3890:	19 f4       	brne	.+6      	; 0x3898 <prvIsQueueEmpty+0x28>
		{
			xReturn = pdTRUE;
    3892:	81 e0       	ldi	r24, 0x01	; 1
    3894:	89 83       	std	Y+1, r24	; 0x01
    3896:	01 c0       	rjmp	.+2      	; 0x389a <prvIsQueueEmpty+0x2a>
		}
		else
		{
			xReturn = pdFALSE;
    3898:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    389a:	0f 90       	pop	r0
    389c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    389e:	89 81       	ldd	r24, Y+1	; 0x01
}
    38a0:	0f 90       	pop	r0
    38a2:	0f 90       	pop	r0
    38a4:	0f 90       	pop	r0
    38a6:	df 91       	pop	r29
    38a8:	cf 91       	pop	r28
    38aa:	08 95       	ret

000038ac <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    38ac:	cf 93       	push	r28
    38ae:	df 93       	push	r29
    38b0:	00 d0       	rcall	.+0      	; 0x38b2 <xQueueIsQueueEmptyFromISR+0x6>
    38b2:	1f 92       	push	r1
    38b4:	cd b7       	in	r28, 0x3d	; 61
    38b6:	de b7       	in	r29, 0x3e	; 62
    38b8:	9b 83       	std	Y+3, r25	; 0x03
    38ba:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    38bc:	8a 81       	ldd	r24, Y+2	; 0x02
    38be:	9b 81       	ldd	r25, Y+3	; 0x03
    38c0:	fc 01       	movw	r30, r24
    38c2:	82 8d       	ldd	r24, Z+26	; 0x1a
    38c4:	88 23       	and	r24, r24
    38c6:	19 f4       	brne	.+6      	; 0x38ce <xQueueIsQueueEmptyFromISR+0x22>
	{
		xReturn = pdTRUE;
    38c8:	81 e0       	ldi	r24, 0x01	; 1
    38ca:	89 83       	std	Y+1, r24	; 0x01
    38cc:	01 c0       	rjmp	.+2      	; 0x38d0 <xQueueIsQueueEmptyFromISR+0x24>
	}
	else
	{
		xReturn = pdFALSE;
    38ce:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    38d0:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    38d2:	0f 90       	pop	r0
    38d4:	0f 90       	pop	r0
    38d6:	0f 90       	pop	r0
    38d8:	df 91       	pop	r29
    38da:	cf 91       	pop	r28
    38dc:	08 95       	ret

000038de <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    38de:	cf 93       	push	r28
    38e0:	df 93       	push	r29
    38e2:	00 d0       	rcall	.+0      	; 0x38e4 <prvIsQueueFull+0x6>
    38e4:	1f 92       	push	r1
    38e6:	cd b7       	in	r28, 0x3d	; 61
    38e8:	de b7       	in	r29, 0x3e	; 62
    38ea:	9b 83       	std	Y+3, r25	; 0x03
    38ec:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    38ee:	0f b6       	in	r0, 0x3f	; 63
    38f0:	f8 94       	cli
    38f2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    38f4:	8a 81       	ldd	r24, Y+2	; 0x02
    38f6:	9b 81       	ldd	r25, Y+3	; 0x03
    38f8:	fc 01       	movw	r30, r24
    38fa:	22 8d       	ldd	r18, Z+26	; 0x1a
    38fc:	8a 81       	ldd	r24, Y+2	; 0x02
    38fe:	9b 81       	ldd	r25, Y+3	; 0x03
    3900:	fc 01       	movw	r30, r24
    3902:	83 8d       	ldd	r24, Z+27	; 0x1b
    3904:	28 17       	cp	r18, r24
    3906:	19 f4       	brne	.+6      	; 0x390e <prvIsQueueFull+0x30>
		{
			xReturn = pdTRUE;
    3908:	81 e0       	ldi	r24, 0x01	; 1
    390a:	89 83       	std	Y+1, r24	; 0x01
    390c:	01 c0       	rjmp	.+2      	; 0x3910 <prvIsQueueFull+0x32>
		}
		else
		{
			xReturn = pdFALSE;
    390e:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3910:	0f 90       	pop	r0
    3912:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3914:	89 81       	ldd	r24, Y+1	; 0x01
}
    3916:	0f 90       	pop	r0
    3918:	0f 90       	pop	r0
    391a:	0f 90       	pop	r0
    391c:	df 91       	pop	r29
    391e:	cf 91       	pop	r28
    3920:	08 95       	ret

00003922 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    3922:	cf 93       	push	r28
    3924:	df 93       	push	r29
    3926:	00 d0       	rcall	.+0      	; 0x3928 <xQueueIsQueueFullFromISR+0x6>
    3928:	1f 92       	push	r1
    392a:	cd b7       	in	r28, 0x3d	; 61
    392c:	de b7       	in	r29, 0x3e	; 62
    392e:	9b 83       	std	Y+3, r25	; 0x03
    3930:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    3932:	8a 81       	ldd	r24, Y+2	; 0x02
    3934:	9b 81       	ldd	r25, Y+3	; 0x03
    3936:	fc 01       	movw	r30, r24
    3938:	22 8d       	ldd	r18, Z+26	; 0x1a
    393a:	8a 81       	ldd	r24, Y+2	; 0x02
    393c:	9b 81       	ldd	r25, Y+3	; 0x03
    393e:	fc 01       	movw	r30, r24
    3940:	83 8d       	ldd	r24, Z+27	; 0x1b
    3942:	28 17       	cp	r18, r24
    3944:	19 f4       	brne	.+6      	; 0x394c <xQueueIsQueueFullFromISR+0x2a>
	{
		xReturn = pdTRUE;
    3946:	81 e0       	ldi	r24, 0x01	; 1
    3948:	89 83       	std	Y+1, r24	; 0x01
    394a:	01 c0       	rjmp	.+2      	; 0x394e <xQueueIsQueueFullFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    394c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    394e:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3950:	0f 90       	pop	r0
    3952:	0f 90       	pop	r0
    3954:	0f 90       	pop	r0
    3956:	df 91       	pop	r29
    3958:	cf 91       	pop	r28
    395a:	08 95       	ret

0000395c <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    395c:	af 92       	push	r10
    395e:	bf 92       	push	r11
    3960:	cf 92       	push	r12
    3962:	df 92       	push	r13
    3964:	ef 92       	push	r14
    3966:	ff 92       	push	r15
    3968:	0f 93       	push	r16
    396a:	1f 93       	push	r17
    396c:	cf 93       	push	r28
    396e:	df 93       	push	r29
    3970:	cd b7       	in	r28, 0x3d	; 61
    3972:	de b7       	in	r29, 0x3e	; 62
    3974:	64 97       	sbiw	r28, 0x14	; 20
    3976:	0f b6       	in	r0, 0x3f	; 63
    3978:	f8 94       	cli
    397a:	de bf       	out	0x3e, r29	; 62
    397c:	0f be       	out	0x3f, r0	; 63
    397e:	cd bf       	out	0x3d, r28	; 61
    3980:	9f 83       	std	Y+7, r25	; 0x07
    3982:	8e 83       	std	Y+6, r24	; 0x06
    3984:	79 87       	std	Y+9, r23	; 0x09
    3986:	68 87       	std	Y+8, r22	; 0x08
    3988:	5b 87       	std	Y+11, r21	; 0x0b
    398a:	4a 87       	std	Y+10, r20	; 0x0a
    398c:	3d 87       	std	Y+13, r19	; 0x0d
    398e:	2c 87       	std	Y+12, r18	; 0x0c
    3990:	0e 87       	std	Y+14, r16	; 0x0e
    3992:	f8 8a       	std	Y+16, r15	; 0x10
    3994:	ef 86       	std	Y+15, r14	; 0x0f
    3996:	da 8a       	std	Y+18, r13	; 0x12
    3998:	c9 8a       	std	Y+17, r12	; 0x11
    399a:	bc 8a       	std	Y+20, r11	; 0x14
    399c:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    399e:	29 89       	ldd	r18, Y+17	; 0x11
    39a0:	3a 89       	ldd	r19, Y+18	; 0x12
    39a2:	8a 85       	ldd	r24, Y+10	; 0x0a
    39a4:	9b 85       	ldd	r25, Y+11	; 0x0b
    39a6:	b9 01       	movw	r22, r18
    39a8:	0e 94 4a 24 	call	0x4894	; 0x4894 <prvAllocateTCBAndStack>
    39ac:	9b 83       	std	Y+3, r25	; 0x03
    39ae:	8a 83       	std	Y+2, r24	; 0x02

	if( pxNewTCB != NULL )
    39b0:	8a 81       	ldd	r24, Y+2	; 0x02
    39b2:	9b 81       	ldd	r25, Y+3	; 0x03
    39b4:	89 2b       	or	r24, r25
    39b6:	09 f4       	brne	.+2      	; 0x39ba <xTaskGenericCreate+0x5e>
    39b8:	91 c0       	rjmp	.+290    	; 0x3adc <xTaskGenericCreate+0x180>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    39ba:	8a 81       	ldd	r24, Y+2	; 0x02
    39bc:	9b 81       	ldd	r25, Y+3	; 0x03
    39be:	fc 01       	movw	r30, r24
    39c0:	27 89       	ldd	r18, Z+23	; 0x17
    39c2:	30 8d       	ldd	r19, Z+24	; 0x18
    39c4:	8a 85       	ldd	r24, Y+10	; 0x0a
    39c6:	9b 85       	ldd	r25, Y+11	; 0x0b
    39c8:	01 97       	sbiw	r24, 0x01	; 1
    39ca:	82 0f       	add	r24, r18
    39cc:	93 1f       	adc	r25, r19
    39ce:	9d 83       	std	Y+5, r25	; 0x05
    39d0:	8c 83       	std	Y+4, r24	; 0x04
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    39d2:	4a 85       	ldd	r20, Y+10	; 0x0a
    39d4:	5b 85       	ldd	r21, Y+11	; 0x0b
    39d6:	2b 89       	ldd	r18, Y+19	; 0x13
    39d8:	3c 89       	ldd	r19, Y+20	; 0x14
    39da:	68 85       	ldd	r22, Y+8	; 0x08
    39dc:	79 85       	ldd	r23, Y+9	; 0x09
    39de:	8a 81       	ldd	r24, Y+2	; 0x02
    39e0:	9b 81       	ldd	r25, Y+3	; 0x03
    39e2:	8a 01       	movw	r16, r20
    39e4:	4e 85       	ldd	r20, Y+14	; 0x0e
    39e6:	0e 94 ff 22 	call	0x45fe	; 0x45fe <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    39ea:	4c 85       	ldd	r20, Y+12	; 0x0c
    39ec:	5d 85       	ldd	r21, Y+13	; 0x0d
    39ee:	2e 81       	ldd	r18, Y+6	; 0x06
    39f0:	3f 81       	ldd	r19, Y+7	; 0x07
    39f2:	8c 81       	ldd	r24, Y+4	; 0x04
    39f4:	9d 81       	ldd	r25, Y+5	; 0x05
    39f6:	b9 01       	movw	r22, r18
    39f8:	0e 94 06 13 	call	0x260c	; 0x260c <pxPortInitialiseStack>
    39fc:	9c 01       	movw	r18, r24
    39fe:	8a 81       	ldd	r24, Y+2	; 0x02
    3a00:	9b 81       	ldd	r25, Y+3	; 0x03
    3a02:	fc 01       	movw	r30, r24
    3a04:	31 83       	std	Z+1, r19	; 0x01
    3a06:	20 83       	st	Z, r18
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    3a08:	8f 85       	ldd	r24, Y+15	; 0x0f
    3a0a:	98 89       	ldd	r25, Y+16	; 0x10
    3a0c:	89 2b       	or	r24, r25
    3a0e:	39 f0       	breq	.+14     	; 0x3a1e <xTaskGenericCreate+0xc2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3a10:	8f 85       	ldd	r24, Y+15	; 0x0f
    3a12:	98 89       	ldd	r25, Y+16	; 0x10
    3a14:	2a 81       	ldd	r18, Y+2	; 0x02
    3a16:	3b 81       	ldd	r19, Y+3	; 0x03
    3a18:	fc 01       	movw	r30, r24
    3a1a:	31 83       	std	Z+1, r19	; 0x01
    3a1c:	20 83       	st	Z, r18
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    3a1e:	0f b6       	in	r0, 0x3f	; 63
    3a20:	f8 94       	cli
    3a22:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    3a24:	80 91 4d 05 	lds	r24, 0x054D
    3a28:	8f 5f       	subi	r24, 0xFF	; 255
    3a2a:	80 93 4d 05 	sts	0x054D, r24
			if( pxCurrentTCB == NULL )
    3a2e:	80 91 fe 04 	lds	r24, 0x04FE
    3a32:	90 91 ff 04 	lds	r25, 0x04FF
    3a36:	89 2b       	or	r24, r25
    3a38:	69 f4       	brne	.+26     	; 0x3a54 <xTaskGenericCreate+0xf8>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    3a3a:	8a 81       	ldd	r24, Y+2	; 0x02
    3a3c:	9b 81       	ldd	r25, Y+3	; 0x03
    3a3e:	90 93 ff 04 	sts	0x04FF, r25
    3a42:	80 93 fe 04 	sts	0x04FE, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3a46:	80 91 4d 05 	lds	r24, 0x054D
    3a4a:	81 30       	cpi	r24, 0x01	; 1
    3a4c:	b1 f4       	brne	.+44     	; 0x3a7a <xTaskGenericCreate+0x11e>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    3a4e:	0e 94 83 23 	call	0x4706	; 0x4706 <prvInitialiseTaskLists>
    3a52:	13 c0       	rjmp	.+38     	; 0x3a7a <xTaskGenericCreate+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    3a54:	80 91 51 05 	lds	r24, 0x0551
    3a58:	88 23       	and	r24, r24
    3a5a:	79 f4       	brne	.+30     	; 0x3a7a <xTaskGenericCreate+0x11e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    3a5c:	80 91 fe 04 	lds	r24, 0x04FE
    3a60:	90 91 ff 04 	lds	r25, 0x04FF
    3a64:	fc 01       	movw	r30, r24
    3a66:	96 89       	ldd	r25, Z+22	; 0x16
    3a68:	8e 85       	ldd	r24, Y+14	; 0x0e
    3a6a:	89 17       	cp	r24, r25
    3a6c:	30 f0       	brcs	.+12     	; 0x3a7a <xTaskGenericCreate+0x11e>
					{
						pxCurrentTCB = pxNewTCB;
    3a6e:	8a 81       	ldd	r24, Y+2	; 0x02
    3a70:	9b 81       	ldd	r25, Y+3	; 0x03
    3a72:	90 93 ff 04 	sts	0x04FF, r25
    3a76:	80 93 fe 04 	sts	0x04FE, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    3a7a:	80 91 55 05 	lds	r24, 0x0555
    3a7e:	8f 5f       	subi	r24, 0xFF	; 255
    3a80:	80 93 55 05 	sts	0x0555, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    3a84:	8a 81       	ldd	r24, Y+2	; 0x02
    3a86:	9b 81       	ldd	r25, Y+3	; 0x03
    3a88:	fc 01       	movw	r30, r24
    3a8a:	96 89       	ldd	r25, Z+22	; 0x16
    3a8c:	80 91 50 05 	lds	r24, 0x0550
    3a90:	89 17       	cp	r24, r25
    3a92:	30 f4       	brcc	.+12     	; 0x3aa0 <xTaskGenericCreate+0x144>
    3a94:	8a 81       	ldd	r24, Y+2	; 0x02
    3a96:	9b 81       	ldd	r25, Y+3	; 0x03
    3a98:	fc 01       	movw	r30, r24
    3a9a:	86 89       	ldd	r24, Z+22	; 0x16
    3a9c:	80 93 50 05 	sts	0x0550, r24
    3aa0:	8a 81       	ldd	r24, Y+2	; 0x02
    3aa2:	9b 81       	ldd	r25, Y+3	; 0x03
    3aa4:	ac 01       	movw	r20, r24
    3aa6:	4e 5f       	subi	r20, 0xFE	; 254
    3aa8:	5f 4f       	sbci	r21, 0xFF	; 255
    3aaa:	8a 81       	ldd	r24, Y+2	; 0x02
    3aac:	9b 81       	ldd	r25, Y+3	; 0x03
    3aae:	fc 01       	movw	r30, r24
    3ab0:	86 89       	ldd	r24, Z+22	; 0x16
    3ab2:	28 2f       	mov	r18, r24
    3ab4:	30 e0       	ldi	r19, 0x00	; 0
    3ab6:	c9 01       	movw	r24, r18
    3ab8:	88 0f       	add	r24, r24
    3aba:	99 1f       	adc	r25, r25
    3abc:	88 0f       	add	r24, r24
    3abe:	99 1f       	adc	r25, r25
    3ac0:	88 0f       	add	r24, r24
    3ac2:	99 1f       	adc	r25, r25
    3ac4:	82 0f       	add	r24, r18
    3ac6:	93 1f       	adc	r25, r19
    3ac8:	80 50       	subi	r24, 0x00	; 0
    3aca:	9b 4f       	sbci	r25, 0xFB	; 251
    3acc:	ba 01       	movw	r22, r20
    3ace:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vListInsertEnd>

			xReturn = pdPASS;
    3ad2:	81 e0       	ldi	r24, 0x01	; 1
    3ad4:	89 83       	std	Y+1, r24	; 0x01
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    3ad6:	0f 90       	pop	r0
    3ad8:	0f be       	out	0x3f, r0	; 63
    3ada:	02 c0       	rjmp	.+4      	; 0x3ae0 <xTaskGenericCreate+0x184>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3adc:	8f ef       	ldi	r24, 0xFF	; 255
    3ade:	89 83       	std	Y+1, r24	; 0x01
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    3ae0:	89 81       	ldd	r24, Y+1	; 0x01
    3ae2:	81 30       	cpi	r24, 0x01	; 1
    3ae4:	79 f4       	brne	.+30     	; 0x3b04 <xTaskGenericCreate+0x1a8>
	{
		if( xSchedulerRunning != pdFALSE )
    3ae6:	80 91 51 05 	lds	r24, 0x0551
    3aea:	88 23       	and	r24, r24
    3aec:	59 f0       	breq	.+22     	; 0x3b04 <xTaskGenericCreate+0x1a8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    3aee:	80 91 fe 04 	lds	r24, 0x04FE
    3af2:	90 91 ff 04 	lds	r25, 0x04FF
    3af6:	fc 01       	movw	r30, r24
    3af8:	96 89       	ldd	r25, Z+22	; 0x16
    3afa:	8e 85       	ldd	r24, Y+14	; 0x0e
    3afc:	98 17       	cp	r25, r24
    3afe:	10 f4       	brcc	.+4      	; 0x3b04 <xTaskGenericCreate+0x1a8>
			{
				taskYIELD_IF_USING_PREEMPTION();
    3b00:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    3b04:	89 81       	ldd	r24, Y+1	; 0x01
}
    3b06:	64 96       	adiw	r28, 0x14	; 20
    3b08:	0f b6       	in	r0, 0x3f	; 63
    3b0a:	f8 94       	cli
    3b0c:	de bf       	out	0x3e, r29	; 62
    3b0e:	0f be       	out	0x3f, r0	; 63
    3b10:	cd bf       	out	0x3d, r28	; 61
    3b12:	df 91       	pop	r29
    3b14:	cf 91       	pop	r28
    3b16:	1f 91       	pop	r17
    3b18:	0f 91       	pop	r16
    3b1a:	ff 90       	pop	r15
    3b1c:	ef 90       	pop	r14
    3b1e:	df 90       	pop	r13
    3b20:	cf 90       	pop	r12
    3b22:	bf 90       	pop	r11
    3b24:	af 90       	pop	r10
    3b26:	08 95       	ret

00003b28 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    3b28:	cf 93       	push	r28
    3b2a:	df 93       	push	r29
    3b2c:	00 d0       	rcall	.+0      	; 0x3b2e <vTaskDelete+0x6>
    3b2e:	00 d0       	rcall	.+0      	; 0x3b30 <vTaskDelete+0x8>
    3b30:	cd b7       	in	r28, 0x3d	; 61
    3b32:	de b7       	in	r29, 0x3e	; 62
    3b34:	9c 83       	std	Y+4, r25	; 0x04
    3b36:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3b38:	0f b6       	in	r0, 0x3f	; 63
    3b3a:	f8 94       	cli
    3b3c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3b3e:	8b 81       	ldd	r24, Y+3	; 0x03
    3b40:	9c 81       	ldd	r25, Y+4	; 0x04
    3b42:	89 2b       	or	r24, r25
    3b44:	29 f4       	brne	.+10     	; 0x3b50 <vTaskDelete+0x28>
    3b46:	80 91 fe 04 	lds	r24, 0x04FE
    3b4a:	90 91 ff 04 	lds	r25, 0x04FF
    3b4e:	02 c0       	rjmp	.+4      	; 0x3b54 <vTaskDelete+0x2c>
    3b50:	8b 81       	ldd	r24, Y+3	; 0x03
    3b52:	9c 81       	ldd	r25, Y+4	; 0x04
    3b54:	9a 83       	std	Y+2, r25	; 0x02
    3b56:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3b58:	89 81       	ldd	r24, Y+1	; 0x01
    3b5a:	9a 81       	ldd	r25, Y+2	; 0x02
    3b5c:	02 96       	adiw	r24, 0x02	; 2
    3b5e:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3b62:	89 81       	ldd	r24, Y+1	; 0x01
    3b64:	9a 81       	ldd	r25, Y+2	; 0x02
    3b66:	fc 01       	movw	r30, r24
    3b68:	84 89       	ldd	r24, Z+20	; 0x14
    3b6a:	95 89       	ldd	r25, Z+21	; 0x15
    3b6c:	89 2b       	or	r24, r25
    3b6e:	29 f0       	breq	.+10     	; 0x3b7a <vTaskDelete+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3b70:	89 81       	ldd	r24, Y+1	; 0x01
    3b72:	9a 81       	ldd	r25, Y+2	; 0x02
    3b74:	0c 96       	adiw	r24, 0x0c	; 12
    3b76:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    3b7a:	89 81       	ldd	r24, Y+1	; 0x01
    3b7c:	9a 81       	ldd	r25, Y+2	; 0x02
    3b7e:	02 96       	adiw	r24, 0x02	; 2
    3b80:	bc 01       	movw	r22, r24
    3b82:	83 e4       	ldi	r24, 0x43	; 67
    3b84:	95 e0       	ldi	r25, 0x05	; 5
    3b86:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    3b8a:	80 91 4c 05 	lds	r24, 0x054C
    3b8e:	8f 5f       	subi	r24, 0xFF	; 255
    3b90:	80 93 4c 05 	sts	0x054C, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    3b94:	80 91 55 05 	lds	r24, 0x0555
    3b98:	8f 5f       	subi	r24, 0xFF	; 255
    3b9a:	80 93 55 05 	sts	0x0555, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    3b9e:	0f 90       	pop	r0
    3ba0:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    3ba2:	80 91 51 05 	lds	r24, 0x0551
    3ba6:	88 23       	and	r24, r24
    3ba8:	99 f0       	breq	.+38     	; 0x3bd0 <vTaskDelete+0xa8>
		{
			if( pxTCB == pxCurrentTCB )
    3baa:	80 91 fe 04 	lds	r24, 0x04FE
    3bae:	90 91 ff 04 	lds	r25, 0x04FF
    3bb2:	29 81       	ldd	r18, Y+1	; 0x01
    3bb4:	3a 81       	ldd	r19, Y+2	; 0x02
    3bb6:	28 17       	cp	r18, r24
    3bb8:	39 07       	cpc	r19, r25
    3bba:	19 f4       	brne	.+6      	; 0x3bc2 <vTaskDelete+0x9a>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    3bbc:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <vPortYield>
    3bc0:	07 c0       	rjmp	.+14     	; 0x3bd0 <vTaskDelete+0xa8>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    3bc2:	0f b6       	in	r0, 0x3f	; 63
    3bc4:	f8 94       	cli
    3bc6:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    3bc8:	0e 94 a4 24 	call	0x4948	; 0x4948 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    3bcc:	0f 90       	pop	r0
    3bce:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    3bd0:	0f 90       	pop	r0
    3bd2:	0f 90       	pop	r0
    3bd4:	0f 90       	pop	r0
    3bd6:	0f 90       	pop	r0
    3bd8:	df 91       	pop	r29
    3bda:	cf 91       	pop	r28
    3bdc:	08 95       	ret

00003bde <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    3bde:	cf 93       	push	r28
    3be0:	df 93       	push	r29
    3be2:	cd b7       	in	r28, 0x3d	; 61
    3be4:	de b7       	in	r29, 0x3e	; 62
    3be6:	2a 97       	sbiw	r28, 0x0a	; 10
    3be8:	0f b6       	in	r0, 0x3f	; 63
    3bea:	f8 94       	cli
    3bec:	de bf       	out	0x3e, r29	; 62
    3bee:	0f be       	out	0x3f, r0	; 63
    3bf0:	cd bf       	out	0x3d, r28	; 61
    3bf2:	98 87       	std	Y+8, r25	; 0x08
    3bf4:	8f 83       	std	Y+7, r24	; 0x07
    3bf6:	7a 87       	std	Y+10, r23	; 0x0a
    3bf8:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    3bfa:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    3bfc:	0e 94 e5 1e 	call	0x3dca	; 0x3dca <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    3c00:	80 91 4e 05 	lds	r24, 0x054E
    3c04:	90 91 4f 05 	lds	r25, 0x054F
    3c08:	9b 83       	std	Y+3, r25	; 0x03
    3c0a:	8a 83       	std	Y+2, r24	; 0x02

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3c0c:	8f 81       	ldd	r24, Y+7	; 0x07
    3c0e:	98 85       	ldd	r25, Y+8	; 0x08
    3c10:	fc 01       	movw	r30, r24
    3c12:	20 81       	ld	r18, Z
    3c14:	31 81       	ldd	r19, Z+1	; 0x01
    3c16:	89 85       	ldd	r24, Y+9	; 0x09
    3c18:	9a 85       	ldd	r25, Y+10	; 0x0a
    3c1a:	82 0f       	add	r24, r18
    3c1c:	93 1f       	adc	r25, r19
    3c1e:	9d 83       	std	Y+5, r25	; 0x05
    3c20:	8c 83       	std	Y+4, r24	; 0x04

			if( xConstTickCount < *pxPreviousWakeTime )
    3c22:	8f 81       	ldd	r24, Y+7	; 0x07
    3c24:	98 85       	ldd	r25, Y+8	; 0x08
    3c26:	fc 01       	movw	r30, r24
    3c28:	20 81       	ld	r18, Z
    3c2a:	31 81       	ldd	r19, Z+1	; 0x01
    3c2c:	8a 81       	ldd	r24, Y+2	; 0x02
    3c2e:	9b 81       	ldd	r25, Y+3	; 0x03
    3c30:	82 17       	cp	r24, r18
    3c32:	93 07       	cpc	r25, r19
    3c34:	a0 f4       	brcc	.+40     	; 0x3c5e <vTaskDelayUntil+0x80>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    3c36:	8f 81       	ldd	r24, Y+7	; 0x07
    3c38:	98 85       	ldd	r25, Y+8	; 0x08
    3c3a:	fc 01       	movw	r30, r24
    3c3c:	20 81       	ld	r18, Z
    3c3e:	31 81       	ldd	r19, Z+1	; 0x01
    3c40:	8c 81       	ldd	r24, Y+4	; 0x04
    3c42:	9d 81       	ldd	r25, Y+5	; 0x05
    3c44:	82 17       	cp	r24, r18
    3c46:	93 07       	cpc	r25, r19
    3c48:	e8 f4       	brcc	.+58     	; 0x3c84 <vTaskDelayUntil+0xa6>
    3c4a:	2c 81       	ldd	r18, Y+4	; 0x04
    3c4c:	3d 81       	ldd	r19, Y+5	; 0x05
    3c4e:	8a 81       	ldd	r24, Y+2	; 0x02
    3c50:	9b 81       	ldd	r25, Y+3	; 0x03
    3c52:	82 17       	cp	r24, r18
    3c54:	93 07       	cpc	r25, r19
    3c56:	b0 f4       	brcc	.+44     	; 0x3c84 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    3c58:	81 e0       	ldi	r24, 0x01	; 1
    3c5a:	89 83       	std	Y+1, r24	; 0x01
    3c5c:	13 c0       	rjmp	.+38     	; 0x3c84 <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    3c5e:	8f 81       	ldd	r24, Y+7	; 0x07
    3c60:	98 85       	ldd	r25, Y+8	; 0x08
    3c62:	fc 01       	movw	r30, r24
    3c64:	20 81       	ld	r18, Z
    3c66:	31 81       	ldd	r19, Z+1	; 0x01
    3c68:	8c 81       	ldd	r24, Y+4	; 0x04
    3c6a:	9d 81       	ldd	r25, Y+5	; 0x05
    3c6c:	82 17       	cp	r24, r18
    3c6e:	93 07       	cpc	r25, r19
    3c70:	38 f0       	brcs	.+14     	; 0x3c80 <vTaskDelayUntil+0xa2>
    3c72:	2c 81       	ldd	r18, Y+4	; 0x04
    3c74:	3d 81       	ldd	r19, Y+5	; 0x05
    3c76:	8a 81       	ldd	r24, Y+2	; 0x02
    3c78:	9b 81       	ldd	r25, Y+3	; 0x03
    3c7a:	82 17       	cp	r24, r18
    3c7c:	93 07       	cpc	r25, r19
    3c7e:	10 f4       	brcc	.+4      	; 0x3c84 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    3c80:	81 e0       	ldi	r24, 0x01	; 1
    3c82:	89 83       	std	Y+1, r24	; 0x01
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    3c84:	8f 81       	ldd	r24, Y+7	; 0x07
    3c86:	98 85       	ldd	r25, Y+8	; 0x08
    3c88:	2c 81       	ldd	r18, Y+4	; 0x04
    3c8a:	3d 81       	ldd	r19, Y+5	; 0x05
    3c8c:	fc 01       	movw	r30, r24
    3c8e:	31 83       	std	Z+1, r19	; 0x01
    3c90:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
    3c92:	89 81       	ldd	r24, Y+1	; 0x01
    3c94:	88 23       	and	r24, r24
    3c96:	59 f0       	breq	.+22     	; 0x3cae <vTaskDelayUntil+0xd0>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3c98:	80 91 fe 04 	lds	r24, 0x04FE
    3c9c:	90 91 ff 04 	lds	r25, 0x04FF
    3ca0:	02 96       	adiw	r24, 0x02	; 2
    3ca2:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3ca6:	8c 81       	ldd	r24, Y+4	; 0x04
    3ca8:	9d 81       	ldd	r25, Y+5	; 0x05
    3caa:	0e 94 00 24 	call	0x4800	; 0x4800 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    3cae:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <xTaskResumeAll>
    3cb2:	8e 83       	std	Y+6, r24	; 0x06

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3cb4:	8e 81       	ldd	r24, Y+6	; 0x06
    3cb6:	88 23       	and	r24, r24
    3cb8:	11 f4       	brne	.+4      	; 0x3cbe <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
    3cba:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3cbe:	2a 96       	adiw	r28, 0x0a	; 10
    3cc0:	0f b6       	in	r0, 0x3f	; 63
    3cc2:	f8 94       	cli
    3cc4:	de bf       	out	0x3e, r29	; 62
    3cc6:	0f be       	out	0x3f, r0	; 63
    3cc8:	cd bf       	out	0x3d, r28	; 61
    3cca:	df 91       	pop	r29
    3ccc:	cf 91       	pop	r28
    3cce:	08 95       	ret

00003cd0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    3cd0:	cf 93       	push	r28
    3cd2:	df 93       	push	r29
    3cd4:	00 d0       	rcall	.+0      	; 0x3cd6 <vTaskDelay+0x6>
    3cd6:	00 d0       	rcall	.+0      	; 0x3cd8 <vTaskDelay+0x8>
    3cd8:	1f 92       	push	r1
    3cda:	cd b7       	in	r28, 0x3d	; 61
    3cdc:	de b7       	in	r29, 0x3e	; 62
    3cde:	9d 83       	std	Y+5, r25	; 0x05
    3ce0:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    3ce2:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3ce4:	8c 81       	ldd	r24, Y+4	; 0x04
    3ce6:	9d 81       	ldd	r25, Y+5	; 0x05
    3ce8:	89 2b       	or	r24, r25
    3cea:	d1 f0       	breq	.+52     	; 0x3d20 <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    3cec:	0e 94 e5 1e 	call	0x3dca	; 0x3dca <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    3cf0:	20 91 4e 05 	lds	r18, 0x054E
    3cf4:	30 91 4f 05 	lds	r19, 0x054F
    3cf8:	8c 81       	ldd	r24, Y+4	; 0x04
    3cfa:	9d 81       	ldd	r25, Y+5	; 0x05
    3cfc:	82 0f       	add	r24, r18
    3cfe:	93 1f       	adc	r25, r19
    3d00:	9b 83       	std	Y+3, r25	; 0x03
    3d02:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3d04:	80 91 fe 04 	lds	r24, 0x04FE
    3d08:	90 91 ff 04 	lds	r25, 0x04FF
    3d0c:	02 96       	adiw	r24, 0x02	; 2
    3d0e:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3d12:	8a 81       	ldd	r24, Y+2	; 0x02
    3d14:	9b 81       	ldd	r25, Y+3	; 0x03
    3d16:	0e 94 00 24 	call	0x4800	; 0x4800 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3d1a:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <xTaskResumeAll>
    3d1e:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3d20:	89 81       	ldd	r24, Y+1	; 0x01
    3d22:	88 23       	and	r24, r24
    3d24:	11 f4       	brne	.+4      	; 0x3d2a <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    3d26:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3d2a:	0f 90       	pop	r0
    3d2c:	0f 90       	pop	r0
    3d2e:	0f 90       	pop	r0
    3d30:	0f 90       	pop	r0
    3d32:	0f 90       	pop	r0
    3d34:	df 91       	pop	r29
    3d36:	cf 91       	pop	r28
    3d38:	08 95       	ret

00003d3a <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3d3a:	af 92       	push	r10
    3d3c:	bf 92       	push	r11
    3d3e:	cf 92       	push	r12
    3d40:	df 92       	push	r13
    3d42:	ef 92       	push	r14
    3d44:	ff 92       	push	r15
    3d46:	0f 93       	push	r16
    3d48:	cf 93       	push	r28
    3d4a:	df 93       	push	r29
    3d4c:	1f 92       	push	r1
    3d4e:	cd b7       	in	r28, 0x3d	; 61
    3d50:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    3d52:	a1 2c       	mov	r10, r1
    3d54:	b1 2c       	mov	r11, r1
    3d56:	c1 2c       	mov	r12, r1
    3d58:	d1 2c       	mov	r13, r1
    3d5a:	e1 2c       	mov	r14, r1
    3d5c:	f1 2c       	mov	r15, r1
    3d5e:	00 e0       	ldi	r16, 0x00	; 0
    3d60:	20 e0       	ldi	r18, 0x00	; 0
    3d62:	30 e0       	ldi	r19, 0x00	; 0
    3d64:	44 e6       	ldi	r20, 0x64	; 100
    3d66:	50 e0       	ldi	r21, 0x00	; 0
    3d68:	6d e0       	ldi	r22, 0x0D	; 13
    3d6a:	71 e0       	ldi	r23, 0x01	; 1
    3d6c:	8f ee       	ldi	r24, 0xEF	; 239
    3d6e:	92 e2       	ldi	r25, 0x22	; 34
    3d70:	0e 94 ae 1c 	call	0x395c	; 0x395c <xTaskGenericCreate>
    3d74:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    3d76:	89 81       	ldd	r24, Y+1	; 0x01
    3d78:	81 30       	cpi	r24, 0x01	; 1
    3d7a:	81 f4       	brne	.+32     	; 0x3d9c <vTaskStartScheduler+0x62>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    3d7c:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    3d7e:	8f ef       	ldi	r24, 0xFF	; 255
    3d80:	9f ef       	ldi	r25, 0xFF	; 255
    3d82:	90 93 57 05 	sts	0x0557, r25
    3d86:	80 93 56 05 	sts	0x0556, r24
		xSchedulerRunning = pdTRUE;
    3d8a:	81 e0       	ldi	r24, 0x01	; 1
    3d8c:	80 93 51 05 	sts	0x0551, r24
		xTickCount = ( TickType_t ) 0U;
    3d90:	10 92 4f 05 	sts	0x054F, r1
    3d94:	10 92 4e 05 	sts	0x054E, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    3d98:	0e 94 af 14 	call	0x295e	; 0x295e <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    3d9c:	0f 90       	pop	r0
    3d9e:	df 91       	pop	r29
    3da0:	cf 91       	pop	r28
    3da2:	0f 91       	pop	r16
    3da4:	ff 90       	pop	r15
    3da6:	ef 90       	pop	r14
    3da8:	df 90       	pop	r13
    3daa:	cf 90       	pop	r12
    3dac:	bf 90       	pop	r11
    3dae:	af 90       	pop	r10
    3db0:	08 95       	ret

00003db2 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3db2:	cf 93       	push	r28
    3db4:	df 93       	push	r29
    3db6:	cd b7       	in	r28, 0x3d	; 61
    3db8:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    3dba:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    3dbc:	10 92 51 05 	sts	0x0551, r1
	vPortEndScheduler();
    3dc0:	0e 94 e4 14 	call	0x29c8	; 0x29c8 <vPortEndScheduler>
}
    3dc4:	df 91       	pop	r29
    3dc6:	cf 91       	pop	r28
    3dc8:	08 95       	ret

00003dca <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3dca:	cf 93       	push	r28
    3dcc:	df 93       	push	r29
    3dce:	cd b7       	in	r28, 0x3d	; 61
    3dd0:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    3dd2:	80 91 58 05 	lds	r24, 0x0558
    3dd6:	8f 5f       	subi	r24, 0xFF	; 255
    3dd8:	80 93 58 05 	sts	0x0558, r24
}
    3ddc:	df 91       	pop	r29
    3dde:	cf 91       	pop	r28
    3de0:	08 95       	ret

00003de2 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3de2:	cf 93       	push	r28
    3de4:	df 93       	push	r29
    3de6:	00 d0       	rcall	.+0      	; 0x3de8 <xTaskResumeAll+0x6>
    3de8:	1f 92       	push	r1
    3dea:	cd b7       	in	r28, 0x3d	; 61
    3dec:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    3dee:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    3df0:	0f b6       	in	r0, 0x3f	; 63
    3df2:	f8 94       	cli
    3df4:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    3df6:	80 91 58 05 	lds	r24, 0x0558
    3dfa:	81 50       	subi	r24, 0x01	; 1
    3dfc:	80 93 58 05 	sts	0x0558, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3e00:	80 91 58 05 	lds	r24, 0x0558
    3e04:	88 23       	and	r24, r24
    3e06:	09 f0       	breq	.+2      	; 0x3e0a <xTaskResumeAll+0x28>
    3e08:	71 c0       	rjmp	.+226    	; 0x3eec <xTaskResumeAll+0x10a>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3e0a:	80 91 4d 05 	lds	r24, 0x054D
    3e0e:	88 23       	and	r24, r24
    3e10:	09 f4       	brne	.+2      	; 0x3e14 <xTaskResumeAll+0x32>
    3e12:	6c c0       	rjmp	.+216    	; 0x3eec <xTaskResumeAll+0x10a>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3e14:	49 c0       	rjmp	.+146    	; 0x3ea8 <xTaskResumeAll+0xc6>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    3e16:	80 91 3f 05 	lds	r24, 0x053F
    3e1a:	90 91 40 05 	lds	r25, 0x0540
    3e1e:	fc 01       	movw	r30, r24
    3e20:	86 81       	ldd	r24, Z+6	; 0x06
    3e22:	97 81       	ldd	r25, Z+7	; 0x07
    3e24:	9b 83       	std	Y+3, r25	; 0x03
    3e26:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3e28:	8a 81       	ldd	r24, Y+2	; 0x02
    3e2a:	9b 81       	ldd	r25, Y+3	; 0x03
    3e2c:	0c 96       	adiw	r24, 0x0c	; 12
    3e2e:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3e32:	8a 81       	ldd	r24, Y+2	; 0x02
    3e34:	9b 81       	ldd	r25, Y+3	; 0x03
    3e36:	02 96       	adiw	r24, 0x02	; 2
    3e38:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3e3c:	8a 81       	ldd	r24, Y+2	; 0x02
    3e3e:	9b 81       	ldd	r25, Y+3	; 0x03
    3e40:	fc 01       	movw	r30, r24
    3e42:	96 89       	ldd	r25, Z+22	; 0x16
    3e44:	80 91 50 05 	lds	r24, 0x0550
    3e48:	89 17       	cp	r24, r25
    3e4a:	30 f4       	brcc	.+12     	; 0x3e58 <xTaskResumeAll+0x76>
    3e4c:	8a 81       	ldd	r24, Y+2	; 0x02
    3e4e:	9b 81       	ldd	r25, Y+3	; 0x03
    3e50:	fc 01       	movw	r30, r24
    3e52:	86 89       	ldd	r24, Z+22	; 0x16
    3e54:	80 93 50 05 	sts	0x0550, r24
    3e58:	8a 81       	ldd	r24, Y+2	; 0x02
    3e5a:	9b 81       	ldd	r25, Y+3	; 0x03
    3e5c:	ac 01       	movw	r20, r24
    3e5e:	4e 5f       	subi	r20, 0xFE	; 254
    3e60:	5f 4f       	sbci	r21, 0xFF	; 255
    3e62:	8a 81       	ldd	r24, Y+2	; 0x02
    3e64:	9b 81       	ldd	r25, Y+3	; 0x03
    3e66:	fc 01       	movw	r30, r24
    3e68:	86 89       	ldd	r24, Z+22	; 0x16
    3e6a:	28 2f       	mov	r18, r24
    3e6c:	30 e0       	ldi	r19, 0x00	; 0
    3e6e:	c9 01       	movw	r24, r18
    3e70:	88 0f       	add	r24, r24
    3e72:	99 1f       	adc	r25, r25
    3e74:	88 0f       	add	r24, r24
    3e76:	99 1f       	adc	r25, r25
    3e78:	88 0f       	add	r24, r24
    3e7a:	99 1f       	adc	r25, r25
    3e7c:	82 0f       	add	r24, r18
    3e7e:	93 1f       	adc	r25, r19
    3e80:	80 50       	subi	r24, 0x00	; 0
    3e82:	9b 4f       	sbci	r25, 0xFB	; 251
    3e84:	ba 01       	movw	r22, r20
    3e86:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3e8a:	8a 81       	ldd	r24, Y+2	; 0x02
    3e8c:	9b 81       	ldd	r25, Y+3	; 0x03
    3e8e:	fc 01       	movw	r30, r24
    3e90:	26 89       	ldd	r18, Z+22	; 0x16
    3e92:	80 91 fe 04 	lds	r24, 0x04FE
    3e96:	90 91 ff 04 	lds	r25, 0x04FF
    3e9a:	fc 01       	movw	r30, r24
    3e9c:	86 89       	ldd	r24, Z+22	; 0x16
    3e9e:	28 17       	cp	r18, r24
    3ea0:	18 f0       	brcs	.+6      	; 0x3ea8 <xTaskResumeAll+0xc6>
					{
						xYieldPending = pdTRUE;
    3ea2:	81 e0       	ldi	r24, 0x01	; 1
    3ea4:	80 93 53 05 	sts	0x0553, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3ea8:	80 91 3a 05 	lds	r24, 0x053A
    3eac:	88 23       	and	r24, r24
    3eae:	09 f0       	breq	.+2      	; 0x3eb2 <xTaskResumeAll+0xd0>
    3eb0:	b2 cf       	rjmp	.-156    	; 0x3e16 <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    3eb2:	80 91 52 05 	lds	r24, 0x0552
    3eb6:	88 23       	and	r24, r24
    3eb8:	89 f0       	breq	.+34     	; 0x3edc <xTaskResumeAll+0xfa>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    3eba:	0c c0       	rjmp	.+24     	; 0x3ed4 <xTaskResumeAll+0xf2>
					{
						if( xTaskIncrementTick() != pdFALSE )
    3ebc:	0e 94 b4 1f 	call	0x3f68	; 0x3f68 <xTaskIncrementTick>
    3ec0:	88 23       	and	r24, r24
    3ec2:	19 f0       	breq	.+6      	; 0x3eca <xTaskResumeAll+0xe8>
						{
							xYieldPending = pdTRUE;
    3ec4:	81 e0       	ldi	r24, 0x01	; 1
    3ec6:	80 93 53 05 	sts	0x0553, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    3eca:	80 91 52 05 	lds	r24, 0x0552
    3ece:	81 50       	subi	r24, 0x01	; 1
    3ed0:	80 93 52 05 	sts	0x0552, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    3ed4:	80 91 52 05 	lds	r24, 0x0552
    3ed8:	88 23       	and	r24, r24
    3eda:	81 f7       	brne	.-32     	; 0x3ebc <xTaskResumeAll+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    3edc:	80 91 53 05 	lds	r24, 0x0553
    3ee0:	81 30       	cpi	r24, 0x01	; 1
    3ee2:	21 f4       	brne	.+8      	; 0x3eec <xTaskResumeAll+0x10a>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    3ee4:	81 e0       	ldi	r24, 0x01	; 1
    3ee6:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    3ee8:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    3eec:	0f 90       	pop	r0
    3eee:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3ef0:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ef2:	0f 90       	pop	r0
    3ef4:	0f 90       	pop	r0
    3ef6:	0f 90       	pop	r0
    3ef8:	df 91       	pop	r29
    3efa:	cf 91       	pop	r28
    3efc:	08 95       	ret

00003efe <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3efe:	cf 93       	push	r28
    3f00:	df 93       	push	r29
    3f02:	00 d0       	rcall	.+0      	; 0x3f04 <xTaskGetTickCount+0x6>
    3f04:	cd b7       	in	r28, 0x3d	; 61
    3f06:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    3f08:	0f b6       	in	r0, 0x3f	; 63
    3f0a:	f8 94       	cli
    3f0c:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3f0e:	80 91 4e 05 	lds	r24, 0x054E
    3f12:	90 91 4f 05 	lds	r25, 0x054F
    3f16:	9a 83       	std	Y+2, r25	; 0x02
    3f18:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    3f1a:	0f 90       	pop	r0
    3f1c:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3f1e:	89 81       	ldd	r24, Y+1	; 0x01
    3f20:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3f22:	0f 90       	pop	r0
    3f24:	0f 90       	pop	r0
    3f26:	df 91       	pop	r29
    3f28:	cf 91       	pop	r28
    3f2a:	08 95       	ret

00003f2c <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3f2c:	cf 93       	push	r28
    3f2e:	df 93       	push	r29
    3f30:	00 d0       	rcall	.+0      	; 0x3f32 <xTaskGetTickCountFromISR+0x6>
    3f32:	1f 92       	push	r1
    3f34:	cd b7       	in	r28, 0x3d	; 61
    3f36:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    3f38:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    3f3a:	80 91 4e 05 	lds	r24, 0x054E
    3f3e:	90 91 4f 05 	lds	r25, 0x054F
    3f42:	9b 83       	std	Y+3, r25	; 0x03
    3f44:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3f46:	8a 81       	ldd	r24, Y+2	; 0x02
    3f48:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3f4a:	0f 90       	pop	r0
    3f4c:	0f 90       	pop	r0
    3f4e:	0f 90       	pop	r0
    3f50:	df 91       	pop	r29
    3f52:	cf 91       	pop	r28
    3f54:	08 95       	ret

00003f56 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3f56:	cf 93       	push	r28
    3f58:	df 93       	push	r29
    3f5a:	cd b7       	in	r28, 0x3d	; 61
    3f5c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    3f5e:	80 91 4d 05 	lds	r24, 0x054D
}
    3f62:	df 91       	pop	r29
    3f64:	cf 91       	pop	r28
    3f66:	08 95       	ret

00003f68 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3f68:	cf 93       	push	r28
    3f6a:	df 93       	push	r29
    3f6c:	cd b7       	in	r28, 0x3d	; 61
    3f6e:	de b7       	in	r29, 0x3e	; 62
    3f70:	29 97       	sbiw	r28, 0x09	; 9
    3f72:	0f b6       	in	r0, 0x3f	; 63
    3f74:	f8 94       	cli
    3f76:	de bf       	out	0x3e, r29	; 62
    3f78:	0f be       	out	0x3f, r0	; 63
    3f7a:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    3f7c:	19 82       	std	Y+1, r1	; 0x01

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3f7e:	80 91 58 05 	lds	r24, 0x0558
    3f82:	88 23       	and	r24, r24
    3f84:	09 f0       	breq	.+2      	; 0x3f88 <xTaskIncrementTick+0x20>
    3f86:	c9 c0       	rjmp	.+402    	; 0x411a <xTaskIncrementTick+0x1b2>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    3f88:	80 91 4e 05 	lds	r24, 0x054E
    3f8c:	90 91 4f 05 	lds	r25, 0x054F
    3f90:	01 96       	adiw	r24, 0x01	; 1
    3f92:	90 93 4f 05 	sts	0x054F, r25
    3f96:	80 93 4e 05 	sts	0x054E, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    3f9a:	80 91 4e 05 	lds	r24, 0x054E
    3f9e:	90 91 4f 05 	lds	r25, 0x054F
    3fa2:	9b 83       	std	Y+3, r25	; 0x03
    3fa4:	8a 83       	std	Y+2, r24	; 0x02

			if( xConstTickCount == ( TickType_t ) 0U )
    3fa6:	8a 81       	ldd	r24, Y+2	; 0x02
    3fa8:	9b 81       	ldd	r25, Y+3	; 0x03
    3faa:	89 2b       	or	r24, r25
    3fac:	d9 f4       	brne	.+54     	; 0x3fe4 <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    3fae:	80 91 36 05 	lds	r24, 0x0536
    3fb2:	90 91 37 05 	lds	r25, 0x0537
    3fb6:	9d 83       	std	Y+5, r25	; 0x05
    3fb8:	8c 83       	std	Y+4, r24	; 0x04
    3fba:	80 91 38 05 	lds	r24, 0x0538
    3fbe:	90 91 39 05 	lds	r25, 0x0539
    3fc2:	90 93 37 05 	sts	0x0537, r25
    3fc6:	80 93 36 05 	sts	0x0536, r24
    3fca:	8c 81       	ldd	r24, Y+4	; 0x04
    3fcc:	9d 81       	ldd	r25, Y+5	; 0x05
    3fce:	90 93 39 05 	sts	0x0539, r25
    3fd2:	80 93 38 05 	sts	0x0538, r24
    3fd6:	80 91 54 05 	lds	r24, 0x0554
    3fda:	8f 5f       	subi	r24, 0xFF	; 255
    3fdc:	80 93 54 05 	sts	0x0554, r24
    3fe0:	0e 94 a4 24 	call	0x4948	; 0x4948 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    3fe4:	80 91 56 05 	lds	r24, 0x0556
    3fe8:	90 91 57 05 	lds	r25, 0x0557
    3fec:	2a 81       	ldd	r18, Y+2	; 0x02
    3fee:	3b 81       	ldd	r19, Y+3	; 0x03
    3ff0:	28 17       	cp	r18, r24
    3ff2:	39 07       	cpc	r19, r25
    3ff4:	08 f4       	brcc	.+2      	; 0x3ff8 <xTaskIncrementTick+0x90>
    3ff6:	77 c0       	rjmp	.+238    	; 0x40e6 <xTaskIncrementTick+0x17e>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3ff8:	80 91 36 05 	lds	r24, 0x0536
    3ffc:	90 91 37 05 	lds	r25, 0x0537
    4000:	fc 01       	movw	r30, r24
    4002:	80 81       	ld	r24, Z
    4004:	88 23       	and	r24, r24
    4006:	39 f4       	brne	.+14     	; 0x4016 <xTaskIncrementTick+0xae>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    4008:	8f ef       	ldi	r24, 0xFF	; 255
    400a:	9f ef       	ldi	r25, 0xFF	; 255
    400c:	90 93 57 05 	sts	0x0557, r25
    4010:	80 93 56 05 	sts	0x0556, r24
						break;
    4014:	68 c0       	rjmp	.+208    	; 0x40e6 <xTaskIncrementTick+0x17e>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    4016:	80 91 36 05 	lds	r24, 0x0536
    401a:	90 91 37 05 	lds	r25, 0x0537
    401e:	fc 01       	movw	r30, r24
    4020:	85 81       	ldd	r24, Z+5	; 0x05
    4022:	96 81       	ldd	r25, Z+6	; 0x06
    4024:	fc 01       	movw	r30, r24
    4026:	86 81       	ldd	r24, Z+6	; 0x06
    4028:	97 81       	ldd	r25, Z+7	; 0x07
    402a:	9f 83       	std	Y+7, r25	; 0x07
    402c:	8e 83       	std	Y+6, r24	; 0x06
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    402e:	8e 81       	ldd	r24, Y+6	; 0x06
    4030:	9f 81       	ldd	r25, Y+7	; 0x07
    4032:	fc 01       	movw	r30, r24
    4034:	82 81       	ldd	r24, Z+2	; 0x02
    4036:	93 81       	ldd	r25, Z+3	; 0x03
    4038:	99 87       	std	Y+9, r25	; 0x09
    403a:	88 87       	std	Y+8, r24	; 0x08

						if( xConstTickCount < xItemValue )
    403c:	2a 81       	ldd	r18, Y+2	; 0x02
    403e:	3b 81       	ldd	r19, Y+3	; 0x03
    4040:	88 85       	ldd	r24, Y+8	; 0x08
    4042:	99 85       	ldd	r25, Y+9	; 0x09
    4044:	28 17       	cp	r18, r24
    4046:	39 07       	cpc	r19, r25
    4048:	38 f4       	brcc	.+14     	; 0x4058 <xTaskIncrementTick+0xf0>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    404a:	88 85       	ldd	r24, Y+8	; 0x08
    404c:	99 85       	ldd	r25, Y+9	; 0x09
    404e:	90 93 57 05 	sts	0x0557, r25
    4052:	80 93 56 05 	sts	0x0556, r24
							break;
    4056:	47 c0       	rjmp	.+142    	; 0x40e6 <xTaskIncrementTick+0x17e>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    4058:	8e 81       	ldd	r24, Y+6	; 0x06
    405a:	9f 81       	ldd	r25, Y+7	; 0x07
    405c:	02 96       	adiw	r24, 0x02	; 2
    405e:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4062:	8e 81       	ldd	r24, Y+6	; 0x06
    4064:	9f 81       	ldd	r25, Y+7	; 0x07
    4066:	fc 01       	movw	r30, r24
    4068:	84 89       	ldd	r24, Z+20	; 0x14
    406a:	95 89       	ldd	r25, Z+21	; 0x15
    406c:	89 2b       	or	r24, r25
    406e:	29 f0       	breq	.+10     	; 0x407a <xTaskIncrementTick+0x112>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4070:	8e 81       	ldd	r24, Y+6	; 0x06
    4072:	9f 81       	ldd	r25, Y+7	; 0x07
    4074:	0c 96       	adiw	r24, 0x0c	; 12
    4076:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    407a:	8e 81       	ldd	r24, Y+6	; 0x06
    407c:	9f 81       	ldd	r25, Y+7	; 0x07
    407e:	fc 01       	movw	r30, r24
    4080:	96 89       	ldd	r25, Z+22	; 0x16
    4082:	80 91 50 05 	lds	r24, 0x0550
    4086:	89 17       	cp	r24, r25
    4088:	30 f4       	brcc	.+12     	; 0x4096 <xTaskIncrementTick+0x12e>
    408a:	8e 81       	ldd	r24, Y+6	; 0x06
    408c:	9f 81       	ldd	r25, Y+7	; 0x07
    408e:	fc 01       	movw	r30, r24
    4090:	86 89       	ldd	r24, Z+22	; 0x16
    4092:	80 93 50 05 	sts	0x0550, r24
    4096:	8e 81       	ldd	r24, Y+6	; 0x06
    4098:	9f 81       	ldd	r25, Y+7	; 0x07
    409a:	ac 01       	movw	r20, r24
    409c:	4e 5f       	subi	r20, 0xFE	; 254
    409e:	5f 4f       	sbci	r21, 0xFF	; 255
    40a0:	8e 81       	ldd	r24, Y+6	; 0x06
    40a2:	9f 81       	ldd	r25, Y+7	; 0x07
    40a4:	fc 01       	movw	r30, r24
    40a6:	86 89       	ldd	r24, Z+22	; 0x16
    40a8:	28 2f       	mov	r18, r24
    40aa:	30 e0       	ldi	r19, 0x00	; 0
    40ac:	c9 01       	movw	r24, r18
    40ae:	88 0f       	add	r24, r24
    40b0:	99 1f       	adc	r25, r25
    40b2:	88 0f       	add	r24, r24
    40b4:	99 1f       	adc	r25, r25
    40b6:	88 0f       	add	r24, r24
    40b8:	99 1f       	adc	r25, r25
    40ba:	82 0f       	add	r24, r18
    40bc:	93 1f       	adc	r25, r19
    40be:	80 50       	subi	r24, 0x00	; 0
    40c0:	9b 4f       	sbci	r25, 0xFB	; 251
    40c2:	ba 01       	movw	r22, r20
    40c4:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    40c8:	8e 81       	ldd	r24, Y+6	; 0x06
    40ca:	9f 81       	ldd	r25, Y+7	; 0x07
    40cc:	fc 01       	movw	r30, r24
    40ce:	26 89       	ldd	r18, Z+22	; 0x16
    40d0:	80 91 fe 04 	lds	r24, 0x04FE
    40d4:	90 91 ff 04 	lds	r25, 0x04FF
    40d8:	fc 01       	movw	r30, r24
    40da:	86 89       	ldd	r24, Z+22	; 0x16
    40dc:	28 17       	cp	r18, r24
    40de:	10 f0       	brcs	.+4      	; 0x40e4 <xTaskIncrementTick+0x17c>
							{
								xSwitchRequired = pdTRUE;
    40e0:	81 e0       	ldi	r24, 0x01	; 1
    40e2:	89 83       	std	Y+1, r24	; 0x01
								mtCOVERAGE_TEST_MARKER();
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
    40e4:	89 cf       	rjmp	.-238    	; 0x3ff8 <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    40e6:	80 91 fe 04 	lds	r24, 0x04FE
    40ea:	90 91 ff 04 	lds	r25, 0x04FF
    40ee:	fc 01       	movw	r30, r24
    40f0:	86 89       	ldd	r24, Z+22	; 0x16
    40f2:	28 2f       	mov	r18, r24
    40f4:	30 e0       	ldi	r19, 0x00	; 0
    40f6:	c9 01       	movw	r24, r18
    40f8:	88 0f       	add	r24, r24
    40fa:	99 1f       	adc	r25, r25
    40fc:	88 0f       	add	r24, r24
    40fe:	99 1f       	adc	r25, r25
    4100:	88 0f       	add	r24, r24
    4102:	99 1f       	adc	r25, r25
    4104:	82 0f       	add	r24, r18
    4106:	93 1f       	adc	r25, r19
    4108:	80 50       	subi	r24, 0x00	; 0
    410a:	9b 4f       	sbci	r25, 0xFB	; 251
    410c:	fc 01       	movw	r30, r24
    410e:	80 81       	ld	r24, Z
    4110:	82 30       	cpi	r24, 0x02	; 2
    4112:	40 f0       	brcs	.+16     	; 0x4124 <xTaskIncrementTick+0x1bc>
			{
				xSwitchRequired = pdTRUE;
    4114:	81 e0       	ldi	r24, 0x01	; 1
    4116:	89 83       	std	Y+1, r24	; 0x01
    4118:	05 c0       	rjmp	.+10     	; 0x4124 <xTaskIncrementTick+0x1bc>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    411a:	80 91 52 05 	lds	r24, 0x0552
    411e:	8f 5f       	subi	r24, 0xFF	; 255
    4120:	80 93 52 05 	sts	0x0552, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    4124:	80 91 53 05 	lds	r24, 0x0553
    4128:	88 23       	and	r24, r24
    412a:	11 f0       	breq	.+4      	; 0x4130 <xTaskIncrementTick+0x1c8>
		{
			xSwitchRequired = pdTRUE;
    412c:	81 e0       	ldi	r24, 0x01	; 1
    412e:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    4130:	89 81       	ldd	r24, Y+1	; 0x01
}
    4132:	29 96       	adiw	r28, 0x09	; 9
    4134:	0f b6       	in	r0, 0x3f	; 63
    4136:	f8 94       	cli
    4138:	de bf       	out	0x3e, r29	; 62
    413a:	0f be       	out	0x3f, r0	; 63
    413c:	cd bf       	out	0x3d, r28	; 61
    413e:	df 91       	pop	r29
    4140:	cf 91       	pop	r28
    4142:	08 95       	ret

00004144 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    4144:	cf 93       	push	r28
    4146:	df 93       	push	r29
    4148:	00 d0       	rcall	.+0      	; 0x414a <vTaskSwitchContext+0x6>
    414a:	cd b7       	in	r28, 0x3d	; 61
    414c:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    414e:	80 91 58 05 	lds	r24, 0x0558
    4152:	88 23       	and	r24, r24
    4154:	21 f0       	breq	.+8      	; 0x415e <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    4156:	81 e0       	ldi	r24, 0x01	; 1
    4158:	80 93 53 05 	sts	0x0553, r24
    415c:	5d c0       	rjmp	.+186    	; 0x4218 <vTaskSwitchContext+0xd4>
	}
	else
	{
		xYieldPending = pdFALSE;
    415e:	10 92 53 05 	sts	0x0553, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    4162:	05 c0       	rjmp	.+10     	; 0x416e <vTaskSwitchContext+0x2a>
    4164:	80 91 50 05 	lds	r24, 0x0550
    4168:	81 50       	subi	r24, 0x01	; 1
    416a:	80 93 50 05 	sts	0x0550, r24
    416e:	80 91 50 05 	lds	r24, 0x0550
    4172:	28 2f       	mov	r18, r24
    4174:	30 e0       	ldi	r19, 0x00	; 0
    4176:	c9 01       	movw	r24, r18
    4178:	88 0f       	add	r24, r24
    417a:	99 1f       	adc	r25, r25
    417c:	88 0f       	add	r24, r24
    417e:	99 1f       	adc	r25, r25
    4180:	88 0f       	add	r24, r24
    4182:	99 1f       	adc	r25, r25
    4184:	82 0f       	add	r24, r18
    4186:	93 1f       	adc	r25, r19
    4188:	80 50       	subi	r24, 0x00	; 0
    418a:	9b 4f       	sbci	r25, 0xFB	; 251
    418c:	fc 01       	movw	r30, r24
    418e:	80 81       	ld	r24, Z
    4190:	88 23       	and	r24, r24
    4192:	41 f3       	breq	.-48     	; 0x4164 <vTaskSwitchContext+0x20>
    4194:	80 91 50 05 	lds	r24, 0x0550
    4198:	28 2f       	mov	r18, r24
    419a:	30 e0       	ldi	r19, 0x00	; 0
    419c:	c9 01       	movw	r24, r18
    419e:	88 0f       	add	r24, r24
    41a0:	99 1f       	adc	r25, r25
    41a2:	88 0f       	add	r24, r24
    41a4:	99 1f       	adc	r25, r25
    41a6:	88 0f       	add	r24, r24
    41a8:	99 1f       	adc	r25, r25
    41aa:	82 0f       	add	r24, r18
    41ac:	93 1f       	adc	r25, r19
    41ae:	80 50       	subi	r24, 0x00	; 0
    41b0:	9b 4f       	sbci	r25, 0xFB	; 251
    41b2:	9a 83       	std	Y+2, r25	; 0x02
    41b4:	89 83       	std	Y+1, r24	; 0x01
    41b6:	89 81       	ldd	r24, Y+1	; 0x01
    41b8:	9a 81       	ldd	r25, Y+2	; 0x02
    41ba:	fc 01       	movw	r30, r24
    41bc:	81 81       	ldd	r24, Z+1	; 0x01
    41be:	92 81       	ldd	r25, Z+2	; 0x02
    41c0:	fc 01       	movw	r30, r24
    41c2:	22 81       	ldd	r18, Z+2	; 0x02
    41c4:	33 81       	ldd	r19, Z+3	; 0x03
    41c6:	89 81       	ldd	r24, Y+1	; 0x01
    41c8:	9a 81       	ldd	r25, Y+2	; 0x02
    41ca:	fc 01       	movw	r30, r24
    41cc:	32 83       	std	Z+2, r19	; 0x02
    41ce:	21 83       	std	Z+1, r18	; 0x01
    41d0:	89 81       	ldd	r24, Y+1	; 0x01
    41d2:	9a 81       	ldd	r25, Y+2	; 0x02
    41d4:	fc 01       	movw	r30, r24
    41d6:	21 81       	ldd	r18, Z+1	; 0x01
    41d8:	32 81       	ldd	r19, Z+2	; 0x02
    41da:	89 81       	ldd	r24, Y+1	; 0x01
    41dc:	9a 81       	ldd	r25, Y+2	; 0x02
    41de:	03 96       	adiw	r24, 0x03	; 3
    41e0:	28 17       	cp	r18, r24
    41e2:	39 07       	cpc	r19, r25
    41e4:	69 f4       	brne	.+26     	; 0x4200 <vTaskSwitchContext+0xbc>
    41e6:	89 81       	ldd	r24, Y+1	; 0x01
    41e8:	9a 81       	ldd	r25, Y+2	; 0x02
    41ea:	fc 01       	movw	r30, r24
    41ec:	81 81       	ldd	r24, Z+1	; 0x01
    41ee:	92 81       	ldd	r25, Z+2	; 0x02
    41f0:	fc 01       	movw	r30, r24
    41f2:	22 81       	ldd	r18, Z+2	; 0x02
    41f4:	33 81       	ldd	r19, Z+3	; 0x03
    41f6:	89 81       	ldd	r24, Y+1	; 0x01
    41f8:	9a 81       	ldd	r25, Y+2	; 0x02
    41fa:	fc 01       	movw	r30, r24
    41fc:	32 83       	std	Z+2, r19	; 0x02
    41fe:	21 83       	std	Z+1, r18	; 0x01
    4200:	89 81       	ldd	r24, Y+1	; 0x01
    4202:	9a 81       	ldd	r25, Y+2	; 0x02
    4204:	fc 01       	movw	r30, r24
    4206:	81 81       	ldd	r24, Z+1	; 0x01
    4208:	92 81       	ldd	r25, Z+2	; 0x02
    420a:	fc 01       	movw	r30, r24
    420c:	86 81       	ldd	r24, Z+6	; 0x06
    420e:	97 81       	ldd	r25, Z+7	; 0x07
    4210:	90 93 ff 04 	sts	0x04FF, r25
    4214:	80 93 fe 04 	sts	0x04FE, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4218:	0f 90       	pop	r0
    421a:	0f 90       	pop	r0
    421c:	df 91       	pop	r29
    421e:	cf 91       	pop	r28
    4220:	08 95       	ret

00004222 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    4222:	cf 93       	push	r28
    4224:	df 93       	push	r29
    4226:	00 d0       	rcall	.+0      	; 0x4228 <vTaskPlaceOnEventList+0x6>
    4228:	00 d0       	rcall	.+0      	; 0x422a <vTaskPlaceOnEventList+0x8>
    422a:	00 d0       	rcall	.+0      	; 0x422c <vTaskPlaceOnEventList+0xa>
    422c:	cd b7       	in	r28, 0x3d	; 61
    422e:	de b7       	in	r29, 0x3e	; 62
    4230:	9c 83       	std	Y+4, r25	; 0x04
    4232:	8b 83       	std	Y+3, r24	; 0x03
    4234:	7e 83       	std	Y+6, r23	; 0x06
    4236:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4238:	80 91 fe 04 	lds	r24, 0x04FE
    423c:	90 91 ff 04 	lds	r25, 0x04FF
    4240:	9c 01       	movw	r18, r24
    4242:	24 5f       	subi	r18, 0xF4	; 244
    4244:	3f 4f       	sbci	r19, 0xFF	; 255
    4246:	8b 81       	ldd	r24, Y+3	; 0x03
    4248:	9c 81       	ldd	r25, Y+4	; 0x04
    424a:	b9 01       	movw	r22, r18
    424c:	0e 94 38 12 	call	0x2470	; 0x2470 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4250:	80 91 fe 04 	lds	r24, 0x04FE
    4254:	90 91 ff 04 	lds	r25, 0x04FF
    4258:	02 96       	adiw	r24, 0x02	; 2
    425a:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    425e:	20 91 4e 05 	lds	r18, 0x054E
    4262:	30 91 4f 05 	lds	r19, 0x054F
    4266:	8d 81       	ldd	r24, Y+5	; 0x05
    4268:	9e 81       	ldd	r25, Y+6	; 0x06
    426a:	82 0f       	add	r24, r18
    426c:	93 1f       	adc	r25, r19
    426e:	9a 83       	std	Y+2, r25	; 0x02
    4270:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    4272:	89 81       	ldd	r24, Y+1	; 0x01
    4274:	9a 81       	ldd	r25, Y+2	; 0x02
    4276:	0e 94 00 24 	call	0x4800	; 0x4800 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    427a:	26 96       	adiw	r28, 0x06	; 6
    427c:	0f b6       	in	r0, 0x3f	; 63
    427e:	f8 94       	cli
    4280:	de bf       	out	0x3e, r29	; 62
    4282:	0f be       	out	0x3f, r0	; 63
    4284:	cd bf       	out	0x3d, r28	; 61
    4286:	df 91       	pop	r29
    4288:	cf 91       	pop	r28
    428a:	08 95       	ret

0000428c <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    428c:	cf 93       	push	r28
    428e:	df 93       	push	r29
    4290:	cd b7       	in	r28, 0x3d	; 61
    4292:	de b7       	in	r29, 0x3e	; 62
    4294:	28 97       	sbiw	r28, 0x08	; 8
    4296:	0f b6       	in	r0, 0x3f	; 63
    4298:	f8 94       	cli
    429a:	de bf       	out	0x3e, r29	; 62
    429c:	0f be       	out	0x3f, r0	; 63
    429e:	cd bf       	out	0x3d, r28	; 61
    42a0:	9c 83       	std	Y+4, r25	; 0x04
    42a2:	8b 83       	std	Y+3, r24	; 0x03
    42a4:	7e 83       	std	Y+6, r23	; 0x06
    42a6:	6d 83       	std	Y+5, r22	; 0x05
    42a8:	58 87       	std	Y+8, r21	; 0x08
    42aa:	4f 83       	std	Y+7, r20	; 0x07
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    42ac:	80 91 fe 04 	lds	r24, 0x04FE
    42b0:	90 91 ff 04 	lds	r25, 0x04FF
    42b4:	2d 81       	ldd	r18, Y+5	; 0x05
    42b6:	3e 81       	ldd	r19, Y+6	; 0x06
    42b8:	30 68       	ori	r19, 0x80	; 128
    42ba:	fc 01       	movw	r30, r24
    42bc:	35 87       	std	Z+13, r19	; 0x0d
    42be:	24 87       	std	Z+12, r18	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    42c0:	80 91 fe 04 	lds	r24, 0x04FE
    42c4:	90 91 ff 04 	lds	r25, 0x04FF
    42c8:	9c 01       	movw	r18, r24
    42ca:	24 5f       	subi	r18, 0xF4	; 244
    42cc:	3f 4f       	sbci	r19, 0xFF	; 255
    42ce:	8b 81       	ldd	r24, Y+3	; 0x03
    42d0:	9c 81       	ldd	r25, Y+4	; 0x04
    42d2:	b9 01       	movw	r22, r18
    42d4:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    42d8:	80 91 fe 04 	lds	r24, 0x04FE
    42dc:	90 91 ff 04 	lds	r25, 0x04FF
    42e0:	02 96       	adiw	r24, 0x02	; 2
    42e2:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    42e6:	20 91 4e 05 	lds	r18, 0x054E
    42ea:	30 91 4f 05 	lds	r19, 0x054F
    42ee:	8f 81       	ldd	r24, Y+7	; 0x07
    42f0:	98 85       	ldd	r25, Y+8	; 0x08
    42f2:	82 0f       	add	r24, r18
    42f4:	93 1f       	adc	r25, r19
    42f6:	9a 83       	std	Y+2, r25	; 0x02
    42f8:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    42fa:	89 81       	ldd	r24, Y+1	; 0x01
    42fc:	9a 81       	ldd	r25, Y+2	; 0x02
    42fe:	0e 94 00 24 	call	0x4800	; 0x4800 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    4302:	28 96       	adiw	r28, 0x08	; 8
    4304:	0f b6       	in	r0, 0x3f	; 63
    4306:	f8 94       	cli
    4308:	de bf       	out	0x3e, r29	; 62
    430a:	0f be       	out	0x3f, r0	; 63
    430c:	cd bf       	out	0x3d, r28	; 61
    430e:	df 91       	pop	r29
    4310:	cf 91       	pop	r28
    4312:	08 95       	ret

00004314 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4314:	cf 93       	push	r28
    4316:	df 93       	push	r29
    4318:	00 d0       	rcall	.+0      	; 0x431a <xTaskRemoveFromEventList+0x6>
    431a:	00 d0       	rcall	.+0      	; 0x431c <xTaskRemoveFromEventList+0x8>
    431c:	1f 92       	push	r1
    431e:	cd b7       	in	r28, 0x3d	; 61
    4320:	de b7       	in	r29, 0x3e	; 62
    4322:	9d 83       	std	Y+5, r25	; 0x05
    4324:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    4326:	8c 81       	ldd	r24, Y+4	; 0x04
    4328:	9d 81       	ldd	r25, Y+5	; 0x05
    432a:	fc 01       	movw	r30, r24
    432c:	85 81       	ldd	r24, Z+5	; 0x05
    432e:	96 81       	ldd	r25, Z+6	; 0x06
    4330:	fc 01       	movw	r30, r24
    4332:	86 81       	ldd	r24, Z+6	; 0x06
    4334:	97 81       	ldd	r25, Z+7	; 0x07
    4336:	9b 83       	std	Y+3, r25	; 0x03
    4338:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    433a:	8a 81       	ldd	r24, Y+2	; 0x02
    433c:	9b 81       	ldd	r25, Y+3	; 0x03
    433e:	0c 96       	adiw	r24, 0x0c	; 12
    4340:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4344:	80 91 58 05 	lds	r24, 0x0558
    4348:	88 23       	and	r24, r24
    434a:	69 f5       	brne	.+90     	; 0x43a6 <xTaskRemoveFromEventList+0x92>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    434c:	8a 81       	ldd	r24, Y+2	; 0x02
    434e:	9b 81       	ldd	r25, Y+3	; 0x03
    4350:	02 96       	adiw	r24, 0x02	; 2
    4352:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4356:	8a 81       	ldd	r24, Y+2	; 0x02
    4358:	9b 81       	ldd	r25, Y+3	; 0x03
    435a:	fc 01       	movw	r30, r24
    435c:	96 89       	ldd	r25, Z+22	; 0x16
    435e:	80 91 50 05 	lds	r24, 0x0550
    4362:	89 17       	cp	r24, r25
    4364:	30 f4       	brcc	.+12     	; 0x4372 <xTaskRemoveFromEventList+0x5e>
    4366:	8a 81       	ldd	r24, Y+2	; 0x02
    4368:	9b 81       	ldd	r25, Y+3	; 0x03
    436a:	fc 01       	movw	r30, r24
    436c:	86 89       	ldd	r24, Z+22	; 0x16
    436e:	80 93 50 05 	sts	0x0550, r24
    4372:	8a 81       	ldd	r24, Y+2	; 0x02
    4374:	9b 81       	ldd	r25, Y+3	; 0x03
    4376:	ac 01       	movw	r20, r24
    4378:	4e 5f       	subi	r20, 0xFE	; 254
    437a:	5f 4f       	sbci	r21, 0xFF	; 255
    437c:	8a 81       	ldd	r24, Y+2	; 0x02
    437e:	9b 81       	ldd	r25, Y+3	; 0x03
    4380:	fc 01       	movw	r30, r24
    4382:	86 89       	ldd	r24, Z+22	; 0x16
    4384:	28 2f       	mov	r18, r24
    4386:	30 e0       	ldi	r19, 0x00	; 0
    4388:	c9 01       	movw	r24, r18
    438a:	88 0f       	add	r24, r24
    438c:	99 1f       	adc	r25, r25
    438e:	88 0f       	add	r24, r24
    4390:	99 1f       	adc	r25, r25
    4392:	88 0f       	add	r24, r24
    4394:	99 1f       	adc	r25, r25
    4396:	82 0f       	add	r24, r18
    4398:	93 1f       	adc	r25, r19
    439a:	80 50       	subi	r24, 0x00	; 0
    439c:	9b 4f       	sbci	r25, 0xFB	; 251
    439e:	ba 01       	movw	r22, r20
    43a0:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vListInsertEnd>
    43a4:	08 c0       	rjmp	.+16     	; 0x43b6 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    43a6:	8a 81       	ldd	r24, Y+2	; 0x02
    43a8:	9b 81       	ldd	r25, Y+3	; 0x03
    43aa:	0c 96       	adiw	r24, 0x0c	; 12
    43ac:	bc 01       	movw	r22, r24
    43ae:	8a e3       	ldi	r24, 0x3A	; 58
    43b0:	95 e0       	ldi	r25, 0x05	; 5
    43b2:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    43b6:	8a 81       	ldd	r24, Y+2	; 0x02
    43b8:	9b 81       	ldd	r25, Y+3	; 0x03
    43ba:	fc 01       	movw	r30, r24
    43bc:	26 89       	ldd	r18, Z+22	; 0x16
    43be:	80 91 fe 04 	lds	r24, 0x04FE
    43c2:	90 91 ff 04 	lds	r25, 0x04FF
    43c6:	fc 01       	movw	r30, r24
    43c8:	86 89       	ldd	r24, Z+22	; 0x16
    43ca:	82 17       	cp	r24, r18
    43cc:	30 f4       	brcc	.+12     	; 0x43da <xTaskRemoveFromEventList+0xc6>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    43ce:	81 e0       	ldi	r24, 0x01	; 1
    43d0:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    43d2:	81 e0       	ldi	r24, 0x01	; 1
    43d4:	80 93 53 05 	sts	0x0553, r24
    43d8:	01 c0       	rjmp	.+2      	; 0x43dc <xTaskRemoveFromEventList+0xc8>
	}
	else
	{
		xReturn = pdFALSE;
    43da:	19 82       	std	Y+1, r1	; 0x01
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    43dc:	89 81       	ldd	r24, Y+1	; 0x01
}
    43de:	0f 90       	pop	r0
    43e0:	0f 90       	pop	r0
    43e2:	0f 90       	pop	r0
    43e4:	0f 90       	pop	r0
    43e6:	0f 90       	pop	r0
    43e8:	df 91       	pop	r29
    43ea:	cf 91       	pop	r28
    43ec:	08 95       	ret

000043ee <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    43ee:	cf 93       	push	r28
    43f0:	df 93       	push	r29
    43f2:	cd b7       	in	r28, 0x3d	; 61
    43f4:	de b7       	in	r29, 0x3e	; 62
    43f6:	27 97       	sbiw	r28, 0x07	; 7
    43f8:	0f b6       	in	r0, 0x3f	; 63
    43fa:	f8 94       	cli
    43fc:	de bf       	out	0x3e, r29	; 62
    43fe:	0f be       	out	0x3f, r0	; 63
    4400:	cd bf       	out	0x3d, r28	; 61
    4402:	9d 83       	std	Y+5, r25	; 0x05
    4404:	8c 83       	std	Y+4, r24	; 0x04
    4406:	7f 83       	std	Y+7, r23	; 0x07
    4408:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    440a:	8e 81       	ldd	r24, Y+6	; 0x06
    440c:	9f 81       	ldd	r25, Y+7	; 0x07
    440e:	9c 01       	movw	r18, r24
    4410:	30 68       	ori	r19, 0x80	; 128
    4412:	8c 81       	ldd	r24, Y+4	; 0x04
    4414:	9d 81       	ldd	r25, Y+5	; 0x05
    4416:	fc 01       	movw	r30, r24
    4418:	31 83       	std	Z+1, r19	; 0x01
    441a:	20 83       	st	Z, r18

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    441c:	8c 81       	ldd	r24, Y+4	; 0x04
    441e:	9d 81       	ldd	r25, Y+5	; 0x05
    4420:	fc 01       	movw	r30, r24
    4422:	86 81       	ldd	r24, Z+6	; 0x06
    4424:	97 81       	ldd	r25, Z+7	; 0x07
    4426:	9b 83       	std	Y+3, r25	; 0x03
    4428:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    442a:	8c 81       	ldd	r24, Y+4	; 0x04
    442c:	9d 81       	ldd	r25, Y+5	; 0x05
    442e:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    4432:	8a 81       	ldd	r24, Y+2	; 0x02
    4434:	9b 81       	ldd	r25, Y+3	; 0x03
    4436:	02 96       	adiw	r24, 0x02	; 2
    4438:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    443c:	8a 81       	ldd	r24, Y+2	; 0x02
    443e:	9b 81       	ldd	r25, Y+3	; 0x03
    4440:	fc 01       	movw	r30, r24
    4442:	96 89       	ldd	r25, Z+22	; 0x16
    4444:	80 91 50 05 	lds	r24, 0x0550
    4448:	89 17       	cp	r24, r25
    444a:	30 f4       	brcc	.+12     	; 0x4458 <xTaskRemoveFromUnorderedEventList+0x6a>
    444c:	8a 81       	ldd	r24, Y+2	; 0x02
    444e:	9b 81       	ldd	r25, Y+3	; 0x03
    4450:	fc 01       	movw	r30, r24
    4452:	86 89       	ldd	r24, Z+22	; 0x16
    4454:	80 93 50 05 	sts	0x0550, r24
    4458:	8a 81       	ldd	r24, Y+2	; 0x02
    445a:	9b 81       	ldd	r25, Y+3	; 0x03
    445c:	ac 01       	movw	r20, r24
    445e:	4e 5f       	subi	r20, 0xFE	; 254
    4460:	5f 4f       	sbci	r21, 0xFF	; 255
    4462:	8a 81       	ldd	r24, Y+2	; 0x02
    4464:	9b 81       	ldd	r25, Y+3	; 0x03
    4466:	fc 01       	movw	r30, r24
    4468:	86 89       	ldd	r24, Z+22	; 0x16
    446a:	28 2f       	mov	r18, r24
    446c:	30 e0       	ldi	r19, 0x00	; 0
    446e:	c9 01       	movw	r24, r18
    4470:	88 0f       	add	r24, r24
    4472:	99 1f       	adc	r25, r25
    4474:	88 0f       	add	r24, r24
    4476:	99 1f       	adc	r25, r25
    4478:	88 0f       	add	r24, r24
    447a:	99 1f       	adc	r25, r25
    447c:	82 0f       	add	r24, r18
    447e:	93 1f       	adc	r25, r19
    4480:	80 50       	subi	r24, 0x00	; 0
    4482:	9b 4f       	sbci	r25, 0xFB	; 251
    4484:	ba 01       	movw	r22, r20
    4486:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    448a:	8a 81       	ldd	r24, Y+2	; 0x02
    448c:	9b 81       	ldd	r25, Y+3	; 0x03
    448e:	fc 01       	movw	r30, r24
    4490:	26 89       	ldd	r18, Z+22	; 0x16
    4492:	80 91 fe 04 	lds	r24, 0x04FE
    4496:	90 91 ff 04 	lds	r25, 0x04FF
    449a:	fc 01       	movw	r30, r24
    449c:	86 89       	ldd	r24, Z+22	; 0x16
    449e:	82 17       	cp	r24, r18
    44a0:	30 f4       	brcc	.+12     	; 0x44ae <xTaskRemoveFromUnorderedEventList+0xc0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    44a2:	81 e0       	ldi	r24, 0x01	; 1
    44a4:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    44a6:	81 e0       	ldi	r24, 0x01	; 1
    44a8:	80 93 53 05 	sts	0x0553, r24
    44ac:	01 c0       	rjmp	.+2      	; 0x44b0 <xTaskRemoveFromUnorderedEventList+0xc2>
	}
	else
	{
		xReturn = pdFALSE;
    44ae:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    44b0:	89 81       	ldd	r24, Y+1	; 0x01
}
    44b2:	27 96       	adiw	r28, 0x07	; 7
    44b4:	0f b6       	in	r0, 0x3f	; 63
    44b6:	f8 94       	cli
    44b8:	de bf       	out	0x3e, r29	; 62
    44ba:	0f be       	out	0x3f, r0	; 63
    44bc:	cd bf       	out	0x3d, r28	; 61
    44be:	df 91       	pop	r29
    44c0:	cf 91       	pop	r28
    44c2:	08 95       	ret

000044c4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    44c4:	cf 93       	push	r28
    44c6:	df 93       	push	r29
    44c8:	00 d0       	rcall	.+0      	; 0x44ca <vTaskSetTimeOutState+0x6>
    44ca:	cd b7       	in	r28, 0x3d	; 61
    44cc:	de b7       	in	r29, 0x3e	; 62
    44ce:	9a 83       	std	Y+2, r25	; 0x02
    44d0:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    44d2:	20 91 54 05 	lds	r18, 0x0554
    44d6:	89 81       	ldd	r24, Y+1	; 0x01
    44d8:	9a 81       	ldd	r25, Y+2	; 0x02
    44da:	fc 01       	movw	r30, r24
    44dc:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    44de:	20 91 4e 05 	lds	r18, 0x054E
    44e2:	30 91 4f 05 	lds	r19, 0x054F
    44e6:	89 81       	ldd	r24, Y+1	; 0x01
    44e8:	9a 81       	ldd	r25, Y+2	; 0x02
    44ea:	fc 01       	movw	r30, r24
    44ec:	32 83       	std	Z+2, r19	; 0x02
    44ee:	21 83       	std	Z+1, r18	; 0x01
}
    44f0:	0f 90       	pop	r0
    44f2:	0f 90       	pop	r0
    44f4:	df 91       	pop	r29
    44f6:	cf 91       	pop	r28
    44f8:	08 95       	ret

000044fa <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    44fa:	cf 93       	push	r28
    44fc:	df 93       	push	r29
    44fe:	cd b7       	in	r28, 0x3d	; 61
    4500:	de b7       	in	r29, 0x3e	; 62
    4502:	27 97       	sbiw	r28, 0x07	; 7
    4504:	0f b6       	in	r0, 0x3f	; 63
    4506:	f8 94       	cli
    4508:	de bf       	out	0x3e, r29	; 62
    450a:	0f be       	out	0x3f, r0	; 63
    450c:	cd bf       	out	0x3d, r28	; 61
    450e:	9d 83       	std	Y+5, r25	; 0x05
    4510:	8c 83       	std	Y+4, r24	; 0x04
    4512:	7f 83       	std	Y+7, r23	; 0x07
    4514:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4516:	0f b6       	in	r0, 0x3f	; 63
    4518:	f8 94       	cli
    451a:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    451c:	80 91 4e 05 	lds	r24, 0x054E
    4520:	90 91 4f 05 	lds	r25, 0x054F
    4524:	9b 83       	std	Y+3, r25	; 0x03
    4526:	8a 83       	std	Y+2, r24	; 0x02
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4528:	8c 81       	ldd	r24, Y+4	; 0x04
    452a:	9d 81       	ldd	r25, Y+5	; 0x05
    452c:	fc 01       	movw	r30, r24
    452e:	90 81       	ld	r25, Z
    4530:	80 91 54 05 	lds	r24, 0x0554
    4534:	98 17       	cp	r25, r24
    4536:	69 f0       	breq	.+26     	; 0x4552 <xTaskCheckForTimeOut+0x58>
    4538:	8c 81       	ldd	r24, Y+4	; 0x04
    453a:	9d 81       	ldd	r25, Y+5	; 0x05
    453c:	fc 01       	movw	r30, r24
    453e:	21 81       	ldd	r18, Z+1	; 0x01
    4540:	32 81       	ldd	r19, Z+2	; 0x02
    4542:	8a 81       	ldd	r24, Y+2	; 0x02
    4544:	9b 81       	ldd	r25, Y+3	; 0x03
    4546:	82 17       	cp	r24, r18
    4548:	93 07       	cpc	r25, r19
    454a:	18 f0       	brcs	.+6      	; 0x4552 <xTaskCheckForTimeOut+0x58>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    454c:	81 e0       	ldi	r24, 0x01	; 1
    454e:	89 83       	std	Y+1, r24	; 0x01
    4550:	30 c0       	rjmp	.+96     	; 0x45b2 <xTaskCheckForTimeOut+0xb8>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    4552:	8c 81       	ldd	r24, Y+4	; 0x04
    4554:	9d 81       	ldd	r25, Y+5	; 0x05
    4556:	fc 01       	movw	r30, r24
    4558:	81 81       	ldd	r24, Z+1	; 0x01
    455a:	92 81       	ldd	r25, Z+2	; 0x02
    455c:	2a 81       	ldd	r18, Y+2	; 0x02
    455e:	3b 81       	ldd	r19, Y+3	; 0x03
    4560:	28 1b       	sub	r18, r24
    4562:	39 0b       	sbc	r19, r25
    4564:	8e 81       	ldd	r24, Y+6	; 0x06
    4566:	9f 81       	ldd	r25, Y+7	; 0x07
    4568:	fc 01       	movw	r30, r24
    456a:	80 81       	ld	r24, Z
    456c:	91 81       	ldd	r25, Z+1	; 0x01
    456e:	28 17       	cp	r18, r24
    4570:	39 07       	cpc	r19, r25
    4572:	e8 f4       	brcc	.+58     	; 0x45ae <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    4574:	8e 81       	ldd	r24, Y+6	; 0x06
    4576:	9f 81       	ldd	r25, Y+7	; 0x07
    4578:	fc 01       	movw	r30, r24
    457a:	20 81       	ld	r18, Z
    457c:	31 81       	ldd	r19, Z+1	; 0x01
    457e:	8c 81       	ldd	r24, Y+4	; 0x04
    4580:	9d 81       	ldd	r25, Y+5	; 0x05
    4582:	fc 01       	movw	r30, r24
    4584:	41 81       	ldd	r20, Z+1	; 0x01
    4586:	52 81       	ldd	r21, Z+2	; 0x02
    4588:	8a 81       	ldd	r24, Y+2	; 0x02
    458a:	9b 81       	ldd	r25, Y+3	; 0x03
    458c:	ba 01       	movw	r22, r20
    458e:	68 1b       	sub	r22, r24
    4590:	79 0b       	sbc	r23, r25
    4592:	cb 01       	movw	r24, r22
    4594:	28 0f       	add	r18, r24
    4596:	39 1f       	adc	r19, r25
    4598:	8e 81       	ldd	r24, Y+6	; 0x06
    459a:	9f 81       	ldd	r25, Y+7	; 0x07
    459c:	fc 01       	movw	r30, r24
    459e:	31 83       	std	Z+1, r19	; 0x01
    45a0:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    45a2:	8c 81       	ldd	r24, Y+4	; 0x04
    45a4:	9d 81       	ldd	r25, Y+5	; 0x05
    45a6:	0e 94 62 22 	call	0x44c4	; 0x44c4 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    45aa:	19 82       	std	Y+1, r1	; 0x01
    45ac:	02 c0       	rjmp	.+4      	; 0x45b2 <xTaskCheckForTimeOut+0xb8>
		}
		else
		{
			xReturn = pdTRUE;
    45ae:	81 e0       	ldi	r24, 0x01	; 1
    45b0:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    45b2:	0f 90       	pop	r0
    45b4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    45b6:	89 81       	ldd	r24, Y+1	; 0x01
}
    45b8:	27 96       	adiw	r28, 0x07	; 7
    45ba:	0f b6       	in	r0, 0x3f	; 63
    45bc:	f8 94       	cli
    45be:	de bf       	out	0x3e, r29	; 62
    45c0:	0f be       	out	0x3f, r0	; 63
    45c2:	cd bf       	out	0x3d, r28	; 61
    45c4:	df 91       	pop	r29
    45c6:	cf 91       	pop	r28
    45c8:	08 95       	ret

000045ca <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    45ca:	cf 93       	push	r28
    45cc:	df 93       	push	r29
    45ce:	cd b7       	in	r28, 0x3d	; 61
    45d0:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    45d2:	81 e0       	ldi	r24, 0x01	; 1
    45d4:	80 93 53 05 	sts	0x0553, r24
}
    45d8:	df 91       	pop	r29
    45da:	cf 91       	pop	r28
    45dc:	08 95       	ret

000045de <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    45de:	cf 93       	push	r28
    45e0:	df 93       	push	r29
    45e2:	00 d0       	rcall	.+0      	; 0x45e4 <prvIdleTask+0x6>
    45e4:	cd b7       	in	r28, 0x3d	; 61
    45e6:	de b7       	in	r29, 0x3e	; 62
    45e8:	9a 83       	std	Y+2, r25	; 0x02
    45ea:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    45ec:	0e 94 c0 23 	call	0x4780	; 0x4780 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    45f0:	80 91 00 05 	lds	r24, 0x0500
    45f4:	82 30       	cpi	r24, 0x02	; 2
    45f6:	10 f0       	brcs	.+4      	; 0x45fc <prvIdleTask+0x1e>
			{
				taskYIELD();
    45f8:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <vPortYield>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    45fc:	f7 cf       	rjmp	.-18     	; 0x45ec <prvIdleTask+0xe>

000045fe <prvInitialiseTCBVariables>:

#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    45fe:	0f 93       	push	r16
    4600:	1f 93       	push	r17
    4602:	cf 93       	push	r28
    4604:	df 93       	push	r29
    4606:	cd b7       	in	r28, 0x3d	; 61
    4608:	de b7       	in	r29, 0x3e	; 62
    460a:	2a 97       	sbiw	r28, 0x0a	; 10
    460c:	0f b6       	in	r0, 0x3f	; 63
    460e:	f8 94       	cli
    4610:	de bf       	out	0x3e, r29	; 62
    4612:	0f be       	out	0x3f, r0	; 63
    4614:	cd bf       	out	0x3d, r28	; 61
    4616:	9b 83       	std	Y+3, r25	; 0x03
    4618:	8a 83       	std	Y+2, r24	; 0x02
    461a:	7d 83       	std	Y+5, r23	; 0x05
    461c:	6c 83       	std	Y+4, r22	; 0x04
    461e:	4e 83       	std	Y+6, r20	; 0x06
    4620:	38 87       	std	Y+8, r19	; 0x08
    4622:	2f 83       	std	Y+7, r18	; 0x07
    4624:	1a 87       	std	Y+10, r17	; 0x0a
    4626:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4628:	19 82       	std	Y+1, r1	; 0x01
    462a:	22 c0       	rjmp	.+68     	; 0x4670 <prvInitialiseTCBVariables+0x72>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    462c:	89 81       	ldd	r24, Y+1	; 0x01
    462e:	88 2f       	mov	r24, r24
    4630:	90 e0       	ldi	r25, 0x00	; 0
    4632:	29 81       	ldd	r18, Y+1	; 0x01
    4634:	22 2f       	mov	r18, r18
    4636:	30 e0       	ldi	r19, 0x00	; 0
    4638:	4c 81       	ldd	r20, Y+4	; 0x04
    463a:	5d 81       	ldd	r21, Y+5	; 0x05
    463c:	24 0f       	add	r18, r20
    463e:	35 1f       	adc	r19, r21
    4640:	f9 01       	movw	r30, r18
    4642:	40 81       	ld	r20, Z
    4644:	2a 81       	ldd	r18, Y+2	; 0x02
    4646:	3b 81       	ldd	r19, Y+3	; 0x03
    4648:	82 0f       	add	r24, r18
    464a:	93 1f       	adc	r25, r19
    464c:	49 96       	adiw	r24, 0x19	; 25
    464e:	fc 01       	movw	r30, r24
    4650:	40 83       	st	Z, r20

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    4652:	89 81       	ldd	r24, Y+1	; 0x01
    4654:	88 2f       	mov	r24, r24
    4656:	90 e0       	ldi	r25, 0x00	; 0
    4658:	2c 81       	ldd	r18, Y+4	; 0x04
    465a:	3d 81       	ldd	r19, Y+5	; 0x05
    465c:	82 0f       	add	r24, r18
    465e:	93 1f       	adc	r25, r19
    4660:	fc 01       	movw	r30, r24
    4662:	80 81       	ld	r24, Z
    4664:	88 23       	and	r24, r24
    4666:	09 f4       	brne	.+2      	; 0x466a <prvInitialiseTCBVariables+0x6c>
		{
			break;
    4668:	06 c0       	rjmp	.+12     	; 0x4676 <prvInitialiseTCBVariables+0x78>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    466a:	89 81       	ldd	r24, Y+1	; 0x01
    466c:	8f 5f       	subi	r24, 0xFF	; 255
    466e:	89 83       	std	Y+1, r24	; 0x01
    4670:	89 81       	ldd	r24, Y+1	; 0x01
    4672:	88 30       	cpi	r24, 0x08	; 8
    4674:	d8 f2       	brcs	.-74     	; 0x462c <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    4676:	8a 81       	ldd	r24, Y+2	; 0x02
    4678:	9b 81       	ldd	r25, Y+3	; 0x03
    467a:	fc 01       	movw	r30, r24
    467c:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    467e:	8e 81       	ldd	r24, Y+6	; 0x06
    4680:	84 30       	cpi	r24, 0x04	; 4
    4682:	10 f0       	brcs	.+4      	; 0x4688 <prvInitialiseTCBVariables+0x8a>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    4684:	83 e0       	ldi	r24, 0x03	; 3
    4686:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    4688:	8a 81       	ldd	r24, Y+2	; 0x02
    468a:	9b 81       	ldd	r25, Y+3	; 0x03
    468c:	2e 81       	ldd	r18, Y+6	; 0x06
    468e:	fc 01       	movw	r30, r24
    4690:	26 8b       	std	Z+22, r18	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    4692:	8a 81       	ldd	r24, Y+2	; 0x02
    4694:	9b 81       	ldd	r25, Y+3	; 0x03
    4696:	02 96       	adiw	r24, 0x02	; 2
    4698:	0e 94 d9 11 	call	0x23b2	; 0x23b2 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    469c:	8a 81       	ldd	r24, Y+2	; 0x02
    469e:	9b 81       	ldd	r25, Y+3	; 0x03
    46a0:	0c 96       	adiw	r24, 0x0c	; 12
    46a2:	0e 94 d9 11 	call	0x23b2	; 0x23b2 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    46a6:	8a 81       	ldd	r24, Y+2	; 0x02
    46a8:	9b 81       	ldd	r25, Y+3	; 0x03
    46aa:	2a 81       	ldd	r18, Y+2	; 0x02
    46ac:	3b 81       	ldd	r19, Y+3	; 0x03
    46ae:	fc 01       	movw	r30, r24
    46b0:	31 87       	std	Z+9, r19	; 0x09
    46b2:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    46b4:	8e 81       	ldd	r24, Y+6	; 0x06
    46b6:	88 2f       	mov	r24, r24
    46b8:	90 e0       	ldi	r25, 0x00	; 0
    46ba:	24 e0       	ldi	r18, 0x04	; 4
    46bc:	30 e0       	ldi	r19, 0x00	; 0
    46be:	28 1b       	sub	r18, r24
    46c0:	39 0b       	sbc	r19, r25
    46c2:	8a 81       	ldd	r24, Y+2	; 0x02
    46c4:	9b 81       	ldd	r25, Y+3	; 0x03
    46c6:	fc 01       	movw	r30, r24
    46c8:	35 87       	std	Z+13, r19	; 0x0d
    46ca:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    46cc:	8a 81       	ldd	r24, Y+2	; 0x02
    46ce:	9b 81       	ldd	r25, Y+3	; 0x03
    46d0:	2a 81       	ldd	r18, Y+2	; 0x02
    46d2:	3b 81       	ldd	r19, Y+3	; 0x03
    46d4:	fc 01       	movw	r30, r24
    46d6:	33 8b       	std	Z+19, r19	; 0x13
    46d8:	22 8b       	std	Z+18, r18	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    46da:	8a 81       	ldd	r24, Y+2	; 0x02
    46dc:	9b 81       	ldd	r25, Y+3	; 0x03
    46de:	fc 01       	movw	r30, r24
    46e0:	11 a2       	std	Z+33, r1	; 0x21
    46e2:	12 a2       	std	Z+34, r1	; 0x22
    46e4:	13 a2       	std	Z+35, r1	; 0x23
    46e6:	14 a2       	std	Z+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
    46e8:	8a 81       	ldd	r24, Y+2	; 0x02
    46ea:	9b 81       	ldd	r25, Y+3	; 0x03
    46ec:	fc 01       	movw	r30, r24
    46ee:	15 a2       	std	Z+37, r1	; 0x25
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    46f0:	2a 96       	adiw	r28, 0x0a	; 10
    46f2:	0f b6       	in	r0, 0x3f	; 63
    46f4:	f8 94       	cli
    46f6:	de bf       	out	0x3e, r29	; 62
    46f8:	0f be       	out	0x3f, r0	; 63
    46fa:	cd bf       	out	0x3d, r28	; 61
    46fc:	df 91       	pop	r29
    46fe:	cf 91       	pop	r28
    4700:	1f 91       	pop	r17
    4702:	0f 91       	pop	r16
    4704:	08 95       	ret

00004706 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4706:	cf 93       	push	r28
    4708:	df 93       	push	r29
    470a:	1f 92       	push	r1
    470c:	cd b7       	in	r28, 0x3d	; 61
    470e:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4710:	19 82       	std	Y+1, r1	; 0x01
    4712:	13 c0       	rjmp	.+38     	; 0x473a <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4714:	89 81       	ldd	r24, Y+1	; 0x01
    4716:	28 2f       	mov	r18, r24
    4718:	30 e0       	ldi	r19, 0x00	; 0
    471a:	c9 01       	movw	r24, r18
    471c:	88 0f       	add	r24, r24
    471e:	99 1f       	adc	r25, r25
    4720:	88 0f       	add	r24, r24
    4722:	99 1f       	adc	r25, r25
    4724:	88 0f       	add	r24, r24
    4726:	99 1f       	adc	r25, r25
    4728:	82 0f       	add	r24, r18
    472a:	93 1f       	adc	r25, r19
    472c:	80 50       	subi	r24, 0x00	; 0
    472e:	9b 4f       	sbci	r25, 0xFB	; 251
    4730:	0e 94 a4 11 	call	0x2348	; 0x2348 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4734:	89 81       	ldd	r24, Y+1	; 0x01
    4736:	8f 5f       	subi	r24, 0xFF	; 255
    4738:	89 83       	std	Y+1, r24	; 0x01
    473a:	89 81       	ldd	r24, Y+1	; 0x01
    473c:	84 30       	cpi	r24, 0x04	; 4
    473e:	50 f3       	brcs	.-44     	; 0x4714 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    4740:	84 e2       	ldi	r24, 0x24	; 36
    4742:	95 e0       	ldi	r25, 0x05	; 5
    4744:	0e 94 a4 11 	call	0x2348	; 0x2348 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    4748:	8d e2       	ldi	r24, 0x2D	; 45
    474a:	95 e0       	ldi	r25, 0x05	; 5
    474c:	0e 94 a4 11 	call	0x2348	; 0x2348 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    4750:	8a e3       	ldi	r24, 0x3A	; 58
    4752:	95 e0       	ldi	r25, 0x05	; 5
    4754:	0e 94 a4 11 	call	0x2348	; 0x2348 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    4758:	83 e4       	ldi	r24, 0x43	; 67
    475a:	95 e0       	ldi	r25, 0x05	; 5
    475c:	0e 94 a4 11 	call	0x2348	; 0x2348 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4760:	84 e2       	ldi	r24, 0x24	; 36
    4762:	95 e0       	ldi	r25, 0x05	; 5
    4764:	90 93 37 05 	sts	0x0537, r25
    4768:	80 93 36 05 	sts	0x0536, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    476c:	8d e2       	ldi	r24, 0x2D	; 45
    476e:	95 e0       	ldi	r25, 0x05	; 5
    4770:	90 93 39 05 	sts	0x0539, r25
    4774:	80 93 38 05 	sts	0x0538, r24
}
    4778:	0f 90       	pop	r0
    477a:	df 91       	pop	r29
    477c:	cf 91       	pop	r28
    477e:	08 95       	ret

00004780 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4780:	cf 93       	push	r28
    4782:	df 93       	push	r29
    4784:	00 d0       	rcall	.+0      	; 0x4786 <prvCheckTasksWaitingTermination+0x6>
    4786:	1f 92       	push	r1
    4788:	cd b7       	in	r28, 0x3d	; 61
    478a:	de b7       	in	r29, 0x3e	; 62
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    478c:	2f c0       	rjmp	.+94     	; 0x47ec <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
    478e:	0e 94 e5 1e 	call	0x3dca	; 0x3dca <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    4792:	90 91 43 05 	lds	r25, 0x0543
    4796:	81 e0       	ldi	r24, 0x01	; 1
    4798:	99 23       	and	r25, r25
    479a:	09 f0       	breq	.+2      	; 0x479e <prvCheckTasksWaitingTermination+0x1e>
    479c:	80 e0       	ldi	r24, 0x00	; 0
    479e:	89 83       	std	Y+1, r24	; 0x01
			}
			( void ) xTaskResumeAll();
    47a0:	0e 94 f1 1e 	call	0x3de2	; 0x3de2 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    47a4:	89 81       	ldd	r24, Y+1	; 0x01
    47a6:	88 23       	and	r24, r24
    47a8:	09 f5       	brne	.+66     	; 0x47ec <prvCheckTasksWaitingTermination+0x6c>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    47aa:	0f b6       	in	r0, 0x3f	; 63
    47ac:	f8 94       	cli
    47ae:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    47b0:	80 91 48 05 	lds	r24, 0x0548
    47b4:	90 91 49 05 	lds	r25, 0x0549
    47b8:	fc 01       	movw	r30, r24
    47ba:	86 81       	ldd	r24, Z+6	; 0x06
    47bc:	97 81       	ldd	r25, Z+7	; 0x07
    47be:	9b 83       	std	Y+3, r25	; 0x03
    47c0:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    47c2:	8a 81       	ldd	r24, Y+2	; 0x02
    47c4:	9b 81       	ldd	r25, Y+3	; 0x03
    47c6:	02 96       	adiw	r24, 0x02	; 2
    47c8:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>
					--uxCurrentNumberOfTasks;
    47cc:	80 91 4d 05 	lds	r24, 0x054D
    47d0:	81 50       	subi	r24, 0x01	; 1
    47d2:	80 93 4d 05 	sts	0x054D, r24
					--uxTasksDeleted;
    47d6:	80 91 4c 05 	lds	r24, 0x054C
    47da:	81 50       	subi	r24, 0x01	; 1
    47dc:	80 93 4c 05 	sts	0x054C, r24
				}
				taskEXIT_CRITICAL();
    47e0:	0f 90       	pop	r0
    47e2:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    47e4:	8a 81       	ldd	r24, Y+2	; 0x02
    47e6:	9b 81       	ldd	r25, Y+3	; 0x03
    47e8:	0e 94 8d 24 	call	0x491a	; 0x491a <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    47ec:	80 91 4c 05 	lds	r24, 0x054C
    47f0:	88 23       	and	r24, r24
    47f2:	69 f6       	brne	.-102    	; 0x478e <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    47f4:	0f 90       	pop	r0
    47f6:	0f 90       	pop	r0
    47f8:	0f 90       	pop	r0
    47fa:	df 91       	pop	r29
    47fc:	cf 91       	pop	r28
    47fe:	08 95       	ret

00004800 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    4800:	cf 93       	push	r28
    4802:	df 93       	push	r29
    4804:	00 d0       	rcall	.+0      	; 0x4806 <prvAddCurrentTaskToDelayedList+0x6>
    4806:	cd b7       	in	r28, 0x3d	; 61
    4808:	de b7       	in	r29, 0x3e	; 62
    480a:	9a 83       	std	Y+2, r25	; 0x02
    480c:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    480e:	80 91 fe 04 	lds	r24, 0x04FE
    4812:	90 91 ff 04 	lds	r25, 0x04FF
    4816:	29 81       	ldd	r18, Y+1	; 0x01
    4818:	3a 81       	ldd	r19, Y+2	; 0x02
    481a:	fc 01       	movw	r30, r24
    481c:	33 83       	std	Z+3, r19	; 0x03
    481e:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    4820:	80 91 4e 05 	lds	r24, 0x054E
    4824:	90 91 4f 05 	lds	r25, 0x054F
    4828:	29 81       	ldd	r18, Y+1	; 0x01
    482a:	3a 81       	ldd	r19, Y+2	; 0x02
    482c:	28 17       	cp	r18, r24
    482e:	39 07       	cpc	r19, r25
    4830:	78 f4       	brcc	.+30     	; 0x4850 <prvAddCurrentTaskToDelayedList+0x50>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    4832:	80 91 fe 04 	lds	r24, 0x04FE
    4836:	90 91 ff 04 	lds	r25, 0x04FF
    483a:	9c 01       	movw	r18, r24
    483c:	2e 5f       	subi	r18, 0xFE	; 254
    483e:	3f 4f       	sbci	r19, 0xFF	; 255
    4840:	80 91 38 05 	lds	r24, 0x0538
    4844:	90 91 39 05 	lds	r25, 0x0539
    4848:	b9 01       	movw	r22, r18
    484a:	0e 94 38 12 	call	0x2470	; 0x2470 <vListInsert>
    484e:	1d c0       	rjmp	.+58     	; 0x488a <prvAddCurrentTaskToDelayedList+0x8a>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    4850:	80 91 fe 04 	lds	r24, 0x04FE
    4854:	90 91 ff 04 	lds	r25, 0x04FF
    4858:	9c 01       	movw	r18, r24
    485a:	2e 5f       	subi	r18, 0xFE	; 254
    485c:	3f 4f       	sbci	r19, 0xFF	; 255
    485e:	80 91 36 05 	lds	r24, 0x0536
    4862:	90 91 37 05 	lds	r25, 0x0537
    4866:	b9 01       	movw	r22, r18
    4868:	0e 94 38 12 	call	0x2470	; 0x2470 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    486c:	80 91 56 05 	lds	r24, 0x0556
    4870:	90 91 57 05 	lds	r25, 0x0557
    4874:	29 81       	ldd	r18, Y+1	; 0x01
    4876:	3a 81       	ldd	r19, Y+2	; 0x02
    4878:	28 17       	cp	r18, r24
    487a:	39 07       	cpc	r19, r25
    487c:	30 f4       	brcc	.+12     	; 0x488a <prvAddCurrentTaskToDelayedList+0x8a>
		{
			xNextTaskUnblockTime = xTimeToWake;
    487e:	89 81       	ldd	r24, Y+1	; 0x01
    4880:	9a 81       	ldd	r25, Y+2	; 0x02
    4882:	90 93 57 05 	sts	0x0557, r25
    4886:	80 93 56 05 	sts	0x0556, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    488a:	0f 90       	pop	r0
    488c:	0f 90       	pop	r0
    488e:	df 91       	pop	r29
    4890:	cf 91       	pop	r28
    4892:	08 95       	ret

00004894 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    4894:	cf 93       	push	r28
    4896:	df 93       	push	r29
    4898:	cd b7       	in	r28, 0x3d	; 61
    489a:	de b7       	in	r29, 0x3e	; 62
    489c:	28 97       	sbiw	r28, 0x08	; 8
    489e:	0f b6       	in	r0, 0x3f	; 63
    48a0:	f8 94       	cli
    48a2:	de bf       	out	0x3e, r29	; 62
    48a4:	0f be       	out	0x3f, r0	; 63
    48a6:	cd bf       	out	0x3d, r28	; 61
    48a8:	9e 83       	std	Y+6, r25	; 0x06
    48aa:	8d 83       	std	Y+5, r24	; 0x05
    48ac:	78 87       	std	Y+8, r23	; 0x08
    48ae:	6f 83       	std	Y+7, r22	; 0x07
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    48b0:	8f 81       	ldd	r24, Y+7	; 0x07
    48b2:	98 85       	ldd	r25, Y+8	; 0x08
    48b4:	89 2b       	or	r24, r25
    48b6:	29 f4       	brne	.+10     	; 0x48c2 <prvAllocateTCBAndStack+0x2e>
    48b8:	8d 81       	ldd	r24, Y+5	; 0x05
    48ba:	9e 81       	ldd	r25, Y+6	; 0x06
    48bc:	0e 94 0a 16 	call	0x2c14	; 0x2c14 <pvPortMalloc>
    48c0:	02 c0       	rjmp	.+4      	; 0x48c6 <prvAllocateTCBAndStack+0x32>
    48c2:	8f 81       	ldd	r24, Y+7	; 0x07
    48c4:	98 85       	ldd	r25, Y+8	; 0x08
    48c6:	9c 83       	std	Y+4, r25	; 0x04
    48c8:	8b 83       	std	Y+3, r24	; 0x03

		if( pxStack != NULL )
    48ca:	8b 81       	ldd	r24, Y+3	; 0x03
    48cc:	9c 81       	ldd	r25, Y+4	; 0x04
    48ce:	89 2b       	or	r24, r25
    48d0:	b9 f0       	breq	.+46     	; 0x4900 <prvAllocateTCBAndStack+0x6c>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    48d2:	86 e2       	ldi	r24, 0x26	; 38
    48d4:	90 e0       	ldi	r25, 0x00	; 0
    48d6:	0e 94 0a 16 	call	0x2c14	; 0x2c14 <pvPortMalloc>
    48da:	9a 83       	std	Y+2, r25	; 0x02
    48dc:	89 83       	std	Y+1, r24	; 0x01

			if( pxNewTCB != NULL )
    48de:	89 81       	ldd	r24, Y+1	; 0x01
    48e0:	9a 81       	ldd	r25, Y+2	; 0x02
    48e2:	89 2b       	or	r24, r25
    48e4:	41 f0       	breq	.+16     	; 0x48f6 <prvAllocateTCBAndStack+0x62>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    48e6:	89 81       	ldd	r24, Y+1	; 0x01
    48e8:	9a 81       	ldd	r25, Y+2	; 0x02
    48ea:	2b 81       	ldd	r18, Y+3	; 0x03
    48ec:	3c 81       	ldd	r19, Y+4	; 0x04
    48ee:	fc 01       	movw	r30, r24
    48f0:	30 8f       	std	Z+24, r19	; 0x18
    48f2:	27 8b       	std	Z+23, r18	; 0x17
    48f4:	07 c0       	rjmp	.+14     	; 0x4904 <prvAllocateTCBAndStack+0x70>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    48f6:	8b 81       	ldd	r24, Y+3	; 0x03
    48f8:	9c 81       	ldd	r25, Y+4	; 0x04
    48fa:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <vPortFree>
    48fe:	02 c0       	rjmp	.+4      	; 0x4904 <prvAllocateTCBAndStack+0x70>
			}
		}
		else
		{
			pxNewTCB = NULL;
    4900:	1a 82       	std	Y+2, r1	; 0x02
    4902:	19 82       	std	Y+1, r1	; 0x01
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
		}
		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
	}

	return pxNewTCB;
    4904:	89 81       	ldd	r24, Y+1	; 0x01
    4906:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4908:	28 96       	adiw	r28, 0x08	; 8
    490a:	0f b6       	in	r0, 0x3f	; 63
    490c:	f8 94       	cli
    490e:	de bf       	out	0x3e, r29	; 62
    4910:	0f be       	out	0x3f, r0	; 63
    4912:	cd bf       	out	0x3d, r28	; 61
    4914:	df 91       	pop	r29
    4916:	cf 91       	pop	r28
    4918:	08 95       	ret

0000491a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    491a:	cf 93       	push	r28
    491c:	df 93       	push	r29
    491e:	00 d0       	rcall	.+0      	; 0x4920 <prvDeleteTCB+0x6>
    4920:	cd b7       	in	r28, 0x3d	; 61
    4922:	de b7       	in	r29, 0x3e	; 62
    4924:	9a 83       	std	Y+2, r25	; 0x02
    4926:	89 83       	std	Y+1, r24	; 0x01
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
    4928:	89 81       	ldd	r24, Y+1	; 0x01
    492a:	9a 81       	ldd	r25, Y+2	; 0x02
    492c:	fc 01       	movw	r30, r24
    492e:	87 89       	ldd	r24, Z+23	; 0x17
    4930:	90 8d       	ldd	r25, Z+24	; 0x18
    4932:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
    4936:	89 81       	ldd	r24, Y+1	; 0x01
    4938:	9a 81       	ldd	r25, Y+2	; 0x02
    493a:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <vPortFree>
	}
    493e:	0f 90       	pop	r0
    4940:	0f 90       	pop	r0
    4942:	df 91       	pop	r29
    4944:	cf 91       	pop	r28
    4946:	08 95       	ret

00004948 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4948:	cf 93       	push	r28
    494a:	df 93       	push	r29
    494c:	00 d0       	rcall	.+0      	; 0x494e <prvResetNextTaskUnblockTime+0x6>
    494e:	cd b7       	in	r28, 0x3d	; 61
    4950:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4952:	80 91 36 05 	lds	r24, 0x0536
    4956:	90 91 37 05 	lds	r25, 0x0537
    495a:	fc 01       	movw	r30, r24
    495c:	80 81       	ld	r24, Z
    495e:	88 23       	and	r24, r24
    4960:	39 f4       	brne	.+14     	; 0x4970 <prvResetNextTaskUnblockTime+0x28>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    4962:	8f ef       	ldi	r24, 0xFF	; 255
    4964:	9f ef       	ldi	r25, 0xFF	; 255
    4966:	90 93 57 05 	sts	0x0557, r25
    496a:	80 93 56 05 	sts	0x0556, r24
    496e:	15 c0       	rjmp	.+42     	; 0x499a <prvResetNextTaskUnblockTime+0x52>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    4970:	80 91 36 05 	lds	r24, 0x0536
    4974:	90 91 37 05 	lds	r25, 0x0537
    4978:	fc 01       	movw	r30, r24
    497a:	85 81       	ldd	r24, Z+5	; 0x05
    497c:	96 81       	ldd	r25, Z+6	; 0x06
    497e:	fc 01       	movw	r30, r24
    4980:	86 81       	ldd	r24, Z+6	; 0x06
    4982:	97 81       	ldd	r25, Z+7	; 0x07
    4984:	9a 83       	std	Y+2, r25	; 0x02
    4986:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    4988:	89 81       	ldd	r24, Y+1	; 0x01
    498a:	9a 81       	ldd	r25, Y+2	; 0x02
    498c:	fc 01       	movw	r30, r24
    498e:	82 81       	ldd	r24, Z+2	; 0x02
    4990:	93 81       	ldd	r25, Z+3	; 0x03
    4992:	90 93 57 05 	sts	0x0557, r25
    4996:	80 93 56 05 	sts	0x0556, r24
	}
}
    499a:	0f 90       	pop	r0
    499c:	0f 90       	pop	r0
    499e:	df 91       	pop	r29
    49a0:	cf 91       	pop	r28
    49a2:	08 95       	ret

000049a4 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    49a4:	cf 93       	push	r28
    49a6:	df 93       	push	r29
    49a8:	00 d0       	rcall	.+0      	; 0x49aa <uxTaskResetEventItemValue+0x6>
    49aa:	cd b7       	in	r28, 0x3d	; 61
    49ac:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    49ae:	80 91 fe 04 	lds	r24, 0x04FE
    49b2:	90 91 ff 04 	lds	r25, 0x04FF
    49b6:	fc 01       	movw	r30, r24
    49b8:	84 85       	ldd	r24, Z+12	; 0x0c
    49ba:	95 85       	ldd	r25, Z+13	; 0x0d
    49bc:	9a 83       	std	Y+2, r25	; 0x02
    49be:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    49c0:	80 91 fe 04 	lds	r24, 0x04FE
    49c4:	90 91 ff 04 	lds	r25, 0x04FF
    49c8:	20 91 fe 04 	lds	r18, 0x04FE
    49cc:	30 91 ff 04 	lds	r19, 0x04FF
    49d0:	f9 01       	movw	r30, r18
    49d2:	26 89       	ldd	r18, Z+22	; 0x16
    49d4:	22 2f       	mov	r18, r18
    49d6:	30 e0       	ldi	r19, 0x00	; 0
    49d8:	44 e0       	ldi	r20, 0x04	; 4
    49da:	50 e0       	ldi	r21, 0x00	; 0
    49dc:	ba 01       	movw	r22, r20
    49de:	62 1b       	sub	r22, r18
    49e0:	73 0b       	sbc	r23, r19
    49e2:	9b 01       	movw	r18, r22
    49e4:	fc 01       	movw	r30, r24
    49e6:	35 87       	std	Z+13, r19	; 0x0d
    49e8:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
    49ea:	89 81       	ldd	r24, Y+1	; 0x01
    49ec:	9a 81       	ldd	r25, Y+2	; 0x02
}
    49ee:	0f 90       	pop	r0
    49f0:	0f 90       	pop	r0
    49f2:	df 91       	pop	r29
    49f4:	cf 91       	pop	r28
    49f6:	08 95       	ret

000049f8 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    49f8:	cf 93       	push	r28
    49fa:	df 93       	push	r29
    49fc:	cd b7       	in	r28, 0x3d	; 61
    49fe:	de b7       	in	r29, 0x3e	; 62
    4a00:	29 97       	sbiw	r28, 0x09	; 9
    4a02:	0f b6       	in	r0, 0x3f	; 63
    4a04:	f8 94       	cli
    4a06:	de bf       	out	0x3e, r29	; 62
    4a08:	0f be       	out	0x3f, r0	; 63
    4a0a:	cd bf       	out	0x3d, r28	; 61
    4a0c:	8f 83       	std	Y+7, r24	; 0x07
    4a0e:	79 87       	std	Y+9, r23	; 0x09
    4a10:	68 87       	std	Y+8, r22	; 0x08
	TickType_t xTimeToWake;
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    4a12:	0f b6       	in	r0, 0x3f	; 63
    4a14:	f8 94       	cli
    4a16:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    4a18:	80 91 fe 04 	lds	r24, 0x04FE
    4a1c:	90 91 ff 04 	lds	r25, 0x04FF
    4a20:	fc 01       	movw	r30, r24
    4a22:	81 a1       	ldd	r24, Z+33	; 0x21
    4a24:	92 a1       	ldd	r25, Z+34	; 0x22
    4a26:	a3 a1       	ldd	r26, Z+35	; 0x23
    4a28:	b4 a1       	ldd	r27, Z+36	; 0x24
    4a2a:	89 2b       	or	r24, r25
    4a2c:	8a 2b       	or	r24, r26
    4a2e:	8b 2b       	or	r24, r27
    4a30:	11 f5       	brne	.+68     	; 0x4a76 <ulTaskNotifyTake+0x7e>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    4a32:	80 91 fe 04 	lds	r24, 0x04FE
    4a36:	90 91 ff 04 	lds	r25, 0x04FF
    4a3a:	21 e0       	ldi	r18, 0x01	; 1
    4a3c:	fc 01       	movw	r30, r24
    4a3e:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    4a40:	88 85       	ldd	r24, Y+8	; 0x08
    4a42:	99 85       	ldd	r25, Y+9	; 0x09
    4a44:	89 2b       	or	r24, r25
    4a46:	b9 f0       	breq	.+46     	; 0x4a76 <ulTaskNotifyTake+0x7e>
				{
					/* The task is going to block.  First it must be removed
					from the ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4a48:	80 91 fe 04 	lds	r24, 0x04FE
    4a4c:	90 91 ff 04 	lds	r25, 0x04FF
    4a50:	02 96       	adiw	r24, 0x02	; 2
    4a52:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>
					{
							/* Calculate the time at which the task should be
							woken if the event does not occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    4a56:	20 91 4e 05 	lds	r18, 0x054E
    4a5a:	30 91 4f 05 	lds	r19, 0x054F
    4a5e:	88 85       	ldd	r24, Y+8	; 0x08
    4a60:	99 85       	ldd	r25, Y+9	; 0x09
    4a62:	82 0f       	add	r24, r18
    4a64:	93 1f       	adc	r25, r19
    4a66:	9a 83       	std	Y+2, r25	; 0x02
    4a68:	89 83       	std	Y+1, r24	; 0x01
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    4a6a:	89 81       	ldd	r24, Y+1	; 0x01
    4a6c:	9a 81       	ldd	r25, Y+2	; 0x02
    4a6e:	0e 94 00 24 	call	0x4800	; 0x4800 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4a72:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4a76:	0f 90       	pop	r0
    4a78:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4a7a:	0f b6       	in	r0, 0x3f	; 63
    4a7c:	f8 94       	cli
    4a7e:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    4a80:	80 91 fe 04 	lds	r24, 0x04FE
    4a84:	90 91 ff 04 	lds	r25, 0x04FF
    4a88:	fc 01       	movw	r30, r24
    4a8a:	81 a1       	ldd	r24, Z+33	; 0x21
    4a8c:	92 a1       	ldd	r25, Z+34	; 0x22
    4a8e:	a3 a1       	ldd	r26, Z+35	; 0x23
    4a90:	b4 a1       	ldd	r27, Z+36	; 0x24
    4a92:	8b 83       	std	Y+3, r24	; 0x03
    4a94:	9c 83       	std	Y+4, r25	; 0x04
    4a96:	ad 83       	std	Y+5, r26	; 0x05
    4a98:	be 83       	std	Y+6, r27	; 0x06

			if( ulReturn != 0UL )
    4a9a:	8b 81       	ldd	r24, Y+3	; 0x03
    4a9c:	9c 81       	ldd	r25, Y+4	; 0x04
    4a9e:	ad 81       	ldd	r26, Y+5	; 0x05
    4aa0:	be 81       	ldd	r27, Y+6	; 0x06
    4aa2:	89 2b       	or	r24, r25
    4aa4:	8a 2b       	or	r24, r26
    4aa6:	8b 2b       	or	r24, r27
    4aa8:	f1 f0       	breq	.+60     	; 0x4ae6 <ulTaskNotifyTake+0xee>
			{
				if( xClearCountOnExit != pdFALSE )
    4aaa:	8f 81       	ldd	r24, Y+7	; 0x07
    4aac:	88 23       	and	r24, r24
    4aae:	51 f0       	breq	.+20     	; 0x4ac4 <ulTaskNotifyTake+0xcc>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    4ab0:	80 91 fe 04 	lds	r24, 0x04FE
    4ab4:	90 91 ff 04 	lds	r25, 0x04FF
    4ab8:	fc 01       	movw	r30, r24
    4aba:	11 a2       	std	Z+33, r1	; 0x21
    4abc:	12 a2       	std	Z+34, r1	; 0x22
    4abe:	13 a2       	std	Z+35, r1	; 0x23
    4ac0:	14 a2       	std	Z+36, r1	; 0x24
    4ac2:	11 c0       	rjmp	.+34     	; 0x4ae6 <ulTaskNotifyTake+0xee>
				}
				else
				{
					( pxCurrentTCB->ulNotifiedValue )--;
    4ac4:	20 91 fe 04 	lds	r18, 0x04FE
    4ac8:	30 91 ff 04 	lds	r19, 0x04FF
    4acc:	f9 01       	movw	r30, r18
    4ace:	81 a1       	ldd	r24, Z+33	; 0x21
    4ad0:	92 a1       	ldd	r25, Z+34	; 0x22
    4ad2:	a3 a1       	ldd	r26, Z+35	; 0x23
    4ad4:	b4 a1       	ldd	r27, Z+36	; 0x24
    4ad6:	01 97       	sbiw	r24, 0x01	; 1
    4ad8:	a1 09       	sbc	r26, r1
    4ada:	b1 09       	sbc	r27, r1
    4adc:	f9 01       	movw	r30, r18
    4ade:	81 a3       	std	Z+33, r24	; 0x21
    4ae0:	92 a3       	std	Z+34, r25	; 0x22
    4ae2:	a3 a3       	std	Z+35, r26	; 0x23
    4ae4:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    4ae6:	80 91 fe 04 	lds	r24, 0x04FE
    4aea:	90 91 ff 04 	lds	r25, 0x04FF
    4aee:	fc 01       	movw	r30, r24
    4af0:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    4af2:	0f 90       	pop	r0
    4af4:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    4af6:	8b 81       	ldd	r24, Y+3	; 0x03
    4af8:	9c 81       	ldd	r25, Y+4	; 0x04
    4afa:	ad 81       	ldd	r26, Y+5	; 0x05
    4afc:	be 81       	ldd	r27, Y+6	; 0x06
	}
    4afe:	bc 01       	movw	r22, r24
    4b00:	cd 01       	movw	r24, r26
    4b02:	29 96       	adiw	r28, 0x09	; 9
    4b04:	0f b6       	in	r0, 0x3f	; 63
    4b06:	f8 94       	cli
    4b08:	de bf       	out	0x3e, r29	; 62
    4b0a:	0f be       	out	0x3f, r0	; 63
    4b0c:	cd bf       	out	0x3d, r28	; 61
    4b0e:	df 91       	pop	r29
    4b10:	cf 91       	pop	r28
    4b12:	08 95       	ret

00004b14 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    4b14:	ef 92       	push	r14
    4b16:	ff 92       	push	r15
    4b18:	0f 93       	push	r16
    4b1a:	1f 93       	push	r17
    4b1c:	cf 93       	push	r28
    4b1e:	df 93       	push	r29
    4b20:	cd b7       	in	r28, 0x3d	; 61
    4b22:	de b7       	in	r29, 0x3e	; 62
    4b24:	2f 97       	sbiw	r28, 0x0f	; 15
    4b26:	0f b6       	in	r0, 0x3f	; 63
    4b28:	f8 94       	cli
    4b2a:	de bf       	out	0x3e, r29	; 62
    4b2c:	0f be       	out	0x3f, r0	; 63
    4b2e:	cd bf       	out	0x3d, r28	; 61
    4b30:	6c 83       	std	Y+4, r22	; 0x04
    4b32:	7d 83       	std	Y+5, r23	; 0x05
    4b34:	8e 83       	std	Y+6, r24	; 0x06
    4b36:	9f 83       	std	Y+7, r25	; 0x07
    4b38:	28 87       	std	Y+8, r18	; 0x08
    4b3a:	39 87       	std	Y+9, r19	; 0x09
    4b3c:	4a 87       	std	Y+10, r20	; 0x0a
    4b3e:	5b 87       	std	Y+11, r21	; 0x0b
    4b40:	1d 87       	std	Y+13, r17	; 0x0d
    4b42:	0c 87       	std	Y+12, r16	; 0x0c
    4b44:	ff 86       	std	Y+15, r15	; 0x0f
    4b46:	ee 86       	std	Y+14, r14	; 0x0e
	TickType_t xTimeToWake;
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    4b48:	0f b6       	in	r0, 0x3f	; 63
    4b4a:	f8 94       	cli
    4b4c:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->eNotifyState != eNotified )
    4b4e:	80 91 fe 04 	lds	r24, 0x04FE
    4b52:	90 91 ff 04 	lds	r25, 0x04FF
    4b56:	fc 01       	movw	r30, r24
    4b58:	85 a1       	ldd	r24, Z+37	; 0x25
    4b5a:	82 30       	cpi	r24, 0x02	; 2
    4b5c:	e1 f1       	breq	.+120    	; 0x4bd6 <xTaskNotifyWait+0xc2>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    4b5e:	60 91 fe 04 	lds	r22, 0x04FE
    4b62:	70 91 ff 04 	lds	r23, 0x04FF
    4b66:	fb 01       	movw	r30, r22
    4b68:	21 a1       	ldd	r18, Z+33	; 0x21
    4b6a:	32 a1       	ldd	r19, Z+34	; 0x22
    4b6c:	43 a1       	ldd	r20, Z+35	; 0x23
    4b6e:	54 a1       	ldd	r21, Z+36	; 0x24
    4b70:	8c 81       	ldd	r24, Y+4	; 0x04
    4b72:	9d 81       	ldd	r25, Y+5	; 0x05
    4b74:	ae 81       	ldd	r26, Y+6	; 0x06
    4b76:	bf 81       	ldd	r27, Y+7	; 0x07
    4b78:	80 95       	com	r24
    4b7a:	90 95       	com	r25
    4b7c:	a0 95       	com	r26
    4b7e:	b0 95       	com	r27
    4b80:	82 23       	and	r24, r18
    4b82:	93 23       	and	r25, r19
    4b84:	a4 23       	and	r26, r20
    4b86:	b5 23       	and	r27, r21
    4b88:	fb 01       	movw	r30, r22
    4b8a:	81 a3       	std	Z+33, r24	; 0x21
    4b8c:	92 a3       	std	Z+34, r25	; 0x22
    4b8e:	a3 a3       	std	Z+35, r26	; 0x23
    4b90:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    4b92:	80 91 fe 04 	lds	r24, 0x04FE
    4b96:	90 91 ff 04 	lds	r25, 0x04FF
    4b9a:	21 e0       	ldi	r18, 0x01	; 1
    4b9c:	fc 01       	movw	r30, r24
    4b9e:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    4ba0:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ba2:	9f 85       	ldd	r25, Y+15	; 0x0f
    4ba4:	89 2b       	or	r24, r25
    4ba6:	b9 f0       	breq	.+46     	; 0x4bd6 <xTaskNotifyWait+0xc2>
				{
					/* The task is going to block.  First it must be removed
					from the	ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4ba8:	80 91 fe 04 	lds	r24, 0x04FE
    4bac:	90 91 ff 04 	lds	r25, 0x04FF
    4bb0:	02 96       	adiw	r24, 0x02	; 2
    4bb2:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>
					{
							/* Calculate the time at which the task should be
							woken if the event does not occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    4bb6:	20 91 4e 05 	lds	r18, 0x054E
    4bba:	30 91 4f 05 	lds	r19, 0x054F
    4bbe:	8e 85       	ldd	r24, Y+14	; 0x0e
    4bc0:	9f 85       	ldd	r25, Y+15	; 0x0f
    4bc2:	82 0f       	add	r24, r18
    4bc4:	93 1f       	adc	r25, r19
    4bc6:	9b 83       	std	Y+3, r25	; 0x03
    4bc8:	8a 83       	std	Y+2, r24	; 0x02
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    4bca:	8a 81       	ldd	r24, Y+2	; 0x02
    4bcc:	9b 81       	ldd	r25, Y+3	; 0x03
    4bce:	0e 94 00 24 	call	0x4800	; 0x4800 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4bd2:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4bd6:	0f 90       	pop	r0
    4bd8:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4bda:	0f b6       	in	r0, 0x3f	; 63
    4bdc:	f8 94       	cli
    4bde:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    4be0:	8c 85       	ldd	r24, Y+12	; 0x0c
    4be2:	9d 85       	ldd	r25, Y+13	; 0x0d
    4be4:	89 2b       	or	r24, r25
    4be6:	81 f0       	breq	.+32     	; 0x4c08 <xTaskNotifyWait+0xf4>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    4be8:	80 91 fe 04 	lds	r24, 0x04FE
    4bec:	90 91 ff 04 	lds	r25, 0x04FF
    4bf0:	fc 01       	movw	r30, r24
    4bf2:	81 a1       	ldd	r24, Z+33	; 0x21
    4bf4:	92 a1       	ldd	r25, Z+34	; 0x22
    4bf6:	a3 a1       	ldd	r26, Z+35	; 0x23
    4bf8:	b4 a1       	ldd	r27, Z+36	; 0x24
    4bfa:	2c 85       	ldd	r18, Y+12	; 0x0c
    4bfc:	3d 85       	ldd	r19, Y+13	; 0x0d
    4bfe:	f9 01       	movw	r30, r18
    4c00:	80 83       	st	Z, r24
    4c02:	91 83       	std	Z+1, r25	; 0x01
    4c04:	a2 83       	std	Z+2, r26	; 0x02
    4c06:	b3 83       	std	Z+3, r27	; 0x03

			/* If eNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
    4c08:	80 91 fe 04 	lds	r24, 0x04FE
    4c0c:	90 91 ff 04 	lds	r25, 0x04FF
    4c10:	fc 01       	movw	r30, r24
    4c12:	85 a1       	ldd	r24, Z+37	; 0x25
    4c14:	81 30       	cpi	r24, 0x01	; 1
    4c16:	11 f4       	brne	.+4      	; 0x4c1c <xTaskNotifyWait+0x108>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4c18:	19 82       	std	Y+1, r1	; 0x01
    4c1a:	1c c0       	rjmp	.+56     	; 0x4c54 <xTaskNotifyWait+0x140>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    4c1c:	60 91 fe 04 	lds	r22, 0x04FE
    4c20:	70 91 ff 04 	lds	r23, 0x04FF
    4c24:	fb 01       	movw	r30, r22
    4c26:	21 a1       	ldd	r18, Z+33	; 0x21
    4c28:	32 a1       	ldd	r19, Z+34	; 0x22
    4c2a:	43 a1       	ldd	r20, Z+35	; 0x23
    4c2c:	54 a1       	ldd	r21, Z+36	; 0x24
    4c2e:	88 85       	ldd	r24, Y+8	; 0x08
    4c30:	99 85       	ldd	r25, Y+9	; 0x09
    4c32:	aa 85       	ldd	r26, Y+10	; 0x0a
    4c34:	bb 85       	ldd	r27, Y+11	; 0x0b
    4c36:	80 95       	com	r24
    4c38:	90 95       	com	r25
    4c3a:	a0 95       	com	r26
    4c3c:	b0 95       	com	r27
    4c3e:	82 23       	and	r24, r18
    4c40:	93 23       	and	r25, r19
    4c42:	a4 23       	and	r26, r20
    4c44:	b5 23       	and	r27, r21
    4c46:	fb 01       	movw	r30, r22
    4c48:	81 a3       	std	Z+33, r24	; 0x21
    4c4a:	92 a3       	std	Z+34, r25	; 0x22
    4c4c:	a3 a3       	std	Z+35, r26	; 0x23
    4c4e:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    4c50:	81 e0       	ldi	r24, 0x01	; 1
    4c52:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    4c54:	80 91 fe 04 	lds	r24, 0x04FE
    4c58:	90 91 ff 04 	lds	r25, 0x04FF
    4c5c:	fc 01       	movw	r30, r24
    4c5e:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    4c60:	0f 90       	pop	r0
    4c62:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4c64:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4c66:	2f 96       	adiw	r28, 0x0f	; 15
    4c68:	0f b6       	in	r0, 0x3f	; 63
    4c6a:	f8 94       	cli
    4c6c:	de bf       	out	0x3e, r29	; 62
    4c6e:	0f be       	out	0x3f, r0	; 63
    4c70:	cd bf       	out	0x3d, r28	; 61
    4c72:	df 91       	pop	r29
    4c74:	cf 91       	pop	r28
    4c76:	1f 91       	pop	r17
    4c78:	0f 91       	pop	r16
    4c7a:	ff 90       	pop	r15
    4c7c:	ef 90       	pop	r14
    4c7e:	08 95       	ret

00004c80 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    4c80:	0f 93       	push	r16
    4c82:	1f 93       	push	r17
    4c84:	cf 93       	push	r28
    4c86:	df 93       	push	r29
    4c88:	cd b7       	in	r28, 0x3d	; 61
    4c8a:	de b7       	in	r29, 0x3e	; 62
    4c8c:	2d 97       	sbiw	r28, 0x0d	; 13
    4c8e:	0f b6       	in	r0, 0x3f	; 63
    4c90:	f8 94       	cli
    4c92:	de bf       	out	0x3e, r29	; 62
    4c94:	0f be       	out	0x3f, r0	; 63
    4c96:	cd bf       	out	0x3d, r28	; 61
    4c98:	9e 83       	std	Y+6, r25	; 0x06
    4c9a:	8d 83       	std	Y+5, r24	; 0x05
    4c9c:	4f 83       	std	Y+7, r20	; 0x07
    4c9e:	58 87       	std	Y+8, r21	; 0x08
    4ca0:	69 87       	std	Y+9, r22	; 0x09
    4ca2:	7a 87       	std	Y+10, r23	; 0x0a
    4ca4:	2b 87       	std	Y+11, r18	; 0x0b
    4ca6:	1d 87       	std	Y+13, r17	; 0x0d
    4ca8:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    4caa:	81 e0       	ldi	r24, 0x01	; 1
    4cac:	89 83       	std	Y+1, r24	; 0x01

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
    4cae:	8d 81       	ldd	r24, Y+5	; 0x05
    4cb0:	9e 81       	ldd	r25, Y+6	; 0x06
    4cb2:	9b 83       	std	Y+3, r25	; 0x03
    4cb4:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    4cb6:	0f b6       	in	r0, 0x3f	; 63
    4cb8:	f8 94       	cli
    4cba:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    4cbc:	8c 85       	ldd	r24, Y+12	; 0x0c
    4cbe:	9d 85       	ldd	r25, Y+13	; 0x0d
    4cc0:	89 2b       	or	r24, r25
    4cc2:	71 f0       	breq	.+28     	; 0x4ce0 <xTaskGenericNotify+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4cc4:	8a 81       	ldd	r24, Y+2	; 0x02
    4cc6:	9b 81       	ldd	r25, Y+3	; 0x03
    4cc8:	fc 01       	movw	r30, r24
    4cca:	81 a1       	ldd	r24, Z+33	; 0x21
    4ccc:	92 a1       	ldd	r25, Z+34	; 0x22
    4cce:	a3 a1       	ldd	r26, Z+35	; 0x23
    4cd0:	b4 a1       	ldd	r27, Z+36	; 0x24
    4cd2:	2c 85       	ldd	r18, Y+12	; 0x0c
    4cd4:	3d 85       	ldd	r19, Y+13	; 0x0d
    4cd6:	f9 01       	movw	r30, r18
    4cd8:	80 83       	st	Z, r24
    4cda:	91 83       	std	Z+1, r25	; 0x01
    4cdc:	a2 83       	std	Z+2, r26	; 0x02
    4cde:	b3 83       	std	Z+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    4ce0:	8a 81       	ldd	r24, Y+2	; 0x02
    4ce2:	9b 81       	ldd	r25, Y+3	; 0x03
    4ce4:	fc 01       	movw	r30, r24
    4ce6:	85 a1       	ldd	r24, Z+37	; 0x25
    4ce8:	8c 83       	std	Y+4, r24	; 0x04

			pxTCB->eNotifyState = eNotified;
    4cea:	8a 81       	ldd	r24, Y+2	; 0x02
    4cec:	9b 81       	ldd	r25, Y+3	; 0x03
    4cee:	22 e0       	ldi	r18, 0x02	; 2
    4cf0:	fc 01       	movw	r30, r24
    4cf2:	25 a3       	std	Z+37, r18	; 0x25

			switch( eAction )
    4cf4:	8b 85       	ldd	r24, Y+11	; 0x0b
    4cf6:	88 2f       	mov	r24, r24
    4cf8:	90 e0       	ldi	r25, 0x00	; 0
    4cfa:	82 30       	cpi	r24, 0x02	; 2
    4cfc:	91 05       	cpc	r25, r1
    4cfe:	31 f1       	breq	.+76     	; 0x4d4c <xTaskGenericNotify+0xcc>
    4d00:	83 30       	cpi	r24, 0x03	; 3
    4d02:	91 05       	cpc	r25, r1
    4d04:	34 f4       	brge	.+12     	; 0x4d12 <xTaskGenericNotify+0x92>
    4d06:	00 97       	sbiw	r24, 0x00	; 0
    4d08:	09 f4       	brne	.+2      	; 0x4d0c <xTaskGenericNotify+0x8c>
    4d0a:	4f c0       	rjmp	.+158    	; 0x4daa <xTaskGenericNotify+0x12a>
    4d0c:	01 97       	sbiw	r24, 0x01	; 1
    4d0e:	39 f0       	breq	.+14     	; 0x4d1e <xTaskGenericNotify+0x9e>
    4d10:	4d c0       	rjmp	.+154    	; 0x4dac <xTaskGenericNotify+0x12c>
    4d12:	83 30       	cpi	r24, 0x03	; 3
    4d14:	91 05       	cpc	r25, r1
    4d16:	61 f1       	breq	.+88     	; 0x4d70 <xTaskGenericNotify+0xf0>
    4d18:	04 97       	sbiw	r24, 0x04	; 4
    4d1a:	b1 f1       	breq	.+108    	; 0x4d88 <xTaskGenericNotify+0x108>
    4d1c:	47 c0       	rjmp	.+142    	; 0x4dac <xTaskGenericNotify+0x12c>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4d1e:	8a 81       	ldd	r24, Y+2	; 0x02
    4d20:	9b 81       	ldd	r25, Y+3	; 0x03
    4d22:	fc 01       	movw	r30, r24
    4d24:	21 a1       	ldd	r18, Z+33	; 0x21
    4d26:	32 a1       	ldd	r19, Z+34	; 0x22
    4d28:	43 a1       	ldd	r20, Z+35	; 0x23
    4d2a:	54 a1       	ldd	r21, Z+36	; 0x24
    4d2c:	8f 81       	ldd	r24, Y+7	; 0x07
    4d2e:	98 85       	ldd	r25, Y+8	; 0x08
    4d30:	a9 85       	ldd	r26, Y+9	; 0x09
    4d32:	ba 85       	ldd	r27, Y+10	; 0x0a
    4d34:	82 2b       	or	r24, r18
    4d36:	93 2b       	or	r25, r19
    4d38:	a4 2b       	or	r26, r20
    4d3a:	b5 2b       	or	r27, r21
    4d3c:	2a 81       	ldd	r18, Y+2	; 0x02
    4d3e:	3b 81       	ldd	r19, Y+3	; 0x03
    4d40:	f9 01       	movw	r30, r18
    4d42:	81 a3       	std	Z+33, r24	; 0x21
    4d44:	92 a3       	std	Z+34, r25	; 0x22
    4d46:	a3 a3       	std	Z+35, r26	; 0x23
    4d48:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    4d4a:	30 c0       	rjmp	.+96     	; 0x4dac <xTaskGenericNotify+0x12c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4d4c:	8a 81       	ldd	r24, Y+2	; 0x02
    4d4e:	9b 81       	ldd	r25, Y+3	; 0x03
    4d50:	fc 01       	movw	r30, r24
    4d52:	81 a1       	ldd	r24, Z+33	; 0x21
    4d54:	92 a1       	ldd	r25, Z+34	; 0x22
    4d56:	a3 a1       	ldd	r26, Z+35	; 0x23
    4d58:	b4 a1       	ldd	r27, Z+36	; 0x24
    4d5a:	01 96       	adiw	r24, 0x01	; 1
    4d5c:	a1 1d       	adc	r26, r1
    4d5e:	b1 1d       	adc	r27, r1
    4d60:	2a 81       	ldd	r18, Y+2	; 0x02
    4d62:	3b 81       	ldd	r19, Y+3	; 0x03
    4d64:	f9 01       	movw	r30, r18
    4d66:	81 a3       	std	Z+33, r24	; 0x21
    4d68:	92 a3       	std	Z+34, r25	; 0x22
    4d6a:	a3 a3       	std	Z+35, r26	; 0x23
    4d6c:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    4d6e:	1e c0       	rjmp	.+60     	; 0x4dac <xTaskGenericNotify+0x12c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4d70:	2a 81       	ldd	r18, Y+2	; 0x02
    4d72:	3b 81       	ldd	r19, Y+3	; 0x03
    4d74:	8f 81       	ldd	r24, Y+7	; 0x07
    4d76:	98 85       	ldd	r25, Y+8	; 0x08
    4d78:	a9 85       	ldd	r26, Y+9	; 0x09
    4d7a:	ba 85       	ldd	r27, Y+10	; 0x0a
    4d7c:	f9 01       	movw	r30, r18
    4d7e:	81 a3       	std	Z+33, r24	; 0x21
    4d80:	92 a3       	std	Z+34, r25	; 0x22
    4d82:	a3 a3       	std	Z+35, r26	; 0x23
    4d84:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    4d86:	12 c0       	rjmp	.+36     	; 0x4dac <xTaskGenericNotify+0x12c>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    4d88:	8c 81       	ldd	r24, Y+4	; 0x04
    4d8a:	82 30       	cpi	r24, 0x02	; 2
    4d8c:	61 f0       	breq	.+24     	; 0x4da6 <xTaskGenericNotify+0x126>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4d8e:	2a 81       	ldd	r18, Y+2	; 0x02
    4d90:	3b 81       	ldd	r19, Y+3	; 0x03
    4d92:	8f 81       	ldd	r24, Y+7	; 0x07
    4d94:	98 85       	ldd	r25, Y+8	; 0x08
    4d96:	a9 85       	ldd	r26, Y+9	; 0x09
    4d98:	ba 85       	ldd	r27, Y+10	; 0x0a
    4d9a:	f9 01       	movw	r30, r18
    4d9c:	81 a3       	std	Z+33, r24	; 0x21
    4d9e:	92 a3       	std	Z+34, r25	; 0x22
    4da0:	a3 a3       	std	Z+35, r26	; 0x23
    4da2:	b4 a3       	std	Z+36, r27	; 0x24
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    4da4:	03 c0       	rjmp	.+6      	; 0x4dac <xTaskGenericNotify+0x12c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4da6:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    4da8:	01 c0       	rjmp	.+2      	; 0x4dac <xTaskGenericNotify+0x12c>

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
    4daa:	00 00       	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    4dac:	8c 81       	ldd	r24, Y+4	; 0x04
    4dae:	81 30       	cpi	r24, 0x01	; 1
    4db0:	d1 f5       	brne	.+116    	; 0x4e26 <xTaskGenericNotify+0x1a6>
			{
				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    4db2:	8a 81       	ldd	r24, Y+2	; 0x02
    4db4:	9b 81       	ldd	r25, Y+3	; 0x03
    4db6:	02 96       	adiw	r24, 0x02	; 2
    4db8:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    4dbc:	8a 81       	ldd	r24, Y+2	; 0x02
    4dbe:	9b 81       	ldd	r25, Y+3	; 0x03
    4dc0:	fc 01       	movw	r30, r24
    4dc2:	96 89       	ldd	r25, Z+22	; 0x16
    4dc4:	80 91 50 05 	lds	r24, 0x0550
    4dc8:	89 17       	cp	r24, r25
    4dca:	30 f4       	brcc	.+12     	; 0x4dd8 <xTaskGenericNotify+0x158>
    4dcc:	8a 81       	ldd	r24, Y+2	; 0x02
    4dce:	9b 81       	ldd	r25, Y+3	; 0x03
    4dd0:	fc 01       	movw	r30, r24
    4dd2:	86 89       	ldd	r24, Z+22	; 0x16
    4dd4:	80 93 50 05 	sts	0x0550, r24
    4dd8:	8a 81       	ldd	r24, Y+2	; 0x02
    4dda:	9b 81       	ldd	r25, Y+3	; 0x03
    4ddc:	ac 01       	movw	r20, r24
    4dde:	4e 5f       	subi	r20, 0xFE	; 254
    4de0:	5f 4f       	sbci	r21, 0xFF	; 255
    4de2:	8a 81       	ldd	r24, Y+2	; 0x02
    4de4:	9b 81       	ldd	r25, Y+3	; 0x03
    4de6:	fc 01       	movw	r30, r24
    4de8:	86 89       	ldd	r24, Z+22	; 0x16
    4dea:	28 2f       	mov	r18, r24
    4dec:	30 e0       	ldi	r19, 0x00	; 0
    4dee:	c9 01       	movw	r24, r18
    4df0:	88 0f       	add	r24, r24
    4df2:	99 1f       	adc	r25, r25
    4df4:	88 0f       	add	r24, r24
    4df6:	99 1f       	adc	r25, r25
    4df8:	88 0f       	add	r24, r24
    4dfa:	99 1f       	adc	r25, r25
    4dfc:	82 0f       	add	r24, r18
    4dfe:	93 1f       	adc	r25, r19
    4e00:	80 50       	subi	r24, 0x00	; 0
    4e02:	9b 4f       	sbci	r25, 0xFB	; 251
    4e04:	ba 01       	movw	r22, r20
    4e06:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4e0a:	8a 81       	ldd	r24, Y+2	; 0x02
    4e0c:	9b 81       	ldd	r25, Y+3	; 0x03
    4e0e:	fc 01       	movw	r30, r24
    4e10:	26 89       	ldd	r18, Z+22	; 0x16
    4e12:	80 91 fe 04 	lds	r24, 0x04FE
    4e16:	90 91 ff 04 	lds	r25, 0x04FF
    4e1a:	fc 01       	movw	r30, r24
    4e1c:	86 89       	ldd	r24, Z+22	; 0x16
    4e1e:	82 17       	cp	r24, r18
    4e20:	10 f4       	brcc	.+4      	; 0x4e26 <xTaskGenericNotify+0x1a6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    4e22:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4e26:	0f 90       	pop	r0
    4e28:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4e2a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4e2c:	2d 96       	adiw	r28, 0x0d	; 13
    4e2e:	0f b6       	in	r0, 0x3f	; 63
    4e30:	f8 94       	cli
    4e32:	de bf       	out	0x3e, r29	; 62
    4e34:	0f be       	out	0x3f, r0	; 63
    4e36:	cd bf       	out	0x3d, r28	; 61
    4e38:	df 91       	pop	r29
    4e3a:	cf 91       	pop	r28
    4e3c:	1f 91       	pop	r17
    4e3e:	0f 91       	pop	r16
    4e40:	08 95       	ret

00004e42 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4e42:	ef 92       	push	r14
    4e44:	ff 92       	push	r15
    4e46:	0f 93       	push	r16
    4e48:	1f 93       	push	r17
    4e4a:	cf 93       	push	r28
    4e4c:	df 93       	push	r29
    4e4e:	cd b7       	in	r28, 0x3d	; 61
    4e50:	de b7       	in	r29, 0x3e	; 62
    4e52:	60 97       	sbiw	r28, 0x10	; 16
    4e54:	0f b6       	in	r0, 0x3f	; 63
    4e56:	f8 94       	cli
    4e58:	de bf       	out	0x3e, r29	; 62
    4e5a:	0f be       	out	0x3f, r0	; 63
    4e5c:	cd bf       	out	0x3d, r28	; 61
    4e5e:	9f 83       	std	Y+7, r25	; 0x07
    4e60:	8e 83       	std	Y+6, r24	; 0x06
    4e62:	48 87       	std	Y+8, r20	; 0x08
    4e64:	59 87       	std	Y+9, r21	; 0x09
    4e66:	6a 87       	std	Y+10, r22	; 0x0a
    4e68:	7b 87       	std	Y+11, r23	; 0x0b
    4e6a:	2c 87       	std	Y+12, r18	; 0x0c
    4e6c:	1e 87       	std	Y+14, r17	; 0x0e
    4e6e:	0d 87       	std	Y+13, r16	; 0x0d
    4e70:	f8 8a       	std	Y+16, r15	; 0x10
    4e72:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    4e74:	81 e0       	ldi	r24, 0x01	; 1
    4e76:	89 83       	std	Y+1, r24	; 0x01
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    4e78:	8e 81       	ldd	r24, Y+6	; 0x06
    4e7a:	9f 81       	ldd	r25, Y+7	; 0x07
    4e7c:	9b 83       	std	Y+3, r25	; 0x03
    4e7e:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4e80:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( pulPreviousNotificationValue != NULL )
    4e82:	8d 85       	ldd	r24, Y+13	; 0x0d
    4e84:	9e 85       	ldd	r25, Y+14	; 0x0e
    4e86:	89 2b       	or	r24, r25
    4e88:	71 f0       	breq	.+28     	; 0x4ea6 <xTaskGenericNotifyFromISR+0x64>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4e8a:	8a 81       	ldd	r24, Y+2	; 0x02
    4e8c:	9b 81       	ldd	r25, Y+3	; 0x03
    4e8e:	fc 01       	movw	r30, r24
    4e90:	81 a1       	ldd	r24, Z+33	; 0x21
    4e92:	92 a1       	ldd	r25, Z+34	; 0x22
    4e94:	a3 a1       	ldd	r26, Z+35	; 0x23
    4e96:	b4 a1       	ldd	r27, Z+36	; 0x24
    4e98:	2d 85       	ldd	r18, Y+13	; 0x0d
    4e9a:	3e 85       	ldd	r19, Y+14	; 0x0e
    4e9c:	f9 01       	movw	r30, r18
    4e9e:	80 83       	st	Z, r24
    4ea0:	91 83       	std	Z+1, r25	; 0x01
    4ea2:	a2 83       	std	Z+2, r26	; 0x02
    4ea4:	b3 83       	std	Z+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    4ea6:	8a 81       	ldd	r24, Y+2	; 0x02
    4ea8:	9b 81       	ldd	r25, Y+3	; 0x03
    4eaa:	fc 01       	movw	r30, r24
    4eac:	85 a1       	ldd	r24, Z+37	; 0x25
    4eae:	8d 83       	std	Y+5, r24	; 0x05
			pxTCB->eNotifyState = eNotified;
    4eb0:	8a 81       	ldd	r24, Y+2	; 0x02
    4eb2:	9b 81       	ldd	r25, Y+3	; 0x03
    4eb4:	22 e0       	ldi	r18, 0x02	; 2
    4eb6:	fc 01       	movw	r30, r24
    4eb8:	25 a3       	std	Z+37, r18	; 0x25

			switch( eAction )
    4eba:	8c 85       	ldd	r24, Y+12	; 0x0c
    4ebc:	88 2f       	mov	r24, r24
    4ebe:	90 e0       	ldi	r25, 0x00	; 0
    4ec0:	82 30       	cpi	r24, 0x02	; 2
    4ec2:	91 05       	cpc	r25, r1
    4ec4:	31 f1       	breq	.+76     	; 0x4f12 <xTaskGenericNotifyFromISR+0xd0>
    4ec6:	83 30       	cpi	r24, 0x03	; 3
    4ec8:	91 05       	cpc	r25, r1
    4eca:	34 f4       	brge	.+12     	; 0x4ed8 <xTaskGenericNotifyFromISR+0x96>
    4ecc:	00 97       	sbiw	r24, 0x00	; 0
    4ece:	09 f4       	brne	.+2      	; 0x4ed2 <xTaskGenericNotifyFromISR+0x90>
    4ed0:	4f c0       	rjmp	.+158    	; 0x4f70 <xTaskGenericNotifyFromISR+0x12e>
    4ed2:	01 97       	sbiw	r24, 0x01	; 1
    4ed4:	39 f0       	breq	.+14     	; 0x4ee4 <xTaskGenericNotifyFromISR+0xa2>
    4ed6:	4d c0       	rjmp	.+154    	; 0x4f72 <xTaskGenericNotifyFromISR+0x130>
    4ed8:	83 30       	cpi	r24, 0x03	; 3
    4eda:	91 05       	cpc	r25, r1
    4edc:	61 f1       	breq	.+88     	; 0x4f36 <xTaskGenericNotifyFromISR+0xf4>
    4ede:	04 97       	sbiw	r24, 0x04	; 4
    4ee0:	b1 f1       	breq	.+108    	; 0x4f4e <xTaskGenericNotifyFromISR+0x10c>
    4ee2:	47 c0       	rjmp	.+142    	; 0x4f72 <xTaskGenericNotifyFromISR+0x130>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4ee4:	8a 81       	ldd	r24, Y+2	; 0x02
    4ee6:	9b 81       	ldd	r25, Y+3	; 0x03
    4ee8:	fc 01       	movw	r30, r24
    4eea:	21 a1       	ldd	r18, Z+33	; 0x21
    4eec:	32 a1       	ldd	r19, Z+34	; 0x22
    4eee:	43 a1       	ldd	r20, Z+35	; 0x23
    4ef0:	54 a1       	ldd	r21, Z+36	; 0x24
    4ef2:	88 85       	ldd	r24, Y+8	; 0x08
    4ef4:	99 85       	ldd	r25, Y+9	; 0x09
    4ef6:	aa 85       	ldd	r26, Y+10	; 0x0a
    4ef8:	bb 85       	ldd	r27, Y+11	; 0x0b
    4efa:	82 2b       	or	r24, r18
    4efc:	93 2b       	or	r25, r19
    4efe:	a4 2b       	or	r26, r20
    4f00:	b5 2b       	or	r27, r21
    4f02:	2a 81       	ldd	r18, Y+2	; 0x02
    4f04:	3b 81       	ldd	r19, Y+3	; 0x03
    4f06:	f9 01       	movw	r30, r18
    4f08:	81 a3       	std	Z+33, r24	; 0x21
    4f0a:	92 a3       	std	Z+34, r25	; 0x22
    4f0c:	a3 a3       	std	Z+35, r26	; 0x23
    4f0e:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    4f10:	30 c0       	rjmp	.+96     	; 0x4f72 <xTaskGenericNotifyFromISR+0x130>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4f12:	8a 81       	ldd	r24, Y+2	; 0x02
    4f14:	9b 81       	ldd	r25, Y+3	; 0x03
    4f16:	fc 01       	movw	r30, r24
    4f18:	81 a1       	ldd	r24, Z+33	; 0x21
    4f1a:	92 a1       	ldd	r25, Z+34	; 0x22
    4f1c:	a3 a1       	ldd	r26, Z+35	; 0x23
    4f1e:	b4 a1       	ldd	r27, Z+36	; 0x24
    4f20:	01 96       	adiw	r24, 0x01	; 1
    4f22:	a1 1d       	adc	r26, r1
    4f24:	b1 1d       	adc	r27, r1
    4f26:	2a 81       	ldd	r18, Y+2	; 0x02
    4f28:	3b 81       	ldd	r19, Y+3	; 0x03
    4f2a:	f9 01       	movw	r30, r18
    4f2c:	81 a3       	std	Z+33, r24	; 0x21
    4f2e:	92 a3       	std	Z+34, r25	; 0x22
    4f30:	a3 a3       	std	Z+35, r26	; 0x23
    4f32:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    4f34:	1e c0       	rjmp	.+60     	; 0x4f72 <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4f36:	2a 81       	ldd	r18, Y+2	; 0x02
    4f38:	3b 81       	ldd	r19, Y+3	; 0x03
    4f3a:	88 85       	ldd	r24, Y+8	; 0x08
    4f3c:	99 85       	ldd	r25, Y+9	; 0x09
    4f3e:	aa 85       	ldd	r26, Y+10	; 0x0a
    4f40:	bb 85       	ldd	r27, Y+11	; 0x0b
    4f42:	f9 01       	movw	r30, r18
    4f44:	81 a3       	std	Z+33, r24	; 0x21
    4f46:	92 a3       	std	Z+34, r25	; 0x22
    4f48:	a3 a3       	std	Z+35, r26	; 0x23
    4f4a:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    4f4c:	12 c0       	rjmp	.+36     	; 0x4f72 <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    4f4e:	8d 81       	ldd	r24, Y+5	; 0x05
    4f50:	82 30       	cpi	r24, 0x02	; 2
    4f52:	61 f0       	breq	.+24     	; 0x4f6c <xTaskGenericNotifyFromISR+0x12a>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4f54:	2a 81       	ldd	r18, Y+2	; 0x02
    4f56:	3b 81       	ldd	r19, Y+3	; 0x03
    4f58:	88 85       	ldd	r24, Y+8	; 0x08
    4f5a:	99 85       	ldd	r25, Y+9	; 0x09
    4f5c:	aa 85       	ldd	r26, Y+10	; 0x0a
    4f5e:	bb 85       	ldd	r27, Y+11	; 0x0b
    4f60:	f9 01       	movw	r30, r18
    4f62:	81 a3       	std	Z+33, r24	; 0x21
    4f64:	92 a3       	std	Z+34, r25	; 0x22
    4f66:	a3 a3       	std	Z+35, r26	; 0x23
    4f68:	b4 a3       	std	Z+36, r27	; 0x24
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    4f6a:	03 c0       	rjmp	.+6      	; 0x4f72 <xTaskGenericNotifyFromISR+0x130>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4f6c:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    4f6e:	01 c0       	rjmp	.+2      	; 0x4f72 <xTaskGenericNotifyFromISR+0x130>

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
    4f70:	00 00       	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    4f72:	8d 81       	ldd	r24, Y+5	; 0x05
    4f74:	81 30       	cpi	r24, 0x01	; 1
    4f76:	09 f0       	breq	.+2      	; 0x4f7a <xTaskGenericNotifyFromISR+0x138>
    4f78:	4e c0       	rjmp	.+156    	; 0x5016 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4f7a:	80 91 58 05 	lds	r24, 0x0558
    4f7e:	88 23       	and	r24, r24
    4f80:	69 f5       	brne	.+90     	; 0x4fdc <xTaskGenericNotifyFromISR+0x19a>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    4f82:	8a 81       	ldd	r24, Y+2	; 0x02
    4f84:	9b 81       	ldd	r25, Y+3	; 0x03
    4f86:	02 96       	adiw	r24, 0x02	; 2
    4f88:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4f8c:	8a 81       	ldd	r24, Y+2	; 0x02
    4f8e:	9b 81       	ldd	r25, Y+3	; 0x03
    4f90:	fc 01       	movw	r30, r24
    4f92:	96 89       	ldd	r25, Z+22	; 0x16
    4f94:	80 91 50 05 	lds	r24, 0x0550
    4f98:	89 17       	cp	r24, r25
    4f9a:	30 f4       	brcc	.+12     	; 0x4fa8 <xTaskGenericNotifyFromISR+0x166>
    4f9c:	8a 81       	ldd	r24, Y+2	; 0x02
    4f9e:	9b 81       	ldd	r25, Y+3	; 0x03
    4fa0:	fc 01       	movw	r30, r24
    4fa2:	86 89       	ldd	r24, Z+22	; 0x16
    4fa4:	80 93 50 05 	sts	0x0550, r24
    4fa8:	8a 81       	ldd	r24, Y+2	; 0x02
    4faa:	9b 81       	ldd	r25, Y+3	; 0x03
    4fac:	ac 01       	movw	r20, r24
    4fae:	4e 5f       	subi	r20, 0xFE	; 254
    4fb0:	5f 4f       	sbci	r21, 0xFF	; 255
    4fb2:	8a 81       	ldd	r24, Y+2	; 0x02
    4fb4:	9b 81       	ldd	r25, Y+3	; 0x03
    4fb6:	fc 01       	movw	r30, r24
    4fb8:	86 89       	ldd	r24, Z+22	; 0x16
    4fba:	28 2f       	mov	r18, r24
    4fbc:	30 e0       	ldi	r19, 0x00	; 0
    4fbe:	c9 01       	movw	r24, r18
    4fc0:	88 0f       	add	r24, r24
    4fc2:	99 1f       	adc	r25, r25
    4fc4:	88 0f       	add	r24, r24
    4fc6:	99 1f       	adc	r25, r25
    4fc8:	88 0f       	add	r24, r24
    4fca:	99 1f       	adc	r25, r25
    4fcc:	82 0f       	add	r24, r18
    4fce:	93 1f       	adc	r25, r19
    4fd0:	80 50       	subi	r24, 0x00	; 0
    4fd2:	9b 4f       	sbci	r25, 0xFB	; 251
    4fd4:	ba 01       	movw	r22, r20
    4fd6:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vListInsertEnd>
    4fda:	08 c0       	rjmp	.+16     	; 0x4fec <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4fdc:	8a 81       	ldd	r24, Y+2	; 0x02
    4fde:	9b 81       	ldd	r25, Y+3	; 0x03
    4fe0:	0c 96       	adiw	r24, 0x0c	; 12
    4fe2:	bc 01       	movw	r22, r24
    4fe4:	8a e3       	ldi	r24, 0x3A	; 58
    4fe6:	95 e0       	ldi	r25, 0x05	; 5
    4fe8:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4fec:	8a 81       	ldd	r24, Y+2	; 0x02
    4fee:	9b 81       	ldd	r25, Y+3	; 0x03
    4ff0:	fc 01       	movw	r30, r24
    4ff2:	26 89       	ldd	r18, Z+22	; 0x16
    4ff4:	80 91 fe 04 	lds	r24, 0x04FE
    4ff8:	90 91 ff 04 	lds	r25, 0x04FF
    4ffc:	fc 01       	movw	r30, r24
    4ffe:	86 89       	ldd	r24, Z+22	; 0x16
    5000:	82 17       	cp	r24, r18
    5002:	48 f4       	brcc	.+18     	; 0x5016 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    5004:	8f 85       	ldd	r24, Y+15	; 0x0f
    5006:	98 89       	ldd	r25, Y+16	; 0x10
    5008:	89 2b       	or	r24, r25
    500a:	29 f0       	breq	.+10     	; 0x5016 <xTaskGenericNotifyFromISR+0x1d4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    500c:	8f 85       	ldd	r24, Y+15	; 0x0f
    500e:	98 89       	ldd	r25, Y+16	; 0x10
    5010:	21 e0       	ldi	r18, 0x01	; 1
    5012:	fc 01       	movw	r30, r24
    5014:	20 83       	st	Z, r18
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    5016:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5018:	60 96       	adiw	r28, 0x10	; 16
    501a:	0f b6       	in	r0, 0x3f	; 63
    501c:	f8 94       	cli
    501e:	de bf       	out	0x3e, r29	; 62
    5020:	0f be       	out	0x3f, r0	; 63
    5022:	cd bf       	out	0x3d, r28	; 61
    5024:	df 91       	pop	r29
    5026:	cf 91       	pop	r28
    5028:	1f 91       	pop	r17
    502a:	0f 91       	pop	r16
    502c:	ff 90       	pop	r15
    502e:	ef 90       	pop	r14
    5030:	08 95       	ret

00005032 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    5032:	cf 93       	push	r28
    5034:	df 93       	push	r29
    5036:	cd b7       	in	r28, 0x3d	; 61
    5038:	de b7       	in	r29, 0x3e	; 62
    503a:	28 97       	sbiw	r28, 0x08	; 8
    503c:	0f b6       	in	r0, 0x3f	; 63
    503e:	f8 94       	cli
    5040:	de bf       	out	0x3e, r29	; 62
    5042:	0f be       	out	0x3f, r0	; 63
    5044:	cd bf       	out	0x3d, r28	; 61
    5046:	9e 83       	std	Y+6, r25	; 0x06
    5048:	8d 83       	std	Y+5, r24	; 0x05
    504a:	78 87       	std	Y+8, r23	; 0x08
    504c:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    504e:	8d 81       	ldd	r24, Y+5	; 0x05
    5050:	9e 81       	ldd	r25, Y+6	; 0x06
    5052:	9a 83       	std	Y+2, r25	; 0x02
    5054:	89 83       	std	Y+1, r24	; 0x01

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5056:	1b 82       	std	Y+3, r1	; 0x03
		{
			eOriginalNotifyState = pxTCB->eNotifyState;
    5058:	89 81       	ldd	r24, Y+1	; 0x01
    505a:	9a 81       	ldd	r25, Y+2	; 0x02
    505c:	fc 01       	movw	r30, r24
    505e:	85 a1       	ldd	r24, Z+37	; 0x25
    5060:	8c 83       	std	Y+4, r24	; 0x04
			pxTCB->eNotifyState = eNotified;
    5062:	89 81       	ldd	r24, Y+1	; 0x01
    5064:	9a 81       	ldd	r25, Y+2	; 0x02
    5066:	22 e0       	ldi	r18, 0x02	; 2
    5068:	fc 01       	movw	r30, r24
    506a:	25 a3       	std	Z+37, r18	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    506c:	89 81       	ldd	r24, Y+1	; 0x01
    506e:	9a 81       	ldd	r25, Y+2	; 0x02
    5070:	fc 01       	movw	r30, r24
    5072:	81 a1       	ldd	r24, Z+33	; 0x21
    5074:	92 a1       	ldd	r25, Z+34	; 0x22
    5076:	a3 a1       	ldd	r26, Z+35	; 0x23
    5078:	b4 a1       	ldd	r27, Z+36	; 0x24
    507a:	01 96       	adiw	r24, 0x01	; 1
    507c:	a1 1d       	adc	r26, r1
    507e:	b1 1d       	adc	r27, r1
    5080:	29 81       	ldd	r18, Y+1	; 0x01
    5082:	3a 81       	ldd	r19, Y+2	; 0x02
    5084:	f9 01       	movw	r30, r18
    5086:	81 a3       	std	Z+33, r24	; 0x21
    5088:	92 a3       	std	Z+34, r25	; 0x22
    508a:	a3 a3       	std	Z+35, r26	; 0x23
    508c:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    508e:	8c 81       	ldd	r24, Y+4	; 0x04
    5090:	81 30       	cpi	r24, 0x01	; 1
    5092:	09 f0       	breq	.+2      	; 0x5096 <vTaskNotifyGiveFromISR+0x64>
    5094:	4e c0       	rjmp	.+156    	; 0x5132 <vTaskNotifyGiveFromISR+0x100>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5096:	80 91 58 05 	lds	r24, 0x0558
    509a:	88 23       	and	r24, r24
    509c:	69 f5       	brne	.+90     	; 0x50f8 <vTaskNotifyGiveFromISR+0xc6>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    509e:	89 81       	ldd	r24, Y+1	; 0x01
    50a0:	9a 81       	ldd	r25, Y+2	; 0x02
    50a2:	02 96       	adiw	r24, 0x02	; 2
    50a4:	0e 94 af 12 	call	0x255e	; 0x255e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    50a8:	89 81       	ldd	r24, Y+1	; 0x01
    50aa:	9a 81       	ldd	r25, Y+2	; 0x02
    50ac:	fc 01       	movw	r30, r24
    50ae:	96 89       	ldd	r25, Z+22	; 0x16
    50b0:	80 91 50 05 	lds	r24, 0x0550
    50b4:	89 17       	cp	r24, r25
    50b6:	30 f4       	brcc	.+12     	; 0x50c4 <vTaskNotifyGiveFromISR+0x92>
    50b8:	89 81       	ldd	r24, Y+1	; 0x01
    50ba:	9a 81       	ldd	r25, Y+2	; 0x02
    50bc:	fc 01       	movw	r30, r24
    50be:	86 89       	ldd	r24, Z+22	; 0x16
    50c0:	80 93 50 05 	sts	0x0550, r24
    50c4:	89 81       	ldd	r24, Y+1	; 0x01
    50c6:	9a 81       	ldd	r25, Y+2	; 0x02
    50c8:	ac 01       	movw	r20, r24
    50ca:	4e 5f       	subi	r20, 0xFE	; 254
    50cc:	5f 4f       	sbci	r21, 0xFF	; 255
    50ce:	89 81       	ldd	r24, Y+1	; 0x01
    50d0:	9a 81       	ldd	r25, Y+2	; 0x02
    50d2:	fc 01       	movw	r30, r24
    50d4:	86 89       	ldd	r24, Z+22	; 0x16
    50d6:	28 2f       	mov	r18, r24
    50d8:	30 e0       	ldi	r19, 0x00	; 0
    50da:	c9 01       	movw	r24, r18
    50dc:	88 0f       	add	r24, r24
    50de:	99 1f       	adc	r25, r25
    50e0:	88 0f       	add	r24, r24
    50e2:	99 1f       	adc	r25, r25
    50e4:	88 0f       	add	r24, r24
    50e6:	99 1f       	adc	r25, r25
    50e8:	82 0f       	add	r24, r18
    50ea:	93 1f       	adc	r25, r19
    50ec:	80 50       	subi	r24, 0x00	; 0
    50ee:	9b 4f       	sbci	r25, 0xFB	; 251
    50f0:	ba 01       	movw	r22, r20
    50f2:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vListInsertEnd>
    50f6:	08 c0       	rjmp	.+16     	; 0x5108 <vTaskNotifyGiveFromISR+0xd6>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    50f8:	89 81       	ldd	r24, Y+1	; 0x01
    50fa:	9a 81       	ldd	r25, Y+2	; 0x02
    50fc:	0c 96       	adiw	r24, 0x0c	; 12
    50fe:	bc 01       	movw	r22, r24
    5100:	8a e3       	ldi	r24, 0x3A	; 58
    5102:	95 e0       	ldi	r25, 0x05	; 5
    5104:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5108:	89 81       	ldd	r24, Y+1	; 0x01
    510a:	9a 81       	ldd	r25, Y+2	; 0x02
    510c:	fc 01       	movw	r30, r24
    510e:	26 89       	ldd	r18, Z+22	; 0x16
    5110:	80 91 fe 04 	lds	r24, 0x04FE
    5114:	90 91 ff 04 	lds	r25, 0x04FF
    5118:	fc 01       	movw	r30, r24
    511a:	86 89       	ldd	r24, Z+22	; 0x16
    511c:	82 17       	cp	r24, r18
    511e:	48 f4       	brcc	.+18     	; 0x5132 <vTaskNotifyGiveFromISR+0x100>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    5120:	8f 81       	ldd	r24, Y+7	; 0x07
    5122:	98 85       	ldd	r25, Y+8	; 0x08
    5124:	89 2b       	or	r24, r25
    5126:	29 f0       	breq	.+10     	; 0x5132 <vTaskNotifyGiveFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5128:	8f 81       	ldd	r24, Y+7	; 0x07
    512a:	98 85       	ldd	r25, Y+8	; 0x08
    512c:	21 e0       	ldi	r18, 0x01	; 1
    512e:	fc 01       	movw	r30, r24
    5130:	20 83       	st	Z, r18
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    5132:	28 96       	adiw	r28, 0x08	; 8
    5134:	0f b6       	in	r0, 0x3f	; 63
    5136:	f8 94       	cli
    5138:	de bf       	out	0x3e, r29	; 62
    513a:	0f be       	out	0x3f, r0	; 63
    513c:	cd bf       	out	0x3d, r28	; 61
    513e:	df 91       	pop	r29
    5140:	cf 91       	pop	r28
    5142:	08 95       	ret

00005144 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    5144:	cf 93       	push	r28
    5146:	df 93       	push	r29
    5148:	00 d0       	rcall	.+0      	; 0x514a <xTaskNotifyStateClear+0x6>
    514a:	00 d0       	rcall	.+0      	; 0x514c <xTaskNotifyStateClear+0x8>
    514c:	1f 92       	push	r1
    514e:	cd b7       	in	r28, 0x3d	; 61
    5150:	de b7       	in	r29, 0x3e	; 62
    5152:	9d 83       	std	Y+5, r25	; 0x05
    5154:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		pxTCB = ( TCB_t * ) xTask;
    5156:	8c 81       	ldd	r24, Y+4	; 0x04
    5158:	9d 81       	ldd	r25, Y+5	; 0x05
    515a:	9b 83       	std	Y+3, r25	; 0x03
    515c:	8a 83       	std	Y+2, r24	; 0x02

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( pxTCB );
    515e:	8a 81       	ldd	r24, Y+2	; 0x02
    5160:	9b 81       	ldd	r25, Y+3	; 0x03
    5162:	89 2b       	or	r24, r25
    5164:	29 f4       	brne	.+10     	; 0x5170 <xTaskNotifyStateClear+0x2c>
    5166:	80 91 fe 04 	lds	r24, 0x04FE
    516a:	90 91 ff 04 	lds	r25, 0x04FF
    516e:	02 c0       	rjmp	.+4      	; 0x5174 <xTaskNotifyStateClear+0x30>
    5170:	8a 81       	ldd	r24, Y+2	; 0x02
    5172:	9b 81       	ldd	r25, Y+3	; 0x03
    5174:	9b 83       	std	Y+3, r25	; 0x03
    5176:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5178:	0f b6       	in	r0, 0x3f	; 63
    517a:	f8 94       	cli
    517c:	0f 92       	push	r0
		{
			if( pxTCB->eNotifyState == eNotified )
    517e:	8a 81       	ldd	r24, Y+2	; 0x02
    5180:	9b 81       	ldd	r25, Y+3	; 0x03
    5182:	fc 01       	movw	r30, r24
    5184:	85 a1       	ldd	r24, Z+37	; 0x25
    5186:	82 30       	cpi	r24, 0x02	; 2
    5188:	39 f4       	brne	.+14     	; 0x5198 <xTaskNotifyStateClear+0x54>
			{
				pxTCB->eNotifyState = eNotWaitingNotification;
    518a:	8a 81       	ldd	r24, Y+2	; 0x02
    518c:	9b 81       	ldd	r25, Y+3	; 0x03
    518e:	fc 01       	movw	r30, r24
    5190:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    5192:	81 e0       	ldi	r24, 0x01	; 1
    5194:	89 83       	std	Y+1, r24	; 0x01
    5196:	01 c0       	rjmp	.+2      	; 0x519a <xTaskNotifyStateClear+0x56>
			}
			else
			{
				xReturn = pdFAIL;
    5198:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    519a:	0f 90       	pop	r0
    519c:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    519e:	89 81       	ldd	r24, Y+1	; 0x01
	}
    51a0:	0f 90       	pop	r0
    51a2:	0f 90       	pop	r0
    51a4:	0f 90       	pop	r0
    51a6:	0f 90       	pop	r0
    51a8:	0f 90       	pop	r0
    51aa:	df 91       	pop	r29
    51ac:	cf 91       	pop	r28
    51ae:	08 95       	ret

000051b0 <vMCUStatusTask>:
/* MCU Status task
 * Toggles the MCU status LED, to blink at 2Hz
 * Rate: 4Hz
 * Priority: 1 (lowest)
 */
void vMCUStatusTask(void *pvParameters) {
    51b0:	cf 93       	push	r28
    51b2:	df 93       	push	r29
    51b4:	00 d0       	rcall	.+0      	; 0x51b6 <vMCUStatusTask+0x6>
    51b6:	1f 92       	push	r1
    51b8:	cd b7       	in	r28, 0x3d	; 61
    51ba:	de b7       	in	r29, 0x3e	; 62
    51bc:	9b 83       	std	Y+3, r25	; 0x03
    51be:	8a 83       	std	Y+2, r24	; 0x02
	// Make compiler happy
	(void) pvParameters;
	// Task variables
	Bool currentValue = 0;	// false
    51c0:	19 82       	std	Y+1, r1	; 0x01
	// Setup MCU status pin as output
	config_io_pin(MCU_STATUS_PORT, MCU_STATUS_CH, IO_DIR_OUTPUT);
    51c2:	41 e0       	ldi	r20, 0x01	; 1
    51c4:	60 e0       	ldi	r22, 0x00	; 0
    51c6:	81 e0       	ldi	r24, 0x01	; 1
    51c8:	0e 94 a2 00 	call	0x144	; 0x144 <config_io_pin>
	
	for(;;) {
		// Flip value
		currentValue = !currentValue;
    51cc:	81 e0       	ldi	r24, 0x01	; 1
    51ce:	99 81       	ldd	r25, Y+1	; 0x01
    51d0:	99 23       	and	r25, r25
    51d2:	09 f0       	breq	.+2      	; 0x51d6 <vMCUStatusTask+0x26>
    51d4:	80 e0       	ldi	r24, 0x00	; 0
    51d6:	89 83       	std	Y+1, r24	; 0x01
		// Write out value
		set_io_pin(MCU_STATUS_PORT, MCU_STATUS_CH, currentValue);
    51d8:	49 81       	ldd	r20, Y+1	; 0x01
    51da:	60 e0       	ldi	r22, 0x00	; 0
    51dc:	81 e0       	ldi	r24, 0x01	; 1
    51de:	0e 94 36 01 	call	0x26c	; 0x26c <set_io_pin>
		// Delay 250ms for 4Hz
		vTaskDelay((TickType_t)250); 
    51e2:	8a ef       	ldi	r24, 0xFA	; 250
    51e4:	90 e0       	ldi	r25, 0x00	; 0
    51e6:	0e 94 68 1e 	call	0x3cd0	; 0x3cd0 <vTaskDelay>
	}
    51ea:	f0 cf       	rjmp	.-32     	; 0x51cc <vMCUStatusTask+0x1c>

000051ec <vHeartbeatTask>:
/* Heartbeat task
 * Sends a node heartbeat out on the CANBus
 * Rate: 10Hz
 * Priority: 3
 */
void vHeartbeatTask(void *pvParameters) {
    51ec:	cf 93       	push	r28
    51ee:	df 93       	push	r29
    51f0:	00 d0       	rcall	.+0      	; 0x51f2 <vHeartbeatTask+0x6>
    51f2:	00 d0       	rcall	.+0      	; 0x51f4 <vHeartbeatTask+0x8>
    51f4:	cd b7       	in	r28, 0x3d	; 61
    51f6:	de b7       	in	r29, 0x3e	; 62
    51f8:	9c 83       	std	Y+4, r25	; 0x04
    51fa:	8b 83       	std	Y+3, r24	; 0x03
	(void) pvParameters;
	// Data to send
	HeartbeatFSM data;
	
	// Setup values
	data.currentState = RTD;
    51fc:	82 e0       	ldi	r24, 0x02	; 2
    51fe:	89 83       	std	Y+1, r24	; 0x01
	data.someData = 10;
    5200:	8a e0       	ldi	r24, 0x0A	; 10
    5202:	8a 83       	std	Y+2, r24	; 0x02
	
	for(;;) {
		// Transmit the data
		can_tx(FSM_HEARTBEAT_ID, (uint8_t *)&data, sizeof(HeartbeatFSM));
    5204:	42 e0       	ldi	r20, 0x02	; 2
    5206:	ce 01       	movw	r24, r28
    5208:	01 96       	adiw	r24, 0x01	; 1
    520a:	bc 01       	movw	r22, r24
    520c:	84 e0       	ldi	r24, 0x04	; 4
    520e:	92 e0       	ldi	r25, 0x02	; 2
    5210:	0e 94 ca 01 	call	0x394	; 0x394 <can_tx>
		// Delay 100ms
		vTaskDelay((TickType_t)100); 
    5214:	84 e6       	ldi	r24, 0x64	; 100
    5216:	90 e0       	ldi	r25, 0x00	; 0
    5218:	0e 94 68 1e 	call	0x3cd0	; 0x3cd0 <vTaskDelay>
	}
    521c:	f3 cf       	rjmp	.-26     	; 0x5204 <vHeartbeatTask+0x18>

0000521e <vCANSendTask>:
}

void vCANSendTask(void *pvParameters) {
    521e:	cf 93       	push	r28
    5220:	df 93       	push	r29
    5222:	00 d0       	rcall	.+0      	; 0x5224 <vCANSendTask+0x6>
    5224:	cd b7       	in	r28, 0x3d	; 61
    5226:	de b7       	in	r29, 0x3e	; 62
    5228:	9a 83       	std	Y+2, r25	; 0x02
    522a:	89 83       	std	Y+1, r24	; 0x01
	// Make compiler happy
	(void) pvParameters;
}
    522c:	0f 90       	pop	r0
    522e:	0f 90       	pop	r0
    5230:	df 91       	pop	r29
    5232:	cf 91       	pop	r28
    5234:	08 95       	ret

00005236 <vCANReceiveTask>:

void vCANReceiveTask(void *pvParameters) {
    5236:	cf 93       	push	r28
    5238:	df 93       	push	r29
    523a:	00 d0       	rcall	.+0      	; 0x523c <vCANReceiveTask+0x6>
    523c:	cd b7       	in	r28, 0x3d	; 61
    523e:	de b7       	in	r29, 0x3e	; 62
    5240:	9a 83       	std	Y+2, r25	; 0x02
    5242:	89 83       	std	Y+1, r24	; 0x01
	// Make compiler happy
	(void) pvParameters;
    5244:	0f 90       	pop	r0
    5246:	0f 90       	pop	r0
    5248:	df 91       	pop	r29
    524a:	cf 91       	pop	r28
    524c:	08 95       	ret

0000524e <__tablejump2__>:
    524e:	ee 0f       	add	r30, r30
    5250:	ff 1f       	adc	r31, r31
    5252:	05 90       	lpm	r0, Z+
    5254:	f4 91       	lpm	r31, Z
    5256:	e0 2d       	mov	r30, r0
    5258:	09 94       	ijmp

0000525a <memcpy>:
    525a:	fb 01       	movw	r30, r22
    525c:	dc 01       	movw	r26, r24
    525e:	02 c0       	rjmp	.+4      	; 0x5264 <memcpy+0xa>
    5260:	01 90       	ld	r0, Z+
    5262:	0d 92       	st	X+, r0
    5264:	41 50       	subi	r20, 0x01	; 1
    5266:	50 40       	sbci	r21, 0x00	; 0
    5268:	d8 f7       	brcc	.-10     	; 0x5260 <memcpy+0x6>
    526a:	08 95       	ret

0000526c <_exit>:
    526c:	f8 94       	cli

0000526e <__stop_program>:
    526e:	ff cf       	rjmp	.-2      	; 0x526e <__stop_program>
