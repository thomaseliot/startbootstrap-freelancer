
FrontSensorModule.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000006c  00800100  00002b2e  00002bc2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002b2e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000e51  0080016c  0080016c  00002c2e  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00002c2e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002c8c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000140  00000000  00000000  00002ccc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000044fe  00000000  00000000  00002e0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001195  00000000  00000000  0000730a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000277e  00000000  00000000  0000849f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b54  00000000  00000000  0000ac20  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000f205  00000000  00000000  0000b774  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003eaa  00000000  00000000  0001a979  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000070  00000000  00000000  0001e823  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00005316  00000000  00000000  0001e893  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 fe 04 	jmp	0x9fc	; 0x9fc <__vector_12>
      34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 05 01 	jmp	0x20a	; 0x20a <__vector_18>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d0 e1       	ldi	r29, 0x10	; 16
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	11 e0       	ldi	r17, 0x01	; 1
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	ee e2       	ldi	r30, 0x2E	; 46
      90:	fb e2       	ldi	r31, 0x2B	; 43
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	ac 36       	cpi	r26, 0x6C	; 108
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	2f e0       	ldi	r18, 0x0F	; 15
      a0:	ac e6       	ldi	r26, 0x6C	; 108
      a2:	b1 e0       	ldi	r27, 0x01	; 1
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	ad 3b       	cpi	r26, 0xBD	; 189
      aa:	b2 07       	cpc	r27, r18
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 70 11 	call	0x22e0	; 0x22e0 <main>
      b2:	0c 94 95 15 	jmp	0x2b2a	; 0x2b2a <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <mb1_callback>:
 */ 

#include "can_callbacks.h"

// Mailbox 1 callback function
void mb1_callback(CAN_packet packet) {
      ba:	ef 92       	push	r14
      bc:	ff 92       	push	r15
      be:	0f 93       	push	r16
      c0:	1f 93       	push	r17
      c2:	cf 93       	push	r28
      c4:	df 93       	push	r29
      c6:	cd b7       	in	r28, 0x3d	; 61
      c8:	de b7       	in	r29, 0x3e	; 62
      ca:	2f 97       	sbiw	r28, 0x0f	; 15
      cc:	0f b6       	in	r0, 0x3f	; 63
      ce:	f8 94       	cli
      d0:	de bf       	out	0x3e, r29	; 62
      d2:	0f be       	out	0x3f, r0	; 63
      d4:	cd bf       	out	0x3d, r28	; 61
      d6:	ed 82       	std	Y+5, r14	; 0x05
      d8:	fe 82       	std	Y+6, r15	; 0x06
      da:	0f 83       	std	Y+7, r16	; 0x07
      dc:	18 87       	std	Y+8, r17	; 0x08
      de:	29 87       	std	Y+9, r18	; 0x09
      e0:	3a 87       	std	Y+10, r19	; 0x0a
      e2:	4b 87       	std	Y+11, r20	; 0x0b
      e4:	5c 87       	std	Y+12, r21	; 0x0c
      e6:	6d 87       	std	Y+13, r22	; 0x0d
      e8:	7e 87       	std	Y+14, r23	; 0x0e
      ea:	8f 87       	std	Y+15, r24	; 0x0f
	volatile int i, j;
	i = j;
      ec:	89 81       	ldd	r24, Y+1	; 0x01
      ee:	9a 81       	ldd	r25, Y+2	; 0x02
      f0:	9c 83       	std	Y+4, r25	; 0x04
      f2:	8b 83       	std	Y+3, r24	; 0x03
}
      f4:	2f 96       	adiw	r28, 0x0f	; 15
      f6:	0f b6       	in	r0, 0x3f	; 63
      f8:	f8 94       	cli
      fa:	de bf       	out	0x3e, r29	; 62
      fc:	0f be       	out	0x3f, r0	; 63
      fe:	cd bf       	out	0x3d, r28	; 61
     100:	df 91       	pop	r29
     102:	cf 91       	pop	r28
     104:	1f 91       	pop	r17
     106:	0f 91       	pop	r16
     108:	ff 90       	pop	r15
     10a:	ef 90       	pop	r14
     10c:	08 95       	ret

0000010e <mb2_callback>:


// Mailbox 2 callback function
void mb2_callback(CAN_packet packet) {
     10e:	ef 92       	push	r14
     110:	ff 92       	push	r15
     112:	0f 93       	push	r16
     114:	1f 93       	push	r17
     116:	cf 93       	push	r28
     118:	df 93       	push	r29
     11a:	cd b7       	in	r28, 0x3d	; 61
     11c:	de b7       	in	r29, 0x3e	; 62
     11e:	2f 97       	sbiw	r28, 0x0f	; 15
     120:	0f b6       	in	r0, 0x3f	; 63
     122:	f8 94       	cli
     124:	de bf       	out	0x3e, r29	; 62
     126:	0f be       	out	0x3f, r0	; 63
     128:	cd bf       	out	0x3d, r28	; 61
     12a:	ed 82       	std	Y+5, r14	; 0x05
     12c:	fe 82       	std	Y+6, r15	; 0x06
     12e:	0f 83       	std	Y+7, r16	; 0x07
     130:	18 87       	std	Y+8, r17	; 0x08
     132:	29 87       	std	Y+9, r18	; 0x09
     134:	3a 87       	std	Y+10, r19	; 0x0a
     136:	4b 87       	std	Y+11, r20	; 0x0b
     138:	5c 87       	std	Y+12, r21	; 0x0c
     13a:	6d 87       	std	Y+13, r22	; 0x0d
     13c:	7e 87       	std	Y+14, r23	; 0x0e
     13e:	8f 87       	std	Y+15, r24	; 0x0f
	volatile int i, j;
	j = i;
     140:	8b 81       	ldd	r24, Y+3	; 0x03
     142:	9c 81       	ldd	r25, Y+4	; 0x04
     144:	9a 83       	std	Y+2, r25	; 0x02
     146:	89 83       	std	Y+1, r24	; 0x01
}
     148:	2f 96       	adiw	r28, 0x0f	; 15
     14a:	0f b6       	in	r0, 0x3f	; 63
     14c:	f8 94       	cli
     14e:	de bf       	out	0x3e, r29	; 62
     150:	0f be       	out	0x3f, r0	; 63
     152:	cd bf       	out	0x3d, r28	; 61
     154:	df 91       	pop	r29
     156:	cf 91       	pop	r28
     158:	1f 91       	pop	r17
     15a:	0f 91       	pop	r16
     15c:	ff 90       	pop	r15
     15e:	ef 90       	pop	r14
     160:	08 95       	ret

00000162 <mb3_callback>:


// Mailbox 3 callback function
void mb3_callback(CAN_packet packet) {
     162:	ef 92       	push	r14
     164:	ff 92       	push	r15
     166:	0f 93       	push	r16
     168:	1f 93       	push	r17
     16a:	cf 93       	push	r28
     16c:	df 93       	push	r29
     16e:	cd b7       	in	r28, 0x3d	; 61
     170:	de b7       	in	r29, 0x3e	; 62
     172:	2f 97       	sbiw	r28, 0x0f	; 15
     174:	0f b6       	in	r0, 0x3f	; 63
     176:	f8 94       	cli
     178:	de bf       	out	0x3e, r29	; 62
     17a:	0f be       	out	0x3f, r0	; 63
     17c:	cd bf       	out	0x3d, r28	; 61
     17e:	ed 82       	std	Y+5, r14	; 0x05
     180:	fe 82       	std	Y+6, r15	; 0x06
     182:	0f 83       	std	Y+7, r16	; 0x07
     184:	18 87       	std	Y+8, r17	; 0x08
     186:	29 87       	std	Y+9, r18	; 0x09
     188:	3a 87       	std	Y+10, r19	; 0x0a
     18a:	4b 87       	std	Y+11, r20	; 0x0b
     18c:	5c 87       	std	Y+12, r21	; 0x0c
     18e:	6d 87       	std	Y+13, r22	; 0x0d
     190:	7e 87       	std	Y+14, r23	; 0x0e
     192:	8f 87       	std	Y+15, r24	; 0x0f
	volatile int i, j;
	i = j;
     194:	89 81       	ldd	r24, Y+1	; 0x01
     196:	9a 81       	ldd	r25, Y+2	; 0x02
     198:	9c 83       	std	Y+4, r25	; 0x04
     19a:	8b 83       	std	Y+3, r24	; 0x03
}
     19c:	2f 96       	adiw	r28, 0x0f	; 15
     19e:	0f b6       	in	r0, 0x3f	; 63
     1a0:	f8 94       	cli
     1a2:	de bf       	out	0x3e, r29	; 62
     1a4:	0f be       	out	0x3f, r0	; 63
     1a6:	cd bf       	out	0x3d, r28	; 61
     1a8:	df 91       	pop	r29
     1aa:	cf 91       	pop	r28
     1ac:	1f 91       	pop	r17
     1ae:	0f 91       	pop	r16
     1b0:	ff 90       	pop	r15
     1b2:	ef 90       	pop	r14
     1b4:	08 95       	ret

000001b6 <mb4_callback>:


// Mailbox 4 callback function
void mb4_callback(CAN_packet packet) {
     1b6:	ef 92       	push	r14
     1b8:	ff 92       	push	r15
     1ba:	0f 93       	push	r16
     1bc:	1f 93       	push	r17
     1be:	cf 93       	push	r28
     1c0:	df 93       	push	r29
     1c2:	cd b7       	in	r28, 0x3d	; 61
     1c4:	de b7       	in	r29, 0x3e	; 62
     1c6:	2f 97       	sbiw	r28, 0x0f	; 15
     1c8:	0f b6       	in	r0, 0x3f	; 63
     1ca:	f8 94       	cli
     1cc:	de bf       	out	0x3e, r29	; 62
     1ce:	0f be       	out	0x3f, r0	; 63
     1d0:	cd bf       	out	0x3d, r28	; 61
     1d2:	ed 82       	std	Y+5, r14	; 0x05
     1d4:	fe 82       	std	Y+6, r15	; 0x06
     1d6:	0f 83       	std	Y+7, r16	; 0x07
     1d8:	18 87       	std	Y+8, r17	; 0x08
     1da:	29 87       	std	Y+9, r18	; 0x09
     1dc:	3a 87       	std	Y+10, r19	; 0x0a
     1de:	4b 87       	std	Y+11, r20	; 0x0b
     1e0:	5c 87       	std	Y+12, r21	; 0x0c
     1e2:	6d 87       	std	Y+13, r22	; 0x0d
     1e4:	7e 87       	std	Y+14, r23	; 0x0e
     1e6:	8f 87       	std	Y+15, r24	; 0x0f
	volatile int i, j;
	i = j;
     1e8:	89 81       	ldd	r24, Y+1	; 0x01
     1ea:	9a 81       	ldd	r25, Y+2	; 0x02
     1ec:	9c 83       	std	Y+4, r25	; 0x04
     1ee:	8b 83       	std	Y+3, r24	; 0x03
}
     1f0:	2f 96       	adiw	r28, 0x0f	; 15
     1f2:	0f b6       	in	r0, 0x3f	; 63
     1f4:	f8 94       	cli
     1f6:	de bf       	out	0x3e, r29	; 62
     1f8:	0f be       	out	0x3f, r0	; 63
     1fa:	cd bf       	out	0x3d, r28	; 61
     1fc:	df 91       	pop	r29
     1fe:	cf 91       	pop	r28
     200:	1f 91       	pop	r17
     202:	0f 91       	pop	r16
     204:	ff 90       	pop	r15
     206:	ef 90       	pop	r14
     208:	08 95       	ret

0000020a <__vector_18>:
// Note: comments use mailbox and message object buffer interchangeably. 
CAN_cbf canlist[NO_MOBS];

// CAN interrupt service routine
// Used for reception of CAN packets
ISR(CAN_INT_vect) {
     20a:	1f 92       	push	r1
     20c:	0f 92       	push	r0
     20e:	0f b6       	in	r0, 0x3f	; 63
     210:	0f 92       	push	r0
     212:	11 24       	eor	r1, r1
     214:	2f 93       	push	r18
     216:	3f 93       	push	r19
     218:	4f 93       	push	r20
     21a:	5f 93       	push	r21
     21c:	6f 93       	push	r22
     21e:	7f 93       	push	r23
     220:	8f 93       	push	r24
     222:	9f 93       	push	r25
     224:	af 93       	push	r26
     226:	bf 93       	push	r27
     228:	cf 93       	push	r28
     22a:	ef 93       	push	r30
     22c:	ff 93       	push	r31
	// Function variables
	unsigned i;
	static CAN_packet packet;
	char save_canpage = CANPAGE;
     22e:	c0 91 ed 00 	lds	r28, 0x00ED
	
	// Get highest priority mailbox
	unsigned mob = CANHPMOB;
     232:	80 91 ec 00 	lds	r24, 0x00EC
     236:	68 2f       	mov	r22, r24
     238:	70 e0       	ldi	r23, 0x00	; 0
	// Set the CAN page to this mailbox
    CANPAGE = mob & 0xf0;	// note mob is currently upper four bits
     23a:	80 7f       	andi	r24, 0xF0	; 240
     23c:	80 93 ed 00 	sts	0x00ED, r24
	// Shift mailbox number to the lower four bits
	mob >>= 4;;
     240:	94 e0       	ldi	r25, 0x04	; 4
     242:	76 95       	lsr	r23
     244:	67 95       	ror	r22
     246:	9a 95       	dec	r25
     248:	e1 f7       	brne	.-8      	; 0x242 <__vector_18+0x38>
	// Allow only RX ready and DLC warning
	assert((CANSTMOB & ~0xa0) == 0);
	
	register char length;
	// Get ID of incoming message
	packet.id = (CANIDT2 >> 5) | (CANIDT1 << 3);
     24a:	20 91 f2 00 	lds	r18, 0x00F2
     24e:	80 91 f3 00 	lds	r24, 0x00F3
     252:	38 e0       	ldi	r19, 0x08	; 8
     254:	83 9f       	mul	r24, r19
     256:	c0 01       	movw	r24, r0
     258:	11 24       	eor	r1, r1
     25a:	22 95       	swap	r18
     25c:	26 95       	lsr	r18
     25e:	27 70       	andi	r18, 0x07	; 7
     260:	82 2b       	or	r24, r18
     262:	90 93 6d 01 	sts	0x016D, r25
     266:	80 93 6c 01 	sts	0x016C, r24
	// Get length of incoming message and set in packet
	length = CANCDMOB & 0x0f;
     26a:	80 91 ef 00 	lds	r24, 0x00EF
     26e:	8f 70       	andi	r24, 0x0F	; 15
	packet.length = length;
     270:	80 93 6e 01 	sts	0x016E, r24
	
	// Get incoming data
	for (i = 0; i < length; ++i) {
     274:	20 e0       	ldi	r18, 0x00	; 0
     276:	30 e0       	ldi	r19, 0x00	; 0
     278:	08 2e       	mov	r0, r24
     27a:	00 0c       	add	r0, r0
     27c:	99 0b       	sbc	r25, r25
     27e:	28 17       	cp	r18, r24
     280:	39 07       	cpc	r19, r25
     282:	48 f4       	brcc	.+18     	; 0x296 <__vector_18+0x8c>
		// CANMSG index is autoincremented on read
		packet.data[i] = CANMSG;
     284:	40 91 fa 00 	lds	r20, 0x00FA
     288:	f9 01       	movw	r30, r18
     28a:	e4 59       	subi	r30, 0x94	; 148
     28c:	fe 4f       	sbci	r31, 0xFE	; 254
     28e:	43 83       	std	Z+3, r20	; 0x03
	// Get length of incoming message and set in packet
	length = CANCDMOB & 0x0f;
	packet.length = length;
	
	// Get incoming data
	for (i = 0; i < length; ++i) {
     290:	2f 5f       	subi	r18, 0xFF	; 255
     292:	3f 4f       	sbci	r19, 0xFF	; 255
     294:	f4 cf       	rjmp	.-24     	; 0x27e <__vector_18+0x74>
		// CANMSG index is autoincremented on read
		packet.data[i] = CANMSG;
	}
	
	// Reset interrupt flags
	CANSTMOB = 0;
     296:	10 92 ee 00 	sts	0x00EE, r1
	// Re-enable RX on this channel
	CANCDMOB=0x80;
     29a:	80 e8       	ldi	r24, 0x80	; 128
     29c:	80 93 ef 00 	sts	0x00EF, r24
	
	// Call the mailbox callback
	canlist[mob](&packet, mob);
     2a0:	fb 01       	movw	r30, r22
     2a2:	ee 0f       	add	r30, r30
     2a4:	ff 1f       	adc	r31, r31
     2a6:	e5 57       	subi	r30, 0x75	; 117
     2a8:	f0 4f       	sbci	r31, 0xF0	; 240
     2aa:	01 90       	ld	r0, Z+
     2ac:	f0 81       	ld	r31, Z
     2ae:	e0 2d       	mov	r30, r0
     2b0:	8c e6       	ldi	r24, 0x6C	; 108
     2b2:	91 e0       	ldi	r25, 0x01	; 1
     2b4:	09 95       	icall
	
	// Restore CANPAGE
	CANPAGE = save_canpage;
     2b6:	c0 93 ed 00 	sts	0x00ED, r28
}
     2ba:	ff 91       	pop	r31
     2bc:	ef 91       	pop	r30
     2be:	cf 91       	pop	r28
     2c0:	bf 91       	pop	r27
     2c2:	af 91       	pop	r26
     2c4:	9f 91       	pop	r25
     2c6:	8f 91       	pop	r24
     2c8:	7f 91       	pop	r23
     2ca:	6f 91       	pop	r22
     2cc:	5f 91       	pop	r21
     2ce:	4f 91       	pop	r20
     2d0:	3f 91       	pop	r19
     2d2:	2f 91       	pop	r18
     2d4:	0f 90       	pop	r0
     2d6:	0f be       	out	0x3f, r0	; 63
     2d8:	0f 90       	pop	r0
     2da:	1f 90       	pop	r1
     2dc:	18 95       	reti

000002de <can_tx>:
/* Transmit over CAN
 * Transmits the given packet using specified mailbox
 * @param mob: the mailbox to use
 * @param packet: pointer to the packet to send
 */
bool can_tx(char mob, 	CAN_packet *packet ) {
     2de:	fb 01       	movw	r30, r22
	assert(packet->id <= 0x7ff);
	assert(packet->length <=8);
	assert(mob <=14);
	
	// Set the CAN page to this mailbox
    CANPAGE = mob << 4;
     2e0:	82 95       	swap	r24
     2e2:	80 7f       	andi	r24, 0xF0	; 240
     2e4:	80 93 ed 00 	sts	0x00ED, r24
	
	// If MOB in use and TX not ready
	if((CANCDMOB & 0b11000000) && ((CANSTMOB & 0x40) == 0)) {
     2e8:	80 91 ef 00 	lds	r24, 0x00EF
     2ec:	80 7c       	andi	r24, 0xC0	; 192
     2ee:	21 f0       	breq	.+8      	; 0x2f8 <can_tx+0x1a>
     2f0:	80 91 ee 00 	lds	r24, 0x00EE
     2f4:	86 ff       	sbrs	r24, 6
     2f6:	3d c0       	rjmp	.+122    	; 0x372 <can_tx+0x94>
		// Failure
		return false;
	}
	
	// Cancel pending operation
	CANSTMOB = 0x00; 
     2f8:	10 92 ee 00 	sts	0x00EE, r1
	CANCDMOB = 0x00;
     2fc:	10 92 ef 00 	sts	0x00EF, r1
	
	// Support for remote transmission request (RTR)
	if(packet->length != RTR) {
     300:	22 81       	ldd	r18, Z+2	; 0x02
     302:	80 81       	ld	r24, Z
     304:	91 81       	ldd	r25, Z+1	; 0x01
		// Set the ID to send
		CANIDT1 = packet->id >> 3;
     306:	33 e0       	ldi	r19, 0x03	; 3
     308:	96 95       	lsr	r25
     30a:	87 95       	ror	r24
     30c:	3a 95       	dec	r19
     30e:	e1 f7       	brne	.-8      	; 0x308 <can_tx+0x2a>
     310:	80 93 f3 00 	sts	0x00F3, r24
		CANIDT2 = packet->id << 5;
     314:	80 81       	ld	r24, Z
     316:	82 95       	swap	r24
     318:	88 0f       	add	r24, r24
     31a:	80 7e       	andi	r24, 0xE0	; 224
     31c:	80 93 f2 00 	sts	0x00F2, r24
        CANIDT3 = 0;
     320:	10 92 f1 00 	sts	0x00F1, r1
	// Cancel pending operation
	CANSTMOB = 0x00; 
	CANCDMOB = 0x00;
	
	// Support for remote transmission request (RTR)
	if(packet->length != RTR) {
     324:	2f 3f       	cpi	r18, 0xFF	; 255
     326:	a9 f0       	breq	.+42     	; 0x352 <can_tx+0x74>
		// Set the ID to send
		CANIDT1 = packet->id >> 3;
		CANIDT2 = packet->id << 5;
        CANIDT3 = 0;
        CANIDT4 = 0;
     328:	10 92 f0 00 	sts	0x00F0, r1
     32c:	df 01       	movw	r26, r30
     32e:	13 96       	adiw	r26, 0x03	; 3
		
		// Set the data
		for (cnt = 0; cnt < packet->length; ++cnt) {
     330:	20 e0       	ldi	r18, 0x00	; 0
     332:	30 e0       	ldi	r19, 0x00	; 0
     334:	92 81       	ldd	r25, Z+2	; 0x02
     336:	49 2f       	mov	r20, r25
     338:	50 e0       	ldi	r21, 0x00	; 0
     33a:	24 17       	cp	r18, r20
     33c:	35 07       	cpc	r19, r21
     33e:	30 f4       	brcc	.+12     	; 0x34c <can_tx+0x6e>
			// CANMSG auto increments
			CANMSG = packet->data[cnt];
     340:	8d 91       	ld	r24, X+
     342:	80 93 fa 00 	sts	0x00FA, r24
		CANIDT2 = packet->id << 5;
        CANIDT3 = 0;
        CANIDT4 = 0;
		
		// Set the data
		for (cnt = 0; cnt < packet->length; ++cnt) {
     346:	2f 5f       	subi	r18, 0xFF	; 255
     348:	3f 4f       	sbci	r19, 0xFF	; 255
     34a:	f4 cf       	rjmp	.-24     	; 0x334 <can_tx+0x56>
			// CANMSG auto increments
			CANMSG = packet->data[cnt];
		}
		
		// Set message length
    	CANCDMOB |= packet->length;
     34c:	80 91 ef 00 	lds	r24, 0x00EF
     350:	06 c0       	rjmp	.+12     	; 0x35e <can_tx+0x80>
	} else {
		// Set the ID to send
		CANIDT1=packet->id >> 3;
		CANIDT2=packet->id << 5;
        CANIDT3 = 0;
        CANIDT4 = 1<<RTRTAG;	// RTR
     352:	84 e0       	ldi	r24, 0x04	; 4
     354:	80 93 f0 00 	sts	0x00F0, r24
		
		// Set the packet length
		CANCDMOB |= packet->length;
     358:	90 91 ef 00 	lds	r25, 0x00EF
     35c:	82 81       	ldd	r24, Z+2	; 0x02
     35e:	89 2b       	or	r24, r25
     360:	80 93 ef 00 	sts	0x00EF, r24
	}
	
	// Enable TX
    CANCDMOB|=0x40;
     364:	80 91 ef 00 	lds	r24, 0x00EF
     368:	80 64       	ori	r24, 0x40	; 64
     36a:	80 93 ef 00 	sts	0x00EF, r24
	
	// Success
	return true;
     36e:	81 e0       	ldi	r24, 0x01	; 1
     370:	08 95       	ret
    CANPAGE = mob << 4;
	
	// If MOB in use and TX not ready
	if((CANCDMOB & 0b11000000) && ((CANSTMOB & 0x40) == 0)) {
		// Failure
		return false;
     372:	80 e0       	ldi	r24, 0x00	; 0
	// Enable TX
    CANCDMOB|=0x40;
	
	// Success
	return true;
}
     374:	08 95       	ret

00000376 <prepare_rx>:
 * @param idmask: the CAN mask to use
 * @param callback the callback function to call when a receive happens
 */
bool prepare_rx(char mob, unsigned id, unsigned idmask, CAN_cbf callback) {
	// Protect against illegal mailbox number
	if(mob >= 15) {
     376:	8f 30       	cpi	r24, 0x0F	; 15
     378:	14 f0       	brlt	.+4      	; 0x37e <prepare_rx+0x8>
		// True indicates error
		return true;
     37a:	81 e0       	ldi	r24, 0x01	; 1
     37c:	08 95       	ret
	}
	
	// Add the callback to the CAN list
	canlist[(unsigned)mob] = callback;
     37e:	e8 2f       	mov	r30, r24
     380:	ee 0f       	add	r30, r30
     382:	ff 0b       	sbc	r31, r31
     384:	e5 57       	subi	r30, 0x75	; 117
     386:	f0 4f       	sbci	r31, 0xF0	; 240
     388:	31 83       	std	Z+1, r19	; 0x01
     38a:	20 83       	st	Z, r18
	
	// Set the CAN page
    CANPAGE = mob << 4;
     38c:	98 2f       	mov	r25, r24
     38e:	92 95       	swap	r25
     390:	90 7f       	andi	r25, 0xF0	; 240
     392:	90 93 ed 00 	sts	0x00ED, r25
	
	// Release mailbox if requested
	if(callback == 0) { 
     396:	23 2b       	or	r18, r19
     398:	a1 f4       	brne	.+40     	; 0x3c2 <prepare_rx+0x4c>
		// Cancel pending operation
		CANSTMOB = 0x00;
     39a:	10 92 ee 00 	sts	0x00EE, r1
		CANCDMOB = 0x00;
     39e:	10 92 ef 00 	sts	0x00EF, r1
		// Disable interrupt for this mailbox
		unsigned mask = 1 << mob;
		CANIE2 &= ~mask;
     3a2:	40 91 de 00 	lds	r20, 0x00DE
	if(callback == 0) { 
		// Cancel pending operation
		CANSTMOB = 0x00;
		CANCDMOB = 0x00;
		// Disable interrupt for this mailbox
		unsigned mask = 1 << mob;
     3a6:	21 e0       	ldi	r18, 0x01	; 1
     3a8:	30 e0       	ldi	r19, 0x00	; 0
     3aa:	b9 01       	movw	r22, r18
     3ac:	02 c0       	rjmp	.+4      	; 0x3b2 <prepare_rx+0x3c>
     3ae:	66 0f       	add	r22, r22
     3b0:	77 1f       	adc	r23, r23
     3b2:	8a 95       	dec	r24
     3b4:	e2 f7       	brpl	.-8      	; 0x3ae <prepare_rx+0x38>
     3b6:	cb 01       	movw	r24, r22
		CANIE2 &= ~mask;
     3b8:	80 95       	com	r24
     3ba:	84 23       	and	r24, r20
     3bc:	80 93 de 00 	sts	0x00DE, r24
     3c0:	3e c0       	rjmp	.+124    	; 0x43e <prepare_rx+0xc8>
		// Success
		return false;
	} 
	
	// See if the mailbox is in use
	if( CANCDMOB & 0b11000000) {
     3c2:	90 91 ef 00 	lds	r25, 0x00EF
     3c6:	90 7c       	andi	r25, 0xC0	; 192
     3c8:	c1 f6       	brne	.-80     	; 0x37a <prepare_rx+0x4>
		return true;
	}
	
	// Mailbox isn't in use
	// Cancel pending operation
	CANSTMOB = 0x00;
     3ca:	10 92 ee 00 	sts	0x00EE, r1
	CANCDMOB = 0x00;
     3ce:	10 92 ef 00 	sts	0x00EF, r1
	// Enable direct mailbox indexing
	CANHPMOB = 0x00;
     3d2:	10 92 ec 00 	sts	0x00EC, r1
	
	// Set ID to receive
	CANIDT1 = id >> 3;
     3d6:	9b 01       	movw	r18, r22
     3d8:	93 e0       	ldi	r25, 0x03	; 3
     3da:	36 95       	lsr	r19
     3dc:	27 95       	ror	r18
     3de:	9a 95       	dec	r25
     3e0:	e1 f7       	brne	.-8      	; 0x3da <prepare_rx+0x64>
     3e2:	20 93 f3 00 	sts	0x00F3, r18
	CANIDT2 = id << 5;
     3e6:	62 95       	swap	r22
     3e8:	66 0f       	add	r22, r22
     3ea:	60 7e       	andi	r22, 0xE0	; 224
     3ec:	60 93 f2 00 	sts	0x00F2, r22
	// Set receive mask
	CANIDM1=idmask >> 3;
     3f0:	9a 01       	movw	r18, r20
     3f2:	53 e0       	ldi	r21, 0x03	; 3
     3f4:	36 95       	lsr	r19
     3f6:	27 95       	ror	r18
     3f8:	5a 95       	dec	r21
     3fa:	e1 f7       	brne	.-8      	; 0x3f4 <prepare_rx+0x7e>
     3fc:	20 93 f7 00 	sts	0x00F7, r18
	CANIDM2=idmask << 5;
     400:	42 95       	swap	r20
     402:	44 0f       	add	r20, r20
     404:	40 7e       	andi	r20, 0xE0	; 224
     406:	40 93 f6 00 	sts	0x00F6, r20
	CANIDM3=0;
     40a:	10 92 f5 00 	sts	0x00F5, r1
	CANIDM4=0;
     40e:	10 92 f4 00 	sts	0x00F4, r1
	
	// Enable RX
	CANCDMOB = 0x80;
     412:	90 e8       	ldi	r25, 0x80	; 128
     414:	90 93 ef 00 	sts	0x00EF, r25
	// Enable interrupt for this mailbox
	unsigned mask = 1 << mob;
     418:	21 e0       	ldi	r18, 0x01	; 1
     41a:	30 e0       	ldi	r19, 0x00	; 0
     41c:	a9 01       	movw	r20, r18
     41e:	02 c0       	rjmp	.+4      	; 0x424 <prepare_rx+0xae>
     420:	44 0f       	add	r20, r20
     422:	55 1f       	adc	r21, r21
     424:	8a 95       	dec	r24
     426:	e2 f7       	brpl	.-8      	; 0x420 <prepare_rx+0xaa>
     428:	ca 01       	movw	r24, r20
	CANIE2 |= mask;
     42a:	20 91 de 00 	lds	r18, 0x00DE
     42e:	82 2b       	or	r24, r18
     430:	80 93 de 00 	sts	0x00DE, r24
	CANIE1 |= (mask >> 8);
     434:	80 91 df 00 	lds	r24, 0x00DF
     438:	89 2b       	or	r24, r25
     43a:	80 93 df 00 	sts	0x00DF, r24
	
	// Return false indicating success
	return false;
     43e:	80 e0       	ldi	r24, 0x00	; 0
}
     440:	08 95       	ret

00000442 <can_init>:
	// Function variable
	unsigned mob;

	// Set baudrate to 500kbit/s
	// NOTE: ASSUMES 16MHz OSCILLATOR FREQUENCY
	CANBT1=0x06;	// 16 MHz, 500kbit/s
     442:	86 e0       	ldi	r24, 0x06	; 6
     444:	80 93 e2 00 	sts	0x00E2, r24
	CANBT2=0x04;
     448:	84 e0       	ldi	r24, 0x04	; 4
     44a:	80 93 e3 00 	sts	0x00E3, r24
	CANBT3=0x13;
     44e:	83 e1       	ldi	r24, 0x13	; 19
     450:	80 93 e4 00 	sts	0x00E4, r24
     454:	80 e0       	ldi	r24, 0x00	; 0
	
	// Clear registers
	for (mob = 0; mob < NO_MOBS; mob++) {
		CANPAGE  = (mob << 4);
     456:	98 2f       	mov	r25, r24
     458:	92 95       	swap	r25
     45a:	90 7f       	andi	r25, 0xF0	; 240
     45c:	90 93 ed 00 	sts	0x00ED, r25
		CANSTMOB = 0;
     460:	10 92 ee 00 	sts	0x00EE, r1
		CANCDMOB = 0;
     464:	10 92 ef 00 	sts	0x00EF, r1
     468:	8f 5f       	subi	r24, 0xFF	; 255
	CANBT1=0x06;	// 16 MHz, 500kbit/s
	CANBT2=0x04;
	CANBT3=0x13;
	
	// Clear registers
	for (mob = 0; mob < NO_MOBS; mob++) {
     46a:	86 30       	cpi	r24, 0x06	; 6
     46c:	a1 f7       	brne	.-24     	; 0x456 <can_init+0x14>
		CANSTMOB = 0;
		CANCDMOB = 0;
	}
	
	// Enable CAN
	CANGCON |= 0x02;
     46e:	80 91 d8 00 	lds	r24, 0x00D8
     472:	82 60       	ori	r24, 0x02	; 2
     474:	80 93 d8 00 	sts	0x00D8, r24
	// Enable receive interrupt
	CANGIE = (1 << ENIT) | (1 << ENRX);
     478:	80 ea       	ldi	r24, 0xA0	; 160
     47a:	80 93 db 00 	sts	0x00DB, r24
     47e:	08 95       	ret

00000480 <CAN_callback>:
/* CAN callback
 * Callback routine for interrupts of all received CAN packets
 * This routine scans the list of all MOBs to find the responsible FreeRTOS 
 * queue to enqueue this CAN packet to.
 */
static void CAN_callback(CAN_packet *p, unsigned char mob) {
     480:	ff 92       	push	r15
     482:	0f 93       	push	r16
     484:	1f 93       	push	r17
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
     48a:	1f 92       	push	r1
     48c:	cd b7       	in	r28, 0x3d	; 61
     48e:	de b7       	in	r29, 0x3e	; 62
     490:	8c 01       	movw	r16, r24
     492:	f6 2e       	mov	r15, r22
	// Task previously woken varaible
	portBASE_TYPE xTaskWoken = pdFALSE;
     494:	19 82       	std	Y+1, r1	; 0x01
	
	// Make sure queue for this mailbox is set up
	assert(channels[mob] != 0);
	
	// Send the packet to the queue
	xQueueSendFromISR(channels[mob], p, &xTaskWoken);
     496:	e6 2f       	mov	r30, r22
     498:	f0 e0       	ldi	r31, 0x00	; 0
     49a:	ee 0f       	add	r30, r30
     49c:	ff 1f       	adc	r31, r31
     49e:	e9 56       	subi	r30, 0x69	; 105
     4a0:	f0 4f       	sbci	r31, 0xF0	; 240
     4a2:	20 e0       	ldi	r18, 0x00	; 0
     4a4:	ae 01       	movw	r20, r28
     4a6:	4f 5f       	subi	r20, 0xFF	; 255
     4a8:	5f 4f       	sbci	r21, 0xFF	; 255
     4aa:	b8 01       	movw	r22, r16
     4ac:	80 81       	ld	r24, Z
     4ae:	91 81       	ldd	r25, Z+1	; 0x01
     4b0:	0e 94 ed 06 	call	0xdda	; 0xdda <xQueueGenericSendFromISR>
	
	// Send to dump queue if set up, making sure not to double-send
	if(CANdumpQueue && (mob != CAN_DUMP_MOB)) {
     4b4:	80 91 a3 0f 	lds	r24, 0x0FA3
     4b8:	90 91 a4 0f 	lds	r25, 0x0FA4
     4bc:	00 97       	sbiw	r24, 0x00	; 0
     4be:	51 f0       	breq	.+20     	; 0x4d4 <CAN_callback+0x54>
     4c0:	25 e0       	ldi	r18, 0x05	; 5
     4c2:	f2 16       	cp	r15, r18
     4c4:	39 f0       	breq	.+14     	; 0x4d4 <CAN_callback+0x54>
		xQueueSendFromISR(CANdumpQueue, p, &xTaskWoken);
     4c6:	20 e0       	ldi	r18, 0x00	; 0
     4c8:	ae 01       	movw	r20, r28
     4ca:	4f 5f       	subi	r20, 0xFF	; 255
     4cc:	5f 4f       	sbci	r21, 0xFF	; 255
     4ce:	b8 01       	movw	r22, r16
     4d0:	0e 94 ed 06 	call	0xdda	; 0xdda <xQueueGenericSendFromISR>
	}
	
	// If posting to this queue woke a task, then immediately perform a context switch
	if(xTaskWoken)
     4d4:	89 81       	ldd	r24, Y+1	; 0x01
     4d6:	81 11       	cpse	r24, r1
		taskYIELD();
     4d8:	0e 94 49 04 	call	0x892	; 0x892 <vPortYield>
}
     4dc:	0f 90       	pop	r0
     4de:	df 91       	pop	r29
     4e0:	cf 91       	pop	r28
     4e2:	1f 91       	pop	r17
     4e4:	0f 91       	pop	r16
     4e6:	ff 90       	pop	r15
     4e8:	08 95       	ret

000004ea <can_dump_init>:
 * All received packets can be examined using the FreeRTOS queue "CANdumpQueue"
 * @param items buffer size (number of can packets) 
 */	
void can_dump_init(unsigned items) {
	// Create queue to receive all packets
	CANdumpQueue = xQueueCreate(items, sizeof(CAN_packet));
     4ea:	40 e0       	ldi	r20, 0x00	; 0
     4ec:	6b e0       	ldi	r22, 0x0B	; 11
     4ee:	0e 94 1f 06 	call	0xc3e	; 0xc3e <xQueueGenericCreate>
     4f2:	90 93 a4 0f 	sts	0x0FA4, r25
     4f6:	80 93 a3 0f 	sts	0x0FA3, r24
	assert(CANdumpQueue !=0);
	
	// Catch all "floating" IDs using CAN_DUMP_MOB
	channels[CAN_DUMP_MOB] = CANdumpQueue;
     4fa:	90 93 a2 0f 	sts	0x0FA2, r25
     4fe:	80 93 a1 0f 	sts	0x0FA1, r24
     502:	08 95       	ret

00000504 <xCANQueueCreate>:
 * @param id CAN identifier
 * @param id_mask CAN identifier mask
 * @param uxQueueLength number of packets to buffer in queue
 * @return handle of FreeRTOS queue of CAN packets
 */
xQueueHandle xCANQueueCreate(unsigned id, unsigned idmask, portBASE_TYPE uxQueueLength, unsigned char mob) {
     504:	cf 92       	push	r12
     506:	df 92       	push	r13
     508:	ef 92       	push	r14
     50a:	ff 92       	push	r15
     50c:	1f 93       	push	r17
     50e:	cf 93       	push	r28
     510:	df 93       	push	r29
     512:	7c 01       	movw	r14, r24
     514:	6b 01       	movw	r12, r22
     516:	84 2f       	mov	r24, r20
     518:	12 2f       	mov	r17, r18
	
	// Uncomment to make this a critical section
	// taskENTER_CRITICAL();
	
	// Create the queue
	theQ = xQueueCreate(uxQueueLength, sizeof(CAN_packet));
     51a:	40 e0       	ldi	r20, 0x00	; 0
     51c:	6b e0       	ldi	r22, 0x0B	; 11
     51e:	0e 94 1f 06 	call	0xc3e	; 0xc3e <xQueueGenericCreate>
     522:	ec 01       	movw	r28, r24
	
	// Check to see if queue was successfully made
	if(theQ == 0)
     524:	89 2b       	or	r24, r25
     526:	a9 f0       	breq	.+42     	; 0x552 <xCANQueueCreate+0x4e>
		return theQ;	// If unsuccessful return zero now
		
	// Make sure this is a free mailbox
	if(channels[mob] != 0) {
     528:	e1 2f       	mov	r30, r17
     52a:	f0 e0       	ldi	r31, 0x00	; 0
     52c:	ee 0f       	add	r30, r30
     52e:	ff 1f       	adc	r31, r31
     530:	e9 56       	subi	r30, 0x69	; 105
     532:	f0 4f       	sbci	r31, 0xF0	; 240
     534:	80 81       	ld	r24, Z
     536:	91 81       	ldd	r25, Z+1	; 0x01
     538:	89 2b       	or	r24, r25
     53a:	59 f4       	brne	.+22     	; 0x552 <xCANQueueCreate+0x4e>
		return 0;
	}
	
	// Associate queue with free mailbox found and setup receive
	channels[mob] = theQ;
     53c:	d1 83       	std	Z+1, r29	; 0x01
     53e:	c0 83       	st	Z, r28
	prepare_rx(mob, id, idmask, CAN_callback);
     540:	20 e4       	ldi	r18, 0x40	; 64
     542:	32 e0       	ldi	r19, 0x02	; 2
     544:	a6 01       	movw	r20, r12
     546:	b7 01       	movw	r22, r14
     548:	81 2f       	mov	r24, r17
     54a:	0e 94 bb 01 	call	0x376	; 0x376 <prepare_rx>
	
	// Uncomment to make this a critical section
	// taskEXIT_CRITICAL();
	
	// Return the successfully created queue
	return theQ;
     54e:	ce 01       	movw	r24, r28
     550:	02 c0       	rjmp	.+4      	; 0x556 <xCANQueueCreate+0x52>
     552:	80 e0       	ldi	r24, 0x00	; 0
     554:	90 e0       	ldi	r25, 0x00	; 0
}
     556:	df 91       	pop	r29
     558:	cf 91       	pop	r28
     55a:	1f 91       	pop	r17
     55c:	ff 90       	pop	r15
     55e:	ef 90       	pop	r14
     560:	df 90       	pop	r13
     562:	cf 90       	pop	r12
     564:	08 95       	ret

00000566 <get_free_mob>:

/* Get free CAN mailbox
 * Finds first unused CAN mailbox
 * @return mailbox number, or -1 if none found
 */
int get_free_mob() {
     566:	e7 e9       	ldi	r30, 0x97	; 151
     568:	ff e0       	ldi	r31, 0x0F	; 15
	// Function variable
	unsigned mob;
	
	// Find free mailbox
	for(mob = 0; mob < NO_MOBS; ++mob) {
     56a:	20 e0       	ldi	r18, 0x00	; 0
     56c:	30 e0       	ldi	r19, 0x00	; 0
		// Break if this mailbox is free
		if(channels[mob] == 0) {
     56e:	81 91       	ld	r24, Z+
     570:	91 91       	ld	r25, Z+
     572:	89 2b       	or	r24, r25
     574:	41 f0       	breq	.+16     	; 0x586 <get_free_mob+0x20>
int get_free_mob() {
	// Function variable
	unsigned mob;
	
	// Find free mailbox
	for(mob = 0; mob < NO_MOBS; ++mob) {
     576:	2f 5f       	subi	r18, 0xFF	; 255
     578:	3f 4f       	sbci	r19, 0xFF	; 255
     57a:	26 30       	cpi	r18, 0x06	; 6
     57c:	31 05       	cpc	r19, r1
     57e:	b9 f7       	brne	.-18     	; 0x56e <get_free_mob+0x8>
		}
	}
	
	// Return -1 if out of mailboxes
	if(mob == NO_MOBS)
		return -1;
     580:	8f ef       	ldi	r24, 0xFF	; 255
     582:	9f ef       	ldi	r25, 0xFF	; 255
     584:	08 95       	ret
		
	// Else return the mailbox
	return mob;
     586:	c9 01       	movw	r24, r18
}
     588:	08 95       	ret

0000058a <can_send>:
 * @param packet pointer to CAN packet to send
 * @param mob CAN channel to use for this ID (use mob=14 13 12 ...)
 * @param xTicksToWait maximum time before give up (timeout)
 * @return TRUE on successful transmission, FALSE on timeout.
 */	
portBASE_TYPE can_send(CAN_packet *p, unsigned mob, portTickType xTicksToWait) {
     58a:	af 92       	push	r10
     58c:	bf 92       	push	r11
     58e:	cf 92       	push	r12
     590:	df 92       	push	r13
     592:	ef 92       	push	r14
     594:	ff 92       	push	r15
     596:	0f 93       	push	r16
     598:	1f 93       	push	r17
     59a:	cf 93       	push	r28
     59c:	df 93       	push	r29
     59e:	7c 01       	movw	r14, r24
     5a0:	6b 01       	movw	r12, r22

	// Make sure the specified mailbox is vacated
	assert(channels[mob] == (CAN_cbf)0);
	
	// Set mailbox as in use
	channels[mob]=(CAN_cbf)0xffff;
     5a2:	8b 01       	movw	r16, r22
     5a4:	00 0f       	add	r16, r16
     5a6:	11 1f       	adc	r17, r17
     5a8:	f8 01       	movw	r30, r16
     5aa:	e9 56       	subi	r30, 0x69	; 105
     5ac:	f0 4f       	sbci	r31, 0xF0	; 240
     5ae:	8f ef       	ldi	r24, 0xFF	; 255
     5b0:	9f ef       	ldi	r25, 0xFF	; 255
     5b2:	91 83       	std	Z+1, r25	; 0x01
     5b4:	80 83       	st	Z, r24
	
	// Wait for timeout
	while(xTicksToWait--) {
     5b6:	ea 01       	movw	r28, r20
     5b8:	21 97       	sbiw	r28, 0x01	; 1
     5ba:	cf 3f       	cpi	r28, 0xFF	; 255
     5bc:	8f ef       	ldi	r24, 0xFF	; 255
     5be:	d8 07       	cpc	r29, r24
     5c0:	e1 f0       	breq	.+56     	; 0x5fa <can_send+0x70>
		// Try to transmit packet on specified mob
		retv = can_tx(mob, p);
     5c2:	b7 01       	movw	r22, r14
     5c4:	8c 2d       	mov	r24, r12
     5c6:	0e 94 6f 01 	call	0x2de	; 0x2de <can_tx>
     5ca:	5e 01       	movw	r10, r28
     5cc:	91 e0       	ldi	r25, 0x01	; 1
     5ce:	a9 1a       	sub	r10, r25
     5d0:	b1 08       	sbc	r11, r1
		
		// See if transmission successful
		if(retv == true) {
     5d2:	88 23       	and	r24, r24
     5d4:	61 f0       	breq	.+24     	; 0x5ee <can_send+0x64>
			// Send to dump queue if enabled
			if(CANdumpQueue)
     5d6:	80 91 a3 0f 	lds	r24, 0x0FA3
     5da:	90 91 a4 0f 	lds	r25, 0x0FA4
     5de:	00 97       	sbiw	r24, 0x00	; 0
     5e0:	71 f0       	breq	.+28     	; 0x5fe <can_send+0x74>
				xQueueSend(CANdumpQueue, p, xTicksToWait);
     5e2:	20 e0       	ldi	r18, 0x00	; 0
     5e4:	ae 01       	movw	r20, r28
     5e6:	b7 01       	movw	r22, r14
     5e8:	0e 94 53 06 	call	0xca6	; 0xca6 <xQueueGenericSend>
     5ec:	08 c0       	rjmp	.+16     	; 0x5fe <can_send+0x74>
			// Break out of loop
			break;
		}
		// This method is not really elegant, but it is safe and simple, since 
		// in usual systems this "busy" waiting will not be used at all
		vTaskDelay(1);
     5ee:	81 e0       	ldi	r24, 0x01	; 1
     5f0:	90 e0       	ldi	r25, 0x00	; 0
     5f2:	0e 94 24 0c 	call	0x1848	; 0x1848 <vTaskDelay>
     5f6:	e5 01       	movw	r28, r10
     5f8:	e0 cf       	rjmp	.-64     	; 0x5ba <can_send+0x30>
     5fa:	80 e0       	ldi	r24, 0x00	; 0
     5fc:	01 c0       	rjmp	.+2      	; 0x600 <can_send+0x76>
	channels[mob]=(CAN_cbf)0xffff;
	
	// Wait for timeout
	while(xTicksToWait--) {
		// Try to transmit packet on specified mob
		retv = can_tx(mob, p);
     5fe:	81 e0       	ldi	r24, 0x01	; 1
		// in usual systems this "busy" waiting will not be used at all
		vTaskDelay(1);
	}
	
	// Vacate mailbox
	channels[mob]=(CAN_cbf)0;
     600:	f8 01       	movw	r30, r16
     602:	e9 56       	subi	r30, 0x69	; 105
     604:	f0 4f       	sbci	r31, 0xF0	; 240
     606:	11 82       	std	Z+1, r1	; 0x01
     608:	10 82       	st	Z, r1

	return retv;
}
     60a:	df 91       	pop	r29
     60c:	cf 91       	pop	r28
     60e:	1f 91       	pop	r17
     610:	0f 91       	pop	r16
     612:	ff 90       	pop	r15
     614:	ef 90       	pop	r14
     616:	df 90       	pop	r13
     618:	cf 90       	pop	r12
     61a:	bf 90       	pop	r11
     61c:	af 90       	pop	r10
     61e:	08 95       	ret

00000620 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     620:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     622:	03 96       	adiw	r24, 0x03	; 3
     624:	92 83       	std	Z+2, r25	; 0x02
     626:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     628:	2f ef       	ldi	r18, 0xFF	; 255
     62a:	3f ef       	ldi	r19, 0xFF	; 255
     62c:	34 83       	std	Z+4, r19	; 0x04
     62e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     630:	96 83       	std	Z+6, r25	; 0x06
     632:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     634:	90 87       	std	Z+8, r25	; 0x08
     636:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     638:	10 82       	st	Z, r1
     63a:	08 95       	ret

0000063c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     63c:	fc 01       	movw	r30, r24
     63e:	11 86       	std	Z+9, r1	; 0x09
     640:	10 86       	std	Z+8, r1	; 0x08
     642:	08 95       	ret

00000644 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     644:	cf 93       	push	r28
     646:	df 93       	push	r29
     648:	9c 01       	movw	r18, r24
     64a:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     64c:	dc 01       	movw	r26, r24
     64e:	11 96       	adiw	r26, 0x01	; 1
     650:	cd 91       	ld	r28, X+
     652:	dc 91       	ld	r29, X
     654:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     656:	d3 83       	std	Z+3, r29	; 0x03
     658:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     65a:	8c 81       	ldd	r24, Y+4	; 0x04
     65c:	9d 81       	ldd	r25, Y+5	; 0x05
     65e:	95 83       	std	Z+5, r25	; 0x05
     660:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     662:	8c 81       	ldd	r24, Y+4	; 0x04
     664:	9d 81       	ldd	r25, Y+5	; 0x05
     666:	dc 01       	movw	r26, r24
     668:	13 96       	adiw	r26, 0x03	; 3
     66a:	7c 93       	st	X, r23
     66c:	6e 93       	st	-X, r22
     66e:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     670:	7d 83       	std	Y+5, r23	; 0x05
     672:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     674:	31 87       	std	Z+9, r19	; 0x09
     676:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     678:	f9 01       	movw	r30, r18
     67a:	80 81       	ld	r24, Z
     67c:	8f 5f       	subi	r24, 0xFF	; 255
     67e:	80 83       	st	Z, r24
}
     680:	df 91       	pop	r29
     682:	cf 91       	pop	r28
     684:	08 95       	ret

00000686 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     686:	0f 93       	push	r16
     688:	1f 93       	push	r17
     68a:	cf 93       	push	r28
     68c:	df 93       	push	r29
     68e:	8c 01       	movw	r16, r24
     690:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     692:	80 81       	ld	r24, Z
     694:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     696:	8f 3f       	cpi	r24, 0xFF	; 255
     698:	2f ef       	ldi	r18, 0xFF	; 255
     69a:	92 07       	cpc	r25, r18
     69c:	21 f4       	brne	.+8      	; 0x6a6 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     69e:	e8 01       	movw	r28, r16
     6a0:	af 81       	ldd	r26, Y+7	; 0x07
     6a2:	b8 85       	ldd	r27, Y+8	; 0x08
     6a4:	0e c0       	rjmp	.+28     	; 0x6c2 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6a6:	d8 01       	movw	r26, r16
     6a8:	13 96       	adiw	r26, 0x03	; 3
     6aa:	12 96       	adiw	r26, 0x02	; 2
     6ac:	2d 91       	ld	r18, X+
     6ae:	3c 91       	ld	r19, X
     6b0:	13 97       	sbiw	r26, 0x03	; 3
     6b2:	e9 01       	movw	r28, r18
     6b4:	48 81       	ld	r20, Y
     6b6:	59 81       	ldd	r21, Y+1	; 0x01
     6b8:	84 17       	cp	r24, r20
     6ba:	95 07       	cpc	r25, r21
     6bc:	10 f0       	brcs	.+4      	; 0x6c2 <vListInsert+0x3c>
     6be:	d9 01       	movw	r26, r18
     6c0:	f4 cf       	rjmp	.-24     	; 0x6aa <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     6c2:	12 96       	adiw	r26, 0x02	; 2
     6c4:	8d 91       	ld	r24, X+
     6c6:	9c 91       	ld	r25, X
     6c8:	13 97       	sbiw	r26, 0x03	; 3
     6ca:	93 83       	std	Z+3, r25	; 0x03
     6cc:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     6ce:	ec 01       	movw	r28, r24
     6d0:	fd 83       	std	Y+5, r31	; 0x05
     6d2:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     6d4:	b5 83       	std	Z+5, r27	; 0x05
     6d6:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     6d8:	13 96       	adiw	r26, 0x03	; 3
     6da:	fc 93       	st	X, r31
     6dc:	ee 93       	st	-X, r30
     6de:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6e0:	11 87       	std	Z+9, r17	; 0x09
     6e2:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
     6e4:	f8 01       	movw	r30, r16
     6e6:	80 81       	ld	r24, Z
     6e8:	8f 5f       	subi	r24, 0xFF	; 255
     6ea:	80 83       	st	Z, r24
}
     6ec:	df 91       	pop	r29
     6ee:	cf 91       	pop	r28
     6f0:	1f 91       	pop	r17
     6f2:	0f 91       	pop	r16
     6f4:	08 95       	ret

000006f6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     6f6:	cf 93       	push	r28
     6f8:	df 93       	push	r29
     6fa:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     6fc:	a0 85       	ldd	r26, Z+8	; 0x08
     6fe:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     700:	82 81       	ldd	r24, Z+2	; 0x02
     702:	93 81       	ldd	r25, Z+3	; 0x03
     704:	24 81       	ldd	r18, Z+4	; 0x04
     706:	35 81       	ldd	r19, Z+5	; 0x05
     708:	ec 01       	movw	r28, r24
     70a:	3d 83       	std	Y+5, r19	; 0x05
     70c:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     70e:	c4 81       	ldd	r28, Z+4	; 0x04
     710:	d5 81       	ldd	r29, Z+5	; 0x05
     712:	9b 83       	std	Y+3, r25	; 0x03
     714:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     716:	11 96       	adiw	r26, 0x01	; 1
     718:	8d 91       	ld	r24, X+
     71a:	9c 91       	ld	r25, X
     71c:	12 97       	sbiw	r26, 0x02	; 2
     71e:	8e 17       	cp	r24, r30
     720:	9f 07       	cpc	r25, r31
     722:	21 f4       	brne	.+8      	; 0x72c <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     724:	12 96       	adiw	r26, 0x02	; 2
     726:	dc 93       	st	X, r29
     728:	ce 93       	st	-X, r28
     72a:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     72c:	11 86       	std	Z+9, r1	; 0x09
     72e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     730:	8c 91       	ld	r24, X
     732:	81 50       	subi	r24, 0x01	; 1
     734:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     736:	df 91       	pop	r29
     738:	cf 91       	pop	r28
     73a:	08 95       	ret

0000073c <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     73c:	31 e1       	ldi	r19, 0x11	; 17
     73e:	fc 01       	movw	r30, r24
     740:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     742:	31 97       	sbiw	r30, 0x01	; 1
     744:	22 e2       	ldi	r18, 0x22	; 34
     746:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     748:	31 97       	sbiw	r30, 0x01	; 1
     74a:	a3 e3       	ldi	r26, 0x33	; 51
     74c:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     74e:	31 97       	sbiw	r30, 0x01	; 1
     750:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     752:	31 97       	sbiw	r30, 0x01	; 1
     754:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     756:	31 97       	sbiw	r30, 0x01	; 1
     758:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     75a:	31 97       	sbiw	r30, 0x01	; 1
     75c:	60 e8       	ldi	r22, 0x80	; 128
     75e:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     760:	31 97       	sbiw	r30, 0x01	; 1
     762:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     764:	31 97       	sbiw	r30, 0x01	; 1
     766:	62 e0       	ldi	r22, 0x02	; 2
     768:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     76a:	31 97       	sbiw	r30, 0x01	; 1
     76c:	63 e0       	ldi	r22, 0x03	; 3
     76e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     770:	31 97       	sbiw	r30, 0x01	; 1
     772:	64 e0       	ldi	r22, 0x04	; 4
     774:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     776:	31 97       	sbiw	r30, 0x01	; 1
     778:	65 e0       	ldi	r22, 0x05	; 5
     77a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     77c:	31 97       	sbiw	r30, 0x01	; 1
     77e:	66 e0       	ldi	r22, 0x06	; 6
     780:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     782:	31 97       	sbiw	r30, 0x01	; 1
     784:	67 e0       	ldi	r22, 0x07	; 7
     786:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     788:	31 97       	sbiw	r30, 0x01	; 1
     78a:	68 e0       	ldi	r22, 0x08	; 8
     78c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     78e:	31 97       	sbiw	r30, 0x01	; 1
     790:	69 e0       	ldi	r22, 0x09	; 9
     792:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     794:	31 97       	sbiw	r30, 0x01	; 1
     796:	60 e1       	ldi	r22, 0x10	; 16
     798:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     79a:	31 97       	sbiw	r30, 0x01	; 1
     79c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     79e:	31 97       	sbiw	r30, 0x01	; 1
     7a0:	32 e1       	ldi	r19, 0x12	; 18
     7a2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     7a4:	31 97       	sbiw	r30, 0x01	; 1
     7a6:	33 e1       	ldi	r19, 0x13	; 19
     7a8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     7aa:	31 97       	sbiw	r30, 0x01	; 1
     7ac:	34 e1       	ldi	r19, 0x14	; 20
     7ae:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     7b0:	31 97       	sbiw	r30, 0x01	; 1
     7b2:	35 e1       	ldi	r19, 0x15	; 21
     7b4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     7b6:	31 97       	sbiw	r30, 0x01	; 1
     7b8:	36 e1       	ldi	r19, 0x16	; 22
     7ba:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     7bc:	31 97       	sbiw	r30, 0x01	; 1
     7be:	37 e1       	ldi	r19, 0x17	; 23
     7c0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     7c2:	31 97       	sbiw	r30, 0x01	; 1
     7c4:	38 e1       	ldi	r19, 0x18	; 24
     7c6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     7c8:	31 97       	sbiw	r30, 0x01	; 1
     7ca:	39 e1       	ldi	r19, 0x19	; 25
     7cc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     7ce:	31 97       	sbiw	r30, 0x01	; 1
     7d0:	30 e2       	ldi	r19, 0x20	; 32
     7d2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     7d4:	31 97       	sbiw	r30, 0x01	; 1
     7d6:	31 e2       	ldi	r19, 0x21	; 33
     7d8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     7da:	31 97       	sbiw	r30, 0x01	; 1
     7dc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     7de:	31 97       	sbiw	r30, 0x01	; 1
     7e0:	23 e2       	ldi	r18, 0x23	; 35
     7e2:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     7e4:	31 97       	sbiw	r30, 0x01	; 1
     7e6:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     7e8:	31 97       	sbiw	r30, 0x01	; 1
     7ea:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     7ec:	31 97       	sbiw	r30, 0x01	; 1
     7ee:	26 e2       	ldi	r18, 0x26	; 38
     7f0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     7f2:	31 97       	sbiw	r30, 0x01	; 1
     7f4:	27 e2       	ldi	r18, 0x27	; 39
     7f6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     7f8:	31 97       	sbiw	r30, 0x01	; 1
     7fa:	28 e2       	ldi	r18, 0x28	; 40
     7fc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     7fe:	31 97       	sbiw	r30, 0x01	; 1
     800:	29 e2       	ldi	r18, 0x29	; 41
     802:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     804:	31 97       	sbiw	r30, 0x01	; 1
     806:	20 e3       	ldi	r18, 0x30	; 48
     808:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     80a:	31 97       	sbiw	r30, 0x01	; 1
     80c:	21 e3       	ldi	r18, 0x31	; 49
     80e:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     810:	86 97       	sbiw	r24, 0x26	; 38
     812:	08 95       	ret

00000814 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     814:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
     818:	89 ef       	ldi	r24, 0xF9	; 249
     81a:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     81e:	8b e0       	ldi	r24, 0x0B	; 11
     820:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
     824:	ef e6       	ldi	r30, 0x6F	; 111
     826:	f0 e0       	ldi	r31, 0x00	; 0
     828:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     82a:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
     82c:	80 83       	st	Z, r24
	
	TCNT1 = 0;
     82e:	10 92 85 00 	sts	0x0085, r1
     832:	10 92 84 00 	sts	0x0084, r1
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     836:	a0 91 27 0f 	lds	r26, 0x0F27
     83a:	b0 91 28 0f 	lds	r27, 0x0F28
     83e:	cd 91       	ld	r28, X+
     840:	cd bf       	out	0x3d, r28	; 61
     842:	dd 91       	ld	r29, X+
     844:	de bf       	out	0x3e, r29	; 62
     846:	ff 91       	pop	r31
     848:	ef 91       	pop	r30
     84a:	df 91       	pop	r29
     84c:	cf 91       	pop	r28
     84e:	bf 91       	pop	r27
     850:	af 91       	pop	r26
     852:	9f 91       	pop	r25
     854:	8f 91       	pop	r24
     856:	7f 91       	pop	r23
     858:	6f 91       	pop	r22
     85a:	5f 91       	pop	r21
     85c:	4f 91       	pop	r20
     85e:	3f 91       	pop	r19
     860:	2f 91       	pop	r18
     862:	1f 91       	pop	r17
     864:	0f 91       	pop	r16
     866:	ff 90       	pop	r15
     868:	ef 90       	pop	r14
     86a:	df 90       	pop	r13
     86c:	cf 90       	pop	r12
     86e:	bf 90       	pop	r11
     870:	af 90       	pop	r10
     872:	9f 90       	pop	r9
     874:	8f 90       	pop	r8
     876:	7f 90       	pop	r7
     878:	6f 90       	pop	r6
     87a:	5f 90       	pop	r5
     87c:	4f 90       	pop	r4
     87e:	3f 90       	pop	r3
     880:	2f 90       	pop	r2
     882:	1f 90       	pop	r1
     884:	0f 90       	pop	r0
     886:	0f be       	out	0x3f, r0	; 63
     888:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     88a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     88c:	81 e0       	ldi	r24, 0x01	; 1
     88e:	08 95       	ret

00000890 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     890:	08 95       	ret

00000892 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     892:	0f 92       	push	r0
     894:	0f b6       	in	r0, 0x3f	; 63
     896:	f8 94       	cli
     898:	0f 92       	push	r0
     89a:	1f 92       	push	r1
     89c:	11 24       	eor	r1, r1
     89e:	2f 92       	push	r2
     8a0:	3f 92       	push	r3
     8a2:	4f 92       	push	r4
     8a4:	5f 92       	push	r5
     8a6:	6f 92       	push	r6
     8a8:	7f 92       	push	r7
     8aa:	8f 92       	push	r8
     8ac:	9f 92       	push	r9
     8ae:	af 92       	push	r10
     8b0:	bf 92       	push	r11
     8b2:	cf 92       	push	r12
     8b4:	df 92       	push	r13
     8b6:	ef 92       	push	r14
     8b8:	ff 92       	push	r15
     8ba:	0f 93       	push	r16
     8bc:	1f 93       	push	r17
     8be:	2f 93       	push	r18
     8c0:	3f 93       	push	r19
     8c2:	4f 93       	push	r20
     8c4:	5f 93       	push	r21
     8c6:	6f 93       	push	r22
     8c8:	7f 93       	push	r23
     8ca:	8f 93       	push	r24
     8cc:	9f 93       	push	r25
     8ce:	af 93       	push	r26
     8d0:	bf 93       	push	r27
     8d2:	cf 93       	push	r28
     8d4:	df 93       	push	r29
     8d6:	ef 93       	push	r30
     8d8:	ff 93       	push	r31
     8da:	a0 91 27 0f 	lds	r26, 0x0F27
     8de:	b0 91 28 0f 	lds	r27, 0x0F28
     8e2:	0d b6       	in	r0, 0x3d	; 61
     8e4:	0d 92       	st	X+, r0
     8e6:	0e b6       	in	r0, 0x3e	; 62
     8e8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     8ea:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     8ee:	a0 91 27 0f 	lds	r26, 0x0F27
     8f2:	b0 91 28 0f 	lds	r27, 0x0F28
     8f6:	cd 91       	ld	r28, X+
     8f8:	cd bf       	out	0x3d, r28	; 61
     8fa:	dd 91       	ld	r29, X+
     8fc:	de bf       	out	0x3e, r29	; 62
     8fe:	ff 91       	pop	r31
     900:	ef 91       	pop	r30
     902:	df 91       	pop	r29
     904:	cf 91       	pop	r28
     906:	bf 91       	pop	r27
     908:	af 91       	pop	r26
     90a:	9f 91       	pop	r25
     90c:	8f 91       	pop	r24
     90e:	7f 91       	pop	r23
     910:	6f 91       	pop	r22
     912:	5f 91       	pop	r21
     914:	4f 91       	pop	r20
     916:	3f 91       	pop	r19
     918:	2f 91       	pop	r18
     91a:	1f 91       	pop	r17
     91c:	0f 91       	pop	r16
     91e:	ff 90       	pop	r15
     920:	ef 90       	pop	r14
     922:	df 90       	pop	r13
     924:	cf 90       	pop	r12
     926:	bf 90       	pop	r11
     928:	af 90       	pop	r10
     92a:	9f 90       	pop	r9
     92c:	8f 90       	pop	r8
     92e:	7f 90       	pop	r7
     930:	6f 90       	pop	r6
     932:	5f 90       	pop	r5
     934:	4f 90       	pop	r4
     936:	3f 90       	pop	r3
     938:	2f 90       	pop	r2
     93a:	1f 90       	pop	r1
     93c:	0f 90       	pop	r0
     93e:	0f be       	out	0x3f, r0	; 63
     940:	0f 90       	pop	r0

	asm volatile ( "ret" );
     942:	08 95       	ret

00000944 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     944:	0f 92       	push	r0
     946:	0f b6       	in	r0, 0x3f	; 63
     948:	f8 94       	cli
     94a:	0f 92       	push	r0
     94c:	1f 92       	push	r1
     94e:	11 24       	eor	r1, r1
     950:	2f 92       	push	r2
     952:	3f 92       	push	r3
     954:	4f 92       	push	r4
     956:	5f 92       	push	r5
     958:	6f 92       	push	r6
     95a:	7f 92       	push	r7
     95c:	8f 92       	push	r8
     95e:	9f 92       	push	r9
     960:	af 92       	push	r10
     962:	bf 92       	push	r11
     964:	cf 92       	push	r12
     966:	df 92       	push	r13
     968:	ef 92       	push	r14
     96a:	ff 92       	push	r15
     96c:	0f 93       	push	r16
     96e:	1f 93       	push	r17
     970:	2f 93       	push	r18
     972:	3f 93       	push	r19
     974:	4f 93       	push	r20
     976:	5f 93       	push	r21
     978:	6f 93       	push	r22
     97a:	7f 93       	push	r23
     97c:	8f 93       	push	r24
     97e:	9f 93       	push	r25
     980:	af 93       	push	r26
     982:	bf 93       	push	r27
     984:	cf 93       	push	r28
     986:	df 93       	push	r29
     988:	ef 93       	push	r30
     98a:	ff 93       	push	r31
     98c:	a0 91 27 0f 	lds	r26, 0x0F27
     990:	b0 91 28 0f 	lds	r27, 0x0F28
     994:	0d b6       	in	r0, 0x3d	; 61
     996:	0d 92       	st	X+, r0
     998:	0e b6       	in	r0, 0x3e	; 62
     99a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     99c:	0e 94 ca 0a 	call	0x1594	; 0x1594 <xTaskIncrementTick>
     9a0:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     9a2:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     9a6:	a0 91 27 0f 	lds	r26, 0x0F27
     9aa:	b0 91 28 0f 	lds	r27, 0x0F28
     9ae:	cd 91       	ld	r28, X+
     9b0:	cd bf       	out	0x3d, r28	; 61
     9b2:	dd 91       	ld	r29, X+
     9b4:	de bf       	out	0x3e, r29	; 62
     9b6:	ff 91       	pop	r31
     9b8:	ef 91       	pop	r30
     9ba:	df 91       	pop	r29
     9bc:	cf 91       	pop	r28
     9be:	bf 91       	pop	r27
     9c0:	af 91       	pop	r26
     9c2:	9f 91       	pop	r25
     9c4:	8f 91       	pop	r24
     9c6:	7f 91       	pop	r23
     9c8:	6f 91       	pop	r22
     9ca:	5f 91       	pop	r21
     9cc:	4f 91       	pop	r20
     9ce:	3f 91       	pop	r19
     9d0:	2f 91       	pop	r18
     9d2:	1f 91       	pop	r17
     9d4:	0f 91       	pop	r16
     9d6:	ff 90       	pop	r15
     9d8:	ef 90       	pop	r14
     9da:	df 90       	pop	r13
     9dc:	cf 90       	pop	r12
     9de:	bf 90       	pop	r11
     9e0:	af 90       	pop	r10
     9e2:	9f 90       	pop	r9
     9e4:	8f 90       	pop	r8
     9e6:	7f 90       	pop	r7
     9e8:	6f 90       	pop	r6
     9ea:	5f 90       	pop	r5
     9ec:	4f 90       	pop	r4
     9ee:	3f 90       	pop	r3
     9f0:	2f 90       	pop	r2
     9f2:	1f 90       	pop	r1
     9f4:	0f 90       	pop	r0
     9f6:	0f be       	out	0x3f, r0	; 63
     9f8:	0f 90       	pop	r0

	asm volatile ( "ret" );
     9fa:	08 95       	ret

000009fc <__vector_12>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	ISR(TIMER1_COMPA_vect, ISR_NAKED)
	{
		vPortYieldFromTick();
     9fc:	0e 94 a2 04 	call	0x944	; 0x944 <vPortYieldFromTick>
		asm volatile ( "reti" );
     a00:	18 95       	reti

00000a02 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     a02:	cf 93       	push	r28
     a04:	df 93       	push	r29
     a06:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     a08:	0e 94 b2 0a 	call	0x1564	; 0x1564 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     a0c:	80 91 77 01 	lds	r24, 0x0177
     a10:	90 91 78 01 	lds	r25, 0x0178
     a14:	89 2b       	or	r24, r25
     a16:	31 f4       	brne	.+12     	; 0xa24 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     a18:	8c e7       	ldi	r24, 0x7C	; 124
     a1a:	91 e0       	ldi	r25, 0x01	; 1
     a1c:	90 93 78 01 	sts	0x0178, r25
     a20:	80 93 77 01 	sts	0x0177, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     a24:	20 91 79 01 	lds	r18, 0x0179
     a28:	30 91 7a 01 	lds	r19, 0x017A
     a2c:	ce 01       	movw	r24, r28
     a2e:	82 0f       	add	r24, r18
     a30:	93 1f       	adc	r25, r19
     a32:	8b 3a       	cpi	r24, 0xAB	; 171
     a34:	4d e0       	ldi	r20, 0x0D	; 13
     a36:	94 07       	cpc	r25, r20
     a38:	70 f4       	brcc	.+28     	; 0xa56 <pvPortMalloc+0x54>
     a3a:	28 17       	cp	r18, r24
     a3c:	39 07       	cpc	r19, r25
     a3e:	58 f4       	brcc	.+22     	; 0xa56 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     a40:	c0 91 77 01 	lds	r28, 0x0177
     a44:	d0 91 78 01 	lds	r29, 0x0178
     a48:	c2 0f       	add	r28, r18
     a4a:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     a4c:	90 93 7a 01 	sts	0x017A, r25
     a50:	80 93 79 01 	sts	0x0179, r24
     a54:	02 c0       	rjmp	.+4      	; 0xa5a <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     a56:	c0 e0       	ldi	r28, 0x00	; 0
     a58:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     a5a:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     a5e:	ce 01       	movw	r24, r28
     a60:	df 91       	pop	r29
     a62:	cf 91       	pop	r28
     a64:	08 95       	ret

00000a66 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     a66:	08 95       	ret

00000a68 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     a68:	10 92 7a 01 	sts	0x017A, r1
     a6c:	10 92 79 01 	sts	0x0179, r1
     a70:	08 95       	ret

00000a72 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     a72:	20 91 79 01 	lds	r18, 0x0179
     a76:	30 91 7a 01 	lds	r19, 0x017A
}
     a7a:	8b ea       	ldi	r24, 0xAB	; 171
     a7c:	9d e0       	ldi	r25, 0x0D	; 13
     a7e:	82 1b       	sub	r24, r18
     a80:	93 0b       	sbc	r25, r19
     a82:	08 95       	ret

00000a84 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     a84:	1f 93       	push	r17
     a86:	cf 93       	push	r28
     a88:	df 93       	push	r29
     a8a:	ec 01       	movw	r28, r24
     a8c:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     a8e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     a90:	88 23       	and	r24, r24
     a92:	d9 f1       	breq	.+118    	; 0xb0a <prvCopyDataToQueue+0x86>
     a94:	48 2f       	mov	r20, r24
     a96:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     a98:	11 11       	cpse	r17, r1
     a9a:	15 c0       	rjmp	.+42     	; 0xac6 <prvCopyDataToQueue+0x42>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     a9c:	8c 81       	ldd	r24, Y+4	; 0x04
     a9e:	9d 81       	ldd	r25, Y+5	; 0x05
     aa0:	0e 94 b4 12 	call	0x2568	; 0x2568 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     aa4:	2c 8d       	ldd	r18, Y+28	; 0x1c
     aa6:	8c 81       	ldd	r24, Y+4	; 0x04
     aa8:	9d 81       	ldd	r25, Y+5	; 0x05
     aaa:	82 0f       	add	r24, r18
     aac:	91 1d       	adc	r25, r1
     aae:	9d 83       	std	Y+5, r25	; 0x05
     ab0:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     ab2:	2a 81       	ldd	r18, Y+2	; 0x02
     ab4:	3b 81       	ldd	r19, Y+3	; 0x03
     ab6:	82 17       	cp	r24, r18
     ab8:	93 07       	cpc	r25, r19
     aba:	38 f1       	brcs	.+78     	; 0xb0a <prvCopyDataToQueue+0x86>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     abc:	88 81       	ld	r24, Y
     abe:	99 81       	ldd	r25, Y+1	; 0x01
     ac0:	9d 83       	std	Y+5, r25	; 0x05
     ac2:	8c 83       	std	Y+4, r24	; 0x04
     ac4:	22 c0       	rjmp	.+68     	; 0xb0a <prvCopyDataToQueue+0x86>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     ac6:	8e 81       	ldd	r24, Y+6	; 0x06
     ac8:	9f 81       	ldd	r25, Y+7	; 0x07
     aca:	0e 94 b4 12 	call	0x2568	; 0x2568 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     ace:	8c 8d       	ldd	r24, Y+28	; 0x1c
     ad0:	90 e0       	ldi	r25, 0x00	; 0
     ad2:	91 95       	neg	r25
     ad4:	81 95       	neg	r24
     ad6:	91 09       	sbc	r25, r1
     ad8:	2e 81       	ldd	r18, Y+6	; 0x06
     ada:	3f 81       	ldd	r19, Y+7	; 0x07
     adc:	28 0f       	add	r18, r24
     ade:	39 1f       	adc	r19, r25
     ae0:	3f 83       	std	Y+7, r19	; 0x07
     ae2:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     ae4:	48 81       	ld	r20, Y
     ae6:	59 81       	ldd	r21, Y+1	; 0x01
     ae8:	24 17       	cp	r18, r20
     aea:	35 07       	cpc	r19, r21
     aec:	30 f4       	brcc	.+12     	; 0xafa <prvCopyDataToQueue+0x76>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     aee:	2a 81       	ldd	r18, Y+2	; 0x02
     af0:	3b 81       	ldd	r19, Y+3	; 0x03
     af2:	82 0f       	add	r24, r18
     af4:	93 1f       	adc	r25, r19
     af6:	9f 83       	std	Y+7, r25	; 0x07
     af8:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     afa:	12 30       	cpi	r17, 0x02	; 2
     afc:	31 f4       	brne	.+12     	; 0xb0a <prvCopyDataToQueue+0x86>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     afe:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b00:	88 23       	and	r24, r24
     b02:	19 f0       	breq	.+6      	; 0xb0a <prvCopyDataToQueue+0x86>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
     b04:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b06:	81 50       	subi	r24, 0x01	; 1
     b08:	8a 8f       	std	Y+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
     b0a:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b0c:	8f 5f       	subi	r24, 0xFF	; 255
     b0e:	8a 8f       	std	Y+26, r24	; 0x1a

	return xReturn;
}
     b10:	80 e0       	ldi	r24, 0x00	; 0
     b12:	df 91       	pop	r29
     b14:	cf 91       	pop	r28
     b16:	1f 91       	pop	r17
     b18:	08 95       	ret

00000b1a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     b1a:	fc 01       	movw	r30, r24
     b1c:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     b1e:	44 8d       	ldd	r20, Z+28	; 0x1c
     b20:	44 23       	and	r20, r20
     b22:	a1 f0       	breq	.+40     	; 0xb4c <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     b24:	50 e0       	ldi	r21, 0x00	; 0
     b26:	26 81       	ldd	r18, Z+6	; 0x06
     b28:	37 81       	ldd	r19, Z+7	; 0x07
     b2a:	24 0f       	add	r18, r20
     b2c:	35 1f       	adc	r19, r21
     b2e:	37 83       	std	Z+7, r19	; 0x07
     b30:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     b32:	62 81       	ldd	r22, Z+2	; 0x02
     b34:	73 81       	ldd	r23, Z+3	; 0x03
     b36:	26 17       	cp	r18, r22
     b38:	37 07       	cpc	r19, r23
     b3a:	20 f0       	brcs	.+8      	; 0xb44 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     b3c:	20 81       	ld	r18, Z
     b3e:	31 81       	ldd	r19, Z+1	; 0x01
     b40:	37 83       	std	Z+7, r19	; 0x07
     b42:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     b44:	66 81       	ldd	r22, Z+6	; 0x06
     b46:	77 81       	ldd	r23, Z+7	; 0x07
     b48:	0c 94 b4 12 	jmp	0x2568	; 0x2568 <memcpy>
     b4c:	08 95       	ret

00000b4e <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     b4e:	0f 93       	push	r16
     b50:	1f 93       	push	r17
     b52:	cf 93       	push	r28
     b54:	df 93       	push	r29
     b56:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     b58:	0f b6       	in	r0, 0x3f	; 63
     b5a:	f8 94       	cli
     b5c:	0f 92       	push	r0
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     b5e:	8c 01       	movw	r16, r24
     b60:	0f 5e       	subi	r16, 0xEF	; 239
     b62:	1f 4f       	sbci	r17, 0xFF	; 255
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     b64:	9e 8d       	ldd	r25, Y+30	; 0x1e
     b66:	19 16       	cp	r1, r25
     b68:	6c f4       	brge	.+26     	; 0xb84 <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     b6a:	89 89       	ldd	r24, Y+17	; 0x11
     b6c:	88 23       	and	r24, r24
     b6e:	51 f0       	breq	.+20     	; 0xb84 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     b70:	c8 01       	movw	r24, r16
     b72:	0e 94 77 0d 	call	0x1aee	; 0x1aee <xTaskRemoveFromEventList>
     b76:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
     b78:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
     b7c:	9e 8d       	ldd	r25, Y+30	; 0x1e
     b7e:	91 50       	subi	r25, 0x01	; 1
     b80:	9e 8f       	std	Y+30, r25	; 0x1e
     b82:	f0 cf       	rjmp	.-32     	; 0xb64 <prvUnlockQueue+0x16>
		}

		pxQueue->xTxLock = queueUNLOCKED;
     b84:	8f ef       	ldi	r24, 0xFF	; 255
     b86:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     b88:	0f 90       	pop	r0
     b8a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     b8c:	0f b6       	in	r0, 0x3f	; 63
     b8e:	f8 94       	cli
     b90:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     b92:	8e 01       	movw	r16, r28
     b94:	08 5f       	subi	r16, 0xF8	; 248
     b96:	1f 4f       	sbci	r17, 0xFF	; 255
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     b98:	9d 8d       	ldd	r25, Y+29	; 0x1d
     b9a:	19 16       	cp	r1, r25
     b9c:	6c f4       	brge	.+26     	; 0xbb8 <prvUnlockQueue+0x6a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     b9e:	88 85       	ldd	r24, Y+8	; 0x08
     ba0:	88 23       	and	r24, r24
     ba2:	51 f0       	breq	.+20     	; 0xbb8 <prvUnlockQueue+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ba4:	c8 01       	movw	r24, r16
     ba6:	0e 94 77 0d 	call	0x1aee	; 0x1aee <xTaskRemoveFromEventList>
     baa:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     bac:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
     bb0:	9d 8d       	ldd	r25, Y+29	; 0x1d
     bb2:	91 50       	subi	r25, 0x01	; 1
     bb4:	9d 8f       	std	Y+29, r25	; 0x1d
     bb6:	f0 cf       	rjmp	.-32     	; 0xb98 <prvUnlockQueue+0x4a>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     bb8:	8f ef       	ldi	r24, 0xFF	; 255
     bba:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     bbc:	0f 90       	pop	r0
     bbe:	0f be       	out	0x3f, r0	; 63
}
     bc0:	df 91       	pop	r29
     bc2:	cf 91       	pop	r28
     bc4:	1f 91       	pop	r17
     bc6:	0f 91       	pop	r16
     bc8:	08 95       	ret

00000bca <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     bca:	cf 93       	push	r28
     bcc:	df 93       	push	r29
     bce:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     bd0:	0f b6       	in	r0, 0x3f	; 63
     bd2:	f8 94       	cli
     bd4:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     bd6:	28 81       	ld	r18, Y
     bd8:	39 81       	ldd	r19, Y+1	; 0x01
     bda:	9b 8d       	ldd	r25, Y+27	; 0x1b
     bdc:	4c 8d       	ldd	r20, Y+28	; 0x1c
     bde:	94 9f       	mul	r25, r20
     be0:	c0 01       	movw	r24, r0
     be2:	11 24       	eor	r1, r1
     be4:	f9 01       	movw	r30, r18
     be6:	e8 0f       	add	r30, r24
     be8:	f9 1f       	adc	r31, r25
     bea:	fb 83       	std	Y+3, r31	; 0x03
     bec:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     bee:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     bf0:	3d 83       	std	Y+5, r19	; 0x05
     bf2:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     bf4:	84 1b       	sub	r24, r20
     bf6:	91 09       	sbc	r25, r1
     bf8:	82 0f       	add	r24, r18
     bfa:	93 1f       	adc	r25, r19
     bfc:	9f 83       	std	Y+7, r25	; 0x07
     bfe:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     c00:	8f ef       	ldi	r24, 0xFF	; 255
     c02:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     c04:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     c06:	61 11       	cpse	r22, r1
     c08:	0c c0       	rjmp	.+24     	; 0xc22 <xQueueGenericReset+0x58>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     c0a:	88 85       	ldd	r24, Y+8	; 0x08
     c0c:	88 23       	and	r24, r24
     c0e:	89 f0       	breq	.+34     	; 0xc32 <xQueueGenericReset+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     c10:	ce 01       	movw	r24, r28
     c12:	08 96       	adiw	r24, 0x08	; 8
     c14:	0e 94 77 0d 	call	0x1aee	; 0x1aee <xTaskRemoveFromEventList>
     c18:	81 30       	cpi	r24, 0x01	; 1
     c1a:	59 f4       	brne	.+22     	; 0xc32 <xQueueGenericReset+0x68>
				{
					queueYIELD_IF_USING_PREEMPTION();
     c1c:	0e 94 49 04 	call	0x892	; 0x892 <vPortYield>
     c20:	08 c0       	rjmp	.+16     	; 0xc32 <xQueueGenericReset+0x68>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     c22:	ce 01       	movw	r24, r28
     c24:	08 96       	adiw	r24, 0x08	; 8
     c26:	0e 94 10 03 	call	0x620	; 0x620 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     c2a:	ce 01       	movw	r24, r28
     c2c:	41 96       	adiw	r24, 0x11	; 17
     c2e:	0e 94 10 03 	call	0x620	; 0x620 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     c32:	0f 90       	pop	r0
     c34:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     c36:	81 e0       	ldi	r24, 0x01	; 1
     c38:	df 91       	pop	r29
     c3a:	cf 91       	pop	r28
     c3c:	08 95       	ret

00000c3e <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
     c3e:	ef 92       	push	r14
     c40:	ff 92       	push	r15
     c42:	1f 93       	push	r17
     c44:	cf 93       	push	r28
     c46:	df 93       	push	r29
     c48:	1f 92       	push	r1
     c4a:	cd b7       	in	r28, 0x3d	; 61
     c4c:	de b7       	in	r29, 0x3e	; 62
     c4e:	18 2f       	mov	r17, r24
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
     c50:	66 23       	and	r22, r22
     c52:	31 f0       	breq	.+12     	; 0xc60 <xQueueGenericCreate+0x22>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     c54:	86 9f       	mul	r24, r22
     c56:	90 01       	movw	r18, r0
     c58:	11 24       	eor	r1, r1
     c5a:	c9 01       	movw	r24, r18
     c5c:	01 96       	adiw	r24, 0x01	; 1
     c5e:	02 c0       	rjmp	.+4      	; 0xc64 <xQueueGenericCreate+0x26>
	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
	{
		/* There is not going to be a queue storage area. */
		xQueueSizeInBytes = ( size_t ) 0;
     c60:	80 e0       	ldi	r24, 0x00	; 0
     c62:	90 e0       	ldi	r25, 0x00	; 0
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     c64:	4f 96       	adiw	r24, 0x1f	; 31
     c66:	69 83       	std	Y+1, r22	; 0x01
     c68:	0e 94 01 05 	call	0xa02	; 0xa02 <pvPortMalloc>
     c6c:	7c 01       	movw	r14, r24

	if( pxNewQueue != NULL )
     c6e:	69 81       	ldd	r22, Y+1	; 0x01
     c70:	00 97       	sbiw	r24, 0x00	; 0
     c72:	89 f0       	breq	.+34     	; 0xc96 <xQueueGenericCreate+0x58>
	{
		if( uxItemSize == ( UBaseType_t ) 0 )
     c74:	61 11       	cpse	r22, r1
     c76:	04 c0       	rjmp	.+8      	; 0xc80 <xQueueGenericCreate+0x42>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     c78:	fc 01       	movw	r30, r24
     c7a:	91 83       	std	Z+1, r25	; 0x01
     c7c:	80 83       	st	Z, r24
     c7e:	04 c0       	rjmp	.+8      	; 0xc88 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
     c80:	4f 96       	adiw	r24, 0x1f	; 31
     c82:	f7 01       	movw	r30, r14
     c84:	91 83       	std	Z+1, r25	; 0x01
     c86:	80 83       	st	Z, r24
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
     c88:	f7 01       	movw	r30, r14
     c8a:	13 8f       	std	Z+27, r17	; 0x1b
		pxNewQueue->uxItemSize = uxItemSize;
     c8c:	64 8f       	std	Z+28, r22	; 0x1c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     c8e:	61 e0       	ldi	r22, 0x01	; 1
     c90:	c7 01       	movw	r24, r14
     c92:	0e 94 e5 05 	call	0xbca	; 0xbca <xQueueGenericReset>
	}

	configASSERT( xReturn );

	return xReturn;
}
     c96:	c7 01       	movw	r24, r14
     c98:	0f 90       	pop	r0
     c9a:	df 91       	pop	r29
     c9c:	cf 91       	pop	r28
     c9e:	1f 91       	pop	r17
     ca0:	ff 90       	pop	r15
     ca2:	ef 90       	pop	r14
     ca4:	08 95       	ret

00000ca6 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
     ca6:	af 92       	push	r10
     ca8:	bf 92       	push	r11
     caa:	cf 92       	push	r12
     cac:	df 92       	push	r13
     cae:	ff 92       	push	r15
     cb0:	0f 93       	push	r16
     cb2:	1f 93       	push	r17
     cb4:	cf 93       	push	r28
     cb6:	df 93       	push	r29
     cb8:	00 d0       	rcall	.+0      	; 0xcba <xQueueGenericSend+0x14>
     cba:	00 d0       	rcall	.+0      	; 0xcbc <xQueueGenericSend+0x16>
     cbc:	1f 92       	push	r1
     cbe:	cd b7       	in	r28, 0x3d	; 61
     cc0:	de b7       	in	r29, 0x3e	; 62
     cc2:	8c 01       	movw	r16, r24
     cc4:	6b 01       	movw	r12, r22
     cc6:	5d 83       	std	Y+5, r21	; 0x05
     cc8:	4c 83       	std	Y+4, r20	; 0x04
     cca:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
     ccc:	90 e0       	ldi	r25, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     cce:	58 01       	movw	r10, r16
     cd0:	88 e0       	ldi	r24, 0x08	; 8
     cd2:	a8 0e       	add	r10, r24
     cd4:	b1 1c       	adc	r11, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     cd6:	0f b6       	in	r0, 0x3f	; 63
     cd8:	f8 94       	cli
     cda:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     cdc:	f8 01       	movw	r30, r16
     cde:	22 8d       	ldd	r18, Z+26	; 0x1a
     ce0:	83 8d       	ldd	r24, Z+27	; 0x1b
     ce2:	28 17       	cp	r18, r24
     ce4:	18 f0       	brcs	.+6      	; 0xcec <xQueueGenericSend+0x46>
     ce6:	f2 e0       	ldi	r31, 0x02	; 2
     ce8:	ff 12       	cpse	r15, r31
     cea:	18 c0       	rjmp	.+48     	; 0xd1c <xQueueGenericSend+0x76>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     cec:	4f 2d       	mov	r20, r15
     cee:	b6 01       	movw	r22, r12
     cf0:	c8 01       	movw	r24, r16
     cf2:	0e 94 42 05 	call	0xa84	; 0xa84 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     cf6:	f8 01       	movw	r30, r16
     cf8:	91 89       	ldd	r25, Z+17	; 0x11
     cfa:	99 23       	and	r25, r25
     cfc:	49 f0       	breq	.+18     	; 0xd10 <xQueueGenericSend+0x6a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     cfe:	c8 01       	movw	r24, r16
     d00:	41 96       	adiw	r24, 0x11	; 17
     d02:	0e 94 77 0d 	call	0x1aee	; 0x1aee <xTaskRemoveFromEventList>
     d06:	81 30       	cpi	r24, 0x01	; 1
     d08:	29 f4       	brne	.+10     	; 0xd14 <xQueueGenericSend+0x6e>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
     d0a:	0e 94 49 04 	call	0x892	; 0x892 <vPortYield>
     d0e:	02 c0       	rjmp	.+4      	; 0xd14 <xQueueGenericSend+0x6e>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
     d10:	81 11       	cpse	r24, r1
     d12:	fb cf       	rjmp	.-10     	; 0xd0a <xQueueGenericSend+0x64>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
     d14:	0f 90       	pop	r0
     d16:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     d18:	81 e0       	ldi	r24, 0x01	; 1
     d1a:	50 c0       	rjmp	.+160    	; 0xdbc <xQueueGenericSend+0x116>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     d1c:	2c 81       	ldd	r18, Y+4	; 0x04
     d1e:	3d 81       	ldd	r19, Y+5	; 0x05
     d20:	23 2b       	or	r18, r19
     d22:	19 f4       	brne	.+6      	; 0xd2a <xQueueGenericSend+0x84>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     d24:	0f 90       	pop	r0
     d26:	0f be       	out	0x3f, r0	; 63
     d28:	48 c0       	rjmp	.+144    	; 0xdba <xQueueGenericSend+0x114>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
     d2a:	91 11       	cpse	r25, r1
     d2c:	04 c0       	rjmp	.+8      	; 0xd36 <xQueueGenericSend+0x90>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     d2e:	ce 01       	movw	r24, r28
     d30:	01 96       	adiw	r24, 0x01	; 1
     d32:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     d36:	0f 90       	pop	r0
     d38:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     d3a:	0e 94 b2 0a 	call	0x1564	; 0x1564 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     d3e:	0f b6       	in	r0, 0x3f	; 63
     d40:	f8 94       	cli
     d42:	0f 92       	push	r0
     d44:	f8 01       	movw	r30, r16
     d46:	85 8d       	ldd	r24, Z+29	; 0x1d
     d48:	8f 3f       	cpi	r24, 0xFF	; 255
     d4a:	09 f4       	brne	.+2      	; 0xd4e <xQueueGenericSend+0xa8>
     d4c:	15 8e       	std	Z+29, r1	; 0x1d
     d4e:	f8 01       	movw	r30, r16
     d50:	86 8d       	ldd	r24, Z+30	; 0x1e
     d52:	8f 3f       	cpi	r24, 0xFF	; 255
     d54:	09 f4       	brne	.+2      	; 0xd58 <xQueueGenericSend+0xb2>
     d56:	16 8e       	std	Z+30, r1	; 0x1e
     d58:	0f 90       	pop	r0
     d5a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     d5c:	be 01       	movw	r22, r28
     d5e:	6c 5f       	subi	r22, 0xFC	; 252
     d60:	7f 4f       	sbci	r23, 0xFF	; 255
     d62:	ce 01       	movw	r24, r28
     d64:	01 96       	adiw	r24, 0x01	; 1
     d66:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <xTaskCheckForTimeOut>
     d6a:	81 11       	cpse	r24, r1
     d6c:	21 c0       	rjmp	.+66     	; 0xdb0 <xQueueGenericSend+0x10a>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     d6e:	0f b6       	in	r0, 0x3f	; 63
     d70:	f8 94       	cli
     d72:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     d74:	f8 01       	movw	r30, r16
     d76:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     d78:	0f 90       	pop	r0
     d7a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     d7c:	83 8d       	ldd	r24, Z+27	; 0x1b
     d7e:	98 13       	cpse	r25, r24
     d80:	11 c0       	rjmp	.+34     	; 0xda4 <xQueueGenericSend+0xfe>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     d82:	6c 81       	ldd	r22, Y+4	; 0x04
     d84:	7d 81       	ldd	r23, Y+5	; 0x05
     d86:	c5 01       	movw	r24, r10
     d88:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     d8c:	c8 01       	movw	r24, r16
     d8e:	0e 94 a7 05 	call	0xb4e	; 0xb4e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     d92:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <xTaskResumeAll>
     d96:	88 23       	and	r24, r24
     d98:	11 f0       	breq	.+4      	; 0xd9e <xQueueGenericSend+0xf8>
     d9a:	91 e0       	ldi	r25, 0x01	; 1
     d9c:	9c cf       	rjmp	.-200    	; 0xcd6 <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
     d9e:	0e 94 49 04 	call	0x892	; 0x892 <vPortYield>
     da2:	fb cf       	rjmp	.-10     	; 0xd9a <xQueueGenericSend+0xf4>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     da4:	c8 01       	movw	r24, r16
     da6:	0e 94 a7 05 	call	0xb4e	; 0xb4e <prvUnlockQueue>
				( void ) xTaskResumeAll();
     daa:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <xTaskResumeAll>
     dae:	f5 cf       	rjmp	.-22     	; 0xd9a <xQueueGenericSend+0xf4>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     db0:	c8 01       	movw	r24, r16
     db2:	0e 94 a7 05 	call	0xb4e	; 0xb4e <prvUnlockQueue>
			( void ) xTaskResumeAll();
     db6:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     dba:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     dbc:	0f 90       	pop	r0
     dbe:	0f 90       	pop	r0
     dc0:	0f 90       	pop	r0
     dc2:	0f 90       	pop	r0
     dc4:	0f 90       	pop	r0
     dc6:	df 91       	pop	r29
     dc8:	cf 91       	pop	r28
     dca:	1f 91       	pop	r17
     dcc:	0f 91       	pop	r16
     dce:	ff 90       	pop	r15
     dd0:	df 90       	pop	r13
     dd2:	cf 90       	pop	r12
     dd4:	bf 90       	pop	r11
     dd6:	af 90       	pop	r10
     dd8:	08 95       	ret

00000dda <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
     dda:	0f 93       	push	r16
     ddc:	1f 93       	push	r17
     dde:	cf 93       	push	r28
     de0:	df 93       	push	r29
     de2:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     de4:	9a 8d       	ldd	r25, Y+26	; 0x1a
     de6:	8b 8d       	ldd	r24, Y+27	; 0x1b
     de8:	98 17       	cp	r25, r24
     dea:	10 f0       	brcs	.+4      	; 0xdf0 <xQueueGenericSendFromISR+0x16>
     dec:	22 30       	cpi	r18, 0x02	; 2
     dee:	e9 f4       	brne	.+58     	; 0xe2a <xQueueGenericSendFromISR+0x50>
     df0:	8a 01       	movw	r16, r20
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     df2:	42 2f       	mov	r20, r18
     df4:	ce 01       	movw	r24, r28
     df6:	0e 94 42 05 	call	0xa84	; 0xa84 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     dfa:	8e 8d       	ldd	r24, Y+30	; 0x1e
     dfc:	8f 3f       	cpi	r24, 0xFF	; 255
     dfe:	81 f4       	brne	.+32     	; 0xe20 <xQueueGenericSendFromISR+0x46>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e00:	89 89       	ldd	r24, Y+17	; 0x11
     e02:	88 23       	and	r24, r24
     e04:	81 f0       	breq	.+32     	; 0xe26 <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e06:	ce 01       	movw	r24, r28
     e08:	41 96       	adiw	r24, 0x11	; 17
     e0a:	0e 94 77 0d 	call	0x1aee	; 0x1aee <xTaskRemoveFromEventList>
     e0e:	88 23       	and	r24, r24
     e10:	51 f0       	breq	.+20     	; 0xe26 <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     e12:	01 15       	cp	r16, r1
     e14:	11 05       	cpc	r17, r1
     e16:	39 f0       	breq	.+14     	; 0xe26 <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     e18:	81 e0       	ldi	r24, 0x01	; 1
     e1a:	f8 01       	movw	r30, r16
     e1c:	80 83       	st	Z, r24
     e1e:	06 c0       	rjmp	.+12     	; 0xe2c <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     e20:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e22:	8f 5f       	subi	r24, 0xFF	; 255
     e24:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
     e26:	81 e0       	ldi	r24, 0x01	; 1
     e28:	01 c0       	rjmp	.+2      	; 0xe2c <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     e2a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     e2c:	df 91       	pop	r29
     e2e:	cf 91       	pop	r28
     e30:	1f 91       	pop	r17
     e32:	0f 91       	pop	r16
     e34:	08 95       	ret

00000e36 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
     e36:	cf 93       	push	r28
     e38:	df 93       	push	r29
     e3a:	fc 01       	movw	r30, r24
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     e3c:	92 8d       	ldd	r25, Z+26	; 0x1a
     e3e:	83 8d       	ldd	r24, Z+27	; 0x1b
     e40:	98 17       	cp	r25, r24
     e42:	d0 f4       	brcc	.+52     	; 0xe78 <xQueueGiveFromISR+0x42>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
     e44:	82 8d       	ldd	r24, Z+26	; 0x1a
     e46:	8f 5f       	subi	r24, 0xFF	; 255
     e48:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     e4a:	86 8d       	ldd	r24, Z+30	; 0x1e
     e4c:	8f 3f       	cpi	r24, 0xFF	; 255
     e4e:	79 f4       	brne	.+30     	; 0xe6e <xQueueGiveFromISR+0x38>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e50:	81 89       	ldd	r24, Z+17	; 0x11
     e52:	88 23       	and	r24, r24
     e54:	79 f0       	breq	.+30     	; 0xe74 <xQueueGiveFromISR+0x3e>
     e56:	eb 01       	movw	r28, r22
     e58:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e5a:	41 96       	adiw	r24, 0x11	; 17
     e5c:	0e 94 77 0d 	call	0x1aee	; 0x1aee <xTaskRemoveFromEventList>
     e60:	88 23       	and	r24, r24
     e62:	41 f0       	breq	.+16     	; 0xe74 <xQueueGiveFromISR+0x3e>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     e64:	20 97       	sbiw	r28, 0x00	; 0
     e66:	31 f0       	breq	.+12     	; 0xe74 <xQueueGiveFromISR+0x3e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     e68:	81 e0       	ldi	r24, 0x01	; 1
     e6a:	88 83       	st	Y, r24
     e6c:	06 c0       	rjmp	.+12     	; 0xe7a <xQueueGiveFromISR+0x44>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     e6e:	86 8d       	ldd	r24, Z+30	; 0x1e
     e70:	8f 5f       	subi	r24, 0xFF	; 255
     e72:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
     e74:	81 e0       	ldi	r24, 0x01	; 1
     e76:	01 c0       	rjmp	.+2      	; 0xe7a <xQueueGiveFromISR+0x44>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     e78:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     e7a:	df 91       	pop	r29
     e7c:	cf 91       	pop	r28
     e7e:	08 95       	ret

00000e80 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     e80:	af 92       	push	r10
     e82:	bf 92       	push	r11
     e84:	df 92       	push	r13
     e86:	ef 92       	push	r14
     e88:	ff 92       	push	r15
     e8a:	0f 93       	push	r16
     e8c:	1f 93       	push	r17
     e8e:	cf 93       	push	r28
     e90:	df 93       	push	r29
     e92:	00 d0       	rcall	.+0      	; 0xe94 <xQueueGenericReceive+0x14>
     e94:	00 d0       	rcall	.+0      	; 0xe96 <xQueueGenericReceive+0x16>
     e96:	1f 92       	push	r1
     e98:	cd b7       	in	r28, 0x3d	; 61
     e9a:	de b7       	in	r29, 0x3e	; 62
     e9c:	8c 01       	movw	r16, r24
     e9e:	7b 01       	movw	r14, r22
     ea0:	5d 83       	std	Y+5, r21	; 0x05
     ea2:	4c 83       	std	Y+4, r20	; 0x04
     ea4:	d2 2e       	mov	r13, r18
BaseType_t xEntryTimeSet = pdFALSE;
     ea6:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     ea8:	58 01       	movw	r10, r16
     eaa:	81 e1       	ldi	r24, 0x11	; 17
     eac:	a8 0e       	add	r10, r24
     eae:	b1 1c       	adc	r11, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     eb0:	0f b6       	in	r0, 0x3f	; 63
     eb2:	f8 94       	cli
     eb4:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     eb6:	f8 01       	movw	r30, r16
     eb8:	82 8d       	ldd	r24, Z+26	; 0x1a
     eba:	88 23       	and	r24, r24
     ebc:	39 f1       	breq	.+78     	; 0xf0c <xQueueGenericReceive+0x8c>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     ebe:	a6 80       	ldd	r10, Z+6	; 0x06
     ec0:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     ec2:	b7 01       	movw	r22, r14
     ec4:	c8 01       	movw	r24, r16
     ec6:	0e 94 8d 05 	call	0xb1a	; 0xb1a <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
     eca:	f8 01       	movw	r30, r16
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
     ecc:	d1 10       	cpse	r13, r1
     ece:	0f c0       	rjmp	.+30     	; 0xeee <xQueueGenericReceive+0x6e>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
     ed0:	82 8d       	ldd	r24, Z+26	; 0x1a
     ed2:	81 50       	subi	r24, 0x01	; 1
     ed4:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ed6:	80 85       	ldd	r24, Z+8	; 0x08
     ed8:	88 23       	and	r24, r24
     eda:	a1 f0       	breq	.+40     	; 0xf04 <xQueueGenericReceive+0x84>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     edc:	c8 01       	movw	r24, r16
     ede:	08 96       	adiw	r24, 0x08	; 8
     ee0:	0e 94 77 0d 	call	0x1aee	; 0x1aee <xTaskRemoveFromEventList>
     ee4:	81 30       	cpi	r24, 0x01	; 1
     ee6:	71 f4       	brne	.+28     	; 0xf04 <xQueueGenericReceive+0x84>
						{
							queueYIELD_IF_USING_PREEMPTION();
     ee8:	0e 94 49 04 	call	0x892	; 0x892 <vPortYield>
     eec:	0b c0       	rjmp	.+22     	; 0xf04 <xQueueGenericReceive+0x84>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     eee:	b7 82       	std	Z+7, r11	; 0x07
     ef0:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ef2:	81 89       	ldd	r24, Z+17	; 0x11
     ef4:	88 23       	and	r24, r24
     ef6:	31 f0       	breq	.+12     	; 0xf04 <xQueueGenericReceive+0x84>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     ef8:	c8 01       	movw	r24, r16
     efa:	41 96       	adiw	r24, 0x11	; 17
     efc:	0e 94 77 0d 	call	0x1aee	; 0x1aee <xTaskRemoveFromEventList>
     f00:	81 11       	cpse	r24, r1
     f02:	f2 cf       	rjmp	.-28     	; 0xee8 <xQueueGenericReceive+0x68>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     f04:	0f 90       	pop	r0
     f06:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     f08:	81 e0       	ldi	r24, 0x01	; 1
     f0a:	4f c0       	rjmp	.+158    	; 0xfaa <xQueueGenericReceive+0x12a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     f0c:	2c 81       	ldd	r18, Y+4	; 0x04
     f0e:	3d 81       	ldd	r19, Y+5	; 0x05
     f10:	23 2b       	or	r18, r19
     f12:	19 f4       	brne	.+6      	; 0xf1a <xQueueGenericReceive+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     f14:	0f 90       	pop	r0
     f16:	0f be       	out	0x3f, r0	; 63
     f18:	47 c0       	rjmp	.+142    	; 0xfa8 <xQueueGenericReceive+0x128>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
     f1a:	91 11       	cpse	r25, r1
     f1c:	04 c0       	rjmp	.+8      	; 0xf26 <xQueueGenericReceive+0xa6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     f1e:	ce 01       	movw	r24, r28
     f20:	01 96       	adiw	r24, 0x01	; 1
     f22:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <vTaskSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     f26:	0f 90       	pop	r0
     f28:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     f2a:	0e 94 b2 0a 	call	0x1564	; 0x1564 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     f2e:	0f b6       	in	r0, 0x3f	; 63
     f30:	f8 94       	cli
     f32:	0f 92       	push	r0
     f34:	f8 01       	movw	r30, r16
     f36:	85 8d       	ldd	r24, Z+29	; 0x1d
     f38:	8f 3f       	cpi	r24, 0xFF	; 255
     f3a:	09 f4       	brne	.+2      	; 0xf3e <xQueueGenericReceive+0xbe>
     f3c:	15 8e       	std	Z+29, r1	; 0x1d
     f3e:	f8 01       	movw	r30, r16
     f40:	86 8d       	ldd	r24, Z+30	; 0x1e
     f42:	8f 3f       	cpi	r24, 0xFF	; 255
     f44:	09 f4       	brne	.+2      	; 0xf48 <xQueueGenericReceive+0xc8>
     f46:	16 8e       	std	Z+30, r1	; 0x1e
     f48:	0f 90       	pop	r0
     f4a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     f4c:	be 01       	movw	r22, r28
     f4e:	6c 5f       	subi	r22, 0xFC	; 252
     f50:	7f 4f       	sbci	r23, 0xFF	; 255
     f52:	ce 01       	movw	r24, r28
     f54:	01 96       	adiw	r24, 0x01	; 1
     f56:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <xTaskCheckForTimeOut>
     f5a:	81 11       	cpse	r24, r1
     f5c:	20 c0       	rjmp	.+64     	; 0xf9e <xQueueGenericReceive+0x11e>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     f5e:	0f b6       	in	r0, 0x3f	; 63
     f60:	f8 94       	cli
     f62:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     f64:	f8 01       	movw	r30, r16
     f66:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     f68:	0f 90       	pop	r0
     f6a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     f6c:	81 11       	cpse	r24, r1
     f6e:	11 c0       	rjmp	.+34     	; 0xf92 <xQueueGenericReceive+0x112>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     f70:	6c 81       	ldd	r22, Y+4	; 0x04
     f72:	7d 81       	ldd	r23, Y+5	; 0x05
     f74:	c5 01       	movw	r24, r10
     f76:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     f7a:	c8 01       	movw	r24, r16
     f7c:	0e 94 a7 05 	call	0xb4e	; 0xb4e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     f80:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <xTaskResumeAll>
     f84:	88 23       	and	r24, r24
     f86:	11 f0       	breq	.+4      	; 0xf8c <xQueueGenericReceive+0x10c>
     f88:	91 e0       	ldi	r25, 0x01	; 1
     f8a:	92 cf       	rjmp	.-220    	; 0xeb0 <xQueueGenericReceive+0x30>
				{
					portYIELD_WITHIN_API();
     f8c:	0e 94 49 04 	call	0x892	; 0x892 <vPortYield>
     f90:	fb cf       	rjmp	.-10     	; 0xf88 <xQueueGenericReceive+0x108>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     f92:	c8 01       	movw	r24, r16
     f94:	0e 94 a7 05 	call	0xb4e	; 0xb4e <prvUnlockQueue>
				( void ) xTaskResumeAll();
     f98:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <xTaskResumeAll>
     f9c:	f5 cf       	rjmp	.-22     	; 0xf88 <xQueueGenericReceive+0x108>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     f9e:	c8 01       	movw	r24, r16
     fa0:	0e 94 a7 05 	call	0xb4e	; 0xb4e <prvUnlockQueue>
			( void ) xTaskResumeAll();
     fa4:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     fa8:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     faa:	0f 90       	pop	r0
     fac:	0f 90       	pop	r0
     fae:	0f 90       	pop	r0
     fb0:	0f 90       	pop	r0
     fb2:	0f 90       	pop	r0
     fb4:	df 91       	pop	r29
     fb6:	cf 91       	pop	r28
     fb8:	1f 91       	pop	r17
     fba:	0f 91       	pop	r16
     fbc:	ff 90       	pop	r15
     fbe:	ef 90       	pop	r14
     fc0:	df 90       	pop	r13
     fc2:	bf 90       	pop	r11
     fc4:	af 90       	pop	r10
     fc6:	08 95       	ret

00000fc8 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
     fc8:	0f 93       	push	r16
     fca:	1f 93       	push	r17
     fcc:	cf 93       	push	r28
     fce:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     fd0:	fc 01       	movw	r30, r24
     fd2:	22 8d       	ldd	r18, Z+26	; 0x1a
     fd4:	22 23       	and	r18, r18
     fd6:	f9 f0       	breq	.+62     	; 0x1016 <xQueueReceiveFromISR+0x4e>
     fd8:	8a 01       	movw	r16, r20
     fda:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
     fdc:	0e 94 8d 05 	call	0xb1a	; 0xb1a <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
     fe0:	8a 8d       	ldd	r24, Y+26	; 0x1a
     fe2:	81 50       	subi	r24, 0x01	; 1
     fe4:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
     fe6:	8d 8d       	ldd	r24, Y+29	; 0x1d
     fe8:	8f 3f       	cpi	r24, 0xFF	; 255
     fea:	81 f4       	brne	.+32     	; 0x100c <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     fec:	88 85       	ldd	r24, Y+8	; 0x08
     fee:	88 23       	and	r24, r24
     ff0:	81 f0       	breq	.+32     	; 0x1012 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ff2:	ce 01       	movw	r24, r28
     ff4:	08 96       	adiw	r24, 0x08	; 8
     ff6:	0e 94 77 0d 	call	0x1aee	; 0x1aee <xTaskRemoveFromEventList>
     ffa:	88 23       	and	r24, r24
     ffc:	51 f0       	breq	.+20     	; 0x1012 <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
     ffe:	01 15       	cp	r16, r1
    1000:	11 05       	cpc	r17, r1
    1002:	39 f0       	breq	.+14     	; 0x1012 <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1004:	81 e0       	ldi	r24, 0x01	; 1
    1006:	f8 01       	movw	r30, r16
    1008:	80 83       	st	Z, r24
    100a:	06 c0       	rjmp	.+12     	; 0x1018 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    100c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    100e:	8f 5f       	subi	r24, 0xFF	; 255
    1010:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1012:	81 e0       	ldi	r24, 0x01	; 1
    1014:	01 c0       	rjmp	.+2      	; 0x1018 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1016:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1018:	df 91       	pop	r29
    101a:	cf 91       	pop	r28
    101c:	1f 91       	pop	r17
    101e:	0f 91       	pop	r16
    1020:	08 95       	ret

00001022 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1022:	0f 93       	push	r16
    1024:	1f 93       	push	r17
    1026:	cf 93       	push	r28
    1028:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    102a:	fc 01       	movw	r30, r24
    102c:	22 8d       	ldd	r18, Z+26	; 0x1a
    102e:	22 23       	and	r18, r18
    1030:	49 f0       	breq	.+18     	; 0x1044 <xQueuePeekFromISR+0x22>
    1032:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1034:	06 81       	ldd	r16, Z+6	; 0x06
    1036:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1038:	0e 94 8d 05 	call	0xb1a	; 0xb1a <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    103c:	1f 83       	std	Y+7, r17	; 0x07
    103e:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1040:	81 e0       	ldi	r24, 0x01	; 1
    1042:	01 c0       	rjmp	.+2      	; 0x1046 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1044:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1046:	df 91       	pop	r29
    1048:	cf 91       	pop	r28
    104a:	1f 91       	pop	r17
    104c:	0f 91       	pop	r16
    104e:	08 95       	ret

00001050 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1050:	0f b6       	in	r0, 0x3f	; 63
    1052:	f8 94       	cli
    1054:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1056:	fc 01       	movw	r30, r24
    1058:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    105a:	0f 90       	pop	r0
    105c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    105e:	08 95       	ret

00001060 <uxQueueSpacesAvailable>:
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1060:	0f b6       	in	r0, 0x3f	; 63
    1062:	f8 94       	cli
    1064:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1066:	fc 01       	movw	r30, r24
    1068:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    106a:	0f 90       	pop	r0
    106c:	0f be       	out	0x3f, r0	; 63
	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    106e:	83 8d       	ldd	r24, Z+27	; 0x1b
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1070:	82 1b       	sub	r24, r18
    1072:	08 95       	ret

00001074 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1074:	fc 01       	movw	r30, r24
    1076:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1078:	08 95       	ret

0000107a <vQueueDelete>:
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue );
    107a:	0c 94 33 05 	jmp	0xa66	; 0xa66 <vPortFree>

0000107e <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    107e:	fc 01       	movw	r30, r24
    1080:	92 8d       	ldd	r25, Z+26	; 0x1a
    1082:	81 e0       	ldi	r24, 0x01	; 1
    1084:	91 11       	cpse	r25, r1
    1086:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1088:	08 95       	ret

0000108a <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    108a:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    108c:	22 8d       	ldd	r18, Z+26	; 0x1a
    108e:	81 e0       	ldi	r24, 0x01	; 1
    1090:	93 8d       	ldd	r25, Z+27	; 0x1b
    1092:	29 13       	cpse	r18, r25
    1094:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1096:	08 95       	ret

00001098 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1098:	e0 91 53 0f 	lds	r30, 0x0F53
    109c:	f0 91 54 0f 	lds	r31, 0x0F54
    10a0:	80 81       	ld	r24, Z
    10a2:	81 11       	cpse	r24, r1
    10a4:	03 c0       	rjmp	.+6      	; 0x10ac <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    10a6:	8f ef       	ldi	r24, 0xFF	; 255
    10a8:	9f ef       	ldi	r25, 0xFF	; 255
    10aa:	0c c0       	rjmp	.+24     	; 0x10c4 <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    10ac:	e0 91 53 0f 	lds	r30, 0x0F53
    10b0:	f0 91 54 0f 	lds	r31, 0x0F54
    10b4:	05 80       	ldd	r0, Z+5	; 0x05
    10b6:	f6 81       	ldd	r31, Z+6	; 0x06
    10b8:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    10ba:	06 80       	ldd	r0, Z+6	; 0x06
    10bc:	f7 81       	ldd	r31, Z+7	; 0x07
    10be:	e0 2d       	mov	r30, r0
    10c0:	82 81       	ldd	r24, Z+2	; 0x02
    10c2:	93 81       	ldd	r25, Z+3	; 0x03
    10c4:	90 93 2b 0f 	sts	0x0F2B, r25
    10c8:	80 93 2a 0f 	sts	0x0F2A, r24
    10cc:	08 95       	ret

000010ce <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    10ce:	cf 93       	push	r28
    10d0:	df 93       	push	r29
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    10d2:	e0 91 27 0f 	lds	r30, 0x0F27
    10d6:	f0 91 28 0f 	lds	r31, 0x0F28
    10da:	93 83       	std	Z+3, r25	; 0x03
    10dc:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    10de:	20 91 32 0f 	lds	r18, 0x0F32
    10e2:	30 91 33 0f 	lds	r19, 0x0F33
    10e6:	82 17       	cp	r24, r18
    10e8:	93 07       	cpc	r25, r19
    10ea:	70 f4       	brcc	.+28     	; 0x1108 <__stack+0x9>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    10ec:	60 91 27 0f 	lds	r22, 0x0F27
    10f0:	70 91 28 0f 	lds	r23, 0x0F28
    10f4:	80 91 51 0f 	lds	r24, 0x0F51
    10f8:	90 91 52 0f 	lds	r25, 0x0F52
    10fc:	6e 5f       	subi	r22, 0xFE	; 254
    10fe:	7f 4f       	sbci	r23, 0xFF	; 255
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    1100:	df 91       	pop	r29
    1102:	cf 91       	pop	r28
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1104:	0c 94 43 03 	jmp	0x686	; 0x686 <vListInsert>
    1108:	ec 01       	movw	r28, r24
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    110a:	60 91 27 0f 	lds	r22, 0x0F27
    110e:	70 91 28 0f 	lds	r23, 0x0F28
    1112:	80 91 53 0f 	lds	r24, 0x0F53
    1116:	90 91 54 0f 	lds	r25, 0x0F54
    111a:	6e 5f       	subi	r22, 0xFE	; 254
    111c:	7f 4f       	sbci	r23, 0xFF	; 255
    111e:	0e 94 43 03 	call	0x686	; 0x686 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1122:	80 91 2a 0f 	lds	r24, 0x0F2A
    1126:	90 91 2b 0f 	lds	r25, 0x0F2B
    112a:	c8 17       	cp	r28, r24
    112c:	d9 07       	cpc	r29, r25
    112e:	20 f4       	brcc	.+8      	; 0x1138 <__stack+0x39>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1130:	d0 93 2b 0f 	sts	0x0F2B, r29
    1134:	c0 93 2a 0f 	sts	0x0F2A, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    1138:	df 91       	pop	r29
    113a:	cf 91       	pop	r28
    113c:	08 95       	ret

0000113e <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    113e:	5f 92       	push	r5
    1140:	6f 92       	push	r6
    1142:	7f 92       	push	r7
    1144:	8f 92       	push	r8
    1146:	9f 92       	push	r9
    1148:	af 92       	push	r10
    114a:	bf 92       	push	r11
    114c:	cf 92       	push	r12
    114e:	df 92       	push	r13
    1150:	ef 92       	push	r14
    1152:	ff 92       	push	r15
    1154:	0f 93       	push	r16
    1156:	1f 93       	push	r17
    1158:	cf 93       	push	r28
    115a:	df 93       	push	r29
    115c:	4c 01       	movw	r8, r24
    115e:	16 2f       	mov	r17, r22
    1160:	57 2e       	mov	r5, r23
    1162:	5a 01       	movw	r10, r20
    1164:	39 01       	movw	r6, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1166:	c1 14       	cp	r12, r1
    1168:	d1 04       	cpc	r13, r1
    116a:	39 f4       	brne	.+14     	; 0x117a <xTaskGenericCreate+0x3c>
    116c:	ca 01       	movw	r24, r20
    116e:	0e 94 01 05 	call	0xa02	; 0xa02 <pvPortMalloc>
    1172:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
    1174:	89 2b       	or	r24, r25
    1176:	09 f4       	brne	.+2      	; 0x117a <xTaskGenericCreate+0x3c>
    1178:	d0 c0       	rjmp	.+416    	; 0x131a <xTaskGenericCreate+0x1dc>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    117a:	86 e2       	ldi	r24, 0x26	; 38
    117c:	90 e0       	ldi	r25, 0x00	; 0
    117e:	0e 94 01 05 	call	0xa02	; 0xa02 <pvPortMalloc>
    1182:	ec 01       	movw	r28, r24

			if( pxNewTCB != NULL )
    1184:	00 97       	sbiw	r24, 0x00	; 0
    1186:	79 f0       	breq	.+30     	; 0x11a6 <xTaskGenericCreate+0x68>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    1188:	d8 8e       	std	Y+24, r13	; 0x18
    118a:	cf 8a       	std	Y+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    118c:	21 e0       	ldi	r18, 0x01	; 1
    118e:	a2 1a       	sub	r10, r18
    1190:	b1 08       	sbc	r11, r1
    1192:	ac 0c       	add	r10, r12
    1194:	bd 1c       	adc	r11, r13
    1196:	bc 01       	movw	r22, r24
    1198:	67 5e       	subi	r22, 0xE7	; 231
    119a:	7f 4f       	sbci	r23, 0xFF	; 255
    119c:	e1 2f       	mov	r30, r17
    119e:	f5 2d       	mov	r31, r5
    11a0:	cf 01       	movw	r24, r30
    11a2:	08 96       	adiw	r24, 0x08	; 8
    11a4:	07 c0       	rjmp	.+14     	; 0x11b4 <xTaskGenericCreate+0x76>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    11a6:	c6 01       	movw	r24, r12
    11a8:	0e 94 33 05 	call	0xa66	; 0xa66 <vPortFree>
    11ac:	b6 c0       	rjmp	.+364    	; 0x131a <xTaskGenericCreate+0x1dc>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    11ae:	e8 17       	cp	r30, r24
    11b0:	f9 07       	cpc	r31, r25
    11b2:	49 f0       	breq	.+18     	; 0x11c6 <xTaskGenericCreate+0x88>
    11b4:	9f 01       	movw	r18, r30
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    11b6:	41 91       	ld	r20, Z+
    11b8:	db 01       	movw	r26, r22
    11ba:	4d 93       	st	X+, r20
    11bc:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    11be:	d9 01       	movw	r26, r18
    11c0:	2c 91       	ld	r18, X
    11c2:	21 11       	cpse	r18, r1
    11c4:	f4 cf       	rjmp	.-24     	; 0x11ae <xTaskGenericCreate+0x70>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    11c6:	18 a2       	std	Y+32, r1	; 0x20
    11c8:	10 2f       	mov	r17, r16
    11ca:	04 30       	cpi	r16, 0x04	; 4
    11cc:	08 f0       	brcs	.+2      	; 0x11d0 <xTaskGenericCreate+0x92>
    11ce:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    11d0:	1e 8b       	std	Y+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    11d2:	6e 01       	movw	r12, r28
    11d4:	b2 e0       	ldi	r27, 0x02	; 2
    11d6:	cb 0e       	add	r12, r27
    11d8:	d1 1c       	adc	r13, r1
    11da:	c6 01       	movw	r24, r12
    11dc:	0e 94 1e 03 	call	0x63c	; 0x63c <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    11e0:	ce 01       	movw	r24, r28
    11e2:	0c 96       	adiw	r24, 0x0c	; 12
    11e4:	0e 94 1e 03 	call	0x63c	; 0x63c <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    11e8:	d9 87       	std	Y+9, r29	; 0x09
    11ea:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    11ec:	84 e0       	ldi	r24, 0x04	; 4
    11ee:	90 e0       	ldi	r25, 0x00	; 0
    11f0:	81 1b       	sub	r24, r17
    11f2:	91 09       	sbc	r25, r1
    11f4:	9d 87       	std	Y+13, r25	; 0x0d
    11f6:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    11f8:	db 8b       	std	Y+19, r29	; 0x13
    11fa:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    11fc:	19 a2       	std	Y+33, r1	; 0x21
    11fe:	1a a2       	std	Y+34, r1	; 0x22
    1200:	1b a2       	std	Y+35, r1	; 0x23
    1202:	1c a2       	std	Y+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
    1204:	1d a2       	std	Y+37, r1	; 0x25
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1206:	a3 01       	movw	r20, r6
    1208:	b4 01       	movw	r22, r8
    120a:	c5 01       	movw	r24, r10
    120c:	0e 94 9e 03 	call	0x73c	; 0x73c <pxPortInitialiseStack>
    1210:	99 83       	std	Y+1, r25	; 0x01
    1212:	88 83       	st	Y, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    1214:	e1 14       	cp	r14, r1
    1216:	f1 04       	cpc	r15, r1
    1218:	19 f0       	breq	.+6      	; 0x1220 <xTaskGenericCreate+0xe2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    121a:	f7 01       	movw	r30, r14
    121c:	d1 83       	std	Z+1, r29	; 0x01
    121e:	c0 83       	st	Z, r28
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    1220:	0f b6       	in	r0, 0x3f	; 63
    1222:	f8 94       	cli
    1224:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1226:	80 91 34 0f 	lds	r24, 0x0F34
    122a:	8f 5f       	subi	r24, 0xFF	; 255
    122c:	80 93 34 0f 	sts	0x0F34, r24
			if( pxCurrentTCB == NULL )
    1230:	80 91 27 0f 	lds	r24, 0x0F27
    1234:	90 91 28 0f 	lds	r25, 0x0F28
    1238:	89 2b       	or	r24, r25
    123a:	d1 f5       	brne	.+116    	; 0x12b0 <xTaskGenericCreate+0x172>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    123c:	d0 93 28 0f 	sts	0x0F28, r29
    1240:	c0 93 27 0f 	sts	0x0F27, r28

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1244:	80 91 34 0f 	lds	r24, 0x0F34
    1248:	81 30       	cpi	r24, 0x01	; 1
    124a:	09 f0       	breq	.+2      	; 0x124e <xTaskGenericCreate+0x110>
    124c:	40 c0       	rjmp	.+128    	; 0x12ce <xTaskGenericCreate+0x190>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    124e:	87 e6       	ldi	r24, 0x67	; 103
    1250:	9f e0       	ldi	r25, 0x0F	; 15
    1252:	0e 94 10 03 	call	0x620	; 0x620 <vListInitialise>
    1256:	80 e7       	ldi	r24, 0x70	; 112
    1258:	9f e0       	ldi	r25, 0x0F	; 15
    125a:	0e 94 10 03 	call	0x620	; 0x620 <vListInitialise>
    125e:	89 e7       	ldi	r24, 0x79	; 121
    1260:	9f e0       	ldi	r25, 0x0F	; 15
    1262:	0e 94 10 03 	call	0x620	; 0x620 <vListInitialise>
    1266:	82 e8       	ldi	r24, 0x82	; 130
    1268:	9f e0       	ldi	r25, 0x0F	; 15
    126a:	0e 94 10 03 	call	0x620	; 0x620 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
    126e:	8e e5       	ldi	r24, 0x5E	; 94
    1270:	9f e0       	ldi	r25, 0x0F	; 15
    1272:	0e 94 10 03 	call	0x620	; 0x620 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    1276:	85 e5       	ldi	r24, 0x55	; 85
    1278:	9f e0       	ldi	r25, 0x0F	; 15
    127a:	0e 94 10 03 	call	0x620	; 0x620 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    127e:	88 e4       	ldi	r24, 0x48	; 72
    1280:	9f e0       	ldi	r25, 0x0F	; 15
    1282:	0e 94 10 03 	call	0x620	; 0x620 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    1286:	8f e3       	ldi	r24, 0x3F	; 63
    1288:	9f e0       	ldi	r25, 0x0F	; 15
    128a:	0e 94 10 03 	call	0x620	; 0x620 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    128e:	85 e3       	ldi	r24, 0x35	; 53
    1290:	9f e0       	ldi	r25, 0x0F	; 15
    1292:	0e 94 10 03 	call	0x620	; 0x620 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1296:	8e e5       	ldi	r24, 0x5E	; 94
    1298:	9f e0       	ldi	r25, 0x0F	; 15
    129a:	90 93 54 0f 	sts	0x0F54, r25
    129e:	80 93 53 0f 	sts	0x0F53, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    12a2:	85 e5       	ldi	r24, 0x55	; 85
    12a4:	9f e0       	ldi	r25, 0x0F	; 15
    12a6:	90 93 52 0f 	sts	0x0F52, r25
    12aa:	80 93 51 0f 	sts	0x0F51, r24
    12ae:	0f c0       	rjmp	.+30     	; 0x12ce <xTaskGenericCreate+0x190>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    12b0:	80 91 30 0f 	lds	r24, 0x0F30
    12b4:	81 11       	cpse	r24, r1
    12b6:	0b c0       	rjmp	.+22     	; 0x12ce <xTaskGenericCreate+0x190>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    12b8:	e0 91 27 0f 	lds	r30, 0x0F27
    12bc:	f0 91 28 0f 	lds	r31, 0x0F28
    12c0:	86 89       	ldd	r24, Z+22	; 0x16
    12c2:	08 17       	cp	r16, r24
    12c4:	20 f0       	brcs	.+8      	; 0x12ce <xTaskGenericCreate+0x190>
					{
						pxCurrentTCB = pxNewTCB;
    12c6:	d0 93 28 0f 	sts	0x0F28, r29
    12ca:	c0 93 27 0f 	sts	0x0F27, r28
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    12ce:	80 91 2c 0f 	lds	r24, 0x0F2C
    12d2:	8f 5f       	subi	r24, 0xFF	; 255
    12d4:	80 93 2c 0f 	sts	0x0F2C, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    12d8:	8e 89       	ldd	r24, Y+22	; 0x16
    12da:	90 91 31 0f 	lds	r25, 0x0F31
    12de:	98 17       	cp	r25, r24
    12e0:	10 f4       	brcc	.+4      	; 0x12e6 <xTaskGenericCreate+0x1a8>
    12e2:	80 93 31 0f 	sts	0x0F31, r24
    12e6:	f9 e0       	ldi	r31, 0x09	; 9
    12e8:	8f 9f       	mul	r24, r31
    12ea:	c0 01       	movw	r24, r0
    12ec:	11 24       	eor	r1, r1
    12ee:	b6 01       	movw	r22, r12
    12f0:	89 59       	subi	r24, 0x99	; 153
    12f2:	90 4f       	sbci	r25, 0xF0	; 240
    12f4:	0e 94 22 03 	call	0x644	; 0x644 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    12f8:	0f 90       	pop	r0
    12fa:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    12fc:	80 91 30 0f 	lds	r24, 0x0F30
    1300:	88 23       	and	r24, r24
    1302:	49 f0       	breq	.+18     	; 0x1316 <xTaskGenericCreate+0x1d8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1304:	e0 91 27 0f 	lds	r30, 0x0F27
    1308:	f0 91 28 0f 	lds	r31, 0x0F28
    130c:	86 89       	ldd	r24, Z+22	; 0x16
    130e:	80 17       	cp	r24, r16
    1310:	10 f4       	brcc	.+4      	; 0x1316 <xTaskGenericCreate+0x1d8>
			{
				taskYIELD_IF_USING_PREEMPTION();
    1312:	0e 94 49 04 	call	0x892	; 0x892 <vPortYield>
    1316:	81 e0       	ldi	r24, 0x01	; 1
    1318:	01 c0       	rjmp	.+2      	; 0x131c <xTaskGenericCreate+0x1de>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    131a:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
    131c:	df 91       	pop	r29
    131e:	cf 91       	pop	r28
    1320:	1f 91       	pop	r17
    1322:	0f 91       	pop	r16
    1324:	ff 90       	pop	r15
    1326:	ef 90       	pop	r14
    1328:	df 90       	pop	r13
    132a:	cf 90       	pop	r12
    132c:	bf 90       	pop	r11
    132e:	af 90       	pop	r10
    1330:	9f 90       	pop	r9
    1332:	8f 90       	pop	r8
    1334:	7f 90       	pop	r7
    1336:	6f 90       	pop	r6
    1338:	5f 90       	pop	r5
    133a:	08 95       	ret

0000133c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    133c:	0f 93       	push	r16
    133e:	1f 93       	push	r17
    1340:	cf 93       	push	r28
    1342:	df 93       	push	r29
    1344:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    1346:	0f b6       	in	r0, 0x3f	; 63
    1348:	f8 94       	cli
    134a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    134c:	89 2b       	or	r24, r25
    134e:	21 f4       	brne	.+8      	; 0x1358 <vTaskDelete+0x1c>
    1350:	c0 91 27 0f 	lds	r28, 0x0F27
    1354:	d0 91 28 0f 	lds	r29, 0x0F28

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1358:	8e 01       	movw	r16, r28
    135a:	0e 5f       	subi	r16, 0xFE	; 254
    135c:	1f 4f       	sbci	r17, 0xFF	; 255
    135e:	c8 01       	movw	r24, r16
    1360:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1364:	8c 89       	ldd	r24, Y+20	; 0x14
    1366:	9d 89       	ldd	r25, Y+21	; 0x15
    1368:	89 2b       	or	r24, r25
    136a:	21 f0       	breq	.+8      	; 0x1374 <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    136c:	ce 01       	movw	r24, r28
    136e:	0c 96       	adiw	r24, 0x0c	; 12
    1370:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1374:	b8 01       	movw	r22, r16
    1376:	8f e3       	ldi	r24, 0x3F	; 63
    1378:	9f e0       	ldi	r25, 0x0F	; 15
    137a:	0e 94 22 03 	call	0x644	; 0x644 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    137e:	80 91 3e 0f 	lds	r24, 0x0F3E
    1382:	8f 5f       	subi	r24, 0xFF	; 255
    1384:	80 93 3e 0f 	sts	0x0F3E, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1388:	80 91 2c 0f 	lds	r24, 0x0F2C
    138c:	8f 5f       	subi	r24, 0xFF	; 255
    138e:	80 93 2c 0f 	sts	0x0F2C, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1392:	0f 90       	pop	r0
    1394:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    1396:	80 91 30 0f 	lds	r24, 0x0F30
    139a:	88 23       	and	r24, r24
    139c:	89 f0       	breq	.+34     	; 0x13c0 <vTaskDelete+0x84>
		{
			if( pxTCB == pxCurrentTCB )
    139e:	80 91 27 0f 	lds	r24, 0x0F27
    13a2:	90 91 28 0f 	lds	r25, 0x0F28
    13a6:	c8 17       	cp	r28, r24
    13a8:	d9 07       	cpc	r29, r25
    13aa:	19 f4       	brne	.+6      	; 0x13b2 <vTaskDelete+0x76>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    13ac:	0e 94 49 04 	call	0x892	; 0x892 <vPortYield>
    13b0:	07 c0       	rjmp	.+14     	; 0x13c0 <vTaskDelete+0x84>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    13b2:	0f b6       	in	r0, 0x3f	; 63
    13b4:	f8 94       	cli
    13b6:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    13b8:	0e 94 4c 08 	call	0x1098	; 0x1098 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    13bc:	0f 90       	pop	r0
    13be:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    13c0:	df 91       	pop	r29
    13c2:	cf 91       	pop	r28
    13c4:	1f 91       	pop	r17
    13c6:	0f 91       	pop	r16
    13c8:	08 95       	ret

000013ca <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    13ca:	0f 93       	push	r16
    13cc:	1f 93       	push	r17
    13ce:	cf 93       	push	r28
    13d0:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    13d2:	00 97       	sbiw	r24, 0x00	; 0
    13d4:	09 f4       	brne	.+2      	; 0x13d8 <vTaskResume+0xe>
    13d6:	3c c0       	rjmp	.+120    	; 0x1450 <vTaskResume+0x86>
    13d8:	20 91 27 0f 	lds	r18, 0x0F27
    13dc:	30 91 28 0f 	lds	r19, 0x0F28
    13e0:	82 17       	cp	r24, r18
    13e2:	93 07       	cpc	r25, r19
    13e4:	a9 f1       	breq	.+106    	; 0x1450 <vTaskResume+0x86>
		{
			taskENTER_CRITICAL();
    13e6:	0f b6       	in	r0, 0x3f	; 63
    13e8:	f8 94       	cli
    13ea:	0f 92       	push	r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    13ec:	fc 01       	movw	r30, r24
    13ee:	22 85       	ldd	r18, Z+10	; 0x0a
    13f0:	33 85       	ldd	r19, Z+11	; 0x0b
    13f2:	25 53       	subi	r18, 0x35	; 53
    13f4:	3f 40       	sbci	r19, 0x0F	; 15
    13f6:	51 f5       	brne	.+84     	; 0x144c <vTaskResume+0x82>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    13f8:	fc 01       	movw	r30, r24
    13fa:	24 89       	ldd	r18, Z+20	; 0x14
    13fc:	35 89       	ldd	r19, Z+21	; 0x15
    13fe:	ff e0       	ldi	r31, 0x0F	; 15
    1400:	28 34       	cpi	r18, 0x48	; 72
    1402:	3f 07       	cpc	r19, r31
    1404:	19 f1       	breq	.+70     	; 0x144c <vTaskResume+0x82>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
    1406:	23 2b       	or	r18, r19
    1408:	09 f5       	brne	.+66     	; 0x144c <vTaskResume+0x82>
    140a:	ec 01       	movw	r28, r24
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
    140c:	8c 01       	movw	r16, r24
    140e:	0e 5f       	subi	r16, 0xFE	; 254
    1410:	1f 4f       	sbci	r17, 0xFF	; 255
    1412:	c8 01       	movw	r24, r16
    1414:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1418:	9e 89       	ldd	r25, Y+22	; 0x16
    141a:	80 91 31 0f 	lds	r24, 0x0F31
    141e:	89 17       	cp	r24, r25
    1420:	10 f4       	brcc	.+4      	; 0x1426 <vTaskResume+0x5c>
    1422:	90 93 31 0f 	sts	0x0F31, r25
    1426:	29 e0       	ldi	r18, 0x09	; 9
    1428:	92 9f       	mul	r25, r18
    142a:	c0 01       	movw	r24, r0
    142c:	11 24       	eor	r1, r1
    142e:	b8 01       	movw	r22, r16
    1430:	89 59       	subi	r24, 0x99	; 153
    1432:	90 4f       	sbci	r25, 0xF0	; 240
    1434:	0e 94 22 03 	call	0x644	; 0x644 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1438:	e0 91 27 0f 	lds	r30, 0x0F27
    143c:	f0 91 28 0f 	lds	r31, 0x0F28
    1440:	9e 89       	ldd	r25, Y+22	; 0x16
    1442:	86 89       	ldd	r24, Z+22	; 0x16
    1444:	98 17       	cp	r25, r24
    1446:	10 f0       	brcs	.+4      	; 0x144c <vTaskResume+0x82>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    1448:	0e 94 49 04 	call	0x892	; 0x892 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    144c:	0f 90       	pop	r0
    144e:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1450:	df 91       	pop	r29
    1452:	cf 91       	pop	r28
    1454:	1f 91       	pop	r17
    1456:	0f 91       	pop	r16
    1458:	08 95       	ret

0000145a <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    145a:	ef 92       	push	r14
    145c:	ff 92       	push	r15
    145e:	1f 93       	push	r17
    1460:	cf 93       	push	r28
    1462:	df 93       	push	r29
    1464:	ec 01       	movw	r28, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1466:	8a 85       	ldd	r24, Y+10	; 0x0a
    1468:	9b 85       	ldd	r25, Y+11	; 0x0b
    146a:	85 53       	subi	r24, 0x35	; 53
    146c:	9f 40       	sbci	r25, 0x0F	; 15
    146e:	99 f4       	brne	.+38     	; 0x1496 <xTaskResumeFromISR+0x3c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    1470:	8c 89       	ldd	r24, Y+20	; 0x14
    1472:	9d 89       	ldd	r25, Y+21	; 0x15
    1474:	2f e0       	ldi	r18, 0x0F	; 15
    1476:	88 34       	cpi	r24, 0x48	; 72
    1478:	92 07       	cpc	r25, r18
    147a:	69 f0       	breq	.+26     	; 0x1496 <xTaskResumeFromISR+0x3c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
    147c:	89 2b       	or	r24, r25
    147e:	59 f4       	brne	.+22     	; 0x1496 <xTaskResumeFromISR+0x3c>
			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1480:	80 91 29 0f 	lds	r24, 0x0F29
    1484:	88 23       	and	r24, r24
    1486:	49 f0       	breq	.+18     	; 0x149a <xTaskResumeFromISR+0x40>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1488:	be 01       	movw	r22, r28
    148a:	64 5f       	subi	r22, 0xF4	; 244
    148c:	7f 4f       	sbci	r23, 0xFF	; 255
    148e:	88 e4       	ldi	r24, 0x48	; 72
    1490:	9f e0       	ldi	r25, 0x0F	; 15
    1492:	0e 94 22 03 	call	0x644	; 0x644 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
    1496:	10 e0       	ldi	r17, 0x00	; 0
    1498:	21 c0       	rjmp	.+66     	; 0x14dc <xTaskResumeFromISR+0x82>
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    149a:	e0 91 27 0f 	lds	r30, 0x0F27
    149e:	f0 91 28 0f 	lds	r31, 0x0F28
    14a2:	11 e0       	ldi	r17, 0x01	; 1
    14a4:	9e 89       	ldd	r25, Y+22	; 0x16
    14a6:	86 89       	ldd	r24, Z+22	; 0x16
    14a8:	98 17       	cp	r25, r24
    14aa:	08 f4       	brcc	.+2      	; 0x14ae <xTaskResumeFromISR+0x54>
    14ac:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
    14ae:	7e 01       	movw	r14, r28
    14b0:	82 e0       	ldi	r24, 0x02	; 2
    14b2:	e8 0e       	add	r14, r24
    14b4:	f1 1c       	adc	r15, r1
    14b6:	c7 01       	movw	r24, r14
    14b8:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    14bc:	9e 89       	ldd	r25, Y+22	; 0x16
    14be:	80 91 31 0f 	lds	r24, 0x0F31
    14c2:	89 17       	cp	r24, r25
    14c4:	10 f4       	brcc	.+4      	; 0x14ca <xTaskResumeFromISR+0x70>
    14c6:	90 93 31 0f 	sts	0x0F31, r25
    14ca:	29 e0       	ldi	r18, 0x09	; 9
    14cc:	92 9f       	mul	r25, r18
    14ce:	c0 01       	movw	r24, r0
    14d0:	11 24       	eor	r1, r1
    14d2:	b7 01       	movw	r22, r14
    14d4:	89 59       	subi	r24, 0x99	; 153
    14d6:	90 4f       	sbci	r25, 0xF0	; 240
    14d8:	0e 94 22 03 	call	0x644	; 0x644 <vListInsertEnd>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
    14dc:	81 2f       	mov	r24, r17
    14de:	df 91       	pop	r29
    14e0:	cf 91       	pop	r28
    14e2:	1f 91       	pop	r17
    14e4:	ff 90       	pop	r15
    14e6:	ef 90       	pop	r14
    14e8:	08 95       	ret

000014ea <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    14ea:	af 92       	push	r10
    14ec:	bf 92       	push	r11
    14ee:	cf 92       	push	r12
    14f0:	df 92       	push	r13
    14f2:	ef 92       	push	r14
    14f4:	ff 92       	push	r15
    14f6:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    14f8:	a1 2c       	mov	r10, r1
    14fa:	b1 2c       	mov	r11, r1
    14fc:	c1 2c       	mov	r12, r1
    14fe:	d1 2c       	mov	r13, r1
    1500:	e1 2c       	mov	r14, r1
    1502:	f1 2c       	mov	r15, r1
    1504:	00 e0       	ldi	r16, 0x00	; 0
    1506:	20 e0       	ldi	r18, 0x00	; 0
    1508:	30 e0       	ldi	r19, 0x00	; 0
    150a:	44 e6       	ldi	r20, 0x64	; 100
    150c:	50 e0       	ldi	r21, 0x00	; 0
    150e:	66 e6       	ldi	r22, 0x66	; 102
    1510:	71 e0       	ldi	r23, 0x01	; 1
    1512:	85 e4       	ldi	r24, 0x45	; 69
    1514:	9c e0       	ldi	r25, 0x0C	; 12
    1516:	0e 94 9f 08 	call	0x113e	; 0x113e <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    151a:	81 30       	cpi	r24, 0x01	; 1
    151c:	b1 f4       	brne	.+44     	; 0x154a <vTaskStartScheduler+0x60>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    151e:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    1520:	2f ef       	ldi	r18, 0xFF	; 255
    1522:	3f ef       	ldi	r19, 0xFF	; 255
    1524:	30 93 2b 0f 	sts	0x0F2B, r19
    1528:	20 93 2a 0f 	sts	0x0F2A, r18
		xSchedulerRunning = pdTRUE;
    152c:	80 93 30 0f 	sts	0x0F30, r24
		xTickCount = ( TickType_t ) 0U;
    1530:	10 92 33 0f 	sts	0x0F33, r1
    1534:	10 92 32 0f 	sts	0x0F32, r1
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    1538:	0f 91       	pop	r16
    153a:	ff 90       	pop	r15
    153c:	ef 90       	pop	r14
    153e:	df 90       	pop	r13
    1540:	cf 90       	pop	r12
    1542:	bf 90       	pop	r11
    1544:	af 90       	pop	r10
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1546:	0c 94 0a 04 	jmp	0x814	; 0x814 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    154a:	0f 91       	pop	r16
    154c:	ff 90       	pop	r15
    154e:	ef 90       	pop	r14
    1550:	df 90       	pop	r13
    1552:	cf 90       	pop	r12
    1554:	bf 90       	pop	r11
    1556:	af 90       	pop	r10
    1558:	08 95       	ret

0000155a <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    155a:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    155c:	10 92 30 0f 	sts	0x0F30, r1
	vPortEndScheduler();
    1560:	0c 94 48 04 	jmp	0x890	; 0x890 <vPortEndScheduler>

00001564 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    1564:	80 91 29 0f 	lds	r24, 0x0F29
    1568:	8f 5f       	subi	r24, 0xFF	; 255
    156a:	80 93 29 0f 	sts	0x0F29, r24
    156e:	08 95       	ret

00001570 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    1570:	0f b6       	in	r0, 0x3f	; 63
    1572:	f8 94       	cli
    1574:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1576:	80 91 32 0f 	lds	r24, 0x0F32
    157a:	90 91 33 0f 	lds	r25, 0x0F33
	}
	portTICK_TYPE_EXIT_CRITICAL();
    157e:	0f 90       	pop	r0
    1580:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1582:	08 95       	ret

00001584 <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    1584:	80 91 32 0f 	lds	r24, 0x0F32
    1588:	90 91 33 0f 	lds	r25, 0x0F33
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    158c:	08 95       	ret

0000158e <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    158e:	80 91 34 0f 	lds	r24, 0x0F34
}
    1592:	08 95       	ret

00001594 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    1594:	cf 92       	push	r12
    1596:	df 92       	push	r13
    1598:	ef 92       	push	r14
    159a:	ff 92       	push	r15
    159c:	0f 93       	push	r16
    159e:	1f 93       	push	r17
    15a0:	cf 93       	push	r28
    15a2:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    15a4:	80 91 29 0f 	lds	r24, 0x0F29
    15a8:	81 11       	cpse	r24, r1
    15aa:	8f c0       	rjmp	.+286    	; 0x16ca <xTaskIncrementTick+0x136>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    15ac:	80 91 32 0f 	lds	r24, 0x0F32
    15b0:	90 91 33 0f 	lds	r25, 0x0F33
    15b4:	01 96       	adiw	r24, 0x01	; 1
    15b6:	90 93 33 0f 	sts	0x0F33, r25
    15ba:	80 93 32 0f 	sts	0x0F32, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    15be:	e0 90 32 0f 	lds	r14, 0x0F32
    15c2:	f0 90 33 0f 	lds	r15, 0x0F33

			if( xConstTickCount == ( TickType_t ) 0U )
    15c6:	e1 14       	cp	r14, r1
    15c8:	f1 04       	cpc	r15, r1
    15ca:	b9 f4       	brne	.+46     	; 0x15fa <xTaskIncrementTick+0x66>
			{
				taskSWITCH_DELAYED_LISTS();
    15cc:	80 91 53 0f 	lds	r24, 0x0F53
    15d0:	90 91 54 0f 	lds	r25, 0x0F54
    15d4:	20 91 51 0f 	lds	r18, 0x0F51
    15d8:	30 91 52 0f 	lds	r19, 0x0F52
    15dc:	30 93 54 0f 	sts	0x0F54, r19
    15e0:	20 93 53 0f 	sts	0x0F53, r18
    15e4:	90 93 52 0f 	sts	0x0F52, r25
    15e8:	80 93 51 0f 	sts	0x0F51, r24
    15ec:	80 91 2d 0f 	lds	r24, 0x0F2D
    15f0:	8f 5f       	subi	r24, 0xFF	; 255
    15f2:	80 93 2d 0f 	sts	0x0F2D, r24
    15f6:	0e 94 4c 08 	call	0x1098	; 0x1098 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    15fa:	80 91 2a 0f 	lds	r24, 0x0F2A
    15fe:	90 91 2b 0f 	lds	r25, 0x0F2B
    1602:	c0 e0       	ldi	r28, 0x00	; 0
    1604:	e8 16       	cp	r14, r24
    1606:	f9 06       	cpc	r15, r25
    1608:	08 f4       	brcc	.+2      	; 0x160c <xTaskIncrementTick+0x78>
    160a:	4f c0       	rjmp	.+158    	; 0x16aa <xTaskIncrementTick+0x116>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    160c:	d9 e0       	ldi	r29, 0x09	; 9
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    160e:	e0 91 53 0f 	lds	r30, 0x0F53
    1612:	f0 91 54 0f 	lds	r31, 0x0F54
    1616:	80 81       	ld	r24, Z
    1618:	81 11       	cpse	r24, r1
    161a:	03 c0       	rjmp	.+6      	; 0x1622 <xTaskIncrementTick+0x8e>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    161c:	8f ef       	ldi	r24, 0xFF	; 255
    161e:	9f ef       	ldi	r25, 0xFF	; 255
    1620:	11 c0       	rjmp	.+34     	; 0x1644 <xTaskIncrementTick+0xb0>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1622:	e0 91 53 0f 	lds	r30, 0x0F53
    1626:	f0 91 54 0f 	lds	r31, 0x0F54
    162a:	05 80       	ldd	r0, Z+5	; 0x05
    162c:	f6 81       	ldd	r31, Z+6	; 0x06
    162e:	e0 2d       	mov	r30, r0
    1630:	06 81       	ldd	r16, Z+6	; 0x06
    1632:	17 81       	ldd	r17, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1634:	d8 01       	movw	r26, r16
    1636:	12 96       	adiw	r26, 0x02	; 2
    1638:	8d 91       	ld	r24, X+
    163a:	9c 91       	ld	r25, X
    163c:	13 97       	sbiw	r26, 0x03	; 3

						if( xConstTickCount < xItemValue )
    163e:	e8 16       	cp	r14, r24
    1640:	f9 06       	cpc	r15, r25
    1642:	28 f4       	brcc	.+10     	; 0x164e <xTaskIncrementTick+0xba>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    1644:	90 93 2b 0f 	sts	0x0F2B, r25
    1648:	80 93 2a 0f 	sts	0x0F2A, r24
							break;
    164c:	2e c0       	rjmp	.+92     	; 0x16aa <xTaskIncrementTick+0x116>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    164e:	68 01       	movw	r12, r16
    1650:	b2 e0       	ldi	r27, 0x02	; 2
    1652:	cb 0e       	add	r12, r27
    1654:	d1 1c       	adc	r13, r1
    1656:	c6 01       	movw	r24, r12
    1658:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    165c:	f8 01       	movw	r30, r16
    165e:	84 89       	ldd	r24, Z+20	; 0x14
    1660:	95 89       	ldd	r25, Z+21	; 0x15
    1662:	89 2b       	or	r24, r25
    1664:	21 f0       	breq	.+8      	; 0x166e <xTaskIncrementTick+0xda>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1666:	c8 01       	movw	r24, r16
    1668:	0c 96       	adiw	r24, 0x0c	; 12
    166a:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    166e:	d8 01       	movw	r26, r16
    1670:	56 96       	adiw	r26, 0x16	; 22
    1672:	9c 91       	ld	r25, X
    1674:	80 91 31 0f 	lds	r24, 0x0F31
    1678:	89 17       	cp	r24, r25
    167a:	10 f4       	brcc	.+4      	; 0x1680 <xTaskIncrementTick+0xec>
    167c:	90 93 31 0f 	sts	0x0F31, r25
    1680:	d9 9f       	mul	r29, r25
    1682:	c0 01       	movw	r24, r0
    1684:	11 24       	eor	r1, r1
    1686:	b6 01       	movw	r22, r12
    1688:	89 59       	subi	r24, 0x99	; 153
    168a:	90 4f       	sbci	r25, 0xF0	; 240
    168c:	0e 94 22 03 	call	0x644	; 0x644 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1690:	e0 91 27 0f 	lds	r30, 0x0F27
    1694:	f0 91 28 0f 	lds	r31, 0x0F28
    1698:	d8 01       	movw	r26, r16
    169a:	56 96       	adiw	r26, 0x16	; 22
    169c:	9c 91       	ld	r25, X
    169e:	86 89       	ldd	r24, Z+22	; 0x16
    16a0:	98 17       	cp	r25, r24
    16a2:	08 f4       	brcc	.+2      	; 0x16a6 <xTaskIncrementTick+0x112>
    16a4:	b4 cf       	rjmp	.-152    	; 0x160e <xTaskIncrementTick+0x7a>
							{
								xSwitchRequired = pdTRUE;
    16a6:	c1 e0       	ldi	r28, 0x01	; 1
    16a8:	b2 cf       	rjmp	.-156    	; 0x160e <xTaskIncrementTick+0x7a>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    16aa:	e0 91 27 0f 	lds	r30, 0x0F27
    16ae:	f0 91 28 0f 	lds	r31, 0x0F28
    16b2:	e6 89       	ldd	r30, Z+22	; 0x16
    16b4:	b9 e0       	ldi	r27, 0x09	; 9
    16b6:	eb 9f       	mul	r30, r27
    16b8:	f0 01       	movw	r30, r0
    16ba:	11 24       	eor	r1, r1
    16bc:	e9 59       	subi	r30, 0x99	; 153
    16be:	f0 4f       	sbci	r31, 0xF0	; 240
    16c0:	80 81       	ld	r24, Z
    16c2:	82 30       	cpi	r24, 0x02	; 2
    16c4:	40 f0       	brcs	.+16     	; 0x16d6 <xTaskIncrementTick+0x142>
			{
				xSwitchRequired = pdTRUE;
    16c6:	c1 e0       	ldi	r28, 0x01	; 1
    16c8:	06 c0       	rjmp	.+12     	; 0x16d6 <xTaskIncrementTick+0x142>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    16ca:	80 91 2f 0f 	lds	r24, 0x0F2F
    16ce:	8f 5f       	subi	r24, 0xFF	; 255
    16d0:	80 93 2f 0f 	sts	0x0F2F, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    16d4:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    16d6:	80 91 2e 0f 	lds	r24, 0x0F2E
    16da:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
    16dc:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    16de:	8c 2f       	mov	r24, r28
    16e0:	df 91       	pop	r29
    16e2:	cf 91       	pop	r28
    16e4:	1f 91       	pop	r17
    16e6:	0f 91       	pop	r16
    16e8:	ff 90       	pop	r15
    16ea:	ef 90       	pop	r14
    16ec:	df 90       	pop	r13
    16ee:	cf 90       	pop	r12
    16f0:	08 95       	ret

000016f2 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    16f2:	ef 92       	push	r14
    16f4:	ff 92       	push	r15
    16f6:	0f 93       	push	r16
    16f8:	1f 93       	push	r17
    16fa:	cf 93       	push	r28
    16fc:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    16fe:	0f b6       	in	r0, 0x3f	; 63
    1700:	f8 94       	cli
    1702:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1704:	80 91 29 0f 	lds	r24, 0x0F29
    1708:	81 50       	subi	r24, 0x01	; 1
    170a:	80 93 29 0f 	sts	0x0F29, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    170e:	80 91 29 0f 	lds	r24, 0x0F29
    1712:	88 23       	and	r24, r24
    1714:	11 f0       	breq	.+4      	; 0x171a <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    1716:	80 e0       	ldi	r24, 0x00	; 0
    1718:	53 c0       	rjmp	.+166    	; 0x17c0 <xTaskResumeAll+0xce>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    171a:	80 91 34 0f 	lds	r24, 0x0F34
    171e:	88 23       	and	r24, r24
    1720:	d1 f3       	breq	.-12     	; 0x1716 <xTaskResumeAll+0x24>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyList( pxTCB );
    1722:	89 e0       	ldi	r24, 0x09	; 9
    1724:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    1726:	ee 24       	eor	r14, r14
    1728:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    172a:	80 91 48 0f 	lds	r24, 0x0F48
    172e:	88 23       	and	r24, r24
    1730:	51 f1       	breq	.+84     	; 0x1786 <xTaskResumeAll+0x94>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    1732:	e0 91 4d 0f 	lds	r30, 0x0F4D
    1736:	f0 91 4e 0f 	lds	r31, 0x0F4E
    173a:	c6 81       	ldd	r28, Z+6	; 0x06
    173c:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    173e:	ce 01       	movw	r24, r28
    1740:	0c 96       	adiw	r24, 0x0c	; 12
    1742:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1746:	8e 01       	movw	r16, r28
    1748:	0e 5f       	subi	r16, 0xFE	; 254
    174a:	1f 4f       	sbci	r17, 0xFF	; 255
    174c:	c8 01       	movw	r24, r16
    174e:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1752:	9e 89       	ldd	r25, Y+22	; 0x16
    1754:	80 91 31 0f 	lds	r24, 0x0F31
    1758:	89 17       	cp	r24, r25
    175a:	10 f4       	brcc	.+4      	; 0x1760 <xTaskResumeAll+0x6e>
    175c:	90 93 31 0f 	sts	0x0F31, r25
    1760:	f9 9e       	mul	r15, r25
    1762:	c0 01       	movw	r24, r0
    1764:	11 24       	eor	r1, r1
    1766:	b8 01       	movw	r22, r16
    1768:	89 59       	subi	r24, 0x99	; 153
    176a:	90 4f       	sbci	r25, 0xF0	; 240
    176c:	0e 94 22 03 	call	0x644	; 0x644 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1770:	e0 91 27 0f 	lds	r30, 0x0F27
    1774:	f0 91 28 0f 	lds	r31, 0x0F28
    1778:	9e 89       	ldd	r25, Y+22	; 0x16
    177a:	86 89       	ldd	r24, Z+22	; 0x16
    177c:	98 17       	cp	r25, r24
    177e:	a8 f2       	brcs	.-86     	; 0x172a <xTaskResumeAll+0x38>
					{
						xYieldPending = pdTRUE;
    1780:	e0 92 2e 0f 	sts	0x0F2E, r14
    1784:	d2 cf       	rjmp	.-92     	; 0x172a <xTaskResumeAll+0x38>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    1786:	80 91 2f 0f 	lds	r24, 0x0F2F
    178a:	81 11       	cpse	r24, r1
    178c:	09 c0       	rjmp	.+18     	; 0x17a0 <xTaskResumeAll+0xae>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    178e:	80 91 2e 0f 	lds	r24, 0x0F2E
    1792:	81 30       	cpi	r24, 0x01	; 1
    1794:	09 f0       	breq	.+2      	; 0x1798 <xTaskResumeAll+0xa6>
    1796:	bf cf       	rjmp	.-130    	; 0x1716 <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    1798:	0e 94 49 04 	call	0x892	; 0x892 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    179c:	81 e0       	ldi	r24, 0x01	; 1
    179e:	10 c0       	rjmp	.+32     	; 0x17c0 <xTaskResumeAll+0xce>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
    17a0:	c1 e0       	ldi	r28, 0x01	; 1
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    17a2:	80 91 2f 0f 	lds	r24, 0x0F2F
    17a6:	88 23       	and	r24, r24
    17a8:	91 f3       	breq	.-28     	; 0x178e <xTaskResumeAll+0x9c>
					{
						if( xTaskIncrementTick() != pdFALSE )
    17aa:	0e 94 ca 0a 	call	0x1594	; 0x1594 <xTaskIncrementTick>
    17ae:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
    17b0:	c0 93 2e 0f 	sts	0x0F2E, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    17b4:	80 91 2f 0f 	lds	r24, 0x0F2F
    17b8:	81 50       	subi	r24, 0x01	; 1
    17ba:	80 93 2f 0f 	sts	0x0F2F, r24
    17be:	f1 cf       	rjmp	.-30     	; 0x17a2 <xTaskResumeAll+0xb0>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    17c0:	0f 90       	pop	r0
    17c2:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    17c4:	df 91       	pop	r29
    17c6:	cf 91       	pop	r28
    17c8:	1f 91       	pop	r17
    17ca:	0f 91       	pop	r16
    17cc:	ff 90       	pop	r15
    17ce:	ef 90       	pop	r14
    17d0:	08 95       	ret

000017d2 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    17d2:	0f 93       	push	r16
    17d4:	1f 93       	push	r17
    17d6:	cf 93       	push	r28
    17d8:	df 93       	push	r29
    17da:	8c 01       	movw	r16, r24
    17dc:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    17de:	0e 94 b2 0a 	call	0x1564	; 0x1564 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    17e2:	40 91 32 0f 	lds	r20, 0x0F32
    17e6:	50 91 33 0f 	lds	r21, 0x0F33

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    17ea:	f8 01       	movw	r30, r16
    17ec:	20 81       	ld	r18, Z
    17ee:	31 81       	ldd	r19, Z+1	; 0x01
    17f0:	c2 0f       	add	r28, r18
    17f2:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
    17f4:	42 17       	cp	r20, r18
    17f6:	53 07       	cpc	r21, r19
    17f8:	28 f4       	brcc	.+10     	; 0x1804 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    17fa:	c2 17       	cp	r28, r18
    17fc:	d3 07       	cpc	r29, r19
    17fe:	48 f4       	brcc	.+18     	; 0x1812 <vTaskDelayUntil+0x40>
    1800:	91 e0       	ldi	r25, 0x01	; 1
    1802:	04 c0       	rjmp	.+8      	; 0x180c <vTaskDelayUntil+0x3a>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
    1804:	91 e0       	ldi	r25, 0x01	; 1
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    1806:	c2 17       	cp	r28, r18
    1808:	d3 07       	cpc	r29, r19
    180a:	20 f0       	brcs	.+8      	; 0x1814 <vTaskDelayUntil+0x42>
    180c:	4c 17       	cp	r20, r28
    180e:	5d 07       	cpc	r21, r29
    1810:	08 f0       	brcs	.+2      	; 0x1814 <vTaskDelayUntil+0x42>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    1812:	90 e0       	ldi	r25, 0x00	; 0
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1814:	f8 01       	movw	r30, r16
    1816:	d1 83       	std	Z+1, r29	; 0x01
    1818:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    181a:	99 23       	and	r25, r25
    181c:	51 f0       	breq	.+20     	; 0x1832 <vTaskDelayUntil+0x60>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    181e:	80 91 27 0f 	lds	r24, 0x0F27
    1822:	90 91 28 0f 	lds	r25, 0x0F28
    1826:	02 96       	adiw	r24, 0x02	; 2
    1828:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    182c:	ce 01       	movw	r24, r28
    182e:	0e 94 67 08 	call	0x10ce	; 0x10ce <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1832:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1836:	81 11       	cpse	r24, r1
    1838:	02 c0       	rjmp	.+4      	; 0x183e <vTaskDelayUntil+0x6c>
		{
			portYIELD_WITHIN_API();
    183a:	0e 94 49 04 	call	0x892	; 0x892 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    183e:	df 91       	pop	r29
    1840:	cf 91       	pop	r28
    1842:	1f 91       	pop	r17
    1844:	0f 91       	pop	r16
    1846:	08 95       	ret

00001848 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    1848:	cf 93       	push	r28
    184a:	df 93       	push	r29
    184c:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    184e:	89 2b       	or	r24, r25
    1850:	19 f4       	brne	.+6      	; 0x1858 <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
    1852:	0e 94 49 04 	call	0x892	; 0x892 <vPortYield>
    1856:	16 c0       	rjmp	.+44     	; 0x1884 <vTaskDelay+0x3c>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    1858:	0e 94 b2 0a 	call	0x1564	; 0x1564 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    185c:	20 91 32 0f 	lds	r18, 0x0F32
    1860:	30 91 33 0f 	lds	r19, 0x0F33
    1864:	c2 0f       	add	r28, r18
    1866:	d3 1f       	adc	r29, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1868:	80 91 27 0f 	lds	r24, 0x0F27
    186c:	90 91 28 0f 	lds	r25, 0x0F28
    1870:	02 96       	adiw	r24, 0x02	; 2
    1872:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1876:	ce 01       	movw	r24, r28
    1878:	0e 94 67 08 	call	0x10ce	; 0x10ce <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    187c:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1880:	88 23       	and	r24, r24
    1882:	39 f3       	breq	.-50     	; 0x1852 <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1884:	df 91       	pop	r29
    1886:	cf 91       	pop	r28
    1888:	08 95       	ret

0000188a <prvIdleTask>:
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    188a:	80 91 3e 0f 	lds	r24, 0x0F3E
    188e:	88 23       	and	r24, r24
    1890:	49 f1       	breq	.+82     	; 0x18e4 <prvIdleTask+0x5a>
		{
			vTaskSuspendAll();
    1892:	0e 94 b2 0a 	call	0x1564	; 0x1564 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1896:	c0 91 3f 0f 	lds	r28, 0x0F3F
			}
			( void ) xTaskResumeAll();
    189a:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    189e:	cc 23       	and	r28, r28
    18a0:	a1 f3       	breq	.-24     	; 0x188a <prvIdleTask>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    18a2:	0f b6       	in	r0, 0x3f	; 63
    18a4:	f8 94       	cli
    18a6:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    18a8:	e0 91 44 0f 	lds	r30, 0x0F44
    18ac:	f0 91 45 0f 	lds	r31, 0x0F45
    18b0:	c6 81       	ldd	r28, Z+6	; 0x06
    18b2:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    18b4:	ce 01       	movw	r24, r28
    18b6:	02 96       	adiw	r24, 0x02	; 2
    18b8:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
					--uxCurrentNumberOfTasks;
    18bc:	80 91 34 0f 	lds	r24, 0x0F34
    18c0:	81 50       	subi	r24, 0x01	; 1
    18c2:	80 93 34 0f 	sts	0x0F34, r24
					--uxTasksDeleted;
    18c6:	80 91 3e 0f 	lds	r24, 0x0F3E
    18ca:	81 50       	subi	r24, 0x01	; 1
    18cc:	80 93 3e 0f 	sts	0x0F3E, r24
				}
				taskEXIT_CRITICAL();
    18d0:	0f 90       	pop	r0
    18d2:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
    18d4:	8f 89       	ldd	r24, Y+23	; 0x17
    18d6:	98 8d       	ldd	r25, Y+24	; 0x18
    18d8:	0e 94 33 05 	call	0xa66	; 0xa66 <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
    18dc:	ce 01       	movw	r24, r28
    18de:	0e 94 33 05 	call	0xa66	; 0xa66 <vPortFree>
    18e2:	d3 cf       	rjmp	.-90     	; 0x188a <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    18e4:	80 91 67 0f 	lds	r24, 0x0F67
    18e8:	82 30       	cpi	r24, 0x02	; 2
    18ea:	78 f2       	brcs	.-98     	; 0x188a <prvIdleTask>
			{
				taskYIELD();
    18ec:	0e 94 49 04 	call	0x892	; 0x892 <vPortYield>
    18f0:	cc cf       	rjmp	.-104    	; 0x188a <prvIdleTask>

000018f2 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    18f2:	80 91 29 0f 	lds	r24, 0x0F29
    18f6:	88 23       	and	r24, r24
    18f8:	21 f0       	breq	.+8      	; 0x1902 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    18fa:	81 e0       	ldi	r24, 0x01	; 1
    18fc:	80 93 2e 0f 	sts	0x0F2E, r24
    1900:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    1902:	10 92 2e 0f 	sts	0x0F2E, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1906:	99 e0       	ldi	r25, 0x09	; 9
    1908:	e0 91 31 0f 	lds	r30, 0x0F31
    190c:	9e 9f       	mul	r25, r30
    190e:	f0 01       	movw	r30, r0
    1910:	11 24       	eor	r1, r1
    1912:	e9 59       	subi	r30, 0x99	; 153
    1914:	f0 4f       	sbci	r31, 0xF0	; 240
    1916:	80 81       	ld	r24, Z
    1918:	81 11       	cpse	r24, r1
    191a:	06 c0       	rjmp	.+12     	; 0x1928 <vTaskSwitchContext+0x36>
    191c:	80 91 31 0f 	lds	r24, 0x0F31
    1920:	81 50       	subi	r24, 0x01	; 1
    1922:	80 93 31 0f 	sts	0x0F31, r24
    1926:	f0 cf       	rjmp	.-32     	; 0x1908 <vTaskSwitchContext+0x16>
    1928:	80 91 31 0f 	lds	r24, 0x0F31
    192c:	90 e0       	ldi	r25, 0x00	; 0
    192e:	49 e0       	ldi	r20, 0x09	; 9
    1930:	48 9f       	mul	r20, r24
    1932:	90 01       	movw	r18, r0
    1934:	49 9f       	mul	r20, r25
    1936:	30 0d       	add	r19, r0
    1938:	11 24       	eor	r1, r1
    193a:	f9 01       	movw	r30, r18
    193c:	e9 59       	subi	r30, 0x99	; 153
    193e:	f0 4f       	sbci	r31, 0xF0	; 240
    1940:	a1 81       	ldd	r26, Z+1	; 0x01
    1942:	b2 81       	ldd	r27, Z+2	; 0x02
    1944:	12 96       	adiw	r26, 0x02	; 2
    1946:	0d 90       	ld	r0, X+
    1948:	bc 91       	ld	r27, X
    194a:	a0 2d       	mov	r26, r0
    194c:	b2 83       	std	Z+2, r27	; 0x02
    194e:	a1 83       	std	Z+1, r26	; 0x01
    1950:	26 59       	subi	r18, 0x96	; 150
    1952:	30 4f       	sbci	r19, 0xF0	; 240
    1954:	a2 17       	cp	r26, r18
    1956:	b3 07       	cpc	r27, r19
    1958:	31 f4       	brne	.+12     	; 0x1966 <vTaskSwitchContext+0x74>
    195a:	12 96       	adiw	r26, 0x02	; 2
    195c:	2d 91       	ld	r18, X+
    195e:	3c 91       	ld	r19, X
    1960:	13 97       	sbiw	r26, 0x03	; 3
    1962:	32 83       	std	Z+2, r19	; 0x02
    1964:	21 83       	std	Z+1, r18	; 0x01
    1966:	29 e0       	ldi	r18, 0x09	; 9
    1968:	28 9f       	mul	r18, r24
    196a:	f0 01       	movw	r30, r0
    196c:	29 9f       	mul	r18, r25
    196e:	f0 0d       	add	r31, r0
    1970:	11 24       	eor	r1, r1
    1972:	e9 59       	subi	r30, 0x99	; 153
    1974:	f0 4f       	sbci	r31, 0xF0	; 240
    1976:	01 80       	ldd	r0, Z+1	; 0x01
    1978:	f2 81       	ldd	r31, Z+2	; 0x02
    197a:	e0 2d       	mov	r30, r0
    197c:	86 81       	ldd	r24, Z+6	; 0x06
    197e:	97 81       	ldd	r25, Z+7	; 0x07
    1980:	90 93 28 0f 	sts	0x0F28, r25
    1984:	80 93 27 0f 	sts	0x0F27, r24
    1988:	08 95       	ret

0000198a <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    198a:	0f 93       	push	r16
    198c:	1f 93       	push	r17
    198e:	cf 93       	push	r28
    1990:	df 93       	push	r29
    1992:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    1994:	0f b6       	in	r0, 0x3f	; 63
    1996:	f8 94       	cli
    1998:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    199a:	89 2b       	or	r24, r25
    199c:	21 f4       	brne	.+8      	; 0x19a6 <vTaskSuspend+0x1c>
    199e:	c0 91 27 0f 	lds	r28, 0x0F27
    19a2:	d0 91 28 0f 	lds	r29, 0x0F28

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    19a6:	8e 01       	movw	r16, r28
    19a8:	0e 5f       	subi	r16, 0xFE	; 254
    19aa:	1f 4f       	sbci	r17, 0xFF	; 255
    19ac:	c8 01       	movw	r24, r16
    19ae:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    19b2:	8c 89       	ldd	r24, Y+20	; 0x14
    19b4:	9d 89       	ldd	r25, Y+21	; 0x15
    19b6:	89 2b       	or	r24, r25
    19b8:	21 f0       	breq	.+8      	; 0x19c2 <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    19ba:	ce 01       	movw	r24, r28
    19bc:	0c 96       	adiw	r24, 0x0c	; 12
    19be:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    19c2:	b8 01       	movw	r22, r16
    19c4:	85 e3       	ldi	r24, 0x35	; 53
    19c6:	9f e0       	ldi	r25, 0x0F	; 15
    19c8:	0e 94 22 03 	call	0x644	; 0x644 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    19cc:	0f 90       	pop	r0
    19ce:	0f be       	out	0x3f, r0	; 63

		if( pxTCB == pxCurrentTCB )
    19d0:	80 91 27 0f 	lds	r24, 0x0F27
    19d4:	90 91 28 0f 	lds	r25, 0x0F28
    19d8:	c8 17       	cp	r28, r24
    19da:	d9 07       	cpc	r29, r25
    19dc:	c1 f4       	brne	.+48     	; 0x1a0e <vTaskSuspend+0x84>
		{
			if( xSchedulerRunning != pdFALSE )
    19de:	80 91 30 0f 	lds	r24, 0x0F30
    19e2:	88 23       	and	r24, r24
    19e4:	19 f0       	breq	.+6      	; 0x19ec <vTaskSuspend+0x62>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    19e6:	0e 94 49 04 	call	0x892	; 0x892 <vPortYield>
    19ea:	1c c0       	rjmp	.+56     	; 0x1a24 <vTaskSuspend+0x9a>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    19ec:	80 91 34 0f 	lds	r24, 0x0F34
    19f0:	90 91 35 0f 	lds	r25, 0x0F35
    19f4:	98 13       	cpse	r25, r24
    19f6:	05 c0       	rjmp	.+10     	; 0x1a02 <vTaskSuspend+0x78>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    19f8:	10 92 28 0f 	sts	0x0F28, r1
    19fc:	10 92 27 0f 	sts	0x0F27, r1
    1a00:	11 c0       	rjmp	.+34     	; 0x1a24 <vTaskSuspend+0x9a>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    1a02:	df 91       	pop	r29
    1a04:	cf 91       	pop	r28
    1a06:	1f 91       	pop	r17
    1a08:	0f 91       	pop	r16
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
    1a0a:	0c 94 79 0c 	jmp	0x18f2	; 0x18f2 <vTaskSwitchContext>
				}
			}
		}
		else
		{
			if( xSchedulerRunning != pdFALSE )
    1a0e:	80 91 30 0f 	lds	r24, 0x0F30
    1a12:	88 23       	and	r24, r24
    1a14:	39 f0       	breq	.+14     	; 0x1a24 <vTaskSuspend+0x9a>
			{
				/* A task other than the currently running task was suspended,
				reset the next expected unblock time in case it referred to the
				task that is now in the Suspended state. */
				taskENTER_CRITICAL();
    1a16:	0f b6       	in	r0, 0x3f	; 63
    1a18:	f8 94       	cli
    1a1a:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    1a1c:	0e 94 4c 08 	call	0x1098	; 0x1098 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    1a20:	0f 90       	pop	r0
    1a22:	0f be       	out	0x3f, r0	; 63
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    1a24:	df 91       	pop	r29
    1a26:	cf 91       	pop	r28
    1a28:	1f 91       	pop	r17
    1a2a:	0f 91       	pop	r16
    1a2c:	08 95       	ret

00001a2e <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    1a2e:	cf 93       	push	r28
    1a30:	df 93       	push	r29
    1a32:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1a34:	20 91 27 0f 	lds	r18, 0x0F27
    1a38:	30 91 28 0f 	lds	r19, 0x0F28
    1a3c:	b9 01       	movw	r22, r18
    1a3e:	64 5f       	subi	r22, 0xF4	; 244
    1a40:	7f 4f       	sbci	r23, 0xFF	; 255
    1a42:	0e 94 43 03 	call	0x686	; 0x686 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1a46:	80 91 27 0f 	lds	r24, 0x0F27
    1a4a:	90 91 28 0f 	lds	r25, 0x0F28
    1a4e:	02 96       	adiw	r24, 0x02	; 2
    1a50:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    1a54:	cf 3f       	cpi	r28, 0xFF	; 255
    1a56:	8f ef       	ldi	r24, 0xFF	; 255
    1a58:	d8 07       	cpc	r29, r24
    1a5a:	61 f4       	brne	.+24     	; 0x1a74 <vTaskPlaceOnEventList+0x46>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1a5c:	60 91 27 0f 	lds	r22, 0x0F27
    1a60:	70 91 28 0f 	lds	r23, 0x0F28
    1a64:	6e 5f       	subi	r22, 0xFE	; 254
    1a66:	7f 4f       	sbci	r23, 0xFF	; 255
    1a68:	85 e3       	ldi	r24, 0x35	; 53
    1a6a:	9f e0       	ldi	r25, 0x0F	; 15
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1a6c:	df 91       	pop	r29
    1a6e:	cf 91       	pop	r28
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1a70:	0c 94 22 03 	jmp	0x644	; 0x644 <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    1a74:	80 91 32 0f 	lds	r24, 0x0F32
    1a78:	90 91 33 0f 	lds	r25, 0x0F33
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1a7c:	8c 0f       	add	r24, r28
    1a7e:	9d 1f       	adc	r25, r29
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1a80:	df 91       	pop	r29
    1a82:	cf 91       	pop	r28
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1a84:	0c 94 67 08 	jmp	0x10ce	; 0x10ce <prvAddCurrentTaskToDelayedList>

00001a88 <vTaskPlaceOnUnorderedEventList>:
	#endif /* INCLUDE_vTaskSuspend */
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    1a88:	cf 93       	push	r28
    1a8a:	df 93       	push	r29
    1a8c:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1a8e:	e0 91 27 0f 	lds	r30, 0x0F27
    1a92:	f0 91 28 0f 	lds	r31, 0x0F28
    1a96:	70 68       	ori	r23, 0x80	; 128
    1a98:	75 87       	std	Z+13, r23	; 0x0d
    1a9a:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1a9c:	60 91 27 0f 	lds	r22, 0x0F27
    1aa0:	70 91 28 0f 	lds	r23, 0x0F28
    1aa4:	64 5f       	subi	r22, 0xF4	; 244
    1aa6:	7f 4f       	sbci	r23, 0xFF	; 255
    1aa8:	0e 94 22 03 	call	0x644	; 0x644 <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1aac:	80 91 27 0f 	lds	r24, 0x0F27
    1ab0:	90 91 28 0f 	lds	r25, 0x0F28
    1ab4:	02 96       	adiw	r24, 0x02	; 2
    1ab6:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    1aba:	cf 3f       	cpi	r28, 0xFF	; 255
    1abc:	8f ef       	ldi	r24, 0xFF	; 255
    1abe:	d8 07       	cpc	r29, r24
    1ac0:	61 f4       	brne	.+24     	; 0x1ada <vTaskPlaceOnUnorderedEventList+0x52>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1ac2:	60 91 27 0f 	lds	r22, 0x0F27
    1ac6:	70 91 28 0f 	lds	r23, 0x0F28
    1aca:	6e 5f       	subi	r22, 0xFE	; 254
    1acc:	7f 4f       	sbci	r23, 0xFF	; 255
    1ace:	85 e3       	ldi	r24, 0x35	; 53
    1ad0:	9f e0       	ldi	r25, 0x0F	; 15
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1ad2:	df 91       	pop	r29
    1ad4:	cf 91       	pop	r28
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1ad6:	0c 94 22 03 	jmp	0x644	; 0x644 <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    1ada:	80 91 32 0f 	lds	r24, 0x0F32
    1ade:	90 91 33 0f 	lds	r25, 0x0F33
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1ae2:	8c 0f       	add	r24, r28
    1ae4:	9d 1f       	adc	r25, r29
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1ae6:	df 91       	pop	r29
    1ae8:	cf 91       	pop	r28
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1aea:	0c 94 67 08 	jmp	0x10ce	; 0x10ce <prvAddCurrentTaskToDelayedList>

00001aee <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    1aee:	0f 93       	push	r16
    1af0:	1f 93       	push	r17
    1af2:	cf 93       	push	r28
    1af4:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1af6:	dc 01       	movw	r26, r24
    1af8:	15 96       	adiw	r26, 0x05	; 5
    1afa:	ed 91       	ld	r30, X+
    1afc:	fc 91       	ld	r31, X
    1afe:	16 97       	sbiw	r26, 0x06	; 6
    1b00:	c6 81       	ldd	r28, Z+6	; 0x06
    1b02:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1b04:	8e 01       	movw	r16, r28
    1b06:	04 5f       	subi	r16, 0xF4	; 244
    1b08:	1f 4f       	sbci	r17, 0xFF	; 255
    1b0a:	c8 01       	movw	r24, r16
    1b0c:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1b10:	80 91 29 0f 	lds	r24, 0x0F29
    1b14:	81 11       	cpse	r24, r1
    1b16:	14 c0       	rjmp	.+40     	; 0x1b40 <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1b18:	0a 50       	subi	r16, 0x0A	; 10
    1b1a:	11 09       	sbc	r17, r1
    1b1c:	c8 01       	movw	r24, r16
    1b1e:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    1b22:	9e 89       	ldd	r25, Y+22	; 0x16
    1b24:	80 91 31 0f 	lds	r24, 0x0F31
    1b28:	89 17       	cp	r24, r25
    1b2a:	10 f4       	brcc	.+4      	; 0x1b30 <xTaskRemoveFromEventList+0x42>
    1b2c:	90 93 31 0f 	sts	0x0F31, r25
    1b30:	b9 e0       	ldi	r27, 0x09	; 9
    1b32:	9b 9f       	mul	r25, r27
    1b34:	c0 01       	movw	r24, r0
    1b36:	11 24       	eor	r1, r1
    1b38:	b8 01       	movw	r22, r16
    1b3a:	89 59       	subi	r24, 0x99	; 153
    1b3c:	90 4f       	sbci	r25, 0xF0	; 240
    1b3e:	03 c0       	rjmp	.+6      	; 0x1b46 <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1b40:	b8 01       	movw	r22, r16
    1b42:	88 e4       	ldi	r24, 0x48	; 72
    1b44:	9f e0       	ldi	r25, 0x0F	; 15
    1b46:	0e 94 22 03 	call	0x644	; 0x644 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1b4a:	e0 91 27 0f 	lds	r30, 0x0F27
    1b4e:	f0 91 28 0f 	lds	r31, 0x0F28
    1b52:	9e 89       	ldd	r25, Y+22	; 0x16
    1b54:	86 89       	ldd	r24, Z+22	; 0x16
    1b56:	89 17       	cp	r24, r25
    1b58:	20 f4       	brcc	.+8      	; 0x1b62 <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1b5a:	81 e0       	ldi	r24, 0x01	; 1
    1b5c:	80 93 2e 0f 	sts	0x0F2E, r24
    1b60:	01 c0       	rjmp	.+2      	; 0x1b64 <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
    1b62:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    1b64:	df 91       	pop	r29
    1b66:	cf 91       	pop	r28
    1b68:	1f 91       	pop	r17
    1b6a:	0f 91       	pop	r16
    1b6c:	08 95       	ret

00001b6e <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    1b6e:	0f 93       	push	r16
    1b70:	1f 93       	push	r17
    1b72:	cf 93       	push	r28
    1b74:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1b76:	70 68       	ori	r23, 0x80	; 128
    1b78:	fc 01       	movw	r30, r24
    1b7a:	71 83       	std	Z+1, r23	; 0x01
    1b7c:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    1b7e:	c6 81       	ldd	r28, Z+6	; 0x06
    1b80:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    1b82:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1b86:	8e 01       	movw	r16, r28
    1b88:	0e 5f       	subi	r16, 0xFE	; 254
    1b8a:	1f 4f       	sbci	r17, 0xFF	; 255
    1b8c:	c8 01       	movw	r24, r16
    1b8e:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    1b92:	9e 89       	ldd	r25, Y+22	; 0x16
    1b94:	80 91 31 0f 	lds	r24, 0x0F31
    1b98:	89 17       	cp	r24, r25
    1b9a:	10 f4       	brcc	.+4      	; 0x1ba0 <xTaskRemoveFromUnorderedEventList+0x32>
    1b9c:	90 93 31 0f 	sts	0x0F31, r25
    1ba0:	f9 e0       	ldi	r31, 0x09	; 9
    1ba2:	9f 9f       	mul	r25, r31
    1ba4:	c0 01       	movw	r24, r0
    1ba6:	11 24       	eor	r1, r1
    1ba8:	b8 01       	movw	r22, r16
    1baa:	89 59       	subi	r24, 0x99	; 153
    1bac:	90 4f       	sbci	r25, 0xF0	; 240
    1bae:	0e 94 22 03 	call	0x644	; 0x644 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1bb2:	e0 91 27 0f 	lds	r30, 0x0F27
    1bb6:	f0 91 28 0f 	lds	r31, 0x0F28
    1bba:	9e 89       	ldd	r25, Y+22	; 0x16
    1bbc:	86 89       	ldd	r24, Z+22	; 0x16
    1bbe:	89 17       	cp	r24, r25
    1bc0:	20 f4       	brcc	.+8      	; 0x1bca <xTaskRemoveFromUnorderedEventList+0x5c>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1bc2:	81 e0       	ldi	r24, 0x01	; 1
    1bc4:	80 93 2e 0f 	sts	0x0F2E, r24
    1bc8:	01 c0       	rjmp	.+2      	; 0x1bcc <xTaskRemoveFromUnorderedEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    1bca:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    1bcc:	df 91       	pop	r29
    1bce:	cf 91       	pop	r28
    1bd0:	1f 91       	pop	r17
    1bd2:	0f 91       	pop	r16
    1bd4:	08 95       	ret

00001bd6 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1bd6:	20 91 2d 0f 	lds	r18, 0x0F2D
    1bda:	fc 01       	movw	r30, r24
    1bdc:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1bde:	20 91 32 0f 	lds	r18, 0x0F32
    1be2:	30 91 33 0f 	lds	r19, 0x0F33
    1be6:	32 83       	std	Z+2, r19	; 0x02
    1be8:	21 83       	std	Z+1, r18	; 0x01
    1bea:	08 95       	ret

00001bec <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    1bec:	cf 93       	push	r28
    1bee:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1bf0:	0f b6       	in	r0, 0x3f	; 63
    1bf2:	f8 94       	cli
    1bf4:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1bf6:	e0 91 32 0f 	lds	r30, 0x0F32
    1bfa:	f0 91 33 0f 	lds	r31, 0x0F33

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    1bfe:	db 01       	movw	r26, r22
    1c00:	2d 91       	ld	r18, X+
    1c02:	3c 91       	ld	r19, X
    1c04:	2f 3f       	cpi	r18, 0xFF	; 255
    1c06:	bf ef       	ldi	r27, 0xFF	; 255
    1c08:	3b 07       	cpc	r19, r27
    1c0a:	d1 f0       	breq	.+52     	; 0x1c40 <xTaskCheckForTimeOut+0x54>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1c0c:	b0 91 2d 0f 	lds	r27, 0x0F2D
    1c10:	ec 01       	movw	r28, r24
    1c12:	a8 81       	ld	r26, Y
    1c14:	49 81       	ldd	r20, Y+1	; 0x01
    1c16:	5a 81       	ldd	r21, Y+2	; 0x02
    1c18:	ba 17       	cp	r27, r26
    1c1a:	19 f0       	breq	.+6      	; 0x1c22 <xTaskCheckForTimeOut+0x36>
    1c1c:	e4 17       	cp	r30, r20
    1c1e:	f5 07       	cpc	r31, r21
    1c20:	88 f4       	brcc	.+34     	; 0x1c44 <xTaskCheckForTimeOut+0x58>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    1c22:	df 01       	movw	r26, r30
    1c24:	a4 1b       	sub	r26, r20
    1c26:	b5 0b       	sbc	r27, r21
    1c28:	a2 17       	cp	r26, r18
    1c2a:	b3 07       	cpc	r27, r19
    1c2c:	58 f4       	brcc	.+22     	; 0x1c44 <xTaskCheckForTimeOut+0x58>
    1c2e:	db 01       	movw	r26, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    1c30:	4e 1b       	sub	r20, r30
    1c32:	5f 0b       	sbc	r21, r31
    1c34:	24 0f       	add	r18, r20
    1c36:	35 1f       	adc	r19, r21
    1c38:	2d 93       	st	X+, r18
    1c3a:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    1c3c:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <vTaskSetTimeOutState>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    1c40:	80 e0       	ldi	r24, 0x00	; 0
    1c42:	01 c0       	rjmp	.+2      	; 0x1c46 <xTaskCheckForTimeOut+0x5a>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1c44:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    1c46:	0f 90       	pop	r0
    1c48:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1c4a:	df 91       	pop	r29
    1c4c:	cf 91       	pop	r28
    1c4e:	08 95       	ret

00001c50 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1c50:	81 e0       	ldi	r24, 0x01	; 1
    1c52:	80 93 2e 0f 	sts	0x0F2E, r24
    1c56:	08 95       	ret

00001c58 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1c58:	e0 91 27 0f 	lds	r30, 0x0F27
    1c5c:	f0 91 28 0f 	lds	r31, 0x0F28
    1c60:	84 85       	ldd	r24, Z+12	; 0x0c
    1c62:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1c64:	e0 91 27 0f 	lds	r30, 0x0F27
    1c68:	f0 91 28 0f 	lds	r31, 0x0F28
    1c6c:	a0 91 27 0f 	lds	r26, 0x0F27
    1c70:	b0 91 28 0f 	lds	r27, 0x0F28
    1c74:	56 96       	adiw	r26, 0x16	; 22
    1c76:	4c 91       	ld	r20, X
    1c78:	24 e0       	ldi	r18, 0x04	; 4
    1c7a:	30 e0       	ldi	r19, 0x00	; 0
    1c7c:	24 1b       	sub	r18, r20
    1c7e:	31 09       	sbc	r19, r1
    1c80:	35 87       	std	Z+13, r19	; 0x0d
    1c82:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    1c84:	08 95       	ret

00001c86 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    1c86:	0f 93       	push	r16
    1c88:	1f 93       	push	r17
    1c8a:	cf 93       	push	r28
    1c8c:	df 93       	push	r29
    1c8e:	18 2f       	mov	r17, r24
    1c90:	eb 01       	movw	r28, r22
	TickType_t xTimeToWake;
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    1c92:	0f b6       	in	r0, 0x3f	; 63
    1c94:	f8 94       	cli
    1c96:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    1c98:	e0 91 27 0f 	lds	r30, 0x0F27
    1c9c:	f0 91 28 0f 	lds	r31, 0x0F28
    1ca0:	81 a1       	ldd	r24, Z+33	; 0x21
    1ca2:	92 a1       	ldd	r25, Z+34	; 0x22
    1ca4:	a3 a1       	ldd	r26, Z+35	; 0x23
    1ca6:	b4 a1       	ldd	r27, Z+36	; 0x24
    1ca8:	89 2b       	or	r24, r25
    1caa:	8a 2b       	or	r24, r26
    1cac:	8b 2b       	or	r24, r27
    1cae:	41 f5       	brne	.+80     	; 0x1d00 <ulTaskNotifyTake+0x7a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    1cb0:	e0 91 27 0f 	lds	r30, 0x0F27
    1cb4:	f0 91 28 0f 	lds	r31, 0x0F28
    1cb8:	81 e0       	ldi	r24, 0x01	; 1
    1cba:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    1cbc:	20 97       	sbiw	r28, 0x00	; 0
    1cbe:	01 f1       	breq	.+64     	; 0x1d00 <ulTaskNotifyTake+0x7a>
				{
					/* The task is going to block.  First it must be removed
					from the ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1cc0:	80 91 27 0f 	lds	r24, 0x0F27
    1cc4:	90 91 28 0f 	lds	r25, 0x0F28
    1cc8:	02 96       	adiw	r24, 0x02	; 2
    1cca:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					#if ( INCLUDE_vTaskSuspend == 1 )
					{
						if( xTicksToWait == portMAX_DELAY )
    1cce:	cf 3f       	cpi	r28, 0xFF	; 255
    1cd0:	8f ef       	ldi	r24, 0xFF	; 255
    1cd2:	d8 07       	cpc	r29, r24
    1cd4:	59 f4       	brne	.+22     	; 0x1cec <ulTaskNotifyTake+0x66>
						{
							/* Add the task to the suspended task list instead
							of a delayed task list to ensure the task is not
							woken by a timing event.  It will block
							indefinitely. */
							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1cd6:	60 91 27 0f 	lds	r22, 0x0F27
    1cda:	70 91 28 0f 	lds	r23, 0x0F28
    1cde:	6e 5f       	subi	r22, 0xFE	; 254
    1ce0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ce2:	85 e3       	ldi	r24, 0x35	; 53
    1ce4:	9f e0       	ldi	r25, 0x0F	; 15
    1ce6:	0e 94 22 03 	call	0x644	; 0x644 <vListInsertEnd>
    1cea:	08 c0       	rjmp	.+16     	; 0x1cfc <ulTaskNotifyTake+0x76>
						{
							/* Calculate the time at which the task should be
							woken if no notification events occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    1cec:	80 91 32 0f 	lds	r24, 0x0F32
    1cf0:	90 91 33 0f 	lds	r25, 0x0F33
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    1cf4:	8c 0f       	add	r24, r28
    1cf6:	9d 1f       	adc	r25, r29
    1cf8:	0e 94 67 08 	call	0x10ce	; 0x10ce <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1cfc:	0e 94 49 04 	call	0x892	; 0x892 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1d00:	0f 90       	pop	r0
    1d02:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    1d04:	0f b6       	in	r0, 0x3f	; 63
    1d06:	f8 94       	cli
    1d08:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    1d0a:	e0 91 27 0f 	lds	r30, 0x0F27
    1d0e:	f0 91 28 0f 	lds	r31, 0x0F28
    1d12:	61 a1       	ldd	r22, Z+33	; 0x21
    1d14:	72 a1       	ldd	r23, Z+34	; 0x22
    1d16:	83 a1       	ldd	r24, Z+35	; 0x23
    1d18:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
    1d1a:	61 15       	cp	r22, r1
    1d1c:	71 05       	cpc	r23, r1
    1d1e:	81 05       	cpc	r24, r1
    1d20:	91 05       	cpc	r25, r1
    1d22:	b9 f0       	breq	.+46     	; 0x1d52 <ulTaskNotifyTake+0xcc>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    1d24:	e0 91 27 0f 	lds	r30, 0x0F27
    1d28:	f0 91 28 0f 	lds	r31, 0x0F28
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
    1d2c:	11 23       	and	r17, r17
    1d2e:	29 f0       	breq	.+10     	; 0x1d3a <ulTaskNotifyTake+0xb4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    1d30:	11 a2       	std	Z+33, r1	; 0x21
    1d32:	12 a2       	std	Z+34, r1	; 0x22
    1d34:	13 a2       	std	Z+35, r1	; 0x23
    1d36:	14 a2       	std	Z+36, r1	; 0x24
    1d38:	0c c0       	rjmp	.+24     	; 0x1d52 <ulTaskNotifyTake+0xcc>
				}
				else
				{
					( pxCurrentTCB->ulNotifiedValue )--;
    1d3a:	01 a1       	ldd	r16, Z+33	; 0x21
    1d3c:	12 a1       	ldd	r17, Z+34	; 0x22
    1d3e:	23 a1       	ldd	r18, Z+35	; 0x23
    1d40:	34 a1       	ldd	r19, Z+36	; 0x24
    1d42:	01 50       	subi	r16, 0x01	; 1
    1d44:	11 09       	sbc	r17, r1
    1d46:	21 09       	sbc	r18, r1
    1d48:	31 09       	sbc	r19, r1
    1d4a:	01 a3       	std	Z+33, r16	; 0x21
    1d4c:	12 a3       	std	Z+34, r17	; 0x22
    1d4e:	23 a3       	std	Z+35, r18	; 0x23
    1d50:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    1d52:	e0 91 27 0f 	lds	r30, 0x0F27
    1d56:	f0 91 28 0f 	lds	r31, 0x0F28
    1d5a:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    1d5c:	0f 90       	pop	r0
    1d5e:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    1d60:	df 91       	pop	r29
    1d62:	cf 91       	pop	r28
    1d64:	1f 91       	pop	r17
    1d66:	0f 91       	pop	r16
    1d68:	08 95       	ret

00001d6a <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    1d6a:	4f 92       	push	r4
    1d6c:	5f 92       	push	r5
    1d6e:	6f 92       	push	r6
    1d70:	7f 92       	push	r7
    1d72:	8f 92       	push	r8
    1d74:	9f 92       	push	r9
    1d76:	af 92       	push	r10
    1d78:	bf 92       	push	r11
    1d7a:	ef 92       	push	r14
    1d7c:	ff 92       	push	r15
    1d7e:	0f 93       	push	r16
    1d80:	1f 93       	push	r17
    1d82:	29 01       	movw	r4, r18
    1d84:	3a 01       	movw	r6, r20
	TickType_t xTimeToWake;
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    1d86:	0f b6       	in	r0, 0x3f	; 63
    1d88:	f8 94       	cli
    1d8a:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->eNotifyState != eNotified )
    1d8c:	e0 91 27 0f 	lds	r30, 0x0F27
    1d90:	f0 91 28 0f 	lds	r31, 0x0F28
    1d94:	25 a1       	ldd	r18, Z+37	; 0x25
    1d96:	22 30       	cpi	r18, 0x02	; 2
    1d98:	09 f4       	brne	.+2      	; 0x1d9c <xTaskNotifyWait+0x32>
    1d9a:	41 c0       	rjmp	.+130    	; 0x1e1e <xTaskNotifyWait+0xb4>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    1d9c:	e0 91 27 0f 	lds	r30, 0x0F27
    1da0:	f0 91 28 0f 	lds	r31, 0x0F28
    1da4:	21 a1       	ldd	r18, Z+33	; 0x21
    1da6:	32 a1       	ldd	r19, Z+34	; 0x22
    1da8:	43 a1       	ldd	r20, Z+35	; 0x23
    1daa:	54 a1       	ldd	r21, Z+36	; 0x24
    1dac:	4b 01       	movw	r8, r22
    1dae:	5c 01       	movw	r10, r24
    1db0:	80 94       	com	r8
    1db2:	90 94       	com	r9
    1db4:	a0 94       	com	r10
    1db6:	b0 94       	com	r11
    1db8:	d5 01       	movw	r26, r10
    1dba:	c4 01       	movw	r24, r8
    1dbc:	82 23       	and	r24, r18
    1dbe:	93 23       	and	r25, r19
    1dc0:	a4 23       	and	r26, r20
    1dc2:	b5 23       	and	r27, r21
    1dc4:	81 a3       	std	Z+33, r24	; 0x21
    1dc6:	92 a3       	std	Z+34, r25	; 0x22
    1dc8:	a3 a3       	std	Z+35, r26	; 0x23
    1dca:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    1dcc:	e0 91 27 0f 	lds	r30, 0x0F27
    1dd0:	f0 91 28 0f 	lds	r31, 0x0F28
    1dd4:	81 e0       	ldi	r24, 0x01	; 1
    1dd6:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    1dd8:	e1 14       	cp	r14, r1
    1dda:	f1 04       	cpc	r15, r1
    1ddc:	01 f1       	breq	.+64     	; 0x1e1e <xTaskNotifyWait+0xb4>
				{
					/* The task is going to block.  First it must be removed
					from the	ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1dde:	80 91 27 0f 	lds	r24, 0x0F27
    1de2:	90 91 28 0f 	lds	r25, 0x0F28
    1de6:	02 96       	adiw	r24, 0x02	; 2
    1de8:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					#if ( INCLUDE_vTaskSuspend == 1 )
					{
						if( xTicksToWait == portMAX_DELAY )
    1dec:	8f ef       	ldi	r24, 0xFF	; 255
    1dee:	e8 16       	cp	r14, r24
    1df0:	f8 06       	cpc	r15, r24
    1df2:	59 f4       	brne	.+22     	; 0x1e0a <xTaskNotifyWait+0xa0>
						{
							/* Add the task to the suspended task list instead
							of a delayed task list to ensure the task is not
							woken by a timing event.  It will block
							indefinitely. */
							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1df4:	60 91 27 0f 	lds	r22, 0x0F27
    1df8:	70 91 28 0f 	lds	r23, 0x0F28
    1dfc:	6e 5f       	subi	r22, 0xFE	; 254
    1dfe:	7f 4f       	sbci	r23, 0xFF	; 255
    1e00:	85 e3       	ldi	r24, 0x35	; 53
    1e02:	9f e0       	ldi	r25, 0x0F	; 15
    1e04:	0e 94 22 03 	call	0x644	; 0x644 <vListInsertEnd>
    1e08:	08 c0       	rjmp	.+16     	; 0x1e1a <xTaskNotifyWait+0xb0>
						{
							/* Calculate the time at which the task should be
							woken if no notification events occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    1e0a:	80 91 32 0f 	lds	r24, 0x0F32
    1e0e:	90 91 33 0f 	lds	r25, 0x0F33
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    1e12:	8e 0d       	add	r24, r14
    1e14:	9f 1d       	adc	r25, r15
    1e16:	0e 94 67 08 	call	0x10ce	; 0x10ce <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1e1a:	0e 94 49 04 	call	0x892	; 0x892 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1e1e:	0f 90       	pop	r0
    1e20:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    1e22:	0f b6       	in	r0, 0x3f	; 63
    1e24:	f8 94       	cli
    1e26:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    1e28:	01 15       	cp	r16, r1
    1e2a:	11 05       	cpc	r17, r1
    1e2c:	69 f0       	breq	.+26     	; 0x1e48 <xTaskNotifyWait+0xde>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    1e2e:	e0 91 27 0f 	lds	r30, 0x0F27
    1e32:	f0 91 28 0f 	lds	r31, 0x0F28
    1e36:	81 a1       	ldd	r24, Z+33	; 0x21
    1e38:	92 a1       	ldd	r25, Z+34	; 0x22
    1e3a:	a3 a1       	ldd	r26, Z+35	; 0x23
    1e3c:	b4 a1       	ldd	r27, Z+36	; 0x24
    1e3e:	f8 01       	movw	r30, r16
    1e40:	80 83       	st	Z, r24
    1e42:	91 83       	std	Z+1, r25	; 0x01
    1e44:	a2 83       	std	Z+2, r26	; 0x02
    1e46:	b3 83       	std	Z+3, r27	; 0x03

			/* If eNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
    1e48:	e0 91 27 0f 	lds	r30, 0x0F27
    1e4c:	f0 91 28 0f 	lds	r31, 0x0F28
    1e50:	85 a1       	ldd	r24, Z+37	; 0x25
    1e52:	81 30       	cpi	r24, 0x01	; 1
    1e54:	c1 f0       	breq	.+48     	; 0x1e86 <xTaskNotifyWait+0x11c>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    1e56:	e0 91 27 0f 	lds	r30, 0x0F27
    1e5a:	f0 91 28 0f 	lds	r31, 0x0F28
    1e5e:	81 a1       	ldd	r24, Z+33	; 0x21
    1e60:	92 a1       	ldd	r25, Z+34	; 0x22
    1e62:	a3 a1       	ldd	r26, Z+35	; 0x23
    1e64:	b4 a1       	ldd	r27, Z+36	; 0x24
    1e66:	b3 01       	movw	r22, r6
    1e68:	a2 01       	movw	r20, r4
    1e6a:	40 95       	com	r20
    1e6c:	50 95       	com	r21
    1e6e:	60 95       	com	r22
    1e70:	70 95       	com	r23
    1e72:	84 23       	and	r24, r20
    1e74:	95 23       	and	r25, r21
    1e76:	a6 23       	and	r26, r22
    1e78:	b7 23       	and	r27, r23
    1e7a:	81 a3       	std	Z+33, r24	; 0x21
    1e7c:	92 a3       	std	Z+34, r25	; 0x22
    1e7e:	a3 a3       	std	Z+35, r26	; 0x23
    1e80:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    1e82:	81 e0       	ldi	r24, 0x01	; 1
    1e84:	01 c0       	rjmp	.+2      	; 0x1e88 <xTaskNotifyWait+0x11e>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    1e86:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    1e88:	e0 91 27 0f 	lds	r30, 0x0F27
    1e8c:	f0 91 28 0f 	lds	r31, 0x0F28
    1e90:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    1e92:	0f 90       	pop	r0
    1e94:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1e96:	1f 91       	pop	r17
    1e98:	0f 91       	pop	r16
    1e9a:	ff 90       	pop	r15
    1e9c:	ef 90       	pop	r14
    1e9e:	bf 90       	pop	r11
    1ea0:	af 90       	pop	r10
    1ea2:	9f 90       	pop	r9
    1ea4:	8f 90       	pop	r8
    1ea6:	7f 90       	pop	r7
    1ea8:	6f 90       	pop	r6
    1eaa:	5f 90       	pop	r5
    1eac:	4f 90       	pop	r4
    1eae:	08 95       	ret

00001eb0 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    1eb0:	0f 93       	push	r16
    1eb2:	1f 93       	push	r17
    1eb4:	cf 93       	push	r28
    1eb6:	df 93       	push	r29
    1eb8:	fc 01       	movw	r30, r24
	BaseType_t xReturn = pdPASS;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    1eba:	0f b6       	in	r0, 0x3f	; 63
    1ebc:	f8 94       	cli
    1ebe:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    1ec0:	01 15       	cp	r16, r1
    1ec2:	11 05       	cpc	r17, r1
    1ec4:	49 f0       	breq	.+18     	; 0x1ed8 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1ec6:	81 a1       	ldd	r24, Z+33	; 0x21
    1ec8:	92 a1       	ldd	r25, Z+34	; 0x22
    1eca:	a3 a1       	ldd	r26, Z+35	; 0x23
    1ecc:	b4 a1       	ldd	r27, Z+36	; 0x24
    1ece:	e8 01       	movw	r28, r16
    1ed0:	88 83       	st	Y, r24
    1ed2:	99 83       	std	Y+1, r25	; 0x01
    1ed4:	aa 83       	std	Y+2, r26	; 0x02
    1ed6:	bb 83       	std	Y+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    1ed8:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->eNotifyState = eNotified;
    1eda:	82 e0       	ldi	r24, 0x02	; 2
    1edc:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    1ede:	22 30       	cpi	r18, 0x02	; 2
    1ee0:	89 f0       	breq	.+34     	; 0x1f04 <xTaskGenericNotify+0x54>
    1ee2:	58 f4       	brcc	.+22     	; 0x1efa <xTaskGenericNotify+0x4a>
    1ee4:	21 30       	cpi	r18, 0x01	; 1
    1ee6:	01 f5       	brne	.+64     	; 0x1f28 <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1ee8:	81 a1       	ldd	r24, Z+33	; 0x21
    1eea:	92 a1       	ldd	r25, Z+34	; 0x22
    1eec:	a3 a1       	ldd	r26, Z+35	; 0x23
    1eee:	b4 a1       	ldd	r27, Z+36	; 0x24
    1ef0:	48 2b       	or	r20, r24
    1ef2:	59 2b       	or	r21, r25
    1ef4:	6a 2b       	or	r22, r26
    1ef6:	7b 2b       	or	r23, r27
    1ef8:	13 c0       	rjmp	.+38     	; 0x1f20 <xTaskGenericNotify+0x70>

			eOriginalNotifyState = pxTCB->eNotifyState;

			pxTCB->eNotifyState = eNotified;

			switch( eAction )
    1efa:	23 30       	cpi	r18, 0x03	; 3
    1efc:	89 f0       	breq	.+34     	; 0x1f20 <xTaskGenericNotify+0x70>
    1efe:	24 30       	cpi	r18, 0x04	; 4
    1f00:	69 f0       	breq	.+26     	; 0x1f1c <xTaskGenericNotify+0x6c>
    1f02:	12 c0       	rjmp	.+36     	; 0x1f28 <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1f04:	81 a1       	ldd	r24, Z+33	; 0x21
    1f06:	92 a1       	ldd	r25, Z+34	; 0x22
    1f08:	a3 a1       	ldd	r26, Z+35	; 0x23
    1f0a:	b4 a1       	ldd	r27, Z+36	; 0x24
    1f0c:	01 96       	adiw	r24, 0x01	; 1
    1f0e:	a1 1d       	adc	r26, r1
    1f10:	b1 1d       	adc	r27, r1
    1f12:	81 a3       	std	Z+33, r24	; 0x21
    1f14:	92 a3       	std	Z+34, r25	; 0x22
    1f16:	a3 a3       	std	Z+35, r26	; 0x23
    1f18:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1f1a:	06 c0       	rjmp	.+12     	; 0x1f28 <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    1f1c:	32 30       	cpi	r19, 0x02	; 2
    1f1e:	49 f1       	breq	.+82     	; 0x1f72 <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1f20:	41 a3       	std	Z+33, r20	; 0x21
    1f22:	52 a3       	std	Z+34, r21	; 0x22
    1f24:	63 a3       	std	Z+35, r22	; 0x23
    1f26:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    1f28:	31 30       	cpi	r19, 0x01	; 1
    1f2a:	09 f5       	brne	.+66     	; 0x1f6e <xTaskGenericNotify+0xbe>
    1f2c:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1f2e:	8f 01       	movw	r16, r30
    1f30:	0e 5f       	subi	r16, 0xFE	; 254
    1f32:	1f 4f       	sbci	r17, 0xFF	; 255
    1f34:	c8 01       	movw	r24, r16
    1f36:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    1f3a:	9e 89       	ldd	r25, Y+22	; 0x16
    1f3c:	80 91 31 0f 	lds	r24, 0x0F31
    1f40:	89 17       	cp	r24, r25
    1f42:	10 f4       	brcc	.+4      	; 0x1f48 <xTaskGenericNotify+0x98>
    1f44:	90 93 31 0f 	sts	0x0F31, r25
    1f48:	29 e0       	ldi	r18, 0x09	; 9
    1f4a:	92 9f       	mul	r25, r18
    1f4c:	c0 01       	movw	r24, r0
    1f4e:	11 24       	eor	r1, r1
    1f50:	b8 01       	movw	r22, r16
    1f52:	89 59       	subi	r24, 0x99	; 153
    1f54:	90 4f       	sbci	r25, 0xF0	; 240
    1f56:	0e 94 22 03 	call	0x644	; 0x644 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1f5a:	e0 91 27 0f 	lds	r30, 0x0F27
    1f5e:	f0 91 28 0f 	lds	r31, 0x0F28
    1f62:	9e 89       	ldd	r25, Y+22	; 0x16
    1f64:	86 89       	ldd	r24, Z+22	; 0x16
    1f66:	89 17       	cp	r24, r25
    1f68:	10 f4       	brcc	.+4      	; 0x1f6e <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    1f6a:	0e 94 49 04 	call	0x892	; 0x892 <vPortYield>
    1f6e:	81 e0       	ldi	r24, 0x01	; 1
    1f70:	01 c0       	rjmp	.+2      	; 0x1f74 <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    1f72:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1f74:	0f 90       	pop	r0
    1f76:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1f78:	df 91       	pop	r29
    1f7a:	cf 91       	pop	r28
    1f7c:	1f 91       	pop	r17
    1f7e:	0f 91       	pop	r16
    1f80:	08 95       	ret

00001f82 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1f82:	ef 92       	push	r14
    1f84:	ff 92       	push	r15
    1f86:	0f 93       	push	r16
    1f88:	1f 93       	push	r17
    1f8a:	cf 93       	push	r28
    1f8c:	df 93       	push	r29
    1f8e:	fc 01       	movw	r30, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    1f90:	01 15       	cp	r16, r1
    1f92:	11 05       	cpc	r17, r1
    1f94:	49 f0       	breq	.+18     	; 0x1fa8 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1f96:	81 a1       	ldd	r24, Z+33	; 0x21
    1f98:	92 a1       	ldd	r25, Z+34	; 0x22
    1f9a:	a3 a1       	ldd	r26, Z+35	; 0x23
    1f9c:	b4 a1       	ldd	r27, Z+36	; 0x24
    1f9e:	e8 01       	movw	r28, r16
    1fa0:	88 83       	st	Y, r24
    1fa2:	99 83       	std	Y+1, r25	; 0x01
    1fa4:	aa 83       	std	Y+2, r26	; 0x02
    1fa6:	bb 83       	std	Y+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    1fa8:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->eNotifyState = eNotified;
    1faa:	82 e0       	ldi	r24, 0x02	; 2
    1fac:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    1fae:	22 30       	cpi	r18, 0x02	; 2
    1fb0:	89 f0       	breq	.+34     	; 0x1fd4 <xTaskGenericNotifyFromISR+0x52>
    1fb2:	58 f4       	brcc	.+22     	; 0x1fca <xTaskGenericNotifyFromISR+0x48>
    1fb4:	21 30       	cpi	r18, 0x01	; 1
    1fb6:	01 f5       	brne	.+64     	; 0x1ff8 <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1fb8:	81 a1       	ldd	r24, Z+33	; 0x21
    1fba:	92 a1       	ldd	r25, Z+34	; 0x22
    1fbc:	a3 a1       	ldd	r26, Z+35	; 0x23
    1fbe:	b4 a1       	ldd	r27, Z+36	; 0x24
    1fc0:	48 2b       	or	r20, r24
    1fc2:	59 2b       	or	r21, r25
    1fc4:	6a 2b       	or	r22, r26
    1fc6:	7b 2b       	or	r23, r27
    1fc8:	13 c0       	rjmp	.+38     	; 0x1ff0 <xTaskGenericNotifyFromISR+0x6e>
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
			pxTCB->eNotifyState = eNotified;

			switch( eAction )
    1fca:	23 30       	cpi	r18, 0x03	; 3
    1fcc:	89 f0       	breq	.+34     	; 0x1ff0 <xTaskGenericNotifyFromISR+0x6e>
    1fce:	24 30       	cpi	r18, 0x04	; 4
    1fd0:	69 f0       	breq	.+26     	; 0x1fec <xTaskGenericNotifyFromISR+0x6a>
    1fd2:	12 c0       	rjmp	.+36     	; 0x1ff8 <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1fd4:	81 a1       	ldd	r24, Z+33	; 0x21
    1fd6:	92 a1       	ldd	r25, Z+34	; 0x22
    1fd8:	a3 a1       	ldd	r26, Z+35	; 0x23
    1fda:	b4 a1       	ldd	r27, Z+36	; 0x24
    1fdc:	01 96       	adiw	r24, 0x01	; 1
    1fde:	a1 1d       	adc	r26, r1
    1fe0:	b1 1d       	adc	r27, r1
    1fe2:	81 a3       	std	Z+33, r24	; 0x21
    1fe4:	92 a3       	std	Z+34, r25	; 0x22
    1fe6:	a3 a3       	std	Z+35, r26	; 0x23
    1fe8:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1fea:	06 c0       	rjmp	.+12     	; 0x1ff8 <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    1fec:	32 30       	cpi	r19, 0x02	; 2
    1fee:	c1 f1       	breq	.+112    	; 0x2060 <xTaskGenericNotifyFromISR+0xde>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1ff0:	41 a3       	std	Z+33, r20	; 0x21
    1ff2:	52 a3       	std	Z+34, r21	; 0x22
    1ff4:	63 a3       	std	Z+35, r22	; 0x23
    1ff6:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    1ff8:	31 30       	cpi	r19, 0x01	; 1
    1ffa:	11 f0       	breq	.+4      	; 0x2000 <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1ffc:	81 e0       	ldi	r24, 0x01	; 1
    1ffe:	31 c0       	rjmp	.+98     	; 0x2062 <xTaskGenericNotifyFromISR+0xe0>
    2000:	ef 01       	movw	r28, r30
			if( eOriginalNotifyState == eWaitingNotification )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2002:	80 91 29 0f 	lds	r24, 0x0F29
    2006:	81 11       	cpse	r24, r1
    2008:	15 c0       	rjmp	.+42     	; 0x2034 <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    200a:	8f 01       	movw	r16, r30
    200c:	0e 5f       	subi	r16, 0xFE	; 254
    200e:	1f 4f       	sbci	r17, 0xFF	; 255
    2010:	c8 01       	movw	r24, r16
    2012:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2016:	2e 89       	ldd	r18, Y+22	; 0x16
    2018:	80 91 31 0f 	lds	r24, 0x0F31
    201c:	82 17       	cp	r24, r18
    201e:	10 f4       	brcc	.+4      	; 0x2024 <xTaskGenericNotifyFromISR+0xa2>
    2020:	20 93 31 0f 	sts	0x0F31, r18
    2024:	e9 e0       	ldi	r30, 0x09	; 9
    2026:	2e 9f       	mul	r18, r30
    2028:	c0 01       	movw	r24, r0
    202a:	11 24       	eor	r1, r1
    202c:	b8 01       	movw	r22, r16
    202e:	89 59       	subi	r24, 0x99	; 153
    2030:	90 4f       	sbci	r25, 0xF0	; 240
    2032:	05 c0       	rjmp	.+10     	; 0x203e <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2034:	bf 01       	movw	r22, r30
    2036:	64 5f       	subi	r22, 0xF4	; 244
    2038:	7f 4f       	sbci	r23, 0xFF	; 255
    203a:	88 e4       	ldi	r24, 0x48	; 72
    203c:	9f e0       	ldi	r25, 0x0F	; 15
    203e:	0e 94 22 03 	call	0x644	; 0x644 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2042:	e0 91 27 0f 	lds	r30, 0x0F27
    2046:	f0 91 28 0f 	lds	r31, 0x0F28
    204a:	9e 89       	ldd	r25, Y+22	; 0x16
    204c:	86 89       	ldd	r24, Z+22	; 0x16
    204e:	89 17       	cp	r24, r25
    2050:	a8 f6       	brcc	.-86     	; 0x1ffc <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    2052:	e1 14       	cp	r14, r1
    2054:	f1 04       	cpc	r15, r1
    2056:	91 f2       	breq	.-92     	; 0x1ffc <xTaskGenericNotifyFromISR+0x7a>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    2058:	81 e0       	ldi	r24, 0x01	; 1
    205a:	e7 01       	movw	r28, r14
    205c:	88 83       	st	Y, r24
    205e:	01 c0       	rjmp	.+2      	; 0x2062 <xTaskGenericNotifyFromISR+0xe0>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    2060:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    2062:	df 91       	pop	r29
    2064:	cf 91       	pop	r28
    2066:	1f 91       	pop	r17
    2068:	0f 91       	pop	r16
    206a:	ff 90       	pop	r15
    206c:	ef 90       	pop	r14
    206e:	08 95       	ret

00002070 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    2070:	ef 92       	push	r14
    2072:	ff 92       	push	r15
    2074:	0f 93       	push	r16
    2076:	1f 93       	push	r17
    2078:	cf 93       	push	r28
    207a:	df 93       	push	r29
    207c:	fc 01       	movw	r30, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			eOriginalNotifyState = pxTCB->eNotifyState;
    207e:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->eNotifyState = eNotified;
    2080:	82 e0       	ldi	r24, 0x02	; 2
    2082:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    2084:	81 a1       	ldd	r24, Z+33	; 0x21
    2086:	92 a1       	ldd	r25, Z+34	; 0x22
    2088:	a3 a1       	ldd	r26, Z+35	; 0x23
    208a:	b4 a1       	ldd	r27, Z+36	; 0x24
    208c:	01 96       	adiw	r24, 0x01	; 1
    208e:	a1 1d       	adc	r26, r1
    2090:	b1 1d       	adc	r27, r1
    2092:	81 a3       	std	Z+33, r24	; 0x21
    2094:	92 a3       	std	Z+34, r25	; 0x22
    2096:	a3 a3       	std	Z+35, r26	; 0x23
    2098:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    209a:	21 30       	cpi	r18, 0x01	; 1
    209c:	89 f5       	brne	.+98     	; 0x2100 <vTaskNotifyGiveFromISR+0x90>
    209e:	8b 01       	movw	r16, r22
    20a0:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    20a2:	80 91 29 0f 	lds	r24, 0x0F29
    20a6:	81 11       	cpse	r24, r1
    20a8:	16 c0       	rjmp	.+44     	; 0x20d6 <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    20aa:	7f 01       	movw	r14, r30
    20ac:	32 e0       	ldi	r19, 0x02	; 2
    20ae:	e3 0e       	add	r14, r19
    20b0:	f1 1c       	adc	r15, r1
    20b2:	c7 01       	movw	r24, r14
    20b4:	0e 94 7b 03 	call	0x6f6	; 0x6f6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    20b8:	2e 89       	ldd	r18, Y+22	; 0x16
    20ba:	80 91 31 0f 	lds	r24, 0x0F31
    20be:	82 17       	cp	r24, r18
    20c0:	10 f4       	brcc	.+4      	; 0x20c6 <vTaskNotifyGiveFromISR+0x56>
    20c2:	20 93 31 0f 	sts	0x0F31, r18
    20c6:	e9 e0       	ldi	r30, 0x09	; 9
    20c8:	2e 9f       	mul	r18, r30
    20ca:	c0 01       	movw	r24, r0
    20cc:	11 24       	eor	r1, r1
    20ce:	b7 01       	movw	r22, r14
    20d0:	89 59       	subi	r24, 0x99	; 153
    20d2:	90 4f       	sbci	r25, 0xF0	; 240
    20d4:	05 c0       	rjmp	.+10     	; 0x20e0 <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    20d6:	bf 01       	movw	r22, r30
    20d8:	64 5f       	subi	r22, 0xF4	; 244
    20da:	7f 4f       	sbci	r23, 0xFF	; 255
    20dc:	88 e4       	ldi	r24, 0x48	; 72
    20de:	9f e0       	ldi	r25, 0x0F	; 15
    20e0:	0e 94 22 03 	call	0x644	; 0x644 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    20e4:	e0 91 27 0f 	lds	r30, 0x0F27
    20e8:	f0 91 28 0f 	lds	r31, 0x0F28
    20ec:	9e 89       	ldd	r25, Y+22	; 0x16
    20ee:	86 89       	ldd	r24, Z+22	; 0x16
    20f0:	89 17       	cp	r24, r25
    20f2:	30 f4       	brcc	.+12     	; 0x2100 <vTaskNotifyGiveFromISR+0x90>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    20f4:	01 15       	cp	r16, r1
    20f6:	11 05       	cpc	r17, r1
    20f8:	19 f0       	breq	.+6      	; 0x2100 <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    20fa:	81 e0       	ldi	r24, 0x01	; 1
    20fc:	f8 01       	movw	r30, r16
    20fe:	80 83       	st	Z, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    2100:	df 91       	pop	r29
    2102:	cf 91       	pop	r28
    2104:	1f 91       	pop	r17
    2106:	0f 91       	pop	r16
    2108:	ff 90       	pop	r15
    210a:	ef 90       	pop	r14
    210c:	08 95       	ret

0000210e <xTaskNotifyStateClear>:

		pxTCB = ( TCB_t * ) xTask;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( pxTCB );
    210e:	00 97       	sbiw	r24, 0x00	; 0
    2110:	21 f4       	brne	.+8      	; 0x211a <xTaskNotifyStateClear+0xc>
    2112:	80 91 27 0f 	lds	r24, 0x0F27
    2116:	90 91 28 0f 	lds	r25, 0x0F28

		taskENTER_CRITICAL();
    211a:	0f b6       	in	r0, 0x3f	; 63
    211c:	f8 94       	cli
    211e:	0f 92       	push	r0
		{
			if( pxTCB->eNotifyState == eNotified )
    2120:	fc 01       	movw	r30, r24
    2122:	25 a1       	ldd	r18, Z+37	; 0x25
    2124:	22 30       	cpi	r18, 0x02	; 2
    2126:	19 f4       	brne	.+6      	; 0x212e <xTaskNotifyStateClear+0x20>
			{
				pxTCB->eNotifyState = eNotWaitingNotification;
    2128:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    212a:	81 e0       	ldi	r24, 0x01	; 1
    212c:	01 c0       	rjmp	.+2      	; 0x2130 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    212e:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    2130:	0f 90       	pop	r0
    2132:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2134:	08 95       	ret

00002136 <vMCUStatusTask>:
/* MCU Status task
 * Toggles the MCU status LED, to blink at 2Hz
 * Rate: 4Hz
 * Priority: 1 (lowest)
 */
void vMCUStatusTask(void *pvParameters) {
    2136:	cf 93       	push	r28
    2138:	df 93       	push	r29
    213a:	00 d0       	rcall	.+0      	; 0x213c <vMCUStatusTask+0x6>
    213c:	cd b7       	in	r28, 0x3d	; 61
    213e:	de b7       	in	r29, 0x3e	; 62
	// Make compiler happy
	(void) pvParameters;
	
	// Previous wake time pointer, initialized to current tick count.
	// This gets updated by vTaskDelayUntil every time it is called
	TickType_t xLastWakeTime = xTaskGetTickCount();
    2140:	0e 94 b8 0a 	call	0x1570	; 0x1570 <xTaskGetTickCount>
    2144:	9a 83       	std	Y+2, r25	; 0x02
    2146:	89 83       	std	Y+1, r24	; 0x01
	
	// Task variables
	bool currentValue = 0;	// false
	
	// Setup MCU status pin as output
	config_io_pin(MCU_STATUS_PORT, MCU_STATUS_CH, IO_DIR_OUTPUT);
    2148:	41 e0       	ldi	r20, 0x01	; 1
    214a:	60 e0       	ldi	r22, 0x00	; 0
    214c:	81 e0       	ldi	r24, 0x01	; 1
    214e:	0e 94 36 12 	call	0x246c	; 0x246c <config_io_pin>
	
	// Period
	const TickType_t xPeriod = 250;		// In ticks (ms)
	
	// Task variables
	bool currentValue = 0;	// false
    2152:	10 e0       	ldi	r17, 0x00	; 0
	config_io_pin(MCU_STATUS_PORT, MCU_STATUS_CH, IO_DIR_OUTPUT);
	
	// Executes infinitely with defined period using vTaskDelayUntil
	for(;;) {
		// Flip value
		currentValue = !currentValue;
    2154:	01 e0       	ldi	r16, 0x01	; 1
    2156:	10 27       	eor	r17, r16
		// Write out value
		set_io_pin(MCU_STATUS_PORT, MCU_STATUS_CH, currentValue);
    2158:	41 2f       	mov	r20, r17
    215a:	60 e0       	ldi	r22, 0x00	; 0
    215c:	81 e0       	ldi	r24, 0x01	; 1
    215e:	0e 94 75 12 	call	0x24ea	; 0x24ea <set_io_pin>
		// Delay until next period
		vTaskDelayUntil(&xLastWakeTime, xPeriod); 
    2162:	6a ef       	ldi	r22, 0xFA	; 250
    2164:	70 e0       	ldi	r23, 0x00	; 0
    2166:	ce 01       	movw	r24, r28
    2168:	01 96       	adiw	r24, 0x01	; 1
    216a:	0e 94 e9 0b 	call	0x17d2	; 0x17d2 <vTaskDelayUntil>
	}
    216e:	f3 cf       	rjmp	.-26     	; 0x2156 <vMCUStatusTask+0x20>

00002170 <vHeartbeatTask>:
/* Heartbeat task
 * Sends node heartbeat out on the CANBus
 * Rate: 10Hz
 * Priority: 3
 */
void vHeartbeatTask(void *pvParameters) {
    2170:	cf 93       	push	r28
    2172:	df 93       	push	r29
    2174:	cd b7       	in	r28, 0x3d	; 61
    2176:	de b7       	in	r29, 0x3e	; 62
    2178:	28 97       	sbiw	r28, 0x08	; 8
    217a:	0f b6       	in	r0, 0x3f	; 63
    217c:	f8 94       	cli
    217e:	de bf       	out	0x3e, r29	; 62
    2180:	0f be       	out	0x3f, r0	; 63
    2182:	cd bf       	out	0x3d, r28	; 61
    2184:	8c 01       	movw	r16, r24
	
	// Get status variables
	MOB_STATUS *statuses = (MOB_STATUS*)pvParameters;
	
	// Previous wake time pointer
	TickType_t xLastWakeTime = xTaskGetTickCount();
    2186:	0e 94 b8 0a 	call	0x1570	; 0x1570 <xTaskGetTickCount>
    218a:	98 87       	std	Y+8, r25	; 0x08
    218c:	8f 83       	std	Y+7, r24	; 0x07
    218e:	0d 5f       	subi	r16, 0xFD	; 253
    2190:	1f 4f       	sbci	r17, 0xFF	; 255
    2192:	7e 01       	movw	r14, r28
    2194:	87 e0       	ldi	r24, 0x07	; 7
    2196:	e8 0e       	add	r14, r24
    2198:	f1 1c       	adc	r15, r1
		for(i = 0; i < NO_MOBS; i++) {
			counts[i] = statuses[i].cnt;
		}
		
		// Copy counts to data array
		memcpy(packet.data, counts, NO_MOBS * sizeof(uint8_t));
    219a:	86 e0       	ldi	r24, 0x06	; 6
    219c:	d8 2e       	mov	r13, r24
    219e:	d8 01       	movw	r26, r16
    21a0:	fe 01       	movw	r30, r28
    21a2:	31 96       	adiw	r30, 0x01	; 1
	// data.someData = 10;
	
	for(;;) {
		// Update counts
		for(i = 0; i < NO_MOBS; i++) {
			counts[i] = statuses[i].cnt;
    21a4:	8c 91       	ld	r24, X
    21a6:	81 93       	st	Z+, r24
    21a8:	14 96       	adiw	r26, 0x04	; 4
	// data.currentState = RTD;
	// data.someData = 10;
	
	for(;;) {
		// Update counts
		for(i = 0; i < NO_MOBS; i++) {
    21aa:	ee 15       	cp	r30, r14
    21ac:	ff 05       	cpc	r31, r15
    21ae:	d1 f7       	brne	.-12     	; 0x21a4 <vHeartbeatTask+0x34>
			counts[i] = statuses[i].cnt;
		}
		
		// Copy counts to data array
		memcpy(packet.data, counts, NO_MOBS * sizeof(uint8_t));
    21b0:	fe 01       	movw	r30, r28
    21b2:	31 96       	adiw	r30, 0x01	; 1
    21b4:	a7 e2       	ldi	r26, 0x27	; 39
    21b6:	b1 e0       	ldi	r27, 0x01	; 1
    21b8:	8d 2d       	mov	r24, r13
    21ba:	01 90       	ld	r0, Z+
    21bc:	0d 92       	st	X+, r0
    21be:	8a 95       	dec	r24
    21c0:	e1 f7       	brne	.-8      	; 0x21ba <vHeartbeatTask+0x4a>
		
		// Transmit the data. 
		// Format: (Packet Pointer, Mailbox, Timeout (in ticks));
		can_send(&packet, get_free_mob(), 100);
    21c2:	0e 94 b3 02 	call	0x566	; 0x566 <get_free_mob>
    21c6:	44 e6       	ldi	r20, 0x64	; 100
    21c8:	50 e0       	ldi	r21, 0x00	; 0
    21ca:	bc 01       	movw	r22, r24
    21cc:	84 e2       	ldi	r24, 0x24	; 36
    21ce:	91 e0       	ldi	r25, 0x01	; 1
    21d0:	0e 94 c5 02 	call	0x58a	; 0x58a <can_send>
		
		// Delay 100ms
		vTaskDelayUntil(&xLastWakeTime, xPeriod);  
    21d4:	61 e0       	ldi	r22, 0x01	; 1
    21d6:	70 e0       	ldi	r23, 0x00	; 0
    21d8:	c7 01       	movw	r24, r14
    21da:	0e 94 e9 0b 	call	0x17d2	; 0x17d2 <vTaskDelayUntil>
	}
    21de:	df cf       	rjmp	.-66     	; 0x219e <vHeartbeatTask+0x2e>

000021e0 <vCANSendTask>:

/* Send over CAN
 * Uses send mailboxes to send enqueued messages over CAN
 * Currently unimplemented
 */
void vCANSendTask(void *pvParameters) {
    21e0:	08 95       	ret

000021e2 <vCANReceiveTask>:
/* Receive from CAN
 * 
 * 
 * 
 */
void vCANReceiveTask(void *pvParameters) {
    21e2:	ef 92       	push	r14
    21e4:	ff 92       	push	r15
    21e6:	0f 93       	push	r16
    21e8:	1f 93       	push	r17
    21ea:	cf 93       	push	r28
    21ec:	df 93       	push	r29
    21ee:	cd b7       	in	r28, 0x3d	; 61
    21f0:	de b7       	in	r29, 0x3e	; 62
    21f2:	2f 97       	sbiw	r28, 0x0f	; 15
    21f4:	0f b6       	in	r0, 0x3f	; 63
    21f6:	f8 94       	cli
    21f8:	de bf       	out	0x3e, r29	; 62
    21fa:	0f be       	out	0x3f, r0	; 63
    21fc:	cd bf       	out	0x3d, r28	; 61
	CAN_packet packet;
	uint8_t mob_num;
	volatile uint16_t param_val;
	
	// Get MOB number
	param_val = (uint16_t) pvParameters;
    21fe:	9d 87       	std	Y+13, r25	; 0x0d
    2200:	8c 87       	std	Y+12, r24	; 0x0c
	mob_num = statuses[param_val].mob_num;
    2202:	ec 85       	ldd	r30, Y+12	; 0x0c
    2204:	fd 85       	ldd	r31, Y+13	; 0x0d
    2206:	ee 0f       	add	r30, r30
    2208:	ff 1f       	adc	r31, r31
    220a:	ee 0f       	add	r30, r30
    220c:	ff 1f       	adc	r31, r31
    220e:	eb 55       	subi	r30, 0x5B	; 91
    2210:	f0 4f       	sbci	r31, 0xF0	; 240
    2212:	20 81       	ld	r18, Z
	
	// Make sure this is an RX mailbox
	// assert(MOB_DIRS[status.mob_num] == RX);
	
	// Critical section for queue creation
	taskENTER_CRITICAL();
    2214:	0f b6       	in	r0, 0x3f	; 63
    2216:	f8 94       	cli
    2218:	0f 92       	push	r0
	queue = xCANQueueCreate(MOB_IDS[mob_num], MOB_MASKS[mob_num], CAN_QUEUE_LEN, mob_num);
    221a:	82 2f       	mov	r24, r18
    221c:	90 e0       	ldi	r25, 0x00	; 0
    221e:	88 0f       	add	r24, r24
    2220:	99 1f       	adc	r25, r25
    2222:	fc 01       	movw	r30, r24
    2224:	eb 5c       	subi	r30, 0xCB	; 203
    2226:	fe 4f       	sbci	r31, 0xFE	; 254
    2228:	60 81       	ld	r22, Z
    222a:	71 81       	ldd	r23, Z+1	; 0x01
    222c:	fc 01       	movw	r30, r24
    222e:	ef 5b       	subi	r30, 0xBF	; 191
    2230:	fe 4f       	sbci	r31, 0xFE	; 254
    2232:	80 81       	ld	r24, Z
    2234:	91 81       	ldd	r25, Z+1	; 0x01
    2236:	45 e0       	ldi	r20, 0x05	; 5
    2238:	0e 94 82 02 	call	0x504	; 0x504 <xCANQueueCreate>
    223c:	9f 87       	std	Y+15, r25	; 0x0f
    223e:	8e 87       	std	Y+14, r24	; 0x0e
	taskEXIT_CRITICAL();
    2240:	0f 90       	pop	r0
    2242:	0f be       	out	0x3f, r0	; 63
	
	// Check for failure
	if(queue == 0) {
    2244:	8e 85       	ldd	r24, Y+14	; 0x0e
    2246:	9f 85       	ldd	r25, Y+15	; 0x0f
    2248:	89 2b       	or	r24, r25
    224a:	41 f5       	brne	.+80     	; 0x229c <vCANReceiveTask+0xba>
		// Exit task
		vTaskDelete(NULL);
    224c:	80 e0       	ldi	r24, 0x00	; 0
    224e:	90 e0       	ldi	r25, 0x00	; 0
    2250:	0e 94 9e 09 	call	0x133c	; 0x133c <vTaskDelete>
		if(statuses[param_val].cbk != NULL) {
			// Call function with packet as parameter
			(*(statuses[param_val].cbk))(packet);
		}
	}
    2254:	2f 96       	adiw	r28, 0x0f	; 15
    2256:	0f b6       	in	r0, 0x3f	; 63
    2258:	f8 94       	cli
    225a:	de bf       	out	0x3e, r29	; 62
    225c:	0f be       	out	0x3f, r0	; 63
    225e:	cd bf       	out	0x3d, r28	; 61
    2260:	df 91       	pop	r29
    2262:	cf 91       	pop	r28
    2264:	1f 91       	pop	r17
    2266:	0f 91       	pop	r16
    2268:	ff 90       	pop	r15
    226a:	ef 90       	pop	r14
    226c:	08 95       	ret
		statuses[param_val].cnt++;
		
		// See if a callback function is defined
		if(statuses[param_val].cbk != NULL) {
			// Call function with packet as parameter
			(*(statuses[param_val].cbk))(packet);
    226e:	ec 85       	ldd	r30, Y+12	; 0x0c
    2270:	fd 85       	ldd	r31, Y+13	; 0x0d
    2272:	ee 0f       	add	r30, r30
    2274:	ff 1f       	adc	r31, r31
    2276:	ee 0f       	add	r30, r30
    2278:	ff 1f       	adc	r31, r31
    227a:	eb 55       	subi	r30, 0x5B	; 91
    227c:	f0 4f       	sbci	r31, 0xF0	; 240
    227e:	01 80       	ldd	r0, Z+1	; 0x01
    2280:	f2 81       	ldd	r31, Z+2	; 0x02
    2282:	e0 2d       	mov	r30, r0
    2284:	e9 80       	ldd	r14, Y+1	; 0x01
    2286:	fa 80       	ldd	r15, Y+2	; 0x02
    2288:	0b 81       	ldd	r16, Y+3	; 0x03
    228a:	1c 81       	ldd	r17, Y+4	; 0x04
    228c:	2d 81       	ldd	r18, Y+5	; 0x05
    228e:	3e 81       	ldd	r19, Y+6	; 0x06
    2290:	4f 81       	ldd	r20, Y+7	; 0x07
    2292:	58 85       	ldd	r21, Y+8	; 0x08
    2294:	69 85       	ldd	r22, Y+9	; 0x09
    2296:	7a 85       	ldd	r23, Y+10	; 0x0a
    2298:	8b 85       	ldd	r24, Y+11	; 0x0b
    229a:	09 95       	icall
		return;
	}
	
	for(;;) {
		// Receive message
		xQueueReceive(queue, &packet, portMAX_DELAY);
    229c:	8e 85       	ldd	r24, Y+14	; 0x0e
    229e:	9f 85       	ldd	r25, Y+15	; 0x0f
    22a0:	20 e0       	ldi	r18, 0x00	; 0
    22a2:	4f ef       	ldi	r20, 0xFF	; 255
    22a4:	5f ef       	ldi	r21, 0xFF	; 255
    22a6:	be 01       	movw	r22, r28
    22a8:	6f 5f       	subi	r22, 0xFF	; 255
    22aa:	7f 4f       	sbci	r23, 0xFF	; 255
    22ac:	0e 94 40 07 	call	0xe80	; 0xe80 <xQueueGenericReceive>
		
		// Increment mailbox receive count
		statuses[param_val].cnt++;
    22b0:	ec 85       	ldd	r30, Y+12	; 0x0c
    22b2:	fd 85       	ldd	r31, Y+13	; 0x0d
    22b4:	ee 0f       	add	r30, r30
    22b6:	ff 1f       	adc	r31, r31
    22b8:	ee 0f       	add	r30, r30
    22ba:	ff 1f       	adc	r31, r31
    22bc:	eb 55       	subi	r30, 0x5B	; 91
    22be:	f0 4f       	sbci	r31, 0xF0	; 240
    22c0:	83 81       	ldd	r24, Z+3	; 0x03
    22c2:	8f 5f       	subi	r24, 0xFF	; 255
    22c4:	83 83       	std	Z+3, r24	; 0x03
		
		// See if a callback function is defined
		if(statuses[param_val].cbk != NULL) {
    22c6:	ec 85       	ldd	r30, Y+12	; 0x0c
    22c8:	fd 85       	ldd	r31, Y+13	; 0x0d
    22ca:	ee 0f       	add	r30, r30
    22cc:	ff 1f       	adc	r31, r31
    22ce:	ee 0f       	add	r30, r30
    22d0:	ff 1f       	adc	r31, r31
    22d2:	eb 55       	subi	r30, 0x5B	; 91
    22d4:	f0 4f       	sbci	r31, 0xF0	; 240
    22d6:	81 81       	ldd	r24, Z+1	; 0x01
    22d8:	92 81       	ldd	r25, Z+2	; 0x02
    22da:	89 2b       	or	r24, r25
    22dc:	f9 f2       	breq	.-66     	; 0x229c <vCANReceiveTask+0xba>
    22de:	c7 cf       	rjmp	.-114    	; 0x226e <vCANReceiveTask+0x8c>

000022e0 <main>:

//st_cmd_t can_receive_msg;
//uint64_t can_receive_buffer;

int main(void)
{	
    22e0:	2f 92       	push	r2
    22e2:	3f 92       	push	r3
    22e4:	4f 92       	push	r4
    22e6:	5f 92       	push	r5
    22e8:	6f 92       	push	r6
    22ea:	7f 92       	push	r7
    22ec:	8f 92       	push	r8
    22ee:	9f 92       	push	r9
    22f0:	af 92       	push	r10
    22f2:	bf 92       	push	r11
    22f4:	cf 92       	push	r12
    22f6:	df 92       	push	r13
    22f8:	ef 92       	push	r14
    22fa:	ff 92       	push	r15
    22fc:	0f 93       	push	r16
    22fe:	1f 93       	push	r17
    2300:	cf 93       	push	r28
    2302:	df 93       	push	r29
    2304:	00 d0       	rcall	.+0      	; 0x2306 <main+0x26>
    2306:	00 d0       	rcall	.+0      	; 0x2308 <main+0x28>
    2308:	cd b7       	in	r28, 0x3d	; 61
    230a:	de b7       	in	r29, 0x3e	; 62
	// Function variables
	uint16_t i;
	
	// Initialize CAN
	can_init();
    230c:	0e 94 21 02 	call	0x442	; 0x442 <can_init>
	
	// Create the MCU status task, to blink the LED
	// Rate: 4Hz
    xTaskCreate(vMCUStatusTask, "STATUS", configMINIMAL_STACK_SIZE, 
    2310:	a1 2c       	mov	r10, r1
    2312:	b1 2c       	mov	r11, r1
    2314:	c1 2c       	mov	r12, r1
    2316:	d1 2c       	mov	r13, r1
    2318:	e1 2c       	mov	r14, r1
    231a:	f1 2c       	mov	r15, r1
    231c:	01 e0       	ldi	r16, 0x01	; 1
    231e:	20 e0       	ldi	r18, 0x00	; 0
    2320:	30 e0       	ldi	r19, 0x00	; 0
    2322:	44 e6       	ldi	r20, 0x64	; 100
    2324:	50 e0       	ldi	r21, 0x00	; 0
    2326:	63 e5       	ldi	r22, 0x53	; 83
    2328:	71 e0       	ldi	r23, 0x01	; 1
    232a:	8b e9       	ldi	r24, 0x9B	; 155
    232c:	90 e1       	ldi	r25, 0x10	; 16
    232e:	0e 94 9f 08 	call	0x113e	; 0x113e <xTaskGenericCreate>
		NULL, mainMCU_STATUS_TASK_PRIORITY, NULL);
	
	// Assign mailbox callbacks
	statuses[0].cbk = mb1_callback;
    2332:	8d e5       	ldi	r24, 0x5D	; 93
    2334:	90 e0       	ldi	r25, 0x00	; 0
    2336:	90 93 a7 0f 	sts	0x0FA7, r25
    233a:	80 93 a6 0f 	sts	0x0FA6, r24
	statuses[1].cbk = mb2_callback;
    233e:	87 e8       	ldi	r24, 0x87	; 135
    2340:	90 e0       	ldi	r25, 0x00	; 0
    2342:	90 93 ab 0f 	sts	0x0FAB, r25
    2346:	80 93 aa 0f 	sts	0x0FAA, r24
	statuses[2].cbk = mb3_callback;
    234a:	81 eb       	ldi	r24, 0xB1	; 177
    234c:	90 e0       	ldi	r25, 0x00	; 0
    234e:	90 93 af 0f 	sts	0x0FAF, r25
    2352:	80 93 ae 0f 	sts	0x0FAE, r24
	statuses[3].cbk = mb4_callback;
    2356:	8b ed       	ldi	r24, 0xDB	; 219
    2358:	90 e0       	ldi	r25, 0x00	; 0
    235a:	90 93 b3 0f 	sts	0x0FB3, r25
    235e:	80 93 b2 0f 	sts	0x0FB2, r24
    2362:	85 ea       	ldi	r24, 0xA5	; 165
    2364:	68 2e       	mov	r6, r24
    2366:	8f e0       	ldi	r24, 0x0F	; 15
    2368:	78 2e       	mov	r7, r24
    236a:	10 e0       	ldi	r17, 0x00	; 0
	
	
	// Create tasks for receive mailboxes
	for(i = 0; i < NO_MOBS; i++) {
    236c:	81 2c       	mov	r8, r1
    236e:	91 2c       	mov	r9, r1
		statuses[i].cnt = 0;
		
		if(MOB_DIRS[i] == RX) {
			// Name of task
			char name[4];
			sprintf(name, "RCV%d", i);
    2370:	9a e5       	ldi	r25, 0x5A	; 90
    2372:	29 2e       	mov	r2, r25
    2374:	91 e0       	ldi	r25, 0x01	; 1
    2376:	39 2e       	mov	r3, r25
    2378:	ce 01       	movw	r24, r28
    237a:	01 96       	adiw	r24, 0x01	; 1
    237c:	2c 01       	movw	r4, r24
	
	// Create tasks for receive mailboxes
	for(i = 0; i < NO_MOBS; i++) {
		
		// Initialize mailbox status
		statuses[i].mob_num = i;
    237e:	f3 01       	movw	r30, r6
    2380:	10 83       	st	Z, r17
		statuses[i].cnt = 0;
    2382:	13 82       	std	Z+3, r1	; 0x03
		
		if(MOB_DIRS[i] == RX) {
    2384:	f4 01       	movw	r30, r8
    2386:	e2 5e       	subi	r30, 0xE2	; 226
    2388:	fe 4f       	sbci	r31, 0xFE	; 254
    238a:	80 81       	ld	r24, Z
    238c:	81 30       	cpi	r24, 0x01	; 1
    238e:	01 f5       	brne	.+64     	; 0x23d0 <main+0xf0>
			// Name of task
			char name[4];
			sprintf(name, "RCV%d", i);
    2390:	9f 92       	push	r9
    2392:	8f 92       	push	r8
    2394:	3f 92       	push	r3
    2396:	2f 92       	push	r2
    2398:	5f 92       	push	r5
    239a:	4f 92       	push	r4
    239c:	0e 94 bd 12 	call	0x257a	; 0x257a <sprintf>
			// Create task for this mailbox
			xTaskCreate(vCANReceiveTask, name, configMINIMAL_STACK_SIZE,
    23a0:	f4 01       	movw	r30, r8
    23a2:	e0 50       	subi	r30, 0x00	; 0
    23a4:	ff 4f       	sbci	r31, 0xFF	; 255
    23a6:	00 81       	ld	r16, Z
    23a8:	a1 2c       	mov	r10, r1
    23aa:	b1 2c       	mov	r11, r1
    23ac:	c1 2c       	mov	r12, r1
    23ae:	d1 2c       	mov	r13, r1
    23b0:	e1 2c       	mov	r14, r1
    23b2:	f1 2c       	mov	r15, r1
    23b4:	94 01       	movw	r18, r8
    23b6:	44 e6       	ldi	r20, 0x64	; 100
    23b8:	50 e0       	ldi	r21, 0x00	; 0
    23ba:	b2 01       	movw	r22, r4
    23bc:	81 ef       	ldi	r24, 0xF1	; 241
    23be:	90 e1       	ldi	r25, 0x10	; 16
    23c0:	0e 94 9f 08 	call	0x113e	; 0x113e <xTaskGenericCreate>
    23c4:	0f 90       	pop	r0
    23c6:	0f 90       	pop	r0
    23c8:	0f 90       	pop	r0
    23ca:	0f 90       	pop	r0
    23cc:	0f 90       	pop	r0
    23ce:	0f 90       	pop	r0
	statuses[2].cbk = mb3_callback;
	statuses[3].cbk = mb4_callback;
	
	
	// Create tasks for receive mailboxes
	for(i = 0; i < NO_MOBS; i++) {
    23d0:	ff ef       	ldi	r31, 0xFF	; 255
    23d2:	8f 1a       	sub	r8, r31
    23d4:	9f 0a       	sbc	r9, r31
    23d6:	1f 5f       	subi	r17, 0xFF	; 255
    23d8:	84 e0       	ldi	r24, 0x04	; 4
    23da:	68 0e       	add	r6, r24
    23dc:	71 1c       	adc	r7, r1
    23de:	16 30       	cpi	r17, 0x06	; 6
    23e0:	71 f6       	brne	.-100    	; 0x237e <main+0x9e>
		}
	}
	
	// Create the heartbeat task, to transmit over CAN
	// Rate: 10Hz
	xTaskCreate(vHeartbeatTask, "HEART", configMINIMAL_STACK_SIZE,
    23e2:	a1 2c       	mov	r10, r1
    23e4:	b1 2c       	mov	r11, r1
    23e6:	c1 2c       	mov	r12, r1
    23e8:	d1 2c       	mov	r13, r1
    23ea:	e1 2c       	mov	r14, r1
    23ec:	f1 2c       	mov	r15, r1
    23ee:	02 e0       	ldi	r16, 0x02	; 2
    23f0:	25 ea       	ldi	r18, 0xA5	; 165
    23f2:	3f e0       	ldi	r19, 0x0F	; 15
    23f4:	44 e6       	ldi	r20, 0x64	; 100
    23f6:	50 e0       	ldi	r21, 0x00	; 0
    23f8:	60 e6       	ldi	r22, 0x60	; 96
    23fa:	71 e0       	ldi	r23, 0x01	; 1
    23fc:	88 eb       	ldi	r24, 0xB8	; 184
    23fe:	90 e1       	ldi	r25, 0x10	; 16
    2400:	0e 94 9f 08 	call	0x113e	; 0x113e <xTaskGenericCreate>
		statuses, mainHEARTBEAT_TASK_PRIORITY, NULL);
	
	// Start the scheduler
	vTaskStartScheduler();
    2404:	0e 94 75 0a 	call	0x14ea	; 0x14ea <vTaskStartScheduler>
	
	// Return, the scheduler handles the rest
	return 0;
}
    2408:	80 e0       	ldi	r24, 0x00	; 0
    240a:	90 e0       	ldi	r25, 0x00	; 0
    240c:	0f 90       	pop	r0
    240e:	0f 90       	pop	r0
    2410:	0f 90       	pop	r0
    2412:	0f 90       	pop	r0
    2414:	df 91       	pop	r29
    2416:	cf 91       	pop	r28
    2418:	1f 91       	pop	r17
    241a:	0f 91       	pop	r16
    241c:	ff 90       	pop	r15
    241e:	ef 90       	pop	r14
    2420:	df 90       	pop	r13
    2422:	cf 90       	pop	r12
    2424:	bf 90       	pop	r11
    2426:	af 90       	pop	r10
    2428:	9f 90       	pop	r9
    242a:	8f 90       	pop	r8
    242c:	7f 90       	pop	r7
    242e:	6f 90       	pop	r6
    2430:	5f 90       	pop	r5
    2432:	4f 90       	pop	r4
    2434:	3f 90       	pop	r3
    2436:	2f 90       	pop	r2
    2438:	08 95       	ret

0000243a <adc_read>:
    243a:	90 91 7c 00 	lds	r25, 0x007C
    243e:	90 7e       	andi	r25, 0xE0	; 224
    2440:	90 93 7c 00 	sts	0x007C, r25
    2444:	8d 30       	cpi	r24, 0x0D	; 13
    2446:	08 f0       	brcs	.+2      	; 0x244a <adc_read+0x10>
    2448:	82 e1       	ldi	r24, 0x12	; 18
    244a:	90 91 7c 00 	lds	r25, 0x007C
    244e:	89 2b       	or	r24, r25
    2450:	80 93 7c 00 	sts	0x007C, r24
    2454:	80 91 7a 00 	lds	r24, 0x007A
    2458:	80 64       	ori	r24, 0x40	; 64
    245a:	80 93 7a 00 	sts	0x007A, r24
    245e:	80 91 7a 00 	lds	r24, 0x007A
    2462:	86 fd       	sbrc	r24, 6
    2464:	fc cf       	rjmp	.-8      	; 0x245e <adc_read+0x24>
    2466:	80 91 79 00 	lds	r24, 0x0079
    246a:	08 95       	ret

0000246c <config_io_pin>:
    246c:	81 30       	cpi	r24, 0x01	; 1
    246e:	b9 f0       	breq	.+46     	; 0x249e <config_io_pin+0x32>
    2470:	18 f0       	brcs	.+6      	; 0x2478 <config_io_pin+0xc>
    2472:	82 30       	cpi	r24, 0x02	; 2
    2474:	39 f1       	breq	.+78     	; 0x24c4 <config_io_pin+0x58>
    2476:	08 95       	ret
    2478:	84 b1       	in	r24, 0x04	; 4
    247a:	24 b1       	in	r18, 0x04	; 4
    247c:	50 e0       	ldi	r21, 0x00	; 0
    247e:	51 95       	neg	r21
    2480:	41 95       	neg	r20
    2482:	51 09       	sbc	r21, r1
    2484:	48 27       	eor	r20, r24
    2486:	81 e0       	ldi	r24, 0x01	; 1
    2488:	90 e0       	ldi	r25, 0x00	; 0
    248a:	02 c0       	rjmp	.+4      	; 0x2490 <config_io_pin+0x24>
    248c:	88 0f       	add	r24, r24
    248e:	99 1f       	adc	r25, r25
    2490:	6a 95       	dec	r22
    2492:	e2 f7       	brpl	.-8      	; 0x248c <config_io_pin+0x20>
    2494:	48 23       	and	r20, r24
    2496:	59 23       	and	r21, r25
    2498:	42 27       	eor	r20, r18
    249a:	44 b9       	out	0x04, r20	; 4
    249c:	08 95       	ret
    249e:	87 b1       	in	r24, 0x07	; 7
    24a0:	27 b1       	in	r18, 0x07	; 7
    24a2:	50 e0       	ldi	r21, 0x00	; 0
    24a4:	51 95       	neg	r21
    24a6:	41 95       	neg	r20
    24a8:	51 09       	sbc	r21, r1
    24aa:	48 27       	eor	r20, r24
    24ac:	81 e0       	ldi	r24, 0x01	; 1
    24ae:	90 e0       	ldi	r25, 0x00	; 0
    24b0:	02 c0       	rjmp	.+4      	; 0x24b6 <config_io_pin+0x4a>
    24b2:	88 0f       	add	r24, r24
    24b4:	99 1f       	adc	r25, r25
    24b6:	6a 95       	dec	r22
    24b8:	e2 f7       	brpl	.-8      	; 0x24b2 <config_io_pin+0x46>
    24ba:	48 23       	and	r20, r24
    24bc:	59 23       	and	r21, r25
    24be:	42 27       	eor	r20, r18
    24c0:	47 b9       	out	0x07, r20	; 7
    24c2:	08 95       	ret
    24c4:	8a b1       	in	r24, 0x0a	; 10
    24c6:	2a b1       	in	r18, 0x0a	; 10
    24c8:	50 e0       	ldi	r21, 0x00	; 0
    24ca:	51 95       	neg	r21
    24cc:	41 95       	neg	r20
    24ce:	51 09       	sbc	r21, r1
    24d0:	48 27       	eor	r20, r24
    24d2:	81 e0       	ldi	r24, 0x01	; 1
    24d4:	90 e0       	ldi	r25, 0x00	; 0
    24d6:	02 c0       	rjmp	.+4      	; 0x24dc <config_io_pin+0x70>
    24d8:	88 0f       	add	r24, r24
    24da:	99 1f       	adc	r25, r25
    24dc:	6a 95       	dec	r22
    24de:	e2 f7       	brpl	.-8      	; 0x24d8 <config_io_pin+0x6c>
    24e0:	48 23       	and	r20, r24
    24e2:	59 23       	and	r21, r25
    24e4:	42 27       	eor	r20, r18
    24e6:	4a b9       	out	0x0a, r20	; 10
    24e8:	08 95       	ret

000024ea <set_io_pin>:
    24ea:	81 30       	cpi	r24, 0x01	; 1
    24ec:	b9 f0       	breq	.+46     	; 0x251c <set_io_pin+0x32>
    24ee:	18 f0       	brcs	.+6      	; 0x24f6 <set_io_pin+0xc>
    24f0:	82 30       	cpi	r24, 0x02	; 2
    24f2:	39 f1       	breq	.+78     	; 0x2542 <set_io_pin+0x58>
    24f4:	08 95       	ret
    24f6:	85 b1       	in	r24, 0x05	; 5
    24f8:	25 b1       	in	r18, 0x05	; 5
    24fa:	50 e0       	ldi	r21, 0x00	; 0
    24fc:	51 95       	neg	r21
    24fe:	41 95       	neg	r20
    2500:	51 09       	sbc	r21, r1
    2502:	48 27       	eor	r20, r24
    2504:	81 e0       	ldi	r24, 0x01	; 1
    2506:	90 e0       	ldi	r25, 0x00	; 0
    2508:	02 c0       	rjmp	.+4      	; 0x250e <set_io_pin+0x24>
    250a:	88 0f       	add	r24, r24
    250c:	99 1f       	adc	r25, r25
    250e:	6a 95       	dec	r22
    2510:	e2 f7       	brpl	.-8      	; 0x250a <set_io_pin+0x20>
    2512:	48 23       	and	r20, r24
    2514:	59 23       	and	r21, r25
    2516:	42 27       	eor	r20, r18
    2518:	45 b9       	out	0x05, r20	; 5
    251a:	08 95       	ret
    251c:	88 b1       	in	r24, 0x08	; 8
    251e:	28 b1       	in	r18, 0x08	; 8
    2520:	50 e0       	ldi	r21, 0x00	; 0
    2522:	51 95       	neg	r21
    2524:	41 95       	neg	r20
    2526:	51 09       	sbc	r21, r1
    2528:	48 27       	eor	r20, r24
    252a:	81 e0       	ldi	r24, 0x01	; 1
    252c:	90 e0       	ldi	r25, 0x00	; 0
    252e:	02 c0       	rjmp	.+4      	; 0x2534 <set_io_pin+0x4a>
    2530:	88 0f       	add	r24, r24
    2532:	99 1f       	adc	r25, r25
    2534:	6a 95       	dec	r22
    2536:	e2 f7       	brpl	.-8      	; 0x2530 <set_io_pin+0x46>
    2538:	48 23       	and	r20, r24
    253a:	59 23       	and	r21, r25
    253c:	42 27       	eor	r20, r18
    253e:	48 b9       	out	0x08, r20	; 8
    2540:	08 95       	ret
    2542:	8b b1       	in	r24, 0x0b	; 11
    2544:	2b b1       	in	r18, 0x0b	; 11
    2546:	50 e0       	ldi	r21, 0x00	; 0
    2548:	51 95       	neg	r21
    254a:	41 95       	neg	r20
    254c:	51 09       	sbc	r21, r1
    254e:	48 27       	eor	r20, r24
    2550:	81 e0       	ldi	r24, 0x01	; 1
    2552:	90 e0       	ldi	r25, 0x00	; 0
    2554:	02 c0       	rjmp	.+4      	; 0x255a <set_io_pin+0x70>
    2556:	88 0f       	add	r24, r24
    2558:	99 1f       	adc	r25, r25
    255a:	6a 95       	dec	r22
    255c:	e2 f7       	brpl	.-8      	; 0x2556 <set_io_pin+0x6c>
    255e:	48 23       	and	r20, r24
    2560:	59 23       	and	r21, r25
    2562:	42 27       	eor	r20, r18
    2564:	4b b9       	out	0x0b, r20	; 11
    2566:	08 95       	ret

00002568 <memcpy>:
    2568:	fb 01       	movw	r30, r22
    256a:	dc 01       	movw	r26, r24
    256c:	02 c0       	rjmp	.+4      	; 0x2572 <memcpy+0xa>
    256e:	01 90       	ld	r0, Z+
    2570:	0d 92       	st	X+, r0
    2572:	41 50       	subi	r20, 0x01	; 1
    2574:	50 40       	sbci	r21, 0x00	; 0
    2576:	d8 f7       	brcc	.-10     	; 0x256e <memcpy+0x6>
    2578:	08 95       	ret

0000257a <sprintf>:
    257a:	ae e0       	ldi	r26, 0x0E	; 14
    257c:	b0 e0       	ldi	r27, 0x00	; 0
    257e:	e3 ec       	ldi	r30, 0xC3	; 195
    2580:	f2 e1       	ldi	r31, 0x12	; 18
    2582:	0c 94 6c 15 	jmp	0x2ad8	; 0x2ad8 <__prologue_saves__+0x1c>
    2586:	0d 89       	ldd	r16, Y+21	; 0x15
    2588:	1e 89       	ldd	r17, Y+22	; 0x16
    258a:	86 e0       	ldi	r24, 0x06	; 6
    258c:	8c 83       	std	Y+4, r24	; 0x04
    258e:	1a 83       	std	Y+2, r17	; 0x02
    2590:	09 83       	std	Y+1, r16	; 0x01
    2592:	8f ef       	ldi	r24, 0xFF	; 255
    2594:	9f e7       	ldi	r25, 0x7F	; 127
    2596:	9e 83       	std	Y+6, r25	; 0x06
    2598:	8d 83       	std	Y+5, r24	; 0x05
    259a:	ae 01       	movw	r20, r28
    259c:	47 5e       	subi	r20, 0xE7	; 231
    259e:	5f 4f       	sbci	r21, 0xFF	; 255
    25a0:	6f 89       	ldd	r22, Y+23	; 0x17
    25a2:	78 8d       	ldd	r23, Y+24	; 0x18
    25a4:	ce 01       	movw	r24, r28
    25a6:	01 96       	adiw	r24, 0x01	; 1
    25a8:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <vfprintf>
    25ac:	2f 81       	ldd	r18, Y+7	; 0x07
    25ae:	38 85       	ldd	r19, Y+8	; 0x08
    25b0:	f8 01       	movw	r30, r16
    25b2:	e2 0f       	add	r30, r18
    25b4:	f3 1f       	adc	r31, r19
    25b6:	10 82       	st	Z, r1
    25b8:	2e 96       	adiw	r28, 0x0e	; 14
    25ba:	e4 e0       	ldi	r30, 0x04	; 4
    25bc:	0c 94 88 15 	jmp	0x2b10	; 0x2b10 <__epilogue_restores__+0x1c>

000025c0 <vfprintf>:
    25c0:	ac e0       	ldi	r26, 0x0C	; 12
    25c2:	b0 e0       	ldi	r27, 0x00	; 0
    25c4:	e6 ee       	ldi	r30, 0xE6	; 230
    25c6:	f2 e1       	ldi	r31, 0x12	; 18
    25c8:	0c 94 5e 15 	jmp	0x2abc	; 0x2abc <__prologue_saves__>
    25cc:	7c 01       	movw	r14, r24
    25ce:	6b 01       	movw	r12, r22
    25d0:	8a 01       	movw	r16, r20
    25d2:	fc 01       	movw	r30, r24
    25d4:	17 82       	std	Z+7, r1	; 0x07
    25d6:	16 82       	std	Z+6, r1	; 0x06
    25d8:	83 81       	ldd	r24, Z+3	; 0x03
    25da:	81 ff       	sbrs	r24, 1
    25dc:	bd c1       	rjmp	.+890    	; 0x2958 <vfprintf+0x398>
    25de:	ce 01       	movw	r24, r28
    25e0:	01 96       	adiw	r24, 0x01	; 1
    25e2:	4c 01       	movw	r8, r24
    25e4:	f7 01       	movw	r30, r14
    25e6:	93 81       	ldd	r25, Z+3	; 0x03
    25e8:	f6 01       	movw	r30, r12
    25ea:	93 fd       	sbrc	r25, 3
    25ec:	85 91       	lpm	r24, Z+
    25ee:	93 ff       	sbrs	r25, 3
    25f0:	81 91       	ld	r24, Z+
    25f2:	6f 01       	movw	r12, r30
    25f4:	88 23       	and	r24, r24
    25f6:	09 f4       	brne	.+2      	; 0x25fa <vfprintf+0x3a>
    25f8:	ab c1       	rjmp	.+854    	; 0x2950 <vfprintf+0x390>
    25fa:	85 32       	cpi	r24, 0x25	; 37
    25fc:	39 f4       	brne	.+14     	; 0x260c <vfprintf+0x4c>
    25fe:	93 fd       	sbrc	r25, 3
    2600:	85 91       	lpm	r24, Z+
    2602:	93 ff       	sbrs	r25, 3
    2604:	81 91       	ld	r24, Z+
    2606:	6f 01       	movw	r12, r30
    2608:	85 32       	cpi	r24, 0x25	; 37
    260a:	29 f4       	brne	.+10     	; 0x2616 <vfprintf+0x56>
    260c:	b7 01       	movw	r22, r14
    260e:	90 e0       	ldi	r25, 0x00	; 0
    2610:	0e 94 c8 14 	call	0x2990	; 0x2990 <fputc>
    2614:	e7 cf       	rjmp	.-50     	; 0x25e4 <vfprintf+0x24>
    2616:	51 2c       	mov	r5, r1
    2618:	31 2c       	mov	r3, r1
    261a:	20 e0       	ldi	r18, 0x00	; 0
    261c:	20 32       	cpi	r18, 0x20	; 32
    261e:	a0 f4       	brcc	.+40     	; 0x2648 <vfprintf+0x88>
    2620:	8b 32       	cpi	r24, 0x2B	; 43
    2622:	69 f0       	breq	.+26     	; 0x263e <vfprintf+0x7e>
    2624:	30 f4       	brcc	.+12     	; 0x2632 <vfprintf+0x72>
    2626:	80 32       	cpi	r24, 0x20	; 32
    2628:	59 f0       	breq	.+22     	; 0x2640 <vfprintf+0x80>
    262a:	83 32       	cpi	r24, 0x23	; 35
    262c:	69 f4       	brne	.+26     	; 0x2648 <vfprintf+0x88>
    262e:	20 61       	ori	r18, 0x10	; 16
    2630:	2c c0       	rjmp	.+88     	; 0x268a <vfprintf+0xca>
    2632:	8d 32       	cpi	r24, 0x2D	; 45
    2634:	39 f0       	breq	.+14     	; 0x2644 <vfprintf+0x84>
    2636:	80 33       	cpi	r24, 0x30	; 48
    2638:	39 f4       	brne	.+14     	; 0x2648 <vfprintf+0x88>
    263a:	21 60       	ori	r18, 0x01	; 1
    263c:	26 c0       	rjmp	.+76     	; 0x268a <vfprintf+0xca>
    263e:	22 60       	ori	r18, 0x02	; 2
    2640:	24 60       	ori	r18, 0x04	; 4
    2642:	23 c0       	rjmp	.+70     	; 0x268a <vfprintf+0xca>
    2644:	28 60       	ori	r18, 0x08	; 8
    2646:	21 c0       	rjmp	.+66     	; 0x268a <vfprintf+0xca>
    2648:	27 fd       	sbrc	r18, 7
    264a:	27 c0       	rjmp	.+78     	; 0x269a <vfprintf+0xda>
    264c:	30 ed       	ldi	r19, 0xD0	; 208
    264e:	38 0f       	add	r19, r24
    2650:	3a 30       	cpi	r19, 0x0A	; 10
    2652:	78 f4       	brcc	.+30     	; 0x2672 <vfprintf+0xb2>
    2654:	26 ff       	sbrs	r18, 6
    2656:	06 c0       	rjmp	.+12     	; 0x2664 <vfprintf+0xa4>
    2658:	fa e0       	ldi	r31, 0x0A	; 10
    265a:	5f 9e       	mul	r5, r31
    265c:	30 0d       	add	r19, r0
    265e:	11 24       	eor	r1, r1
    2660:	53 2e       	mov	r5, r19
    2662:	13 c0       	rjmp	.+38     	; 0x268a <vfprintf+0xca>
    2664:	8a e0       	ldi	r24, 0x0A	; 10
    2666:	38 9e       	mul	r3, r24
    2668:	30 0d       	add	r19, r0
    266a:	11 24       	eor	r1, r1
    266c:	33 2e       	mov	r3, r19
    266e:	20 62       	ori	r18, 0x20	; 32
    2670:	0c c0       	rjmp	.+24     	; 0x268a <vfprintf+0xca>
    2672:	8e 32       	cpi	r24, 0x2E	; 46
    2674:	21 f4       	brne	.+8      	; 0x267e <vfprintf+0xbe>
    2676:	26 fd       	sbrc	r18, 6
    2678:	6b c1       	rjmp	.+726    	; 0x2950 <vfprintf+0x390>
    267a:	20 64       	ori	r18, 0x40	; 64
    267c:	06 c0       	rjmp	.+12     	; 0x268a <vfprintf+0xca>
    267e:	8c 36       	cpi	r24, 0x6C	; 108
    2680:	11 f4       	brne	.+4      	; 0x2686 <vfprintf+0xc6>
    2682:	20 68       	ori	r18, 0x80	; 128
    2684:	02 c0       	rjmp	.+4      	; 0x268a <vfprintf+0xca>
    2686:	88 36       	cpi	r24, 0x68	; 104
    2688:	41 f4       	brne	.+16     	; 0x269a <vfprintf+0xda>
    268a:	f6 01       	movw	r30, r12
    268c:	93 fd       	sbrc	r25, 3
    268e:	85 91       	lpm	r24, Z+
    2690:	93 ff       	sbrs	r25, 3
    2692:	81 91       	ld	r24, Z+
    2694:	6f 01       	movw	r12, r30
    2696:	81 11       	cpse	r24, r1
    2698:	c1 cf       	rjmp	.-126    	; 0x261c <vfprintf+0x5c>
    269a:	98 2f       	mov	r25, r24
    269c:	9f 7d       	andi	r25, 0xDF	; 223
    269e:	95 54       	subi	r25, 0x45	; 69
    26a0:	93 30       	cpi	r25, 0x03	; 3
    26a2:	28 f4       	brcc	.+10     	; 0x26ae <vfprintf+0xee>
    26a4:	0c 5f       	subi	r16, 0xFC	; 252
    26a6:	1f 4f       	sbci	r17, 0xFF	; 255
    26a8:	ff e3       	ldi	r31, 0x3F	; 63
    26aa:	f9 83       	std	Y+1, r31	; 0x01
    26ac:	0d c0       	rjmp	.+26     	; 0x26c8 <vfprintf+0x108>
    26ae:	83 36       	cpi	r24, 0x63	; 99
    26b0:	31 f0       	breq	.+12     	; 0x26be <vfprintf+0xfe>
    26b2:	83 37       	cpi	r24, 0x73	; 115
    26b4:	71 f0       	breq	.+28     	; 0x26d2 <vfprintf+0x112>
    26b6:	83 35       	cpi	r24, 0x53	; 83
    26b8:	09 f0       	breq	.+2      	; 0x26bc <vfprintf+0xfc>
    26ba:	5b c0       	rjmp	.+182    	; 0x2772 <vfprintf+0x1b2>
    26bc:	22 c0       	rjmp	.+68     	; 0x2702 <vfprintf+0x142>
    26be:	f8 01       	movw	r30, r16
    26c0:	80 81       	ld	r24, Z
    26c2:	89 83       	std	Y+1, r24	; 0x01
    26c4:	0e 5f       	subi	r16, 0xFE	; 254
    26c6:	1f 4f       	sbci	r17, 0xFF	; 255
    26c8:	44 24       	eor	r4, r4
    26ca:	43 94       	inc	r4
    26cc:	51 2c       	mov	r5, r1
    26ce:	54 01       	movw	r10, r8
    26d0:	15 c0       	rjmp	.+42     	; 0x26fc <vfprintf+0x13c>
    26d2:	38 01       	movw	r6, r16
    26d4:	f2 e0       	ldi	r31, 0x02	; 2
    26d6:	6f 0e       	add	r6, r31
    26d8:	71 1c       	adc	r7, r1
    26da:	f8 01       	movw	r30, r16
    26dc:	a0 80       	ld	r10, Z
    26de:	b1 80       	ldd	r11, Z+1	; 0x01
    26e0:	26 ff       	sbrs	r18, 6
    26e2:	03 c0       	rjmp	.+6      	; 0x26ea <vfprintf+0x12a>
    26e4:	65 2d       	mov	r22, r5
    26e6:	70 e0       	ldi	r23, 0x00	; 0
    26e8:	02 c0       	rjmp	.+4      	; 0x26ee <vfprintf+0x12e>
    26ea:	6f ef       	ldi	r22, 0xFF	; 255
    26ec:	7f ef       	ldi	r23, 0xFF	; 255
    26ee:	c5 01       	movw	r24, r10
    26f0:	2c 87       	std	Y+12, r18	; 0x0c
    26f2:	0e 94 bd 14 	call	0x297a	; 0x297a <strnlen>
    26f6:	2c 01       	movw	r4, r24
    26f8:	83 01       	movw	r16, r6
    26fa:	2c 85       	ldd	r18, Y+12	; 0x0c
    26fc:	2f 77       	andi	r18, 0x7F	; 127
    26fe:	22 2e       	mov	r2, r18
    2700:	17 c0       	rjmp	.+46     	; 0x2730 <vfprintf+0x170>
    2702:	38 01       	movw	r6, r16
    2704:	f2 e0       	ldi	r31, 0x02	; 2
    2706:	6f 0e       	add	r6, r31
    2708:	71 1c       	adc	r7, r1
    270a:	f8 01       	movw	r30, r16
    270c:	a0 80       	ld	r10, Z
    270e:	b1 80       	ldd	r11, Z+1	; 0x01
    2710:	26 ff       	sbrs	r18, 6
    2712:	03 c0       	rjmp	.+6      	; 0x271a <vfprintf+0x15a>
    2714:	65 2d       	mov	r22, r5
    2716:	70 e0       	ldi	r23, 0x00	; 0
    2718:	02 c0       	rjmp	.+4      	; 0x271e <vfprintf+0x15e>
    271a:	6f ef       	ldi	r22, 0xFF	; 255
    271c:	7f ef       	ldi	r23, 0xFF	; 255
    271e:	c5 01       	movw	r24, r10
    2720:	2c 87       	std	Y+12, r18	; 0x0c
    2722:	0e 94 b2 14 	call	0x2964	; 0x2964 <strnlen_P>
    2726:	2c 01       	movw	r4, r24
    2728:	2c 85       	ldd	r18, Y+12	; 0x0c
    272a:	20 68       	ori	r18, 0x80	; 128
    272c:	22 2e       	mov	r2, r18
    272e:	83 01       	movw	r16, r6
    2730:	23 fc       	sbrc	r2, 3
    2732:	1b c0       	rjmp	.+54     	; 0x276a <vfprintf+0x1aa>
    2734:	83 2d       	mov	r24, r3
    2736:	90 e0       	ldi	r25, 0x00	; 0
    2738:	48 16       	cp	r4, r24
    273a:	59 06       	cpc	r5, r25
    273c:	b0 f4       	brcc	.+44     	; 0x276a <vfprintf+0x1aa>
    273e:	b7 01       	movw	r22, r14
    2740:	80 e2       	ldi	r24, 0x20	; 32
    2742:	90 e0       	ldi	r25, 0x00	; 0
    2744:	0e 94 c8 14 	call	0x2990	; 0x2990 <fputc>
    2748:	3a 94       	dec	r3
    274a:	f4 cf       	rjmp	.-24     	; 0x2734 <vfprintf+0x174>
    274c:	f5 01       	movw	r30, r10
    274e:	27 fc       	sbrc	r2, 7
    2750:	85 91       	lpm	r24, Z+
    2752:	27 fe       	sbrs	r2, 7
    2754:	81 91       	ld	r24, Z+
    2756:	5f 01       	movw	r10, r30
    2758:	b7 01       	movw	r22, r14
    275a:	90 e0       	ldi	r25, 0x00	; 0
    275c:	0e 94 c8 14 	call	0x2990	; 0x2990 <fputc>
    2760:	31 10       	cpse	r3, r1
    2762:	3a 94       	dec	r3
    2764:	f1 e0       	ldi	r31, 0x01	; 1
    2766:	4f 1a       	sub	r4, r31
    2768:	51 08       	sbc	r5, r1
    276a:	41 14       	cp	r4, r1
    276c:	51 04       	cpc	r5, r1
    276e:	71 f7       	brne	.-36     	; 0x274c <vfprintf+0x18c>
    2770:	e5 c0       	rjmp	.+458    	; 0x293c <vfprintf+0x37c>
    2772:	84 36       	cpi	r24, 0x64	; 100
    2774:	11 f0       	breq	.+4      	; 0x277a <vfprintf+0x1ba>
    2776:	89 36       	cpi	r24, 0x69	; 105
    2778:	39 f5       	brne	.+78     	; 0x27c8 <vfprintf+0x208>
    277a:	f8 01       	movw	r30, r16
    277c:	27 ff       	sbrs	r18, 7
    277e:	07 c0       	rjmp	.+14     	; 0x278e <vfprintf+0x1ce>
    2780:	60 81       	ld	r22, Z
    2782:	71 81       	ldd	r23, Z+1	; 0x01
    2784:	82 81       	ldd	r24, Z+2	; 0x02
    2786:	93 81       	ldd	r25, Z+3	; 0x03
    2788:	0c 5f       	subi	r16, 0xFC	; 252
    278a:	1f 4f       	sbci	r17, 0xFF	; 255
    278c:	08 c0       	rjmp	.+16     	; 0x279e <vfprintf+0x1de>
    278e:	60 81       	ld	r22, Z
    2790:	71 81       	ldd	r23, Z+1	; 0x01
    2792:	07 2e       	mov	r0, r23
    2794:	00 0c       	add	r0, r0
    2796:	88 0b       	sbc	r24, r24
    2798:	99 0b       	sbc	r25, r25
    279a:	0e 5f       	subi	r16, 0xFE	; 254
    279c:	1f 4f       	sbci	r17, 0xFF	; 255
    279e:	2f 76       	andi	r18, 0x6F	; 111
    27a0:	72 2e       	mov	r7, r18
    27a2:	97 ff       	sbrs	r25, 7
    27a4:	09 c0       	rjmp	.+18     	; 0x27b8 <vfprintf+0x1f8>
    27a6:	90 95       	com	r25
    27a8:	80 95       	com	r24
    27aa:	70 95       	com	r23
    27ac:	61 95       	neg	r22
    27ae:	7f 4f       	sbci	r23, 0xFF	; 255
    27b0:	8f 4f       	sbci	r24, 0xFF	; 255
    27b2:	9f 4f       	sbci	r25, 0xFF	; 255
    27b4:	20 68       	ori	r18, 0x80	; 128
    27b6:	72 2e       	mov	r7, r18
    27b8:	2a e0       	ldi	r18, 0x0A	; 10
    27ba:	30 e0       	ldi	r19, 0x00	; 0
    27bc:	a4 01       	movw	r20, r8
    27be:	0e 94 00 15 	call	0x2a00	; 0x2a00 <__ultoa_invert>
    27c2:	a8 2e       	mov	r10, r24
    27c4:	a8 18       	sub	r10, r8
    27c6:	44 c0       	rjmp	.+136    	; 0x2850 <vfprintf+0x290>
    27c8:	85 37       	cpi	r24, 0x75	; 117
    27ca:	29 f4       	brne	.+10     	; 0x27d6 <vfprintf+0x216>
    27cc:	2f 7e       	andi	r18, 0xEF	; 239
    27ce:	b2 2e       	mov	r11, r18
    27d0:	2a e0       	ldi	r18, 0x0A	; 10
    27d2:	30 e0       	ldi	r19, 0x00	; 0
    27d4:	25 c0       	rjmp	.+74     	; 0x2820 <vfprintf+0x260>
    27d6:	f2 2f       	mov	r31, r18
    27d8:	f9 7f       	andi	r31, 0xF9	; 249
    27da:	bf 2e       	mov	r11, r31
    27dc:	8f 36       	cpi	r24, 0x6F	; 111
    27de:	c1 f0       	breq	.+48     	; 0x2810 <vfprintf+0x250>
    27e0:	18 f4       	brcc	.+6      	; 0x27e8 <vfprintf+0x228>
    27e2:	88 35       	cpi	r24, 0x58	; 88
    27e4:	79 f0       	breq	.+30     	; 0x2804 <vfprintf+0x244>
    27e6:	b4 c0       	rjmp	.+360    	; 0x2950 <vfprintf+0x390>
    27e8:	80 37       	cpi	r24, 0x70	; 112
    27ea:	19 f0       	breq	.+6      	; 0x27f2 <vfprintf+0x232>
    27ec:	88 37       	cpi	r24, 0x78	; 120
    27ee:	21 f0       	breq	.+8      	; 0x27f8 <vfprintf+0x238>
    27f0:	af c0       	rjmp	.+350    	; 0x2950 <vfprintf+0x390>
    27f2:	2f 2f       	mov	r18, r31
    27f4:	20 61       	ori	r18, 0x10	; 16
    27f6:	b2 2e       	mov	r11, r18
    27f8:	b4 fe       	sbrs	r11, 4
    27fa:	0d c0       	rjmp	.+26     	; 0x2816 <vfprintf+0x256>
    27fc:	8b 2d       	mov	r24, r11
    27fe:	84 60       	ori	r24, 0x04	; 4
    2800:	b8 2e       	mov	r11, r24
    2802:	09 c0       	rjmp	.+18     	; 0x2816 <vfprintf+0x256>
    2804:	24 ff       	sbrs	r18, 4
    2806:	0a c0       	rjmp	.+20     	; 0x281c <vfprintf+0x25c>
    2808:	9f 2f       	mov	r25, r31
    280a:	96 60       	ori	r25, 0x06	; 6
    280c:	b9 2e       	mov	r11, r25
    280e:	06 c0       	rjmp	.+12     	; 0x281c <vfprintf+0x25c>
    2810:	28 e0       	ldi	r18, 0x08	; 8
    2812:	30 e0       	ldi	r19, 0x00	; 0
    2814:	05 c0       	rjmp	.+10     	; 0x2820 <vfprintf+0x260>
    2816:	20 e1       	ldi	r18, 0x10	; 16
    2818:	30 e0       	ldi	r19, 0x00	; 0
    281a:	02 c0       	rjmp	.+4      	; 0x2820 <vfprintf+0x260>
    281c:	20 e1       	ldi	r18, 0x10	; 16
    281e:	32 e0       	ldi	r19, 0x02	; 2
    2820:	f8 01       	movw	r30, r16
    2822:	b7 fe       	sbrs	r11, 7
    2824:	07 c0       	rjmp	.+14     	; 0x2834 <vfprintf+0x274>
    2826:	60 81       	ld	r22, Z
    2828:	71 81       	ldd	r23, Z+1	; 0x01
    282a:	82 81       	ldd	r24, Z+2	; 0x02
    282c:	93 81       	ldd	r25, Z+3	; 0x03
    282e:	0c 5f       	subi	r16, 0xFC	; 252
    2830:	1f 4f       	sbci	r17, 0xFF	; 255
    2832:	06 c0       	rjmp	.+12     	; 0x2840 <vfprintf+0x280>
    2834:	60 81       	ld	r22, Z
    2836:	71 81       	ldd	r23, Z+1	; 0x01
    2838:	80 e0       	ldi	r24, 0x00	; 0
    283a:	90 e0       	ldi	r25, 0x00	; 0
    283c:	0e 5f       	subi	r16, 0xFE	; 254
    283e:	1f 4f       	sbci	r17, 0xFF	; 255
    2840:	a4 01       	movw	r20, r8
    2842:	0e 94 00 15 	call	0x2a00	; 0x2a00 <__ultoa_invert>
    2846:	a8 2e       	mov	r10, r24
    2848:	a8 18       	sub	r10, r8
    284a:	fb 2d       	mov	r31, r11
    284c:	ff 77       	andi	r31, 0x7F	; 127
    284e:	7f 2e       	mov	r7, r31
    2850:	76 fe       	sbrs	r7, 6
    2852:	0b c0       	rjmp	.+22     	; 0x286a <vfprintf+0x2aa>
    2854:	37 2d       	mov	r19, r7
    2856:	3e 7f       	andi	r19, 0xFE	; 254
    2858:	a5 14       	cp	r10, r5
    285a:	50 f4       	brcc	.+20     	; 0x2870 <vfprintf+0x2b0>
    285c:	74 fe       	sbrs	r7, 4
    285e:	0a c0       	rjmp	.+20     	; 0x2874 <vfprintf+0x2b4>
    2860:	72 fc       	sbrc	r7, 2
    2862:	08 c0       	rjmp	.+16     	; 0x2874 <vfprintf+0x2b4>
    2864:	37 2d       	mov	r19, r7
    2866:	3e 7e       	andi	r19, 0xEE	; 238
    2868:	05 c0       	rjmp	.+10     	; 0x2874 <vfprintf+0x2b4>
    286a:	ba 2c       	mov	r11, r10
    286c:	37 2d       	mov	r19, r7
    286e:	03 c0       	rjmp	.+6      	; 0x2876 <vfprintf+0x2b6>
    2870:	ba 2c       	mov	r11, r10
    2872:	01 c0       	rjmp	.+2      	; 0x2876 <vfprintf+0x2b6>
    2874:	b5 2c       	mov	r11, r5
    2876:	34 ff       	sbrs	r19, 4
    2878:	0d c0       	rjmp	.+26     	; 0x2894 <vfprintf+0x2d4>
    287a:	fe 01       	movw	r30, r28
    287c:	ea 0d       	add	r30, r10
    287e:	f1 1d       	adc	r31, r1
    2880:	80 81       	ld	r24, Z
    2882:	80 33       	cpi	r24, 0x30	; 48
    2884:	11 f4       	brne	.+4      	; 0x288a <vfprintf+0x2ca>
    2886:	39 7e       	andi	r19, 0xE9	; 233
    2888:	09 c0       	rjmp	.+18     	; 0x289c <vfprintf+0x2dc>
    288a:	32 ff       	sbrs	r19, 2
    288c:	06 c0       	rjmp	.+12     	; 0x289a <vfprintf+0x2da>
    288e:	b3 94       	inc	r11
    2890:	b3 94       	inc	r11
    2892:	04 c0       	rjmp	.+8      	; 0x289c <vfprintf+0x2dc>
    2894:	83 2f       	mov	r24, r19
    2896:	86 78       	andi	r24, 0x86	; 134
    2898:	09 f0       	breq	.+2      	; 0x289c <vfprintf+0x2dc>
    289a:	b3 94       	inc	r11
    289c:	33 fd       	sbrc	r19, 3
    289e:	13 c0       	rjmp	.+38     	; 0x28c6 <vfprintf+0x306>
    28a0:	30 ff       	sbrs	r19, 0
    28a2:	06 c0       	rjmp	.+12     	; 0x28b0 <vfprintf+0x2f0>
    28a4:	5a 2c       	mov	r5, r10
    28a6:	b3 14       	cp	r11, r3
    28a8:	18 f4       	brcc	.+6      	; 0x28b0 <vfprintf+0x2f0>
    28aa:	53 0c       	add	r5, r3
    28ac:	5b 18       	sub	r5, r11
    28ae:	b3 2c       	mov	r11, r3
    28b0:	b3 14       	cp	r11, r3
    28b2:	68 f4       	brcc	.+26     	; 0x28ce <vfprintf+0x30e>
    28b4:	b7 01       	movw	r22, r14
    28b6:	80 e2       	ldi	r24, 0x20	; 32
    28b8:	90 e0       	ldi	r25, 0x00	; 0
    28ba:	3c 87       	std	Y+12, r19	; 0x0c
    28bc:	0e 94 c8 14 	call	0x2990	; 0x2990 <fputc>
    28c0:	b3 94       	inc	r11
    28c2:	3c 85       	ldd	r19, Y+12	; 0x0c
    28c4:	f5 cf       	rjmp	.-22     	; 0x28b0 <vfprintf+0x2f0>
    28c6:	b3 14       	cp	r11, r3
    28c8:	10 f4       	brcc	.+4      	; 0x28ce <vfprintf+0x30e>
    28ca:	3b 18       	sub	r3, r11
    28cc:	01 c0       	rjmp	.+2      	; 0x28d0 <vfprintf+0x310>
    28ce:	31 2c       	mov	r3, r1
    28d0:	34 ff       	sbrs	r19, 4
    28d2:	12 c0       	rjmp	.+36     	; 0x28f8 <vfprintf+0x338>
    28d4:	b7 01       	movw	r22, r14
    28d6:	80 e3       	ldi	r24, 0x30	; 48
    28d8:	90 e0       	ldi	r25, 0x00	; 0
    28da:	3c 87       	std	Y+12, r19	; 0x0c
    28dc:	0e 94 c8 14 	call	0x2990	; 0x2990 <fputc>
    28e0:	3c 85       	ldd	r19, Y+12	; 0x0c
    28e2:	32 ff       	sbrs	r19, 2
    28e4:	17 c0       	rjmp	.+46     	; 0x2914 <vfprintf+0x354>
    28e6:	31 fd       	sbrc	r19, 1
    28e8:	03 c0       	rjmp	.+6      	; 0x28f0 <vfprintf+0x330>
    28ea:	88 e7       	ldi	r24, 0x78	; 120
    28ec:	90 e0       	ldi	r25, 0x00	; 0
    28ee:	02 c0       	rjmp	.+4      	; 0x28f4 <vfprintf+0x334>
    28f0:	88 e5       	ldi	r24, 0x58	; 88
    28f2:	90 e0       	ldi	r25, 0x00	; 0
    28f4:	b7 01       	movw	r22, r14
    28f6:	0c c0       	rjmp	.+24     	; 0x2910 <vfprintf+0x350>
    28f8:	83 2f       	mov	r24, r19
    28fa:	86 78       	andi	r24, 0x86	; 134
    28fc:	59 f0       	breq	.+22     	; 0x2914 <vfprintf+0x354>
    28fe:	31 ff       	sbrs	r19, 1
    2900:	02 c0       	rjmp	.+4      	; 0x2906 <vfprintf+0x346>
    2902:	8b e2       	ldi	r24, 0x2B	; 43
    2904:	01 c0       	rjmp	.+2      	; 0x2908 <vfprintf+0x348>
    2906:	80 e2       	ldi	r24, 0x20	; 32
    2908:	37 fd       	sbrc	r19, 7
    290a:	8d e2       	ldi	r24, 0x2D	; 45
    290c:	b7 01       	movw	r22, r14
    290e:	90 e0       	ldi	r25, 0x00	; 0
    2910:	0e 94 c8 14 	call	0x2990	; 0x2990 <fputc>
    2914:	a5 14       	cp	r10, r5
    2916:	38 f4       	brcc	.+14     	; 0x2926 <vfprintf+0x366>
    2918:	b7 01       	movw	r22, r14
    291a:	80 e3       	ldi	r24, 0x30	; 48
    291c:	90 e0       	ldi	r25, 0x00	; 0
    291e:	0e 94 c8 14 	call	0x2990	; 0x2990 <fputc>
    2922:	5a 94       	dec	r5
    2924:	f7 cf       	rjmp	.-18     	; 0x2914 <vfprintf+0x354>
    2926:	aa 94       	dec	r10
    2928:	f4 01       	movw	r30, r8
    292a:	ea 0d       	add	r30, r10
    292c:	f1 1d       	adc	r31, r1
    292e:	80 81       	ld	r24, Z
    2930:	b7 01       	movw	r22, r14
    2932:	90 e0       	ldi	r25, 0x00	; 0
    2934:	0e 94 c8 14 	call	0x2990	; 0x2990 <fputc>
    2938:	a1 10       	cpse	r10, r1
    293a:	f5 cf       	rjmp	.-22     	; 0x2926 <vfprintf+0x366>
    293c:	33 20       	and	r3, r3
    293e:	09 f4       	brne	.+2      	; 0x2942 <vfprintf+0x382>
    2940:	51 ce       	rjmp	.-862    	; 0x25e4 <vfprintf+0x24>
    2942:	b7 01       	movw	r22, r14
    2944:	80 e2       	ldi	r24, 0x20	; 32
    2946:	90 e0       	ldi	r25, 0x00	; 0
    2948:	0e 94 c8 14 	call	0x2990	; 0x2990 <fputc>
    294c:	3a 94       	dec	r3
    294e:	f6 cf       	rjmp	.-20     	; 0x293c <vfprintf+0x37c>
    2950:	f7 01       	movw	r30, r14
    2952:	86 81       	ldd	r24, Z+6	; 0x06
    2954:	97 81       	ldd	r25, Z+7	; 0x07
    2956:	02 c0       	rjmp	.+4      	; 0x295c <vfprintf+0x39c>
    2958:	8f ef       	ldi	r24, 0xFF	; 255
    295a:	9f ef       	ldi	r25, 0xFF	; 255
    295c:	2c 96       	adiw	r28, 0x0c	; 12
    295e:	e2 e1       	ldi	r30, 0x12	; 18
    2960:	0c 94 7a 15 	jmp	0x2af4	; 0x2af4 <__epilogue_restores__>

00002964 <strnlen_P>:
    2964:	fc 01       	movw	r30, r24
    2966:	05 90       	lpm	r0, Z+
    2968:	61 50       	subi	r22, 0x01	; 1
    296a:	70 40       	sbci	r23, 0x00	; 0
    296c:	01 10       	cpse	r0, r1
    296e:	d8 f7       	brcc	.-10     	; 0x2966 <strnlen_P+0x2>
    2970:	80 95       	com	r24
    2972:	90 95       	com	r25
    2974:	8e 0f       	add	r24, r30
    2976:	9f 1f       	adc	r25, r31
    2978:	08 95       	ret

0000297a <strnlen>:
    297a:	fc 01       	movw	r30, r24
    297c:	61 50       	subi	r22, 0x01	; 1
    297e:	70 40       	sbci	r23, 0x00	; 0
    2980:	01 90       	ld	r0, Z+
    2982:	01 10       	cpse	r0, r1
    2984:	d8 f7       	brcc	.-10     	; 0x297c <strnlen+0x2>
    2986:	80 95       	com	r24
    2988:	90 95       	com	r25
    298a:	8e 0f       	add	r24, r30
    298c:	9f 1f       	adc	r25, r31
    298e:	08 95       	ret

00002990 <fputc>:
    2990:	0f 93       	push	r16
    2992:	1f 93       	push	r17
    2994:	cf 93       	push	r28
    2996:	df 93       	push	r29
    2998:	fb 01       	movw	r30, r22
    299a:	23 81       	ldd	r18, Z+3	; 0x03
    299c:	21 fd       	sbrc	r18, 1
    299e:	03 c0       	rjmp	.+6      	; 0x29a6 <fputc+0x16>
    29a0:	8f ef       	ldi	r24, 0xFF	; 255
    29a2:	9f ef       	ldi	r25, 0xFF	; 255
    29a4:	28 c0       	rjmp	.+80     	; 0x29f6 <fputc+0x66>
    29a6:	22 ff       	sbrs	r18, 2
    29a8:	16 c0       	rjmp	.+44     	; 0x29d6 <fputc+0x46>
    29aa:	46 81       	ldd	r20, Z+6	; 0x06
    29ac:	57 81       	ldd	r21, Z+7	; 0x07
    29ae:	24 81       	ldd	r18, Z+4	; 0x04
    29b0:	35 81       	ldd	r19, Z+5	; 0x05
    29b2:	42 17       	cp	r20, r18
    29b4:	53 07       	cpc	r21, r19
    29b6:	44 f4       	brge	.+16     	; 0x29c8 <fputc+0x38>
    29b8:	a0 81       	ld	r26, Z
    29ba:	b1 81       	ldd	r27, Z+1	; 0x01
    29bc:	9d 01       	movw	r18, r26
    29be:	2f 5f       	subi	r18, 0xFF	; 255
    29c0:	3f 4f       	sbci	r19, 0xFF	; 255
    29c2:	31 83       	std	Z+1, r19	; 0x01
    29c4:	20 83       	st	Z, r18
    29c6:	8c 93       	st	X, r24
    29c8:	26 81       	ldd	r18, Z+6	; 0x06
    29ca:	37 81       	ldd	r19, Z+7	; 0x07
    29cc:	2f 5f       	subi	r18, 0xFF	; 255
    29ce:	3f 4f       	sbci	r19, 0xFF	; 255
    29d0:	37 83       	std	Z+7, r19	; 0x07
    29d2:	26 83       	std	Z+6, r18	; 0x06
    29d4:	10 c0       	rjmp	.+32     	; 0x29f6 <fputc+0x66>
    29d6:	eb 01       	movw	r28, r22
    29d8:	09 2f       	mov	r16, r25
    29da:	18 2f       	mov	r17, r24
    29dc:	00 84       	ldd	r0, Z+8	; 0x08
    29de:	f1 85       	ldd	r31, Z+9	; 0x09
    29e0:	e0 2d       	mov	r30, r0
    29e2:	09 95       	icall
    29e4:	89 2b       	or	r24, r25
    29e6:	e1 f6       	brne	.-72     	; 0x29a0 <fputc+0x10>
    29e8:	8e 81       	ldd	r24, Y+6	; 0x06
    29ea:	9f 81       	ldd	r25, Y+7	; 0x07
    29ec:	01 96       	adiw	r24, 0x01	; 1
    29ee:	9f 83       	std	Y+7, r25	; 0x07
    29f0:	8e 83       	std	Y+6, r24	; 0x06
    29f2:	81 2f       	mov	r24, r17
    29f4:	90 2f       	mov	r25, r16
    29f6:	df 91       	pop	r29
    29f8:	cf 91       	pop	r28
    29fa:	1f 91       	pop	r17
    29fc:	0f 91       	pop	r16
    29fe:	08 95       	ret

00002a00 <__ultoa_invert>:
    2a00:	fa 01       	movw	r30, r20
    2a02:	aa 27       	eor	r26, r26
    2a04:	28 30       	cpi	r18, 0x08	; 8
    2a06:	51 f1       	breq	.+84     	; 0x2a5c <__ultoa_invert+0x5c>
    2a08:	20 31       	cpi	r18, 0x10	; 16
    2a0a:	81 f1       	breq	.+96     	; 0x2a6c <__ultoa_invert+0x6c>
    2a0c:	e8 94       	clt
    2a0e:	6f 93       	push	r22
    2a10:	6e 7f       	andi	r22, 0xFE	; 254
    2a12:	6e 5f       	subi	r22, 0xFE	; 254
    2a14:	7f 4f       	sbci	r23, 0xFF	; 255
    2a16:	8f 4f       	sbci	r24, 0xFF	; 255
    2a18:	9f 4f       	sbci	r25, 0xFF	; 255
    2a1a:	af 4f       	sbci	r26, 0xFF	; 255
    2a1c:	b1 e0       	ldi	r27, 0x01	; 1
    2a1e:	3e d0       	rcall	.+124    	; 0x2a9c <__ultoa_invert+0x9c>
    2a20:	b4 e0       	ldi	r27, 0x04	; 4
    2a22:	3c d0       	rcall	.+120    	; 0x2a9c <__ultoa_invert+0x9c>
    2a24:	67 0f       	add	r22, r23
    2a26:	78 1f       	adc	r23, r24
    2a28:	89 1f       	adc	r24, r25
    2a2a:	9a 1f       	adc	r25, r26
    2a2c:	a1 1d       	adc	r26, r1
    2a2e:	68 0f       	add	r22, r24
    2a30:	79 1f       	adc	r23, r25
    2a32:	8a 1f       	adc	r24, r26
    2a34:	91 1d       	adc	r25, r1
    2a36:	a1 1d       	adc	r26, r1
    2a38:	6a 0f       	add	r22, r26
    2a3a:	71 1d       	adc	r23, r1
    2a3c:	81 1d       	adc	r24, r1
    2a3e:	91 1d       	adc	r25, r1
    2a40:	a1 1d       	adc	r26, r1
    2a42:	20 d0       	rcall	.+64     	; 0x2a84 <__ultoa_invert+0x84>
    2a44:	09 f4       	brne	.+2      	; 0x2a48 <__ultoa_invert+0x48>
    2a46:	68 94       	set
    2a48:	3f 91       	pop	r19
    2a4a:	2a e0       	ldi	r18, 0x0A	; 10
    2a4c:	26 9f       	mul	r18, r22
    2a4e:	11 24       	eor	r1, r1
    2a50:	30 19       	sub	r19, r0
    2a52:	30 5d       	subi	r19, 0xD0	; 208
    2a54:	31 93       	st	Z+, r19
    2a56:	de f6       	brtc	.-74     	; 0x2a0e <__ultoa_invert+0xe>
    2a58:	cf 01       	movw	r24, r30
    2a5a:	08 95       	ret
    2a5c:	46 2f       	mov	r20, r22
    2a5e:	47 70       	andi	r20, 0x07	; 7
    2a60:	40 5d       	subi	r20, 0xD0	; 208
    2a62:	41 93       	st	Z+, r20
    2a64:	b3 e0       	ldi	r27, 0x03	; 3
    2a66:	0f d0       	rcall	.+30     	; 0x2a86 <__ultoa_invert+0x86>
    2a68:	c9 f7       	brne	.-14     	; 0x2a5c <__ultoa_invert+0x5c>
    2a6a:	f6 cf       	rjmp	.-20     	; 0x2a58 <__ultoa_invert+0x58>
    2a6c:	46 2f       	mov	r20, r22
    2a6e:	4f 70       	andi	r20, 0x0F	; 15
    2a70:	40 5d       	subi	r20, 0xD0	; 208
    2a72:	4a 33       	cpi	r20, 0x3A	; 58
    2a74:	18 f0       	brcs	.+6      	; 0x2a7c <__ultoa_invert+0x7c>
    2a76:	49 5d       	subi	r20, 0xD9	; 217
    2a78:	31 fd       	sbrc	r19, 1
    2a7a:	40 52       	subi	r20, 0x20	; 32
    2a7c:	41 93       	st	Z+, r20
    2a7e:	02 d0       	rcall	.+4      	; 0x2a84 <__ultoa_invert+0x84>
    2a80:	a9 f7       	brne	.-22     	; 0x2a6c <__ultoa_invert+0x6c>
    2a82:	ea cf       	rjmp	.-44     	; 0x2a58 <__ultoa_invert+0x58>
    2a84:	b4 e0       	ldi	r27, 0x04	; 4
    2a86:	a6 95       	lsr	r26
    2a88:	97 95       	ror	r25
    2a8a:	87 95       	ror	r24
    2a8c:	77 95       	ror	r23
    2a8e:	67 95       	ror	r22
    2a90:	ba 95       	dec	r27
    2a92:	c9 f7       	brne	.-14     	; 0x2a86 <__ultoa_invert+0x86>
    2a94:	00 97       	sbiw	r24, 0x00	; 0
    2a96:	61 05       	cpc	r22, r1
    2a98:	71 05       	cpc	r23, r1
    2a9a:	08 95       	ret
    2a9c:	9b 01       	movw	r18, r22
    2a9e:	ac 01       	movw	r20, r24
    2aa0:	0a 2e       	mov	r0, r26
    2aa2:	06 94       	lsr	r0
    2aa4:	57 95       	ror	r21
    2aa6:	47 95       	ror	r20
    2aa8:	37 95       	ror	r19
    2aaa:	27 95       	ror	r18
    2aac:	ba 95       	dec	r27
    2aae:	c9 f7       	brne	.-14     	; 0x2aa2 <__ultoa_invert+0xa2>
    2ab0:	62 0f       	add	r22, r18
    2ab2:	73 1f       	adc	r23, r19
    2ab4:	84 1f       	adc	r24, r20
    2ab6:	95 1f       	adc	r25, r21
    2ab8:	a0 1d       	adc	r26, r0
    2aba:	08 95       	ret

00002abc <__prologue_saves__>:
    2abc:	2f 92       	push	r2
    2abe:	3f 92       	push	r3
    2ac0:	4f 92       	push	r4
    2ac2:	5f 92       	push	r5
    2ac4:	6f 92       	push	r6
    2ac6:	7f 92       	push	r7
    2ac8:	8f 92       	push	r8
    2aca:	9f 92       	push	r9
    2acc:	af 92       	push	r10
    2ace:	bf 92       	push	r11
    2ad0:	cf 92       	push	r12
    2ad2:	df 92       	push	r13
    2ad4:	ef 92       	push	r14
    2ad6:	ff 92       	push	r15
    2ad8:	0f 93       	push	r16
    2ada:	1f 93       	push	r17
    2adc:	cf 93       	push	r28
    2ade:	df 93       	push	r29
    2ae0:	cd b7       	in	r28, 0x3d	; 61
    2ae2:	de b7       	in	r29, 0x3e	; 62
    2ae4:	ca 1b       	sub	r28, r26
    2ae6:	db 0b       	sbc	r29, r27
    2ae8:	0f b6       	in	r0, 0x3f	; 63
    2aea:	f8 94       	cli
    2aec:	de bf       	out	0x3e, r29	; 62
    2aee:	0f be       	out	0x3f, r0	; 63
    2af0:	cd bf       	out	0x3d, r28	; 61
    2af2:	09 94       	ijmp

00002af4 <__epilogue_restores__>:
    2af4:	2a 88       	ldd	r2, Y+18	; 0x12
    2af6:	39 88       	ldd	r3, Y+17	; 0x11
    2af8:	48 88       	ldd	r4, Y+16	; 0x10
    2afa:	5f 84       	ldd	r5, Y+15	; 0x0f
    2afc:	6e 84       	ldd	r6, Y+14	; 0x0e
    2afe:	7d 84       	ldd	r7, Y+13	; 0x0d
    2b00:	8c 84       	ldd	r8, Y+12	; 0x0c
    2b02:	9b 84       	ldd	r9, Y+11	; 0x0b
    2b04:	aa 84       	ldd	r10, Y+10	; 0x0a
    2b06:	b9 84       	ldd	r11, Y+9	; 0x09
    2b08:	c8 84       	ldd	r12, Y+8	; 0x08
    2b0a:	df 80       	ldd	r13, Y+7	; 0x07
    2b0c:	ee 80       	ldd	r14, Y+6	; 0x06
    2b0e:	fd 80       	ldd	r15, Y+5	; 0x05
    2b10:	0c 81       	ldd	r16, Y+4	; 0x04
    2b12:	1b 81       	ldd	r17, Y+3	; 0x03
    2b14:	aa 81       	ldd	r26, Y+2	; 0x02
    2b16:	b9 81       	ldd	r27, Y+1	; 0x01
    2b18:	ce 0f       	add	r28, r30
    2b1a:	d1 1d       	adc	r29, r1
    2b1c:	0f b6       	in	r0, 0x3f	; 63
    2b1e:	f8 94       	cli
    2b20:	de bf       	out	0x3e, r29	; 62
    2b22:	0f be       	out	0x3f, r0	; 63
    2b24:	cd bf       	out	0x3d, r28	; 61
    2b26:	ed 01       	movw	r28, r26
    2b28:	08 95       	ret

00002b2a <_exit>:
    2b2a:	f8 94       	cli

00002b2c <__stop_program>:
    2b2c:	ff cf       	rjmp	.-2      	; 0x2b2c <__stop_program>
