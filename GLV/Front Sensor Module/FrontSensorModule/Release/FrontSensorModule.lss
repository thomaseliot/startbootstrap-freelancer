
FrontSensorModule.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000a  00800100  00002bbc  00002c50  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002bbc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000677  0080010a  0080010a  00002c5a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002c5a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002c8c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003b0  00000000  00000000  00002ccc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004966  00000000  00000000  0000307c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001058  00000000  00000000  000079e2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002b19  00000000  00000000  00008a3a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000cb8  00000000  00000000  0000b554  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000f15f  00000000  00000000  0000c20c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000051f6  00000000  00000000  0001b36b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000368  00000000  00000000  00020561  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00004d45  00000000  00000000  000208c9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d0 e1       	ldi	r29, 0x10	; 16
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	11 e0       	ldi	r17, 0x01	; 1
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	ec eb       	ldi	r30, 0xBC	; 188
      90:	fb e2       	ldi	r31, 0x2B	; 43
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	aa 30       	cpi	r26, 0x0A	; 10
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	27 e0       	ldi	r18, 0x07	; 7
      a0:	aa e0       	ldi	r26, 0x0A	; 10
      a2:	b1 e0       	ldi	r27, 0x01	; 1
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	a1 38       	cpi	r26, 0x81	; 129
      aa:	b2 07       	cpc	r27, r18
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 5d 00 	call	0xba	; 0xba <main>
      b2:	0c 94 dc 15 	jmp	0x2bb8	; 0x2bb8 <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <main>:
#include "croutine.h"

#define mainLED_TASK_PRIORITY           ( tskIDLE_PRIORITY + 2 )

int main(void)
{
      ba:	af 92       	push	r10
      bc:	bf 92       	push	r11
      be:	cf 92       	push	r12
      c0:	df 92       	push	r13
      c2:	ef 92       	push	r14
      c4:	ff 92       	push	r15
      c6:	0f 93       	push	r16
	config_io_pin(IO_PORT_C, 0, IO_DIR_OUTPUT);
      c8:	41 e0       	ldi	r20, 0x01	; 1
      ca:	60 e0       	ldi	r22, 0x00	; 0
      cc:	81 e0       	ldi	r24, 0x01	; 1
      ce:	0e 94 4a 15 	call	0x2a94	; 0x2a94 <config_io_pin>
	
    xTaskCreate(vLEDFlashTask, "LED", configMINIMAL_STACK_SIZE, 
      d2:	a1 2c       	mov	r10, r1
      d4:	b1 2c       	mov	r11, r1
      d6:	c1 2c       	mov	r12, r1
      d8:	d1 2c       	mov	r13, r1
      da:	e1 2c       	mov	r14, r1
      dc:	f1 2c       	mov	r15, r1
      de:	02 e0       	ldi	r16, 0x02	; 2
      e0:	20 e0       	ldi	r18, 0x00	; 0
      e2:	30 e0       	ldi	r19, 0x00	; 0
      e4:	45 e5       	ldi	r20, 0x55	; 85
      e6:	50 e0       	ldi	r21, 0x00	; 0
      e8:	60 e0       	ldi	r22, 0x00	; 0
      ea:	71 e0       	ldi	r23, 0x01	; 1
      ec:	88 ec       	ldi	r24, 0xC8	; 200
      ee:	95 e1       	ldi	r25, 0x15	; 21
      f0:	0e 94 4f 0c 	call	0x189e	; 0x189e <xTaskGenericCreate>
		NULL, mainLED_TASK_PRIORITY, NULL);
	
	vTaskStartScheduler();
      f4:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <vTaskStartScheduler>
	
	return 0;
}
      f8:	80 e0       	ldi	r24, 0x00	; 0
      fa:	90 e0       	ldi	r25, 0x00	; 0
      fc:	0f 91       	pop	r16
      fe:	ff 90       	pop	r15
     100:	ef 90       	pop	r14
     102:	df 90       	pop	r13
     104:	cf 90       	pop	r12
     106:	bf 90       	pop	r11
     108:	af 90       	pop	r10
     10a:	08 95       	ret

0000010c <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
     10c:	cf 92       	push	r12
     10e:	df 92       	push	r13
     110:	ef 92       	push	r14
     112:	ff 92       	push	r15
     114:	1f 93       	push	r17
     116:	cf 93       	push	r28
     118:	df 93       	push	r29
     11a:	6c 01       	movw	r12, r24
     11c:	16 2f       	mov	r17, r22
     11e:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     120:	8e e1       	ldi	r24, 0x1E	; 30
     122:	90 e0       	ldi	r25, 0x00	; 0
     124:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <pvPortMalloc>
     128:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
     12a:	89 2b       	or	r24, r25
     12c:	09 f4       	brne	.+2      	; 0x130 <xCoRoutineCreate+0x24>
     12e:	5d c0       	rjmp	.+186    	; 0x1ea <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     130:	80 91 17 01 	lds	r24, 0x0117
     134:	90 91 18 01 	lds	r25, 0x0118
     138:	89 2b       	or	r24, r25
     13a:	21 f5       	brne	.+72     	; 0x184 <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     13c:	d0 93 18 01 	sts	0x0118, r29
     140:	c0 93 17 01 	sts	0x0117, r28
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     144:	8e e3       	ldi	r24, 0x3E	; 62
     146:	91 e0       	ldi	r25, 0x01	; 1
     148:	0e 94 41 05 	call	0xa82	; 0xa82 <vListInitialise>
     14c:	89 e4       	ldi	r24, 0x49	; 73
     14e:	91 e0       	ldi	r25, 0x01	; 1
     150:	0e 94 41 05 	call	0xa82	; 0xa82 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
     154:	83 e3       	ldi	r24, 0x33	; 51
     156:	91 e0       	ldi	r25, 0x01	; 1
     158:	0e 94 41 05 	call	0xa82	; 0xa82 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
     15c:	88 e2       	ldi	r24, 0x28	; 40
     15e:	91 e0       	ldi	r25, 0x01	; 1
     160:	0e 94 41 05 	call	0xa82	; 0xa82 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
     164:	89 e1       	ldi	r24, 0x19	; 25
     166:	91 e0       	ldi	r25, 0x01	; 1
     168:	0e 94 41 05 	call	0xa82	; 0xa82 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     16c:	83 e3       	ldi	r24, 0x33	; 51
     16e:	91 e0       	ldi	r25, 0x01	; 1
     170:	90 93 27 01 	sts	0x0127, r25
     174:	80 93 26 01 	sts	0x0126, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     178:	88 e2       	ldi	r24, 0x28	; 40
     17a:	91 e0       	ldi	r25, 0x01	; 1
     17c:	90 93 25 01 	sts	0x0125, r25
     180:	80 93 24 01 	sts	0x0124, r24
     184:	11 11       	cpse	r17, r1
     186:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     188:	1d 8e       	std	Y+29, r1	; 0x1d
     18a:	1c 8e       	std	Y+28, r1	; 0x1c
		pxCoRoutine->uxPriority = uxPriority;
     18c:	1a 8f       	std	Y+26, r17	; 0x1a
		pxCoRoutine->uxIndex = uxIndex;
     18e:	fb 8e       	std	Y+27, r15	; 0x1b
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     190:	fe 01       	movw	r30, r28
     192:	c1 92       	st	Z+, r12
     194:	d1 92       	st	Z+, r13
     196:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     198:	cf 01       	movw	r24, r30
     19a:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     19e:	ce 01       	movw	r24, r28
     1a0:	0e 96       	adiw	r24, 0x0e	; 14
     1a2:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     1a6:	db 87       	std	Y+11, r29	; 0x0b
     1a8:	ca 87       	std	Y+10, r28	; 0x0a
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     1aa:	df 8b       	std	Y+23, r29	; 0x17
     1ac:	ce 8b       	std	Y+22, r28	; 0x16

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     1ae:	82 e0       	ldi	r24, 0x02	; 2
     1b0:	90 e0       	ldi	r25, 0x00	; 0
     1b2:	a0 e0       	ldi	r26, 0x00	; 0
     1b4:	b0 e0       	ldi	r27, 0x00	; 0
     1b6:	81 1b       	sub	r24, r17
     1b8:	91 09       	sbc	r25, r1
     1ba:	a1 09       	sbc	r26, r1
     1bc:	b1 09       	sbc	r27, r1
     1be:	8e 87       	std	Y+14, r24	; 0x0e
     1c0:	9f 87       	std	Y+15, r25	; 0x0f
     1c2:	a8 8b       	std	Y+16, r26	; 0x10
     1c4:	b9 8b       	std	Y+17, r27	; 0x11

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     1c6:	9a 8d       	ldd	r25, Y+26	; 0x1a
     1c8:	80 91 16 01 	lds	r24, 0x0116
     1cc:	89 17       	cp	r24, r25
     1ce:	10 f4       	brcc	.+4      	; 0x1d4 <xCoRoutineCreate+0xc8>
     1d0:	90 93 16 01 	sts	0x0116, r25
     1d4:	fb e0       	ldi	r31, 0x0B	; 11
     1d6:	9f 9f       	mul	r25, r31
     1d8:	c0 01       	movw	r24, r0
     1da:	11 24       	eor	r1, r1
     1dc:	b7 01       	movw	r22, r14
     1de:	82 5c       	subi	r24, 0xC2	; 194
     1e0:	9e 4f       	sbci	r25, 0xFE	; 254
     1e2:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>

		xReturn = pdPASS;
     1e6:	81 e0       	ldi	r24, 0x01	; 1
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <xCoRoutineCreate+0xe0>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     1ea:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
     1ec:	df 91       	pop	r29
     1ee:	cf 91       	pop	r28
     1f0:	1f 91       	pop	r17
     1f2:	ff 90       	pop	r15
     1f4:	ef 90       	pop	r14
     1f6:	df 90       	pop	r13
     1f8:	cf 90       	pop	r12
     1fa:	08 95       	ret

000001fc <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
     1fc:	cf 92       	push	r12
     1fe:	df 92       	push	r13
     200:	ef 92       	push	r14
     202:	ff 92       	push	r15
     204:	cf 93       	push	r28
     206:	df 93       	push	r29
     208:	ea 01       	movw	r28, r20
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     20a:	c0 90 12 01 	lds	r12, 0x0112
     20e:	d0 90 13 01 	lds	r13, 0x0113
     212:	e0 90 14 01 	lds	r14, 0x0114
     216:	f0 90 15 01 	lds	r15, 0x0115
     21a:	c6 0e       	add	r12, r22
     21c:	d7 1e       	adc	r13, r23
     21e:	e8 1e       	adc	r14, r24
     220:	f9 1e       	adc	r15, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     222:	80 91 17 01 	lds	r24, 0x0117
     226:	90 91 18 01 	lds	r25, 0x0118
     22a:	02 96       	adiw	r24, 0x02	; 2
     22c:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     230:	e0 91 17 01 	lds	r30, 0x0117
     234:	f0 91 18 01 	lds	r31, 0x0118
     238:	c2 82       	std	Z+2, r12	; 0x02
     23a:	d3 82       	std	Z+3, r13	; 0x03
     23c:	e4 82       	std	Z+4, r14	; 0x04
     23e:	f5 82       	std	Z+5, r15	; 0x05

	if( xTimeToWake < xCoRoutineTickCount )
     240:	80 91 12 01 	lds	r24, 0x0112
     244:	90 91 13 01 	lds	r25, 0x0113
     248:	a0 91 14 01 	lds	r26, 0x0114
     24c:	b0 91 15 01 	lds	r27, 0x0115
     250:	c8 16       	cp	r12, r24
     252:	d9 06       	cpc	r13, r25
     254:	ea 06       	cpc	r14, r26
     256:	fb 06       	cpc	r15, r27
     258:	50 f4       	brcc	.+20     	; 0x26e <vCoRoutineAddToDelayedList+0x72>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     25a:	bf 01       	movw	r22, r30
     25c:	6e 5f       	subi	r22, 0xFE	; 254
     25e:	7f 4f       	sbci	r23, 0xFF	; 255
     260:	80 91 24 01 	lds	r24, 0x0124
     264:	90 91 25 01 	lds	r25, 0x0125
     268:	0e 94 77 05 	call	0xaee	; 0xaee <vListInsert>
     26c:	09 c0       	rjmp	.+18     	; 0x280 <vCoRoutineAddToDelayedList+0x84>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     26e:	bf 01       	movw	r22, r30
     270:	6e 5f       	subi	r22, 0xFE	; 254
     272:	7f 4f       	sbci	r23, 0xFF	; 255
     274:	80 91 26 01 	lds	r24, 0x0126
     278:	90 91 27 01 	lds	r25, 0x0127
     27c:	0e 94 77 05 	call	0xaee	; 0xaee <vListInsert>
	}

	if( pxEventList )
     280:	20 97       	sbiw	r28, 0x00	; 0
     282:	49 f0       	breq	.+18     	; 0x296 <vCoRoutineAddToDelayedList+0x9a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     284:	60 91 17 01 	lds	r22, 0x0117
     288:	70 91 18 01 	lds	r23, 0x0118
     28c:	62 5f       	subi	r22, 0xF2	; 242
     28e:	7f 4f       	sbci	r23, 0xFF	; 255
     290:	ce 01       	movw	r24, r28
     292:	0e 94 77 05 	call	0xaee	; 0xaee <vListInsert>
	}
}
     296:	df 91       	pop	r29
     298:	cf 91       	pop	r28
     29a:	ff 90       	pop	r15
     29c:	ef 90       	pop	r14
     29e:	df 90       	pop	r13
     2a0:	cf 90       	pop	r12
     2a2:	08 95       	ret

000002a4 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     2a4:	df 92       	push	r13
     2a6:	ef 92       	push	r14
     2a8:	ff 92       	push	r15
     2aa:	0f 93       	push	r16
     2ac:	1f 93       	push	r17
     2ae:	cf 93       	push	r28
     2b0:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2b2:	80 91 19 01 	lds	r24, 0x0119
     2b6:	88 23       	and	r24, r24
     2b8:	81 f1       	breq	.+96     	; 0x31a <vCoRoutineSchedule+0x76>
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     2ba:	0f 2e       	mov	r0, r31
     2bc:	f9 e1       	ldi	r31, 0x19	; 25
     2be:	ef 2e       	mov	r14, r31
     2c0:	f1 e0       	ldi	r31, 0x01	; 1
     2c2:	ff 2e       	mov	r15, r31
     2c4:	f0 2d       	mov	r31, r0
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     2c6:	0f 2e       	mov	r0, r31
     2c8:	fb e0       	ldi	r31, 0x0B	; 11
     2ca:	df 2e       	mov	r13, r31
     2cc:	f0 2d       	mov	r31, r0
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     2ce:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     2d0:	d7 01       	movw	r26, r14
     2d2:	17 96       	adiw	r26, 0x07	; 7
     2d4:	ed 91       	ld	r30, X+
     2d6:	fc 91       	ld	r31, X
     2d8:	18 97       	sbiw	r26, 0x08	; 8
     2da:	c0 85       	ldd	r28, Z+8	; 0x08
     2dc:	d1 85       	ldd	r29, Z+9	; 0x09
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     2de:	ce 01       	movw	r24, r28
     2e0:	0e 96       	adiw	r24, 0x0e	; 14
     2e2:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     2e6:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     2e8:	8e 01       	movw	r16, r28
     2ea:	0e 5f       	subi	r16, 0xFE	; 254
     2ec:	1f 4f       	sbci	r17, 0xFF	; 255
     2ee:	c8 01       	movw	r24, r16
     2f0:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     2f4:	9a 8d       	ldd	r25, Y+26	; 0x1a
     2f6:	80 91 16 01 	lds	r24, 0x0116
     2fa:	89 17       	cp	r24, r25
     2fc:	10 f4       	brcc	.+4      	; 0x302 <vCoRoutineSchedule+0x5e>
     2fe:	90 93 16 01 	sts	0x0116, r25
     302:	d9 9e       	mul	r13, r25
     304:	c0 01       	movw	r24, r0
     306:	11 24       	eor	r1, r1
     308:	b8 01       	movw	r22, r16
     30a:	82 5c       	subi	r24, 0xC2	; 194
     30c:	9e 4f       	sbci	r25, 0xFE	; 254
     30e:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     312:	f7 01       	movw	r30, r14
     314:	80 81       	ld	r24, Z
     316:	81 11       	cpse	r24, r1
     318:	da cf       	rjmp	.-76     	; 0x2ce <vCoRoutineSchedule+0x2a>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     31a:	0e 94 7a 0e 	call	0x1cf4	; 0x1cf4 <xTaskGetTickCount>
     31e:	00 91 0e 01 	lds	r16, 0x010E
     322:	10 91 0f 01 	lds	r17, 0x010F
     326:	20 91 10 01 	lds	r18, 0x0110
     32a:	30 91 11 01 	lds	r19, 0x0111
     32e:	dc 01       	movw	r26, r24
     330:	cb 01       	movw	r24, r22
     332:	80 1b       	sub	r24, r16
     334:	91 0b       	sbc	r25, r17
     336:	a2 0b       	sbc	r26, r18
     338:	b3 0b       	sbc	r27, r19
     33a:	80 93 0a 01 	sts	0x010A, r24
     33e:	90 93 0b 01 	sts	0x010B, r25
     342:	a0 93 0c 01 	sts	0x010C, r26
     346:	b0 93 0d 01 	sts	0x010D, r27
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
     34a:	0f 2e       	mov	r0, r31
     34c:	fb e0       	ldi	r31, 0x0B	; 11
     34e:	ff 2e       	mov	r15, r31
     350:	f0 2d       	mov	r31, r0
     352:	8f c0       	rjmp	.+286    	; 0x472 <vCoRoutineSchedule+0x1ce>
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     354:	40 91 12 01 	lds	r20, 0x0112
     358:	50 91 13 01 	lds	r21, 0x0113
     35c:	60 91 14 01 	lds	r22, 0x0114
     360:	70 91 15 01 	lds	r23, 0x0115
     364:	4f 5f       	subi	r20, 0xFF	; 255
     366:	5f 4f       	sbci	r21, 0xFF	; 255
     368:	6f 4f       	sbci	r22, 0xFF	; 255
     36a:	7f 4f       	sbci	r23, 0xFF	; 255
     36c:	40 93 12 01 	sts	0x0112, r20
     370:	50 93 13 01 	sts	0x0113, r21
     374:	60 93 14 01 	sts	0x0114, r22
     378:	70 93 15 01 	sts	0x0115, r23
		xPassedTicks--;
     37c:	01 97       	sbiw	r24, 0x01	; 1
     37e:	a1 09       	sbc	r26, r1
     380:	b1 09       	sbc	r27, r1
     382:	80 93 0a 01 	sts	0x010A, r24
     386:	90 93 0b 01 	sts	0x010B, r25
     38a:	a0 93 0c 01 	sts	0x010C, r26
     38e:	b0 93 0d 01 	sts	0x010D, r27

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     392:	45 2b       	or	r20, r21
     394:	46 2b       	or	r20, r22
     396:	47 2b       	or	r20, r23
     398:	81 f4       	brne	.+32     	; 0x3ba <vCoRoutineSchedule+0x116>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     39a:	80 91 26 01 	lds	r24, 0x0126
     39e:	90 91 27 01 	lds	r25, 0x0127
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     3a2:	20 91 24 01 	lds	r18, 0x0124
     3a6:	30 91 25 01 	lds	r19, 0x0125
     3aa:	30 93 27 01 	sts	0x0127, r19
     3ae:	20 93 26 01 	sts	0x0126, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
     3b2:	90 93 25 01 	sts	0x0125, r25
     3b6:	80 93 24 01 	sts	0x0124, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     3ba:	e0 91 26 01 	lds	r30, 0x0126
     3be:	f0 91 27 01 	lds	r31, 0x0127
     3c2:	80 81       	ld	r24, Z
     3c4:	88 23       	and	r24, r24
     3c6:	09 f4       	brne	.+2      	; 0x3ca <vCoRoutineSchedule+0x126>
     3c8:	54 c0       	rjmp	.+168    	; 0x472 <vCoRoutineSchedule+0x1ce>
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     3ca:	07 80       	ldd	r0, Z+7	; 0x07
     3cc:	f0 85       	ldd	r31, Z+8	; 0x08
     3ce:	e0 2d       	mov	r30, r0
     3d0:	c0 85       	ldd	r28, Z+8	; 0x08
     3d2:	d1 85       	ldd	r29, Z+9	; 0x09

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     3d4:	4a 81       	ldd	r20, Y+2	; 0x02
     3d6:	5b 81       	ldd	r21, Y+3	; 0x03
     3d8:	6c 81       	ldd	r22, Y+4	; 0x04
     3da:	7d 81       	ldd	r23, Y+5	; 0x05
     3dc:	80 91 12 01 	lds	r24, 0x0112
     3e0:	90 91 13 01 	lds	r25, 0x0113
     3e4:	a0 91 14 01 	lds	r26, 0x0114
     3e8:	b0 91 15 01 	lds	r27, 0x0115
     3ec:	84 17       	cp	r24, r20
     3ee:	95 07       	cpc	r25, r21
     3f0:	a6 07       	cpc	r26, r22
     3f2:	b7 07       	cpc	r27, r23
     3f4:	08 f4       	brcc	.+2      	; 0x3f8 <vCoRoutineSchedule+0x154>
     3f6:	3d c0       	rjmp	.+122    	; 0x472 <vCoRoutineSchedule+0x1ce>
     3f8:	16 c0       	rjmp	.+44     	; 0x426 <vCoRoutineSchedule+0x182>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     3fa:	07 80       	ldd	r0, Z+7	; 0x07
     3fc:	f0 85       	ldd	r31, Z+8	; 0x08
     3fe:	e0 2d       	mov	r30, r0
     400:	c0 85       	ldd	r28, Z+8	; 0x08
     402:	d1 85       	ldd	r29, Z+9	; 0x09

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     404:	4a 81       	ldd	r20, Y+2	; 0x02
     406:	5b 81       	ldd	r21, Y+3	; 0x03
     408:	6c 81       	ldd	r22, Y+4	; 0x04
     40a:	7d 81       	ldd	r23, Y+5	; 0x05
     40c:	80 91 12 01 	lds	r24, 0x0112
     410:	90 91 13 01 	lds	r25, 0x0113
     414:	a0 91 14 01 	lds	r26, 0x0114
     418:	b0 91 15 01 	lds	r27, 0x0115
     41c:	84 17       	cp	r24, r20
     41e:	95 07       	cpc	r25, r21
     420:	a6 07       	cpc	r26, r22
     422:	b7 07       	cpc	r27, r23
     424:	30 f1       	brcs	.+76     	; 0x472 <vCoRoutineSchedule+0x1ce>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
     426:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
     428:	8e 01       	movw	r16, r28
     42a:	0e 5f       	subi	r16, 0xFE	; 254
     42c:	1f 4f       	sbci	r17, 0xFF	; 255
     42e:	c8 01       	movw	r24, r16
     430:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
     434:	88 8d       	ldd	r24, Y+24	; 0x18
     436:	99 8d       	ldd	r25, Y+25	; 0x19
     438:	89 2b       	or	r24, r25
     43a:	21 f0       	breq	.+8      	; 0x444 <vCoRoutineSchedule+0x1a0>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
     43c:	ce 01       	movw	r24, r28
     43e:	0e 96       	adiw	r24, 0x0e	; 14
     440:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     444:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
     446:	9a 8d       	ldd	r25, Y+26	; 0x1a
     448:	80 91 16 01 	lds	r24, 0x0116
     44c:	89 17       	cp	r24, r25
     44e:	10 f4       	brcc	.+4      	; 0x454 <vCoRoutineSchedule+0x1b0>
     450:	90 93 16 01 	sts	0x0116, r25
     454:	f9 9e       	mul	r15, r25
     456:	c0 01       	movw	r24, r0
     458:	11 24       	eor	r1, r1
     45a:	b8 01       	movw	r22, r16
     45c:	82 5c       	subi	r24, 0xC2	; 194
     45e:	9e 4f       	sbci	r25, 0xFE	; 254
     460:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     464:	e0 91 26 01 	lds	r30, 0x0126
     468:	f0 91 27 01 	lds	r31, 0x0127
     46c:	80 81       	ld	r24, Z
     46e:	81 11       	cpse	r24, r1
     470:	c4 cf       	rjmp	.-120    	; 0x3fa <vCoRoutineSchedule+0x156>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     472:	80 91 0a 01 	lds	r24, 0x010A
     476:	90 91 0b 01 	lds	r25, 0x010B
     47a:	a0 91 0c 01 	lds	r26, 0x010C
     47e:	b0 91 0d 01 	lds	r27, 0x010D
     482:	00 97       	sbiw	r24, 0x00	; 0
     484:	a1 05       	cpc	r26, r1
     486:	b1 05       	cpc	r27, r1
     488:	09 f0       	breq	.+2      	; 0x48c <vCoRoutineSchedule+0x1e8>
     48a:	64 cf       	rjmp	.-312    	; 0x354 <vCoRoutineSchedule+0xb0>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
     48c:	80 91 12 01 	lds	r24, 0x0112
     490:	90 91 13 01 	lds	r25, 0x0113
     494:	a0 91 14 01 	lds	r26, 0x0114
     498:	b0 91 15 01 	lds	r27, 0x0115
     49c:	80 93 0e 01 	sts	0x010E, r24
     4a0:	90 93 0f 01 	sts	0x010F, r25
     4a4:	a0 93 10 01 	sts	0x0110, r26
     4a8:	b0 93 11 01 	sts	0x0111, r27

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     4ac:	80 91 16 01 	lds	r24, 0x0116
     4b0:	28 2f       	mov	r18, r24
     4b2:	30 e0       	ldi	r19, 0x00	; 0
     4b4:	9b e0       	ldi	r25, 0x0B	; 11
     4b6:	89 9f       	mul	r24, r25
     4b8:	f0 01       	movw	r30, r0
     4ba:	11 24       	eor	r1, r1
     4bc:	e2 5c       	subi	r30, 0xC2	; 194
     4be:	fe 4f       	sbci	r31, 0xFE	; 254
     4c0:	90 81       	ld	r25, Z
     4c2:	91 11       	cpse	r25, r1
     4c4:	19 c0       	rjmp	.+50     	; 0x4f8 <vCoRoutineSchedule+0x254>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     4c6:	88 23       	and	r24, r24
     4c8:	09 f4       	brne	.+2      	; 0x4cc <vCoRoutineSchedule+0x228>
     4ca:	4c c0       	rjmp	.+152    	; 0x564 <vCoRoutineSchedule+0x2c0>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     4cc:	4b e0       	ldi	r20, 0x0B	; 11
     4ce:	05 c0       	rjmp	.+10     	; 0x4da <vCoRoutineSchedule+0x236>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     4d0:	81 11       	cpse	r24, r1
     4d2:	03 c0       	rjmp	.+6      	; 0x4da <vCoRoutineSchedule+0x236>
     4d4:	10 92 16 01 	sts	0x0116, r1
     4d8:	45 c0       	rjmp	.+138    	; 0x564 <vCoRoutineSchedule+0x2c0>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     4da:	81 50       	subi	r24, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     4dc:	28 2f       	mov	r18, r24
     4de:	30 e0       	ldi	r19, 0x00	; 0
     4e0:	42 9f       	mul	r20, r18
     4e2:	f0 01       	movw	r30, r0
     4e4:	43 9f       	mul	r20, r19
     4e6:	f0 0d       	add	r31, r0
     4e8:	11 24       	eor	r1, r1
     4ea:	e2 5c       	subi	r30, 0xC2	; 194
     4ec:	fe 4f       	sbci	r31, 0xFE	; 254
     4ee:	90 81       	ld	r25, Z
     4f0:	99 23       	and	r25, r25
     4f2:	71 f3       	breq	.-36     	; 0x4d0 <vCoRoutineSchedule+0x22c>
     4f4:	80 93 16 01 	sts	0x0116, r24
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     4f8:	4b e0       	ldi	r20, 0x0B	; 11
     4fa:	42 9f       	mul	r20, r18
     4fc:	c0 01       	movw	r24, r0
     4fe:	43 9f       	mul	r20, r19
     500:	90 0d       	add	r25, r0
     502:	11 24       	eor	r1, r1
     504:	dc 01       	movw	r26, r24
     506:	a2 5c       	subi	r26, 0xC2	; 194
     508:	be 4f       	sbci	r27, 0xFE	; 254
     50a:	11 96       	adiw	r26, 0x01	; 1
     50c:	ed 91       	ld	r30, X+
     50e:	fc 91       	ld	r31, X
     510:	12 97       	sbiw	r26, 0x02	; 2
     512:	04 80       	ldd	r0, Z+4	; 0x04
     514:	f5 81       	ldd	r31, Z+5	; 0x05
     516:	e0 2d       	mov	r30, r0
     518:	12 96       	adiw	r26, 0x02	; 2
     51a:	fc 93       	st	X, r31
     51c:	ee 93       	st	-X, r30
     51e:	11 97       	sbiw	r26, 0x01	; 1
     520:	8f 5b       	subi	r24, 0xBF	; 191
     522:	9e 4f       	sbci	r25, 0xFE	; 254
     524:	e8 17       	cp	r30, r24
     526:	f9 07       	cpc	r31, r25
     528:	29 f4       	brne	.+10     	; 0x534 <vCoRoutineSchedule+0x290>
     52a:	84 81       	ldd	r24, Z+4	; 0x04
     52c:	95 81       	ldd	r25, Z+5	; 0x05
     52e:	fd 01       	movw	r30, r26
     530:	92 83       	std	Z+2, r25	; 0x02
     532:	81 83       	std	Z+1, r24	; 0x01
     534:	8b e0       	ldi	r24, 0x0B	; 11
     536:	82 9f       	mul	r24, r18
     538:	f0 01       	movw	r30, r0
     53a:	83 9f       	mul	r24, r19
     53c:	f0 0d       	add	r31, r0
     53e:	11 24       	eor	r1, r1
     540:	e2 5c       	subi	r30, 0xC2	; 194
     542:	fe 4f       	sbci	r31, 0xFE	; 254
     544:	01 80       	ldd	r0, Z+1	; 0x01
     546:	f2 81       	ldd	r31, Z+2	; 0x02
     548:	e0 2d       	mov	r30, r0
     54a:	80 85       	ldd	r24, Z+8	; 0x08
     54c:	91 85       	ldd	r25, Z+9	; 0x09
     54e:	90 93 18 01 	sts	0x0118, r25
     552:	80 93 17 01 	sts	0x0117, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     556:	dc 01       	movw	r26, r24
     558:	ed 91       	ld	r30, X+
     55a:	fc 91       	ld	r31, X
     55c:	11 97       	sbiw	r26, 0x01	; 1
     55e:	5b 96       	adiw	r26, 0x1b	; 27
     560:	6c 91       	ld	r22, X
     562:	09 95       	icall

	return;
}
     564:	df 91       	pop	r29
     566:	cf 91       	pop	r28
     568:	1f 91       	pop	r17
     56a:	0f 91       	pop	r16
     56c:	ff 90       	pop	r15
     56e:	ef 90       	pop	r14
     570:	df 90       	pop	r13
     572:	08 95       	ret

00000574 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
     574:	0f 93       	push	r16
     576:	1f 93       	push	r17
     578:	cf 93       	push	r28
     57a:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     57c:	dc 01       	movw	r26, r24
     57e:	17 96       	adiw	r26, 0x07	; 7
     580:	ed 91       	ld	r30, X+
     582:	fc 91       	ld	r31, X
     584:	18 97       	sbiw	r26, 0x08	; 8
     586:	c0 85       	ldd	r28, Z+8	; 0x08
     588:	d1 85       	ldd	r29, Z+9	; 0x09
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     58a:	8e 01       	movw	r16, r28
     58c:	02 5f       	subi	r16, 0xF2	; 242
     58e:	1f 4f       	sbci	r17, 0xFF	; 255
     590:	c8 01       	movw	r24, r16
     592:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     596:	b8 01       	movw	r22, r16
     598:	89 e1       	ldi	r24, 0x19	; 25
     59a:	91 e0       	ldi	r25, 0x01	; 1
     59c:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     5a0:	e0 91 17 01 	lds	r30, 0x0117
     5a4:	f0 91 18 01 	lds	r31, 0x0118
     5a8:	81 e0       	ldi	r24, 0x01	; 1
     5aa:	2a 8d       	ldd	r18, Y+26	; 0x1a
     5ac:	92 8d       	ldd	r25, Z+26	; 0x1a
     5ae:	29 17       	cp	r18, r25
     5b0:	08 f4       	brcc	.+2      	; 0x5b4 <xCoRoutineRemoveFromEventList+0x40>
     5b2:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     5b4:	df 91       	pop	r29
     5b6:	cf 91       	pop	r28
     5b8:	1f 91       	pop	r17
     5ba:	0f 91       	pop	r16
     5bc:	08 95       	ret

000005be <xEventGroupCreate>:
static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );

/*-----------------------------------------------------------*/

EventGroupHandle_t xEventGroupCreate( void )
{
     5be:	cf 93       	push	r28
     5c0:	df 93       	push	r29
EventGroup_t *pxEventBits;

	pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
     5c2:	8f e0       	ldi	r24, 0x0F	; 15
     5c4:	90 e0       	ldi	r25, 0x00	; 0
     5c6:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <pvPortMalloc>
     5ca:	ec 01       	movw	r28, r24
	if( pxEventBits != NULL )
     5cc:	00 97       	sbiw	r24, 0x00	; 0
     5ce:	41 f0       	breq	.+16     	; 0x5e0 <xEventGroupCreate+0x22>
	{
		pxEventBits->uxEventBits = 0;
     5d0:	fc 01       	movw	r30, r24
     5d2:	11 92       	st	Z+, r1
     5d4:	11 92       	st	Z+, r1
     5d6:	11 92       	st	Z+, r1
     5d8:	11 92       	st	Z+, r1
     5da:	cf 01       	movw	r24, r30
		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     5dc:	0e 94 41 05 	call	0xa82	; 0xa82 <vListInitialise>
	{
		traceEVENT_GROUP_CREATE_FAILED();
	}

	return ( EventGroupHandle_t ) pxEventBits;
}
     5e0:	ce 01       	movw	r24, r28
     5e2:	df 91       	pop	r29
     5e4:	cf 91       	pop	r28
     5e6:	08 95       	ret

000005e8 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     5e8:	2f 92       	push	r2
     5ea:	3f 92       	push	r3
     5ec:	4f 92       	push	r4
     5ee:	5f 92       	push	r5
     5f0:	6f 92       	push	r6
     5f2:	7f 92       	push	r7
     5f4:	8f 92       	push	r8
     5f6:	9f 92       	push	r9
     5f8:	af 92       	push	r10
     5fa:	bf 92       	push	r11
     5fc:	cf 92       	push	r12
     5fe:	df 92       	push	r13
     600:	ef 92       	push	r14
     602:	ff 92       	push	r15
     604:	0f 93       	push	r16
     606:	1f 93       	push	r17
     608:	cf 93       	push	r28
     60a:	df 93       	push	r29
     60c:	ec 01       	movw	r28, r24
     60e:	4a 01       	movw	r8, r20
     610:	5b 01       	movw	r10, r22
     612:	62 2e       	mov	r6, r18
     614:	70 2e       	mov	r7, r16
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     616:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     61a:	28 80       	ld	r2, Y
     61c:	39 80       	ldd	r3, Y+1	; 0x01
     61e:	4a 80       	ldd	r4, Y+2	; 0x02
     620:	5b 80       	ldd	r5, Y+3	; 0x03

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
     622:	01 11       	cpse	r16, r1
     624:	0d c0       	rjmp	.+26     	; 0x640 <xEventGroupWaitBits+0x58>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     626:	81 e0       	ldi	r24, 0x01	; 1
     628:	b5 01       	movw	r22, r10
     62a:	a4 01       	movw	r20, r8
     62c:	42 21       	and	r20, r2
     62e:	53 21       	and	r21, r3
     630:	64 21       	and	r22, r4
     632:	75 21       	and	r23, r5
     634:	45 2b       	or	r20, r21
     636:	46 2b       	or	r20, r22
     638:	47 2b       	or	r20, r23
     63a:	79 f4       	brne	.+30     	; 0x65a <xEventGroupWaitBits+0x72>
     63c:	80 e0       	ldi	r24, 0x00	; 0
     63e:	0d c0       	rjmp	.+26     	; 0x65a <xEventGroupWaitBits+0x72>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     640:	81 e0       	ldi	r24, 0x01	; 1
     642:	b5 01       	movw	r22, r10
     644:	a4 01       	movw	r20, r8
     646:	42 21       	and	r20, r2
     648:	53 21       	and	r21, r3
     64a:	64 21       	and	r22, r4
     64c:	75 21       	and	r23, r5
     64e:	84 16       	cp	r8, r20
     650:	95 06       	cpc	r9, r21
     652:	a6 06       	cpc	r10, r22
     654:	b7 06       	cpc	r11, r23
     656:	09 f0       	breq	.+2      	; 0x65a <xEventGroupWaitBits+0x72>
     658:	80 e0       	ldi	r24, 0x00	; 0
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );

		if( xWaitConditionMet != pdFALSE )
     65a:	88 23       	and	r24, r24
     65c:	81 f0       	breq	.+32     	; 0x67e <xEventGroupWaitBits+0x96>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     65e:	66 20       	and	r6, r6
     660:	09 f4       	brne	.+2      	; 0x664 <xEventGroupWaitBits+0x7c>
     662:	6c c0       	rjmp	.+216    	; 0x73c <xEventGroupWaitBits+0x154>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     664:	80 94       	com	r8
     666:	90 94       	com	r9
     668:	a0 94       	com	r10
     66a:	b0 94       	com	r11
     66c:	82 20       	and	r8, r2
     66e:	93 20       	and	r9, r3
     670:	a4 20       	and	r10, r4
     672:	b5 20       	and	r11, r5
     674:	88 82       	st	Y, r8
     676:	99 82       	std	Y+1, r9	; 0x01
     678:	aa 82       	std	Y+2, r10	; 0x02
     67a:	bb 82       	std	Y+3, r11	; 0x03
     67c:	5f c0       	rjmp	.+190    	; 0x73c <xEventGroupWaitBits+0x154>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     67e:	c1 14       	cp	r12, r1
     680:	d1 04       	cpc	r13, r1
     682:	e1 04       	cpc	r14, r1
     684:	f1 04       	cpc	r15, r1
     686:	09 f4       	brne	.+2      	; 0x68a <xEventGroupWaitBits+0xa2>
     688:	59 c0       	rjmp	.+178    	; 0x73c <xEventGroupWaitBits+0x154>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     68a:	66 20       	and	r6, r6
     68c:	29 f0       	breq	.+10     	; 0x698 <xEventGroupWaitBits+0xb0>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     68e:	40 e0       	ldi	r20, 0x00	; 0
     690:	50 e0       	ldi	r21, 0x00	; 0
     692:	60 e0       	ldi	r22, 0x00	; 0
     694:	71 e0       	ldi	r23, 0x01	; 1
     696:	03 c0       	rjmp	.+6      	; 0x69e <xEventGroupWaitBits+0xb6>
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
     698:	40 e0       	ldi	r20, 0x00	; 0
     69a:	50 e0       	ldi	r21, 0x00	; 0
     69c:	ba 01       	movw	r22, r20
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     69e:	71 10       	cpse	r7, r1
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     6a0:	74 60       	ori	r23, 0x04	; 4
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     6a2:	48 29       	or	r20, r8
     6a4:	59 29       	or	r21, r9
     6a6:	6a 29       	or	r22, r10
     6a8:	7b 29       	or	r23, r11
     6aa:	97 01       	movw	r18, r14
     6ac:	86 01       	movw	r16, r12
     6ae:	ce 01       	movw	r24, r28
     6b0:	04 96       	adiw	r24, 0x04	; 4
     6b2:	0e 94 51 11 	call	0x22a2	; 0x22a2 <vTaskPlaceOnUnorderedEventList>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     6b6:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
     6ba:	81 11       	cpse	r24, r1
     6bc:	02 c0       	rjmp	.+4      	; 0x6c2 <xEventGroupWaitBits+0xda>
		{
			portYIELD_WITHIN_API();
     6be:	0e 94 81 06 	call	0xd02	; 0xd02 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     6c2:	0e 94 8e 12 	call	0x251c	; 0x251c <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     6c6:	91 fd       	sbrc	r25, 1
     6c8:	35 c0       	rjmp	.+106    	; 0x734 <xEventGroupWaitBits+0x14c>
		{
			taskENTER_CRITICAL();
     6ca:	0f b6       	in	r0, 0x3f	; 63
     6cc:	f8 94       	cli
     6ce:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     6d0:	68 81       	ld	r22, Y
     6d2:	79 81       	ldd	r23, Y+1	; 0x01
     6d4:	8a 81       	ldd	r24, Y+2	; 0x02
     6d6:	9b 81       	ldd	r25, Y+3	; 0x03

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
     6d8:	71 10       	cpse	r7, r1
     6da:	0d c0       	rjmp	.+26     	; 0x6f6 <xEventGroupWaitBits+0x10e>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     6dc:	21 e0       	ldi	r18, 0x01	; 1
     6de:	75 01       	movw	r14, r10
     6e0:	64 01       	movw	r12, r8
     6e2:	c6 22       	and	r12, r22
     6e4:	d7 22       	and	r13, r23
     6e6:	e8 22       	and	r14, r24
     6e8:	f9 22       	and	r15, r25
     6ea:	cd 28       	or	r12, r13
     6ec:	ce 28       	or	r12, r14
     6ee:	cf 28       	or	r12, r15
     6f0:	79 f4       	brne	.+30     	; 0x710 <xEventGroupWaitBits+0x128>
     6f2:	20 e0       	ldi	r18, 0x00	; 0
     6f4:	0d c0       	rjmp	.+26     	; 0x710 <xEventGroupWaitBits+0x128>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     6f6:	21 e0       	ldi	r18, 0x01	; 1
     6f8:	75 01       	movw	r14, r10
     6fa:	64 01       	movw	r12, r8
     6fc:	c6 22       	and	r12, r22
     6fe:	d7 22       	and	r13, r23
     700:	e8 22       	and	r14, r24
     702:	f9 22       	and	r15, r25
     704:	8c 14       	cp	r8, r12
     706:	9d 04       	cpc	r9, r13
     708:	ae 04       	cpc	r10, r14
     70a:	bf 04       	cpc	r11, r15
     70c:	09 f0       	breq	.+2      	; 0x710 <xEventGroupWaitBits+0x128>
     70e:	20 e0       	ldi	r18, 0x00	; 0
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     710:	22 23       	and	r18, r18
     712:	71 f0       	breq	.+28     	; 0x730 <xEventGroupWaitBits+0x148>
				{
					if( xClearOnExit != pdFALSE )
     714:	66 20       	and	r6, r6
     716:	61 f0       	breq	.+24     	; 0x730 <xEventGroupWaitBits+0x148>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     718:	80 94       	com	r8
     71a:	90 94       	com	r9
     71c:	a0 94       	com	r10
     71e:	b0 94       	com	r11
     720:	86 22       	and	r8, r22
     722:	97 22       	and	r9, r23
     724:	a8 22       	and	r10, r24
     726:	b9 22       	and	r11, r25
     728:	88 82       	st	Y, r8
     72a:	99 82       	std	Y+1, r9	; 0x01
     72c:	aa 82       	std	Y+2, r10	; 0x02
     72e:	bb 82       	std	Y+3, r11	; 0x03
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     730:	0f 90       	pop	r0
     732:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     734:	1b 01       	movw	r2, r22
     736:	2c 01       	movw	r4, r24
     738:	55 24       	eor	r5, r5
     73a:	02 c0       	rjmp	.+4      	; 0x740 <xEventGroupWaitBits+0x158>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     73c:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <xTaskResumeAll>
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     740:	c2 01       	movw	r24, r4
     742:	b1 01       	movw	r22, r2
     744:	df 91       	pop	r29
     746:	cf 91       	pop	r28
     748:	1f 91       	pop	r17
     74a:	0f 91       	pop	r16
     74c:	ff 90       	pop	r15
     74e:	ef 90       	pop	r14
     750:	df 90       	pop	r13
     752:	cf 90       	pop	r12
     754:	bf 90       	pop	r11
     756:	af 90       	pop	r10
     758:	9f 90       	pop	r9
     75a:	8f 90       	pop	r8
     75c:	7f 90       	pop	r7
     75e:	6f 90       	pop	r6
     760:	5f 90       	pop	r5
     762:	4f 90       	pop	r4
     764:	3f 90       	pop	r3
     766:	2f 90       	pop	r2
     768:	08 95       	ret

0000076a <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     76a:	0f 93       	push	r16
     76c:	1f 93       	push	r17
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     76e:	0f b6       	in	r0, 0x3f	; 63
     770:	f8 94       	cli
     772:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     774:	fc 01       	movw	r30, r24
     776:	00 81       	ld	r16, Z
     778:	11 81       	ldd	r17, Z+1	; 0x01
     77a:	22 81       	ldd	r18, Z+2	; 0x02
     77c:	33 81       	ldd	r19, Z+3	; 0x03

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     77e:	40 95       	com	r20
     780:	50 95       	com	r21
     782:	60 95       	com	r22
     784:	70 95       	com	r23
     786:	40 23       	and	r20, r16
     788:	51 23       	and	r21, r17
     78a:	62 23       	and	r22, r18
     78c:	73 23       	and	r23, r19
     78e:	40 83       	st	Z, r20
     790:	51 83       	std	Z+1, r21	; 0x01
     792:	62 83       	std	Z+2, r22	; 0x02
     794:	73 83       	std	Z+3, r23	; 0x03
	}
	taskEXIT_CRITICAL();
     796:	0f 90       	pop	r0
     798:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     79a:	c9 01       	movw	r24, r18
     79c:	b8 01       	movw	r22, r16
     79e:	1f 91       	pop	r17
     7a0:	0f 91       	pop	r16
     7a2:	08 95       	ret

000007a4 <xEventGroupGetBitsFromISR>:
	{
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     7a4:	fc 01       	movw	r30, r24
     7a6:	60 81       	ld	r22, Z
     7a8:	71 81       	ldd	r23, Z+1	; 0x01
     7aa:	82 81       	ldd	r24, Z+2	; 0x02
     7ac:	93 81       	ldd	r25, Z+3	; 0x03
}
     7ae:	08 95       	ret

000007b0 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     7b0:	4f 92       	push	r4
     7b2:	5f 92       	push	r5
     7b4:	6f 92       	push	r6
     7b6:	7f 92       	push	r7
     7b8:	8f 92       	push	r8
     7ba:	9f 92       	push	r9
     7bc:	af 92       	push	r10
     7be:	bf 92       	push	r11
     7c0:	cf 92       	push	r12
     7c2:	df 92       	push	r13
     7c4:	ef 92       	push	r14
     7c6:	ff 92       	push	r15
     7c8:	0f 93       	push	r16
     7ca:	1f 93       	push	r17
     7cc:	cf 93       	push	r28
     7ce:	df 93       	push	r29
     7d0:	ec 01       	movw	r28, r24
     7d2:	6a 01       	movw	r12, r20
     7d4:	7b 01       	movw	r14, r22
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     7d6:	8c 01       	movw	r16, r24
     7d8:	09 5f       	subi	r16, 0xF9	; 249
     7da:	1f 4f       	sbci	r17, 0xFF	; 255
	vTaskSuspendAll();
     7dc:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     7e0:	eb 85       	ldd	r30, Y+11	; 0x0b
     7e2:	fc 85       	ldd	r31, Y+12	; 0x0c

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     7e4:	88 81       	ld	r24, Y
     7e6:	99 81       	ldd	r25, Y+1	; 0x01
     7e8:	aa 81       	ldd	r26, Y+2	; 0x02
     7ea:	bb 81       	ldd	r27, Y+3	; 0x03
     7ec:	c8 2a       	or	r12, r24
     7ee:	d9 2a       	or	r13, r25
     7f0:	ea 2a       	or	r14, r26
     7f2:	fb 2a       	or	r15, r27
     7f4:	c8 82       	st	Y, r12
     7f6:	d9 82       	std	Y+1, r13	; 0x01
     7f8:	ea 82       	std	Y+2, r14	; 0x02
     7fa:	fb 82       	std	Y+3, r15	; 0x03

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     7fc:	0e 17       	cp	r16, r30
     7fe:	1f 07       	cpc	r17, r31
     800:	09 f4       	brne	.+2      	; 0x804 <xEventGroupSetBits+0x54>
     802:	45 c0       	rjmp	.+138    	; 0x88e <xEventGroupSetBits+0xde>
     804:	c1 2c       	mov	r12, r1
     806:	d1 2c       	mov	r13, r1
     808:	76 01       	movw	r14, r12
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     80a:	99 24       	eor	r9, r9
     80c:	93 94       	inc	r9
     80e:	81 2c       	mov	r8, r1
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     810:	a4 80       	ldd	r10, Z+4	; 0x04
     812:	b5 80       	ldd	r11, Z+5	; 0x05
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     814:	40 81       	ld	r20, Z
     816:	51 81       	ldd	r21, Z+1	; 0x01
     818:	62 81       	ldd	r22, Z+2	; 0x02
     81a:	73 81       	ldd	r23, Z+3	; 0x03
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     81c:	db 01       	movw	r26, r22
     81e:	ca 01       	movw	r24, r20
     820:	bb 27       	eor	r27, r27

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     822:	72 fd       	sbrc	r23, 2
     824:	0f c0       	rjmp	.+30     	; 0x844 <xEventGroupSetBits+0x94>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     826:	48 80       	ld	r4, Y
     828:	59 80       	ldd	r5, Y+1	; 0x01
     82a:	6a 80       	ldd	r6, Y+2	; 0x02
     82c:	7b 80       	ldd	r7, Y+3	; 0x03
     82e:	48 22       	and	r4, r24
     830:	59 22       	and	r5, r25
     832:	6a 22       	and	r6, r26
     834:	7b 22       	and	r7, r27
     836:	29 2d       	mov	r18, r9
     838:	45 28       	or	r4, r5
     83a:	46 28       	or	r4, r6
     83c:	47 28       	or	r4, r7
     83e:	89 f4       	brne	.+34     	; 0x862 <xEventGroupSetBits+0xb2>
     840:	28 2d       	mov	r18, r8
     842:	0f c0       	rjmp	.+30     	; 0x862 <xEventGroupSetBits+0xb2>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     844:	48 80       	ld	r4, Y
     846:	59 80       	ldd	r5, Y+1	; 0x01
     848:	6a 80       	ldd	r6, Y+2	; 0x02
     84a:	7b 80       	ldd	r7, Y+3	; 0x03
     84c:	48 22       	and	r4, r24
     84e:	59 22       	and	r5, r25
     850:	6a 22       	and	r6, r26
     852:	7b 22       	and	r7, r27
     854:	29 2d       	mov	r18, r9
     856:	84 15       	cp	r24, r4
     858:	95 05       	cpc	r25, r5
     85a:	a6 05       	cpc	r26, r6
     85c:	b7 05       	cpc	r27, r7
     85e:	09 f0       	breq	.+2      	; 0x862 <xEventGroupSetBits+0xb2>
     860:	28 2d       	mov	r18, r8
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     862:	22 23       	and	r18, r18
     864:	71 f0       	breq	.+28     	; 0x882 <xEventGroupSetBits+0xd2>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     866:	70 ff       	sbrs	r23, 0
     868:	04 c0       	rjmp	.+8      	; 0x872 <xEventGroupSetBits+0xc2>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     86a:	c8 2a       	or	r12, r24
     86c:	d9 2a       	or	r13, r25
     86e:	ea 2a       	or	r14, r26
     870:	fb 2a       	or	r15, r27
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     872:	48 81       	ld	r20, Y
     874:	59 81       	ldd	r21, Y+1	; 0x01
     876:	6a 81       	ldd	r22, Y+2	; 0x02
     878:	7b 81       	ldd	r23, Y+3	; 0x03
     87a:	72 60       	ori	r23, 0x02	; 2
     87c:	cf 01       	movw	r24, r30
     87e:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <xTaskRemoveFromUnorderedEventList>
     882:	ea 2d       	mov	r30, r10
     884:	fb 2d       	mov	r31, r11

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     886:	0e 17       	cp	r16, r30
     888:	1f 07       	cpc	r17, r31
     88a:	11 f6       	brne	.-124    	; 0x810 <xEventGroupSetBits+0x60>
     88c:	03 c0       	rjmp	.+6      	; 0x894 <xEventGroupSetBits+0xe4>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     88e:	c1 2c       	mov	r12, r1
     890:	d1 2c       	mov	r13, r1
     892:	76 01       	movw	r14, r12
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     894:	c0 94       	com	r12
     896:	d0 94       	com	r13
     898:	e0 94       	com	r14
     89a:	f0 94       	com	r15
     89c:	88 81       	ld	r24, Y
     89e:	99 81       	ldd	r25, Y+1	; 0x01
     8a0:	aa 81       	ldd	r26, Y+2	; 0x02
     8a2:	bb 81       	ldd	r27, Y+3	; 0x03
     8a4:	c8 22       	and	r12, r24
     8a6:	d9 22       	and	r13, r25
     8a8:	ea 22       	and	r14, r26
     8aa:	fb 22       	and	r15, r27
     8ac:	c8 82       	st	Y, r12
     8ae:	d9 82       	std	Y+1, r13	; 0x01
     8b0:	ea 82       	std	Y+2, r14	; 0x02
     8b2:	fb 82       	std	Y+3, r15	; 0x03
	}
	( void ) xTaskResumeAll();
     8b4:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     8b8:	68 81       	ld	r22, Y
     8ba:	79 81       	ldd	r23, Y+1	; 0x01
     8bc:	8a 81       	ldd	r24, Y+2	; 0x02
     8be:	9b 81       	ldd	r25, Y+3	; 0x03
}
     8c0:	df 91       	pop	r29
     8c2:	cf 91       	pop	r28
     8c4:	1f 91       	pop	r17
     8c6:	0f 91       	pop	r16
     8c8:	ff 90       	pop	r15
     8ca:	ef 90       	pop	r14
     8cc:	df 90       	pop	r13
     8ce:	cf 90       	pop	r12
     8d0:	bf 90       	pop	r11
     8d2:	af 90       	pop	r10
     8d4:	9f 90       	pop	r9
     8d6:	8f 90       	pop	r8
     8d8:	7f 90       	pop	r7
     8da:	6f 90       	pop	r6
     8dc:	5f 90       	pop	r5
     8de:	4f 90       	pop	r4
     8e0:	08 95       	ret

000008e2 <xEventGroupSync>:
	return ( EventGroupHandle_t ) pxEventBits;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     8e2:	2f 92       	push	r2
     8e4:	3f 92       	push	r3
     8e6:	4f 92       	push	r4
     8e8:	5f 92       	push	r5
     8ea:	6f 92       	push	r6
     8ec:	7f 92       	push	r7
     8ee:	8f 92       	push	r8
     8f0:	9f 92       	push	r9
     8f2:	af 92       	push	r10
     8f4:	bf 92       	push	r11
     8f6:	cf 92       	push	r12
     8f8:	df 92       	push	r13
     8fa:	ef 92       	push	r14
     8fc:	ff 92       	push	r15
     8fe:	0f 93       	push	r16
     900:	1f 93       	push	r17
     902:	cf 93       	push	r28
     904:	df 93       	push	r29
     906:	00 d0       	rcall	.+0      	; 0x908 <xEventGroupSync+0x26>
     908:	00 d0       	rcall	.+0      	; 0x90a <xEventGroupSync+0x28>
     90a:	cd b7       	in	r28, 0x3d	; 61
     90c:	de b7       	in	r29, 0x3e	; 62
     90e:	1c 01       	movw	r2, r24
     910:	49 83       	std	Y+1, r20	; 0x01
     912:	5a 83       	std	Y+2, r21	; 0x02
     914:	6b 83       	std	Y+3, r22	; 0x03
     916:	7c 83       	std	Y+4, r23	; 0x04
     918:	48 01       	movw	r8, r16
     91a:	59 01       	movw	r10, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     91c:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     920:	d1 01       	movw	r26, r2
     922:	4d 90       	ld	r4, X+
     924:	5d 90       	ld	r5, X+
     926:	6d 90       	ld	r6, X+
     928:	7c 90       	ld	r7, X

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     92a:	49 81       	ldd	r20, Y+1	; 0x01
     92c:	5a 81       	ldd	r21, Y+2	; 0x02
     92e:	6b 81       	ldd	r22, Y+3	; 0x03
     930:	7c 81       	ldd	r23, Y+4	; 0x04
     932:	c1 01       	movw	r24, r2
     934:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     938:	89 81       	ldd	r24, Y+1	; 0x01
     93a:	9a 81       	ldd	r25, Y+2	; 0x02
     93c:	ab 81       	ldd	r26, Y+3	; 0x03
     93e:	bc 81       	ldd	r27, Y+4	; 0x04
     940:	48 2a       	or	r4, r24
     942:	59 2a       	or	r5, r25
     944:	6a 2a       	or	r6, r26
     946:	7b 2a       	or	r7, r27
     948:	d3 01       	movw	r26, r6
     94a:	c2 01       	movw	r24, r4
     94c:	88 21       	and	r24, r8
     94e:	99 21       	and	r25, r9
     950:	aa 21       	and	r26, r10
     952:	bb 21       	and	r27, r11
     954:	88 15       	cp	r24, r8
     956:	99 05       	cpc	r25, r9
     958:	aa 05       	cpc	r26, r10
     95a:	bb 05       	cpc	r27, r11
     95c:	91 f4       	brne	.+36     	; 0x982 <xEventGroupSync+0xa0>
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     95e:	80 95       	com	r24
     960:	90 95       	com	r25
     962:	a0 95       	com	r26
     964:	b0 95       	com	r27
     966:	f1 01       	movw	r30, r2
     968:	40 81       	ld	r20, Z
     96a:	51 81       	ldd	r21, Z+1	; 0x01
     96c:	62 81       	ldd	r22, Z+2	; 0x02
     96e:	73 81       	ldd	r23, Z+3	; 0x03
     970:	84 23       	and	r24, r20
     972:	95 23       	and	r25, r21
     974:	a6 23       	and	r26, r22
     976:	b7 23       	and	r27, r23
     978:	80 83       	st	Z, r24
     97a:	91 83       	std	Z+1, r25	; 0x01
     97c:	a2 83       	std	Z+2, r26	; 0x02
     97e:	b3 83       	std	Z+3, r27	; 0x03
     980:	44 c0       	rjmp	.+136    	; 0xa0a <xEventGroupSync+0x128>

			xTicksToWait = 0;
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     982:	c1 14       	cp	r12, r1
     984:	d1 04       	cpc	r13, r1
     986:	e1 04       	cpc	r14, r1
     988:	f1 04       	cpc	r15, r1
     98a:	71 f0       	breq	.+28     	; 0x9a8 <xEventGroupSync+0xc6>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     98c:	97 01       	movw	r18, r14
     98e:	86 01       	movw	r16, r12
     990:	b5 01       	movw	r22, r10
     992:	a4 01       	movw	r20, r8
     994:	75 60       	ori	r23, 0x05	; 5
     996:	c1 01       	movw	r24, r2
     998:	04 96       	adiw	r24, 0x04	; 4
     99a:	0e 94 51 11 	call	0x22a2	; 0x22a2 <vTaskPlaceOnUnorderedEventList>
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     99e:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
     9a2:	81 11       	cpse	r24, r1
     9a4:	09 c0       	rjmp	.+18     	; 0x9b8 <xEventGroupSync+0xd6>
     9a6:	06 c0       	rjmp	.+12     	; 0x9b4 <xEventGroupSync+0xd2>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     9a8:	d1 01       	movw	r26, r2
     9aa:	4d 90       	ld	r4, X+
     9ac:	5d 90       	ld	r5, X+
     9ae:	6d 90       	ld	r6, X+
     9b0:	7c 90       	ld	r7, X
     9b2:	2b c0       	rjmp	.+86     	; 0xa0a <xEventGroupSync+0x128>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     9b4:	0e 94 81 06 	call	0xd02	; 0xd02 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     9b8:	0e 94 8e 12 	call	0x251c	; 0x251c <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     9bc:	91 fd       	sbrc	r25, 1
     9be:	21 c0       	rjmp	.+66     	; 0xa02 <xEventGroupSync+0x120>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     9c0:	0f b6       	in	r0, 0x3f	; 63
     9c2:	f8 94       	cli
     9c4:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     9c6:	f1 01       	movw	r30, r2
     9c8:	60 81       	ld	r22, Z
     9ca:	71 81       	ldd	r23, Z+1	; 0x01
     9cc:	82 81       	ldd	r24, Z+2	; 0x02
     9ce:	93 81       	ldd	r25, Z+3	; 0x03

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     9d0:	75 01       	movw	r14, r10
     9d2:	64 01       	movw	r12, r8
     9d4:	c6 22       	and	r12, r22
     9d6:	d7 22       	and	r13, r23
     9d8:	e8 22       	and	r14, r24
     9da:	f9 22       	and	r15, r25
     9dc:	c8 14       	cp	r12, r8
     9de:	d9 04       	cpc	r13, r9
     9e0:	ea 04       	cpc	r14, r10
     9e2:	fb 04       	cpc	r15, r11
     9e4:	61 f4       	brne	.+24     	; 0x9fe <xEventGroupSync+0x11c>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     9e6:	c0 94       	com	r12
     9e8:	d0 94       	com	r13
     9ea:	e0 94       	com	r14
     9ec:	f0 94       	com	r15
     9ee:	c6 22       	and	r12, r22
     9f0:	d7 22       	and	r13, r23
     9f2:	e8 22       	and	r14, r24
     9f4:	f9 22       	and	r15, r25
     9f6:	c0 82       	st	Z, r12
     9f8:	d1 82       	std	Z+1, r13	; 0x01
     9fa:	e2 82       	std	Z+2, r14	; 0x02
     9fc:	f3 82       	std	Z+3, r15	; 0x03
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     9fe:	0f 90       	pop	r0
     a00:	0f be       	out	0x3f, r0	; 63
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     a02:	2b 01       	movw	r4, r22
     a04:	3c 01       	movw	r6, r24
     a06:	77 24       	eor	r7, r7
     a08:	02 c0       	rjmp	.+4      	; 0xa0e <xEventGroupSync+0x12c>
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     a0a:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <xTaskResumeAll>
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     a0e:	c3 01       	movw	r24, r6
     a10:	b2 01       	movw	r22, r4
     a12:	0f 90       	pop	r0
     a14:	0f 90       	pop	r0
     a16:	0f 90       	pop	r0
     a18:	0f 90       	pop	r0
     a1a:	df 91       	pop	r29
     a1c:	cf 91       	pop	r28
     a1e:	1f 91       	pop	r17
     a20:	0f 91       	pop	r16
     a22:	ff 90       	pop	r15
     a24:	ef 90       	pop	r14
     a26:	df 90       	pop	r13
     a28:	cf 90       	pop	r12
     a2a:	bf 90       	pop	r11
     a2c:	af 90       	pop	r10
     a2e:	9f 90       	pop	r9
     a30:	8f 90       	pop	r8
     a32:	7f 90       	pop	r7
     a34:	6f 90       	pop	r6
     a36:	5f 90       	pop	r5
     a38:	4f 90       	pop	r4
     a3a:	3f 90       	pop	r3
     a3c:	2f 90       	pop	r2
     a3e:	08 95       	ret

00000a40 <vEventGroupDelete>:
	return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     a40:	cf 93       	push	r28
     a42:	df 93       	push	r29
     a44:	ec 01       	movw	r28, r24
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

	vTaskSuspendAll();
     a46:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     a4a:	8c 81       	ldd	r24, Y+4	; 0x04
     a4c:	88 23       	and	r24, r24
     a4e:	59 f0       	breq	.+22     	; 0xa66 <vEventGroupDelete+0x26>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     a50:	40 e0       	ldi	r20, 0x00	; 0
     a52:	50 e0       	ldi	r21, 0x00	; 0
     a54:	60 e0       	ldi	r22, 0x00	; 0
     a56:	72 e0       	ldi	r23, 0x02	; 2
     a58:	8b 85       	ldd	r24, Y+11	; 0x0b
     a5a:	9c 85       	ldd	r25, Y+12	; 0x0c
     a5c:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     a60:	8c 81       	ldd	r24, Y+4	; 0x04
     a62:	81 11       	cpse	r24, r1
     a64:	f5 cf       	rjmp	.-22     	; 0xa50 <vEventGroupDelete+0x10>
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
		}

		vPortFree( pxEventBits );
     a66:	ce 01       	movw	r24, r28
     a68:	0e 94 8f 07 	call	0xf1e	; 0xf1e <vPortFree>
	}
	( void ) xTaskResumeAll();
     a6c:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <xTaskResumeAll>
}
     a70:	df 91       	pop	r29
     a72:	cf 91       	pop	r28
     a74:	08 95       	ret

00000a76 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
     a76:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <xEventGroupSetBits>
     a7a:	08 95       	ret

00000a7c <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
     a7c:	0e 94 b5 03 	call	0x76a	; 0x76a <xEventGroupClearBits>
     a80:	08 95       	ret

00000a82 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     a82:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a84:	03 96       	adiw	r24, 0x03	; 3
     a86:	92 83       	std	Z+2, r25	; 0x02
     a88:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     a8a:	4f ef       	ldi	r20, 0xFF	; 255
     a8c:	5f ef       	ldi	r21, 0xFF	; 255
     a8e:	ba 01       	movw	r22, r20
     a90:	43 83       	std	Z+3, r20	; 0x03
     a92:	54 83       	std	Z+4, r21	; 0x04
     a94:	65 83       	std	Z+5, r22	; 0x05
     a96:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a98:	90 87       	std	Z+8, r25	; 0x08
     a9a:	87 83       	std	Z+7, r24	; 0x07
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a9c:	92 87       	std	Z+10, r25	; 0x0a
     a9e:	81 87       	std	Z+9, r24	; 0x09

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     aa0:	10 82       	st	Z, r1
     aa2:	08 95       	ret

00000aa4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     aa4:	fc 01       	movw	r30, r24
     aa6:	13 86       	std	Z+11, r1	; 0x0b
     aa8:	12 86       	std	Z+10, r1	; 0x0a
     aaa:	08 95       	ret

00000aac <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     aac:	cf 93       	push	r28
     aae:	df 93       	push	r29
     ab0:	9c 01       	movw	r18, r24
     ab2:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     ab4:	dc 01       	movw	r26, r24
     ab6:	11 96       	adiw	r26, 0x01	; 1
     ab8:	cd 91       	ld	r28, X+
     aba:	dc 91       	ld	r29, X
     abc:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     abe:	d5 83       	std	Z+5, r29	; 0x05
     ac0:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     ac2:	8e 81       	ldd	r24, Y+6	; 0x06
     ac4:	9f 81       	ldd	r25, Y+7	; 0x07
     ac6:	97 83       	std	Z+7, r25	; 0x07
     ac8:	86 83       	std	Z+6, r24	; 0x06

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     aca:	8e 81       	ldd	r24, Y+6	; 0x06
     acc:	9f 81       	ldd	r25, Y+7	; 0x07
     ace:	dc 01       	movw	r26, r24
     ad0:	15 96       	adiw	r26, 0x05	; 5
     ad2:	7c 93       	st	X, r23
     ad4:	6e 93       	st	-X, r22
     ad6:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxPrevious = pxNewListItem;
     ad8:	7f 83       	std	Y+7, r23	; 0x07
     ada:	6e 83       	std	Y+6, r22	; 0x06

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     adc:	33 87       	std	Z+11, r19	; 0x0b
     ade:	22 87       	std	Z+10, r18	; 0x0a

	( pxList->uxNumberOfItems )++;
     ae0:	f9 01       	movw	r30, r18
     ae2:	80 81       	ld	r24, Z
     ae4:	8f 5f       	subi	r24, 0xFF	; 255
     ae6:	80 83       	st	Z, r24
}
     ae8:	df 91       	pop	r29
     aea:	cf 91       	pop	r28
     aec:	08 95       	ret

00000aee <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     aee:	0f 93       	push	r16
     af0:	1f 93       	push	r17
     af2:	cf 93       	push	r28
     af4:	df 93       	push	r29
     af6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     af8:	08 81       	ld	r16, Y
     afa:	19 81       	ldd	r17, Y+1	; 0x01
     afc:	2a 81       	ldd	r18, Y+2	; 0x02
     afe:	3b 81       	ldd	r19, Y+3	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     b00:	0f 3f       	cpi	r16, 0xFF	; 255
     b02:	4f ef       	ldi	r20, 0xFF	; 255
     b04:	14 07       	cpc	r17, r20
     b06:	24 07       	cpc	r18, r20
     b08:	34 07       	cpc	r19, r20
     b0a:	21 f4       	brne	.+8      	; 0xb14 <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     b0c:	fc 01       	movw	r30, r24
     b0e:	a1 85       	ldd	r26, Z+9	; 0x09
     b10:	b2 85       	ldd	r27, Z+10	; 0x0a
     b12:	11 c0       	rjmp	.+34     	; 0xb36 <vListInsert+0x48>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b14:	dc 01       	movw	r26, r24
     b16:	13 96       	adiw	r26, 0x03	; 3
     b18:	01 c0       	rjmp	.+2      	; 0xb1c <vListInsert+0x2e>
     b1a:	df 01       	movw	r26, r30
     b1c:	14 96       	adiw	r26, 0x04	; 4
     b1e:	ed 91       	ld	r30, X+
     b20:	fc 91       	ld	r31, X
     b22:	15 97       	sbiw	r26, 0x05	; 5
     b24:	40 81       	ld	r20, Z
     b26:	51 81       	ldd	r21, Z+1	; 0x01
     b28:	62 81       	ldd	r22, Z+2	; 0x02
     b2a:	73 81       	ldd	r23, Z+3	; 0x03
     b2c:	04 17       	cp	r16, r20
     b2e:	15 07       	cpc	r17, r21
     b30:	26 07       	cpc	r18, r22
     b32:	37 07       	cpc	r19, r23
     b34:	90 f7       	brcc	.-28     	; 0xb1a <vListInsert+0x2c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     b36:	14 96       	adiw	r26, 0x04	; 4
     b38:	ed 91       	ld	r30, X+
     b3a:	fc 91       	ld	r31, X
     b3c:	15 97       	sbiw	r26, 0x05	; 5
     b3e:	fd 83       	std	Y+5, r31	; 0x05
     b40:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     b42:	d7 83       	std	Z+7, r29	; 0x07
     b44:	c6 83       	std	Z+6, r28	; 0x06
	pxNewListItem->pxPrevious = pxIterator;
     b46:	bf 83       	std	Y+7, r27	; 0x07
     b48:	ae 83       	std	Y+6, r26	; 0x06
	pxIterator->pxNext = pxNewListItem;
     b4a:	15 96       	adiw	r26, 0x05	; 5
     b4c:	dc 93       	st	X, r29
     b4e:	ce 93       	st	-X, r28
     b50:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     b52:	9b 87       	std	Y+11, r25	; 0x0b
     b54:	8a 87       	std	Y+10, r24	; 0x0a

	( pxList->uxNumberOfItems )++;
     b56:	fc 01       	movw	r30, r24
     b58:	20 81       	ld	r18, Z
     b5a:	2f 5f       	subi	r18, 0xFF	; 255
     b5c:	20 83       	st	Z, r18
}
     b5e:	df 91       	pop	r29
     b60:	cf 91       	pop	r28
     b62:	1f 91       	pop	r17
     b64:	0f 91       	pop	r16
     b66:	08 95       	ret

00000b68 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     b68:	cf 93       	push	r28
     b6a:	df 93       	push	r29
     b6c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     b6e:	a2 85       	ldd	r26, Z+10	; 0x0a
     b70:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     b72:	c4 81       	ldd	r28, Z+4	; 0x04
     b74:	d5 81       	ldd	r29, Z+5	; 0x05
     b76:	86 81       	ldd	r24, Z+6	; 0x06
     b78:	97 81       	ldd	r25, Z+7	; 0x07
     b7a:	9f 83       	std	Y+7, r25	; 0x07
     b7c:	8e 83       	std	Y+6, r24	; 0x06
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     b7e:	c6 81       	ldd	r28, Z+6	; 0x06
     b80:	d7 81       	ldd	r29, Z+7	; 0x07
     b82:	84 81       	ldd	r24, Z+4	; 0x04
     b84:	95 81       	ldd	r25, Z+5	; 0x05
     b86:	9d 83       	std	Y+5, r25	; 0x05
     b88:	8c 83       	std	Y+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     b8a:	11 96       	adiw	r26, 0x01	; 1
     b8c:	cd 91       	ld	r28, X+
     b8e:	dc 91       	ld	r29, X
     b90:	12 97       	sbiw	r26, 0x02	; 2
     b92:	ce 17       	cp	r28, r30
     b94:	df 07       	cpc	r29, r31
     b96:	31 f4       	brne	.+12     	; 0xba4 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     b98:	8e 81       	ldd	r24, Y+6	; 0x06
     b9a:	9f 81       	ldd	r25, Y+7	; 0x07
     b9c:	12 96       	adiw	r26, 0x02	; 2
     b9e:	9c 93       	st	X, r25
     ba0:	8e 93       	st	-X, r24
     ba2:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     ba4:	13 86       	std	Z+11, r1	; 0x0b
     ba6:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
     ba8:	8c 91       	ld	r24, X
     baa:	81 50       	subi	r24, 0x01	; 1
     bac:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     bae:	df 91       	pop	r29
     bb0:	cf 91       	pop	r28
     bb2:	08 95       	ret

00000bb4 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     bb4:	31 e1       	ldi	r19, 0x11	; 17
     bb6:	fc 01       	movw	r30, r24
     bb8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     bba:	31 97       	sbiw	r30, 0x01	; 1
     bbc:	22 e2       	ldi	r18, 0x22	; 34
     bbe:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     bc0:	31 97       	sbiw	r30, 0x01	; 1
     bc2:	a3 e3       	ldi	r26, 0x33	; 51
     bc4:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     bc6:	31 97       	sbiw	r30, 0x01	; 1
     bc8:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     bca:	31 97       	sbiw	r30, 0x01	; 1
     bcc:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     bce:	31 97       	sbiw	r30, 0x01	; 1
     bd0:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     bd2:	31 97       	sbiw	r30, 0x01	; 1
     bd4:	60 e8       	ldi	r22, 0x80	; 128
     bd6:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     bd8:	31 97       	sbiw	r30, 0x01	; 1
     bda:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     bdc:	31 97       	sbiw	r30, 0x01	; 1
     bde:	62 e0       	ldi	r22, 0x02	; 2
     be0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     be2:	31 97       	sbiw	r30, 0x01	; 1
     be4:	63 e0       	ldi	r22, 0x03	; 3
     be6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     be8:	31 97       	sbiw	r30, 0x01	; 1
     bea:	64 e0       	ldi	r22, 0x04	; 4
     bec:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     bee:	31 97       	sbiw	r30, 0x01	; 1
     bf0:	65 e0       	ldi	r22, 0x05	; 5
     bf2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     bf4:	31 97       	sbiw	r30, 0x01	; 1
     bf6:	66 e0       	ldi	r22, 0x06	; 6
     bf8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     bfa:	31 97       	sbiw	r30, 0x01	; 1
     bfc:	67 e0       	ldi	r22, 0x07	; 7
     bfe:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     c00:	31 97       	sbiw	r30, 0x01	; 1
     c02:	68 e0       	ldi	r22, 0x08	; 8
     c04:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     c06:	31 97       	sbiw	r30, 0x01	; 1
     c08:	69 e0       	ldi	r22, 0x09	; 9
     c0a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     c0c:	31 97       	sbiw	r30, 0x01	; 1
     c0e:	60 e1       	ldi	r22, 0x10	; 16
     c10:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     c12:	31 97       	sbiw	r30, 0x01	; 1
     c14:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     c16:	31 97       	sbiw	r30, 0x01	; 1
     c18:	32 e1       	ldi	r19, 0x12	; 18
     c1a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     c1c:	31 97       	sbiw	r30, 0x01	; 1
     c1e:	33 e1       	ldi	r19, 0x13	; 19
     c20:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     c22:	31 97       	sbiw	r30, 0x01	; 1
     c24:	34 e1       	ldi	r19, 0x14	; 20
     c26:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     c28:	31 97       	sbiw	r30, 0x01	; 1
     c2a:	35 e1       	ldi	r19, 0x15	; 21
     c2c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     c2e:	31 97       	sbiw	r30, 0x01	; 1
     c30:	36 e1       	ldi	r19, 0x16	; 22
     c32:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     c34:	31 97       	sbiw	r30, 0x01	; 1
     c36:	37 e1       	ldi	r19, 0x17	; 23
     c38:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     c3a:	31 97       	sbiw	r30, 0x01	; 1
     c3c:	38 e1       	ldi	r19, 0x18	; 24
     c3e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     c40:	31 97       	sbiw	r30, 0x01	; 1
     c42:	39 e1       	ldi	r19, 0x19	; 25
     c44:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     c46:	31 97       	sbiw	r30, 0x01	; 1
     c48:	30 e2       	ldi	r19, 0x20	; 32
     c4a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     c4c:	31 97       	sbiw	r30, 0x01	; 1
     c4e:	31 e2       	ldi	r19, 0x21	; 33
     c50:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     c52:	31 97       	sbiw	r30, 0x01	; 1
     c54:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     c56:	31 97       	sbiw	r30, 0x01	; 1
     c58:	23 e2       	ldi	r18, 0x23	; 35
     c5a:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     c5c:	31 97       	sbiw	r30, 0x01	; 1
     c5e:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     c60:	31 97       	sbiw	r30, 0x01	; 1
     c62:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     c64:	31 97       	sbiw	r30, 0x01	; 1
     c66:	26 e2       	ldi	r18, 0x26	; 38
     c68:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     c6a:	31 97       	sbiw	r30, 0x01	; 1
     c6c:	27 e2       	ldi	r18, 0x27	; 39
     c6e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     c70:	31 97       	sbiw	r30, 0x01	; 1
     c72:	28 e2       	ldi	r18, 0x28	; 40
     c74:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     c76:	31 97       	sbiw	r30, 0x01	; 1
     c78:	29 e2       	ldi	r18, 0x29	; 41
     c7a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     c7c:	31 97       	sbiw	r30, 0x01	; 1
     c7e:	20 e3       	ldi	r18, 0x30	; 48
     c80:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     c82:	31 97       	sbiw	r30, 0x01	; 1
     c84:	21 e3       	ldi	r18, 0x31	; 49
     c86:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     c88:	86 97       	sbiw	r24, 0x26	; 38
     c8a:	08 95       	ret

00000c8c <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     c8c:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
     c90:	89 ef       	ldi	r24, 0xF9	; 249
     c92:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     c96:	8b e0       	ldi	r24, 0x0B	; 11
     c98:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
     c9c:	ef e6       	ldi	r30, 0x6F	; 111
     c9e:	f0 e0       	ldi	r31, 0x00	; 0
     ca0:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     ca2:	80 61       	ori	r24, 0x10	; 16
	TIMSK1 = ucLowByte;
     ca4:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     ca6:	a0 91 7f 07 	lds	r26, 0x077F
     caa:	b0 91 80 07 	lds	r27, 0x0780
     cae:	cd 91       	ld	r28, X+
     cb0:	cd bf       	out	0x3d, r28	; 61
     cb2:	dd 91       	ld	r29, X+
     cb4:	de bf       	out	0x3e, r29	; 62
     cb6:	ff 91       	pop	r31
     cb8:	ef 91       	pop	r30
     cba:	df 91       	pop	r29
     cbc:	cf 91       	pop	r28
     cbe:	bf 91       	pop	r27
     cc0:	af 91       	pop	r26
     cc2:	9f 91       	pop	r25
     cc4:	8f 91       	pop	r24
     cc6:	7f 91       	pop	r23
     cc8:	6f 91       	pop	r22
     cca:	5f 91       	pop	r21
     ccc:	4f 91       	pop	r20
     cce:	3f 91       	pop	r19
     cd0:	2f 91       	pop	r18
     cd2:	1f 91       	pop	r17
     cd4:	0f 91       	pop	r16
     cd6:	ff 90       	pop	r15
     cd8:	ef 90       	pop	r14
     cda:	df 90       	pop	r13
     cdc:	cf 90       	pop	r12
     cde:	bf 90       	pop	r11
     ce0:	af 90       	pop	r10
     ce2:	9f 90       	pop	r9
     ce4:	8f 90       	pop	r8
     ce6:	7f 90       	pop	r7
     ce8:	6f 90       	pop	r6
     cea:	5f 90       	pop	r5
     cec:	4f 90       	pop	r4
     cee:	3f 90       	pop	r3
     cf0:	2f 90       	pop	r2
     cf2:	1f 90       	pop	r1
     cf4:	0f 90       	pop	r0
     cf6:	0f be       	out	0x3f, r0	; 63
     cf8:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     cfa:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     cfc:	81 e0       	ldi	r24, 0x01	; 1
     cfe:	08 95       	ret

00000d00 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     d00:	08 95       	ret

00000d02 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     d02:	0f 92       	push	r0
     d04:	0f b6       	in	r0, 0x3f	; 63
     d06:	f8 94       	cli
     d08:	0f 92       	push	r0
     d0a:	1f 92       	push	r1
     d0c:	11 24       	eor	r1, r1
     d0e:	2f 92       	push	r2
     d10:	3f 92       	push	r3
     d12:	4f 92       	push	r4
     d14:	5f 92       	push	r5
     d16:	6f 92       	push	r6
     d18:	7f 92       	push	r7
     d1a:	8f 92       	push	r8
     d1c:	9f 92       	push	r9
     d1e:	af 92       	push	r10
     d20:	bf 92       	push	r11
     d22:	cf 92       	push	r12
     d24:	df 92       	push	r13
     d26:	ef 92       	push	r14
     d28:	ff 92       	push	r15
     d2a:	0f 93       	push	r16
     d2c:	1f 93       	push	r17
     d2e:	2f 93       	push	r18
     d30:	3f 93       	push	r19
     d32:	4f 93       	push	r20
     d34:	5f 93       	push	r21
     d36:	6f 93       	push	r22
     d38:	7f 93       	push	r23
     d3a:	8f 93       	push	r24
     d3c:	9f 93       	push	r25
     d3e:	af 93       	push	r26
     d40:	bf 93       	push	r27
     d42:	cf 93       	push	r28
     d44:	df 93       	push	r29
     d46:	ef 93       	push	r30
     d48:	ff 93       	push	r31
     d4a:	a0 91 7f 07 	lds	r26, 0x077F
     d4e:	b0 91 80 07 	lds	r27, 0x0780
     d52:	0d b6       	in	r0, 0x3d	; 61
     d54:	0d 92       	st	X+, r0
     d56:	0e b6       	in	r0, 0x3e	; 62
     d58:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     d5a:	0e 94 68 10 	call	0x20d0	; 0x20d0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     d5e:	a0 91 7f 07 	lds	r26, 0x077F
     d62:	b0 91 80 07 	lds	r27, 0x0780
     d66:	cd 91       	ld	r28, X+
     d68:	cd bf       	out	0x3d, r28	; 61
     d6a:	dd 91       	ld	r29, X+
     d6c:	de bf       	out	0x3e, r29	; 62
     d6e:	ff 91       	pop	r31
     d70:	ef 91       	pop	r30
     d72:	df 91       	pop	r29
     d74:	cf 91       	pop	r28
     d76:	bf 91       	pop	r27
     d78:	af 91       	pop	r26
     d7a:	9f 91       	pop	r25
     d7c:	8f 91       	pop	r24
     d7e:	7f 91       	pop	r23
     d80:	6f 91       	pop	r22
     d82:	5f 91       	pop	r21
     d84:	4f 91       	pop	r20
     d86:	3f 91       	pop	r19
     d88:	2f 91       	pop	r18
     d8a:	1f 91       	pop	r17
     d8c:	0f 91       	pop	r16
     d8e:	ff 90       	pop	r15
     d90:	ef 90       	pop	r14
     d92:	df 90       	pop	r13
     d94:	cf 90       	pop	r12
     d96:	bf 90       	pop	r11
     d98:	af 90       	pop	r10
     d9a:	9f 90       	pop	r9
     d9c:	8f 90       	pop	r8
     d9e:	7f 90       	pop	r7
     da0:	6f 90       	pop	r6
     da2:	5f 90       	pop	r5
     da4:	4f 90       	pop	r4
     da6:	3f 90       	pop	r3
     da8:	2f 90       	pop	r2
     daa:	1f 90       	pop	r1
     dac:	0f 90       	pop	r0
     dae:	0f be       	out	0x3f, r0	; 63
     db0:	0f 90       	pop	r0

	asm volatile ( "ret" );
     db2:	08 95       	ret

00000db4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     db4:	0f 92       	push	r0
     db6:	0f b6       	in	r0, 0x3f	; 63
     db8:	f8 94       	cli
     dba:	0f 92       	push	r0
     dbc:	1f 92       	push	r1
     dbe:	11 24       	eor	r1, r1
     dc0:	2f 92       	push	r2
     dc2:	3f 92       	push	r3
     dc4:	4f 92       	push	r4
     dc6:	5f 92       	push	r5
     dc8:	6f 92       	push	r6
     dca:	7f 92       	push	r7
     dcc:	8f 92       	push	r8
     dce:	9f 92       	push	r9
     dd0:	af 92       	push	r10
     dd2:	bf 92       	push	r11
     dd4:	cf 92       	push	r12
     dd6:	df 92       	push	r13
     dd8:	ef 92       	push	r14
     dda:	ff 92       	push	r15
     ddc:	0f 93       	push	r16
     dde:	1f 93       	push	r17
     de0:	2f 93       	push	r18
     de2:	3f 93       	push	r19
     de4:	4f 93       	push	r20
     de6:	5f 93       	push	r21
     de8:	6f 93       	push	r22
     dea:	7f 93       	push	r23
     dec:	8f 93       	push	r24
     dee:	9f 93       	push	r25
     df0:	af 93       	push	r26
     df2:	bf 93       	push	r27
     df4:	cf 93       	push	r28
     df6:	df 93       	push	r29
     df8:	ef 93       	push	r30
     dfa:	ff 93       	push	r31
     dfc:	a0 91 7f 07 	lds	r26, 0x077F
     e00:	b0 91 80 07 	lds	r27, 0x0780
     e04:	0d b6       	in	r0, 0x3d	; 61
     e06:	0d 92       	st	X+, r0
     e08:	0e b6       	in	r0, 0x3e	; 62
     e0a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     e0c:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <xTaskIncrementTick>
     e10:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     e12:	0e 94 68 10 	call	0x20d0	; 0x20d0 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     e16:	a0 91 7f 07 	lds	r26, 0x077F
     e1a:	b0 91 80 07 	lds	r27, 0x0780
     e1e:	cd 91       	ld	r28, X+
     e20:	cd bf       	out	0x3d, r28	; 61
     e22:	dd 91       	ld	r29, X+
     e24:	de bf       	out	0x3e, r29	; 62
     e26:	ff 91       	pop	r31
     e28:	ef 91       	pop	r30
     e2a:	df 91       	pop	r29
     e2c:	cf 91       	pop	r28
     e2e:	bf 91       	pop	r27
     e30:	af 91       	pop	r26
     e32:	9f 91       	pop	r25
     e34:	8f 91       	pop	r24
     e36:	7f 91       	pop	r23
     e38:	6f 91       	pop	r22
     e3a:	5f 91       	pop	r21
     e3c:	4f 91       	pop	r20
     e3e:	3f 91       	pop	r19
     e40:	2f 91       	pop	r18
     e42:	1f 91       	pop	r17
     e44:	0f 91       	pop	r16
     e46:	ff 90       	pop	r15
     e48:	ef 90       	pop	r14
     e4a:	df 90       	pop	r13
     e4c:	cf 90       	pop	r12
     e4e:	bf 90       	pop	r11
     e50:	af 90       	pop	r10
     e52:	9f 90       	pop	r9
     e54:	8f 90       	pop	r8
     e56:	7f 90       	pop	r7
     e58:	6f 90       	pop	r6
     e5a:	5f 90       	pop	r5
     e5c:	4f 90       	pop	r4
     e5e:	3f 90       	pop	r3
     e60:	2f 90       	pop	r2
     e62:	1f 90       	pop	r1
     e64:	0f 90       	pop	r0
     e66:	0f be       	out	0x3f, r0	; 63
     e68:	0f 90       	pop	r0

	asm volatile ( "ret" );
     e6a:	08 95       	ret

00000e6c <SIG_OUTPUT_COMPARE1A>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
     e6c:	1f 92       	push	r1
     e6e:	0f 92       	push	r0
     e70:	0f b6       	in	r0, 0x3f	; 63
     e72:	0f 92       	push	r0
     e74:	11 24       	eor	r1, r1
     e76:	2f 93       	push	r18
     e78:	3f 93       	push	r19
     e7a:	4f 93       	push	r20
     e7c:	5f 93       	push	r21
     e7e:	6f 93       	push	r22
     e80:	7f 93       	push	r23
     e82:	8f 93       	push	r24
     e84:	9f 93       	push	r25
     e86:	af 93       	push	r26
     e88:	bf 93       	push	r27
     e8a:	ef 93       	push	r30
     e8c:	ff 93       	push	r31
		xTaskIncrementTick();
     e8e:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <xTaskIncrementTick>
	}
     e92:	ff 91       	pop	r31
     e94:	ef 91       	pop	r30
     e96:	bf 91       	pop	r27
     e98:	af 91       	pop	r26
     e9a:	9f 91       	pop	r25
     e9c:	8f 91       	pop	r24
     e9e:	7f 91       	pop	r23
     ea0:	6f 91       	pop	r22
     ea2:	5f 91       	pop	r21
     ea4:	4f 91       	pop	r20
     ea6:	3f 91       	pop	r19
     ea8:	2f 91       	pop	r18
     eaa:	0f 90       	pop	r0
     eac:	0f be       	out	0x3f, r0	; 63
     eae:	0f 90       	pop	r0
     eb0:	1f 90       	pop	r1
     eb2:	18 95       	reti

00000eb4 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     eb4:	cf 93       	push	r28
     eb6:	df 93       	push	r29
     eb8:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     eba:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     ebe:	80 91 54 01 	lds	r24, 0x0154
     ec2:	90 91 55 01 	lds	r25, 0x0155
     ec6:	89 2b       	or	r24, r25
     ec8:	31 f4       	brne	.+12     	; 0xed6 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     eca:	89 e5       	ldi	r24, 0x59	; 89
     ecc:	91 e0       	ldi	r25, 0x01	; 1
     ece:	90 93 55 01 	sts	0x0155, r25
     ed2:	80 93 54 01 	sts	0x0154, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     ed6:	20 91 56 01 	lds	r18, 0x0156
     eda:	30 91 57 01 	lds	r19, 0x0157
     ede:	ce 01       	movw	r24, r28
     ee0:	82 0f       	add	r24, r18
     ee2:	93 1f       	adc	r25, r19
     ee4:	8b 3d       	cpi	r24, 0xDB	; 219
     ee6:	45 e0       	ldi	r20, 0x05	; 5
     ee8:	94 07       	cpc	r25, r20
     eea:	70 f4       	brcc	.+28     	; 0xf08 <pvPortMalloc+0x54>
     eec:	28 17       	cp	r18, r24
     eee:	39 07       	cpc	r19, r25
     ef0:	70 f4       	brcc	.+28     	; 0xf0e <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     ef2:	c0 91 54 01 	lds	r28, 0x0154
     ef6:	d0 91 55 01 	lds	r29, 0x0155
     efa:	c2 0f       	add	r28, r18
     efc:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     efe:	90 93 57 01 	sts	0x0157, r25
     f02:	80 93 56 01 	sts	0x0156, r24
     f06:	05 c0       	rjmp	.+10     	; 0xf12 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     f08:	c0 e0       	ldi	r28, 0x00	; 0
     f0a:	d0 e0       	ldi	r29, 0x00	; 0
     f0c:	02 c0       	rjmp	.+4      	; 0xf12 <pvPortMalloc+0x5e>
     f0e:	c0 e0       	ldi	r28, 0x00	; 0
     f10:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     f12:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     f16:	ce 01       	movw	r24, r28
     f18:	df 91       	pop	r29
     f1a:	cf 91       	pop	r28
     f1c:	08 95       	ret

00000f1e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     f1e:	08 95       	ret

00000f20 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     f20:	10 92 57 01 	sts	0x0157, r1
     f24:	10 92 56 01 	sts	0x0156, r1
     f28:	08 95       	ret

00000f2a <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     f2a:	20 91 56 01 	lds	r18, 0x0156
     f2e:	30 91 57 01 	lds	r19, 0x0157
}
     f32:	8b ed       	ldi	r24, 0xDB	; 219
     f34:	95 e0       	ldi	r25, 0x05	; 5
     f36:	82 1b       	sub	r24, r18
     f38:	93 0b       	sbc	r25, r19
     f3a:	08 95       	ret

00000f3c <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     f3c:	1f 93       	push	r17
     f3e:	cf 93       	push	r28
     f40:	df 93       	push	r29
     f42:	ec 01       	movw	r28, r24
     f44:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     f46:	88 a1       	ldd	r24, Y+32	; 0x20
     f48:	88 23       	and	r24, r24
     f4a:	e9 f1       	breq	.+122    	; 0xfc6 <prvCopyDataToQueue+0x8a>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     f4c:	41 11       	cpse	r20, r1
     f4e:	17 c0       	rjmp	.+46     	; 0xf7e <prvCopyDataToQueue+0x42>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     f50:	48 2f       	mov	r20, r24
     f52:	50 e0       	ldi	r21, 0x00	; 0
     f54:	8c 81       	ldd	r24, Y+4	; 0x04
     f56:	9d 81       	ldd	r25, Y+5	; 0x05
     f58:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     f5c:	28 a1       	ldd	r18, Y+32	; 0x20
     f5e:	8c 81       	ldd	r24, Y+4	; 0x04
     f60:	9d 81       	ldd	r25, Y+5	; 0x05
     f62:	82 0f       	add	r24, r18
     f64:	91 1d       	adc	r25, r1
     f66:	9d 83       	std	Y+5, r25	; 0x05
     f68:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     f6a:	2a 81       	ldd	r18, Y+2	; 0x02
     f6c:	3b 81       	ldd	r19, Y+3	; 0x03
     f6e:	82 17       	cp	r24, r18
     f70:	93 07       	cpc	r25, r19
     f72:	48 f1       	brcs	.+82     	; 0xfc6 <prvCopyDataToQueue+0x8a>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     f74:	88 81       	ld	r24, Y
     f76:	99 81       	ldd	r25, Y+1	; 0x01
     f78:	9d 83       	std	Y+5, r25	; 0x05
     f7a:	8c 83       	std	Y+4, r24	; 0x04
     f7c:	24 c0       	rjmp	.+72     	; 0xfc6 <prvCopyDataToQueue+0x8a>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     f7e:	48 2f       	mov	r20, r24
     f80:	50 e0       	ldi	r21, 0x00	; 0
     f82:	8e 81       	ldd	r24, Y+6	; 0x06
     f84:	9f 81       	ldd	r25, Y+7	; 0x07
     f86:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     f8a:	88 a1       	ldd	r24, Y+32	; 0x20
     f8c:	90 e0       	ldi	r25, 0x00	; 0
     f8e:	91 95       	neg	r25
     f90:	81 95       	neg	r24
     f92:	91 09       	sbc	r25, r1
     f94:	2e 81       	ldd	r18, Y+6	; 0x06
     f96:	3f 81       	ldd	r19, Y+7	; 0x07
     f98:	28 0f       	add	r18, r24
     f9a:	39 1f       	adc	r19, r25
     f9c:	3f 83       	std	Y+7, r19	; 0x07
     f9e:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     fa0:	48 81       	ld	r20, Y
     fa2:	59 81       	ldd	r21, Y+1	; 0x01
     fa4:	24 17       	cp	r18, r20
     fa6:	35 07       	cpc	r19, r21
     fa8:	30 f4       	brcc	.+12     	; 0xfb6 <prvCopyDataToQueue+0x7a>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     faa:	2a 81       	ldd	r18, Y+2	; 0x02
     fac:	3b 81       	ldd	r19, Y+3	; 0x03
     fae:	82 0f       	add	r24, r18
     fb0:	93 1f       	adc	r25, r19
     fb2:	9f 83       	std	Y+7, r25	; 0x07
     fb4:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     fb6:	12 30       	cpi	r17, 0x02	; 2
     fb8:	31 f4       	brne	.+12     	; 0xfc6 <prvCopyDataToQueue+0x8a>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     fba:	8e 8d       	ldd	r24, Y+30	; 0x1e
     fbc:	88 23       	and	r24, r24
     fbe:	19 f0       	breq	.+6      	; 0xfc6 <prvCopyDataToQueue+0x8a>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
     fc0:	8e 8d       	ldd	r24, Y+30	; 0x1e
     fc2:	81 50       	subi	r24, 0x01	; 1
     fc4:	8e 8f       	std	Y+30, r24	; 0x1e
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
     fc6:	8e 8d       	ldd	r24, Y+30	; 0x1e
     fc8:	8f 5f       	subi	r24, 0xFF	; 255
     fca:	8e 8f       	std	Y+30, r24	; 0x1e

	return xReturn;
}
     fcc:	80 e0       	ldi	r24, 0x00	; 0
     fce:	df 91       	pop	r29
     fd0:	cf 91       	pop	r28
     fd2:	1f 91       	pop	r17
     fd4:	08 95       	ret

00000fd6 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     fd6:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     fd8:	40 a1       	ldd	r20, Z+32	; 0x20
     fda:	44 23       	and	r20, r20
     fdc:	a9 f0       	breq	.+42     	; 0x1008 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     fde:	50 e0       	ldi	r21, 0x00	; 0
     fe0:	26 81       	ldd	r18, Z+6	; 0x06
     fe2:	37 81       	ldd	r19, Z+7	; 0x07
     fe4:	24 0f       	add	r18, r20
     fe6:	35 1f       	adc	r19, r21
     fe8:	37 83       	std	Z+7, r19	; 0x07
     fea:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     fec:	82 81       	ldd	r24, Z+2	; 0x02
     fee:	93 81       	ldd	r25, Z+3	; 0x03
     ff0:	28 17       	cp	r18, r24
     ff2:	39 07       	cpc	r19, r25
     ff4:	20 f0       	brcs	.+8      	; 0xffe <prvCopyDataFromQueue+0x28>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     ff6:	80 81       	ld	r24, Z
     ff8:	91 81       	ldd	r25, Z+1	; 0x01
     ffa:	97 83       	std	Z+7, r25	; 0x07
     ffc:	86 83       	std	Z+6, r24	; 0x06
     ffe:	cb 01       	movw	r24, r22
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1000:	66 81       	ldd	r22, Z+6	; 0x06
    1002:	77 81       	ldd	r23, Z+7	; 0x07
    1004:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <memcpy>
    1008:	08 95       	ret

0000100a <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    100a:	0f 93       	push	r16
    100c:	1f 93       	push	r17
    100e:	cf 93       	push	r28
    1010:	df 93       	push	r29
    1012:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1014:	0f b6       	in	r0, 0x3f	; 63
    1016:	f8 94       	cli
    1018:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    101a:	8a a1       	ldd	r24, Y+34	; 0x22
    101c:	18 16       	cp	r1, r24
    101e:	bc f4       	brge	.+46     	; 0x104e <prvUnlockQueue+0x44>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1020:	8b 89       	ldd	r24, Y+19	; 0x13
    1022:	81 11       	cpse	r24, r1
    1024:	05 c0       	rjmp	.+10     	; 0x1030 <prvUnlockQueue+0x26>
    1026:	13 c0       	rjmp	.+38     	; 0x104e <prvUnlockQueue+0x44>
    1028:	9b 89       	ldd	r25, Y+19	; 0x13
    102a:	91 11       	cpse	r25, r1
    102c:	04 c0       	rjmp	.+8      	; 0x1036 <prvUnlockQueue+0x2c>
    102e:	0f c0       	rjmp	.+30     	; 0x104e <prvUnlockQueue+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1030:	8e 01       	movw	r16, r28
    1032:	0d 5e       	subi	r16, 0xED	; 237
    1034:	1f 4f       	sbci	r17, 0xFF	; 255
    1036:	c8 01       	movw	r24, r16
    1038:	0e 94 9a 11 	call	0x2334	; 0x2334 <xTaskRemoveFromEventList>
    103c:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    103e:	0e 94 8a 12 	call	0x2514	; 0x2514 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    1042:	9a a1       	ldd	r25, Y+34	; 0x22
    1044:	91 50       	subi	r25, 0x01	; 1
    1046:	9a a3       	std	Y+34, r25	; 0x22
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1048:	9a a1       	ldd	r25, Y+34	; 0x22
    104a:	19 16       	cp	r1, r25
    104c:	6c f3       	brlt	.-38     	; 0x1028 <prvUnlockQueue+0x1e>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    104e:	8f ef       	ldi	r24, 0xFF	; 255
    1050:	8a a3       	std	Y+34, r24	; 0x22
	}
	taskEXIT_CRITICAL();
    1052:	0f 90       	pop	r0
    1054:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1056:	0f b6       	in	r0, 0x3f	; 63
    1058:	f8 94       	cli
    105a:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    105c:	89 a1       	ldd	r24, Y+33	; 0x21
    105e:	18 16       	cp	r1, r24
    1060:	bc f4       	brge	.+46     	; 0x1090 <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1062:	88 85       	ldd	r24, Y+8	; 0x08
    1064:	81 11       	cpse	r24, r1
    1066:	05 c0       	rjmp	.+10     	; 0x1072 <prvUnlockQueue+0x68>
    1068:	13 c0       	rjmp	.+38     	; 0x1090 <prvUnlockQueue+0x86>
    106a:	98 85       	ldd	r25, Y+8	; 0x08
    106c:	91 11       	cpse	r25, r1
    106e:	04 c0       	rjmp	.+8      	; 0x1078 <prvUnlockQueue+0x6e>
    1070:	0f c0       	rjmp	.+30     	; 0x1090 <prvUnlockQueue+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1072:	8e 01       	movw	r16, r28
    1074:	08 5f       	subi	r16, 0xF8	; 248
    1076:	1f 4f       	sbci	r17, 0xFF	; 255
    1078:	c8 01       	movw	r24, r16
    107a:	0e 94 9a 11 	call	0x2334	; 0x2334 <xTaskRemoveFromEventList>
    107e:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1080:	0e 94 8a 12 	call	0x2514	; 0x2514 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    1084:	99 a1       	ldd	r25, Y+33	; 0x21
    1086:	91 50       	subi	r25, 0x01	; 1
    1088:	99 a3       	std	Y+33, r25	; 0x21
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    108a:	99 a1       	ldd	r25, Y+33	; 0x21
    108c:	19 16       	cp	r1, r25
    108e:	6c f3       	brlt	.-38     	; 0x106a <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1090:	8f ef       	ldi	r24, 0xFF	; 255
    1092:	89 a3       	std	Y+33, r24	; 0x21
	}
	taskEXIT_CRITICAL();
    1094:	0f 90       	pop	r0
    1096:	0f be       	out	0x3f, r0	; 63
}
    1098:	df 91       	pop	r29
    109a:	cf 91       	pop	r28
    109c:	1f 91       	pop	r17
    109e:	0f 91       	pop	r16
    10a0:	08 95       	ret

000010a2 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    10a2:	cf 93       	push	r28
    10a4:	df 93       	push	r29
    10a6:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    10a8:	0f b6       	in	r0, 0x3f	; 63
    10aa:	f8 94       	cli
    10ac:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    10ae:	48 81       	ld	r20, Y
    10b0:	59 81       	ldd	r21, Y+1	; 0x01
    10b2:	28 a1       	ldd	r18, Y+32	; 0x20
    10b4:	30 e0       	ldi	r19, 0x00	; 0
    10b6:	7f 8d       	ldd	r23, Y+31	; 0x1f
    10b8:	72 9f       	mul	r23, r18
    10ba:	c0 01       	movw	r24, r0
    10bc:	73 9f       	mul	r23, r19
    10be:	90 0d       	add	r25, r0
    10c0:	11 24       	eor	r1, r1
    10c2:	fa 01       	movw	r30, r20
    10c4:	e8 0f       	add	r30, r24
    10c6:	f9 1f       	adc	r31, r25
    10c8:	fb 83       	std	Y+3, r31	; 0x03
    10ca:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    10cc:	1e 8e       	std	Y+30, r1	; 0x1e
		pxQueue->pcWriteTo = pxQueue->pcHead;
    10ce:	5d 83       	std	Y+5, r21	; 0x05
    10d0:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    10d2:	82 1b       	sub	r24, r18
    10d4:	93 0b       	sbc	r25, r19
    10d6:	84 0f       	add	r24, r20
    10d8:	95 1f       	adc	r25, r21
    10da:	9f 83       	std	Y+7, r25	; 0x07
    10dc:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    10de:	8f ef       	ldi	r24, 0xFF	; 255
    10e0:	89 a3       	std	Y+33, r24	; 0x21
		pxQueue->xTxLock = queueUNLOCKED;
    10e2:	8a a3       	std	Y+34, r24	; 0x22

		if( xNewQueue == pdFALSE )
    10e4:	61 11       	cpse	r22, r1
    10e6:	08 c0       	rjmp	.+16     	; 0x10f8 <xQueueGenericReset+0x56>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10e8:	88 85       	ldd	r24, Y+8	; 0x08
    10ea:	88 23       	and	r24, r24
    10ec:	69 f0       	breq	.+26     	; 0x1108 <__stack+0x9>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    10ee:	ce 01       	movw	r24, r28
    10f0:	08 96       	adiw	r24, 0x08	; 8
    10f2:	0e 94 9a 11 	call	0x2334	; 0x2334 <xTaskRemoveFromEventList>
    10f6:	08 c0       	rjmp	.+16     	; 0x1108 <__stack+0x9>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    10f8:	ce 01       	movw	r24, r28
    10fa:	08 96       	adiw	r24, 0x08	; 8
    10fc:	0e 94 41 05 	call	0xa82	; 0xa82 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1100:	ce 01       	movw	r24, r28
    1102:	43 96       	adiw	r24, 0x13	; 19
    1104:	0e 94 41 05 	call	0xa82	; 0xa82 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1108:	0f 90       	pop	r0
    110a:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    110c:	81 e0       	ldi	r24, 0x01	; 1
    110e:	df 91       	pop	r29
    1110:	cf 91       	pop	r28
    1112:	08 95       	ret

00001114 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1114:	0f 93       	push	r16
    1116:	1f 93       	push	r17
    1118:	cf 93       	push	r28
    111a:	df 93       	push	r29
    111c:	08 2f       	mov	r16, r24
    111e:	16 2f       	mov	r17, r22
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
    1120:	66 23       	and	r22, r22
    1122:	b9 f0       	breq	.+46     	; 0x1152 <xQueueGenericCreate+0x3e>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1124:	86 9f       	mul	r24, r22
    1126:	c0 01       	movw	r24, r0
    1128:	11 24       	eor	r1, r1
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    112a:	84 96       	adiw	r24, 0x24	; 36
    112c:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <pvPortMalloc>
    1130:	ec 01       	movw	r28, r24

	if( pxNewQueue != NULL )
    1132:	00 97       	sbiw	r24, 0x00	; 0
    1134:	21 f4       	brne	.+8      	; 0x113e <xQueueGenericCreate+0x2a>
    1136:	14 c0       	rjmp	.+40     	; 0x1160 <xQueueGenericCreate+0x4c>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1138:	d9 83       	std	Y+1, r29	; 0x01
    113a:	c8 83       	st	Y, r28
    113c:	03 c0       	rjmp	.+6      	; 0x1144 <xQueueGenericCreate+0x30>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
    113e:	83 96       	adiw	r24, 0x23	; 35
    1140:	99 83       	std	Y+1, r25	; 0x01
    1142:	88 83       	st	Y, r24
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
    1144:	0f 8f       	std	Y+31, r16	; 0x1f
		pxNewQueue->uxItemSize = uxItemSize;
    1146:	18 a3       	std	Y+32, r17	; 0x20
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1148:	61 e0       	ldi	r22, 0x01	; 1
    114a:	ce 01       	movw	r24, r28
    114c:	0e 94 51 08 	call	0x10a2	; 0x10a2 <xQueueGenericReset>
    1150:	07 c0       	rjmp	.+14     	; 0x1160 <xQueueGenericCreate+0x4c>
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    1152:	83 e2       	ldi	r24, 0x23	; 35
    1154:	90 e0       	ldi	r25, 0x00	; 0
    1156:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <pvPortMalloc>
    115a:	ec 01       	movw	r28, r24

	if( pxNewQueue != NULL )
    115c:	89 2b       	or	r24, r25
    115e:	61 f7       	brne	.-40     	; 0x1138 <xQueueGenericCreate+0x24>
	}

	configASSERT( xReturn );

	return xReturn;
}
    1160:	ce 01       	movw	r24, r28
    1162:	df 91       	pop	r29
    1164:	cf 91       	pop	r28
    1166:	1f 91       	pop	r17
    1168:	0f 91       	pop	r16
    116a:	08 95       	ret

0000116c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    116c:	9f 92       	push	r9
    116e:	af 92       	push	r10
    1170:	bf 92       	push	r11
    1172:	cf 92       	push	r12
    1174:	df 92       	push	r13
    1176:	ef 92       	push	r14
    1178:	ff 92       	push	r15
    117a:	0f 93       	push	r16
    117c:	1f 93       	push	r17
    117e:	cf 93       	push	r28
    1180:	df 93       	push	r29
    1182:	cd b7       	in	r28, 0x3d	; 61
    1184:	de b7       	in	r29, 0x3e	; 62
    1186:	29 97       	sbiw	r28, 0x09	; 9
    1188:	0f b6       	in	r0, 0x3f	; 63
    118a:	f8 94       	cli
    118c:	de bf       	out	0x3e, r29	; 62
    118e:	0f be       	out	0x3f, r0	; 63
    1190:	cd bf       	out	0x3d, r28	; 61
    1192:	7c 01       	movw	r14, r24
    1194:	5b 01       	movw	r10, r22
    1196:	2e 83       	std	Y+6, r18	; 0x06
    1198:	3f 83       	std	Y+7, r19	; 0x07
    119a:	48 87       	std	Y+8, r20	; 0x08
    119c:	59 87       	std	Y+9, r21	; 0x09
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    119e:	10 e0       	ldi	r17, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    11a0:	99 24       	eor	r9, r9
    11a2:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    11a4:	6c 01       	movw	r12, r24
    11a6:	88 e0       	ldi	r24, 0x08	; 8
    11a8:	c8 0e       	add	r12, r24
    11aa:	d1 1c       	adc	r13, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    11ac:	0f b6       	in	r0, 0x3f	; 63
    11ae:	f8 94       	cli
    11b0:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    11b2:	f7 01       	movw	r30, r14
    11b4:	26 8d       	ldd	r18, Z+30	; 0x1e
    11b6:	97 8d       	ldd	r25, Z+31	; 0x1f
    11b8:	29 17       	cp	r18, r25
    11ba:	10 f0       	brcs	.+4      	; 0x11c0 <xQueueGenericSend+0x54>
    11bc:	02 30       	cpi	r16, 0x02	; 2
    11be:	89 f4       	brne	.+34     	; 0x11e2 <xQueueGenericSend+0x76>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    11c0:	40 2f       	mov	r20, r16
    11c2:	b5 01       	movw	r22, r10
    11c4:	c7 01       	movw	r24, r14
    11c6:	0e 94 9e 07 	call	0xf3c	; 0xf3c <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    11ca:	f7 01       	movw	r30, r14
    11cc:	83 89       	ldd	r24, Z+19	; 0x13
    11ce:	88 23       	and	r24, r24
    11d0:	21 f0       	breq	.+8      	; 0x11da <xQueueGenericSend+0x6e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    11d2:	c7 01       	movw	r24, r14
    11d4:	43 96       	adiw	r24, 0x13	; 19
    11d6:	0e 94 9a 11 	call	0x2334	; 0x2334 <xTaskRemoveFromEventList>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    11da:	0f 90       	pop	r0
    11dc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    11de:	81 e0       	ldi	r24, 0x01	; 1
    11e0:	56 c0       	rjmp	.+172    	; 0x128e <xQueueGenericSend+0x122>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    11e2:	8e 81       	ldd	r24, Y+6	; 0x06
    11e4:	9f 81       	ldd	r25, Y+7	; 0x07
    11e6:	a8 85       	ldd	r26, Y+8	; 0x08
    11e8:	b9 85       	ldd	r27, Y+9	; 0x09
    11ea:	89 2b       	or	r24, r25
    11ec:	8a 2b       	or	r24, r26
    11ee:	8b 2b       	or	r24, r27
    11f0:	21 f4       	brne	.+8      	; 0x11fa <xQueueGenericSend+0x8e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    11f2:	0f 90       	pop	r0
    11f4:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    11f6:	80 e0       	ldi	r24, 0x00	; 0
    11f8:	4a c0       	rjmp	.+148    	; 0x128e <xQueueGenericSend+0x122>
				}
				else if( xEntryTimeSet == pdFALSE )
    11fa:	11 11       	cpse	r17, r1
    11fc:	05 c0       	rjmp	.+10     	; 0x1208 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    11fe:	ce 01       	movw	r24, r28
    1200:	01 96       	adiw	r24, 0x01	; 1
    1202:	0e 94 12 12 	call	0x2424	; 0x2424 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1206:	19 2d       	mov	r17, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1208:	0f 90       	pop	r0
    120a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    120c:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1210:	0f b6       	in	r0, 0x3f	; 63
    1212:	f8 94       	cli
    1214:	0f 92       	push	r0
    1216:	f7 01       	movw	r30, r14
    1218:	81 a1       	ldd	r24, Z+33	; 0x21
    121a:	8f 3f       	cpi	r24, 0xFF	; 255
    121c:	09 f4       	brne	.+2      	; 0x1220 <xQueueGenericSend+0xb4>
    121e:	11 a2       	std	Z+33, r1	; 0x21
    1220:	f7 01       	movw	r30, r14
    1222:	82 a1       	ldd	r24, Z+34	; 0x22
    1224:	8f 3f       	cpi	r24, 0xFF	; 255
    1226:	09 f4       	brne	.+2      	; 0x122a <xQueueGenericSend+0xbe>
    1228:	12 a2       	std	Z+34, r1	; 0x22
    122a:	0f 90       	pop	r0
    122c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    122e:	be 01       	movw	r22, r28
    1230:	6a 5f       	subi	r22, 0xFA	; 250
    1232:	7f 4f       	sbci	r23, 0xFF	; 255
    1234:	ce 01       	movw	r24, r28
    1236:	01 96       	adiw	r24, 0x01	; 1
    1238:	0e 94 23 12 	call	0x2446	; 0x2446 <xTaskCheckForTimeOut>
    123c:	81 11       	cpse	r24, r1
    123e:	21 c0       	rjmp	.+66     	; 0x1282 <xQueueGenericSend+0x116>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1240:	0f b6       	in	r0, 0x3f	; 63
    1242:	f8 94       	cli
    1244:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1246:	f7 01       	movw	r30, r14
    1248:	96 8d       	ldd	r25, Z+30	; 0x1e
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    124a:	0f 90       	pop	r0
    124c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    124e:	87 8d       	ldd	r24, Z+31	; 0x1f
    1250:	98 13       	cpse	r25, r24
    1252:	11 c0       	rjmp	.+34     	; 0x1276 <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1254:	4e 81       	ldd	r20, Y+6	; 0x06
    1256:	5f 81       	ldd	r21, Y+7	; 0x07
    1258:	68 85       	ldd	r22, Y+8	; 0x08
    125a:	79 85       	ldd	r23, Y+9	; 0x09
    125c:	c6 01       	movw	r24, r12
    125e:	0e 94 15 11 	call	0x222a	; 0x222a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1262:	c7 01       	movw	r24, r14
    1264:	0e 94 05 08 	call	0x100a	; 0x100a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1268:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <xTaskResumeAll>
    126c:	81 11       	cpse	r24, r1
    126e:	9e cf       	rjmp	.-196    	; 0x11ac <xQueueGenericSend+0x40>
				{
					portYIELD_WITHIN_API();
    1270:	0e 94 81 06 	call	0xd02	; 0xd02 <vPortYield>
    1274:	9b cf       	rjmp	.-202    	; 0x11ac <xQueueGenericSend+0x40>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1276:	c7 01       	movw	r24, r14
    1278:	0e 94 05 08 	call	0x100a	; 0x100a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    127c:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <xTaskResumeAll>
    1280:	95 cf       	rjmp	.-214    	; 0x11ac <xQueueGenericSend+0x40>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1282:	c7 01       	movw	r24, r14
    1284:	0e 94 05 08 	call	0x100a	; 0x100a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1288:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    128c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    128e:	29 96       	adiw	r28, 0x09	; 9
    1290:	0f b6       	in	r0, 0x3f	; 63
    1292:	f8 94       	cli
    1294:	de bf       	out	0x3e, r29	; 62
    1296:	0f be       	out	0x3f, r0	; 63
    1298:	cd bf       	out	0x3d, r28	; 61
    129a:	df 91       	pop	r29
    129c:	cf 91       	pop	r28
    129e:	1f 91       	pop	r17
    12a0:	0f 91       	pop	r16
    12a2:	ff 90       	pop	r15
    12a4:	ef 90       	pop	r14
    12a6:	df 90       	pop	r13
    12a8:	cf 90       	pop	r12
    12aa:	bf 90       	pop	r11
    12ac:	af 90       	pop	r10
    12ae:	9f 90       	pop	r9
    12b0:	08 95       	ret

000012b2 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    12b2:	0f 93       	push	r16
    12b4:	1f 93       	push	r17
    12b6:	cf 93       	push	r28
    12b8:	df 93       	push	r29
    12ba:	fa 01       	movw	r30, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    12bc:	dc 01       	movw	r26, r24
    12be:	5e 96       	adiw	r26, 0x1e	; 30
    12c0:	5c 91       	ld	r21, X
    12c2:	5e 97       	sbiw	r26, 0x1e	; 30
    12c4:	5f 96       	adiw	r26, 0x1f	; 31
    12c6:	3c 91       	ld	r19, X
    12c8:	53 17       	cp	r21, r19
    12ca:	10 f0       	brcs	.+4      	; 0x12d0 <xQueueGenericSendFromISR+0x1e>
    12cc:	22 30       	cpi	r18, 0x02	; 2
    12ce:	e9 f4       	brne	.+58     	; 0x130a <xQueueGenericSendFromISR+0x58>
    12d0:	42 2f       	mov	r20, r18
    12d2:	8f 01       	movw	r16, r30
    12d4:	ec 01       	movw	r28, r24
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    12d6:	0e 94 9e 07 	call	0xf3c	; 0xf3c <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    12da:	8a a1       	ldd	r24, Y+34	; 0x22
    12dc:	8f 3f       	cpi	r24, 0xFF	; 255
    12de:	81 f4       	brne	.+32     	; 0x1300 <xQueueGenericSendFromISR+0x4e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12e0:	8b 89       	ldd	r24, Y+19	; 0x13
    12e2:	88 23       	and	r24, r24
    12e4:	a1 f0       	breq	.+40     	; 0x130e <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12e6:	ce 01       	movw	r24, r28
    12e8:	43 96       	adiw	r24, 0x13	; 19
    12ea:	0e 94 9a 11 	call	0x2334	; 0x2334 <xTaskRemoveFromEventList>
    12ee:	88 23       	and	r24, r24
    12f0:	81 f0       	breq	.+32     	; 0x1312 <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    12f2:	01 15       	cp	r16, r1
    12f4:	11 05       	cpc	r17, r1
    12f6:	79 f0       	breq	.+30     	; 0x1316 <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    12f8:	81 e0       	ldi	r24, 0x01	; 1
    12fa:	f8 01       	movw	r30, r16
    12fc:	80 83       	st	Z, r24
    12fe:	0c c0       	rjmp	.+24     	; 0x1318 <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1300:	8a a1       	ldd	r24, Y+34	; 0x22
    1302:	8f 5f       	subi	r24, 0xFF	; 255
    1304:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    1306:	81 e0       	ldi	r24, 0x01	; 1
    1308:	07 c0       	rjmp	.+14     	; 0x1318 <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    130a:	80 e0       	ldi	r24, 0x00	; 0
    130c:	05 c0       	rjmp	.+10     	; 0x1318 <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    130e:	81 e0       	ldi	r24, 0x01	; 1
    1310:	03 c0       	rjmp	.+6      	; 0x1318 <xQueueGenericSendFromISR+0x66>
    1312:	81 e0       	ldi	r24, 0x01	; 1
    1314:	01 c0       	rjmp	.+2      	; 0x1318 <xQueueGenericSendFromISR+0x66>
    1316:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1318:	df 91       	pop	r29
    131a:	cf 91       	pop	r28
    131c:	1f 91       	pop	r17
    131e:	0f 91       	pop	r16
    1320:	08 95       	ret

00001322 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1322:	cf 93       	push	r28
    1324:	df 93       	push	r29
    1326:	fc 01       	movw	r30, r24
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1328:	96 8d       	ldd	r25, Z+30	; 0x1e
    132a:	87 8d       	ldd	r24, Z+31	; 0x1f
    132c:	98 17       	cp	r25, r24
    132e:	d0 f4       	brcc	.+52     	; 0x1364 <xQueueGiveFromISR+0x42>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    1330:	86 8d       	ldd	r24, Z+30	; 0x1e
    1332:	8f 5f       	subi	r24, 0xFF	; 255
    1334:	86 8f       	std	Z+30, r24	; 0x1e

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1336:	82 a1       	ldd	r24, Z+34	; 0x22
    1338:	8f 3f       	cpi	r24, 0xFF	; 255
    133a:	79 f4       	brne	.+30     	; 0x135a <xQueueGiveFromISR+0x38>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    133c:	83 89       	ldd	r24, Z+19	; 0x13
    133e:	88 23       	and	r24, r24
    1340:	99 f0       	breq	.+38     	; 0x1368 <xQueueGiveFromISR+0x46>
    1342:	eb 01       	movw	r28, r22
    1344:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1346:	43 96       	adiw	r24, 0x13	; 19
    1348:	0e 94 9a 11 	call	0x2334	; 0x2334 <xTaskRemoveFromEventList>
    134c:	88 23       	and	r24, r24
    134e:	71 f0       	breq	.+28     	; 0x136c <xQueueGiveFromISR+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1350:	20 97       	sbiw	r28, 0x00	; 0
    1352:	71 f0       	breq	.+28     	; 0x1370 <xQueueGiveFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1354:	81 e0       	ldi	r24, 0x01	; 1
    1356:	88 83       	st	Y, r24
    1358:	0c c0       	rjmp	.+24     	; 0x1372 <xQueueGiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    135a:	82 a1       	ldd	r24, Z+34	; 0x22
    135c:	8f 5f       	subi	r24, 0xFF	; 255
    135e:	82 a3       	std	Z+34, r24	; 0x22
			}

			xReturn = pdPASS;
    1360:	81 e0       	ldi	r24, 0x01	; 1
    1362:	07 c0       	rjmp	.+14     	; 0x1372 <xQueueGiveFromISR+0x50>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1364:	80 e0       	ldi	r24, 0x00	; 0
    1366:	05 c0       	rjmp	.+10     	; 0x1372 <xQueueGiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1368:	81 e0       	ldi	r24, 0x01	; 1
    136a:	03 c0       	rjmp	.+6      	; 0x1372 <xQueueGiveFromISR+0x50>
    136c:	81 e0       	ldi	r24, 0x01	; 1
    136e:	01 c0       	rjmp	.+2      	; 0x1372 <xQueueGiveFromISR+0x50>
    1370:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1372:	df 91       	pop	r29
    1374:	cf 91       	pop	r28
    1376:	08 95       	ret

00001378 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1378:	9f 92       	push	r9
    137a:	af 92       	push	r10
    137c:	bf 92       	push	r11
    137e:	cf 92       	push	r12
    1380:	df 92       	push	r13
    1382:	ef 92       	push	r14
    1384:	ff 92       	push	r15
    1386:	0f 93       	push	r16
    1388:	1f 93       	push	r17
    138a:	cf 93       	push	r28
    138c:	df 93       	push	r29
    138e:	cd b7       	in	r28, 0x3d	; 61
    1390:	de b7       	in	r29, 0x3e	; 62
    1392:	29 97       	sbiw	r28, 0x09	; 9
    1394:	0f b6       	in	r0, 0x3f	; 63
    1396:	f8 94       	cli
    1398:	de bf       	out	0x3e, r29	; 62
    139a:	0f be       	out	0x3f, r0	; 63
    139c:	cd bf       	out	0x3d, r28	; 61
    139e:	7c 01       	movw	r14, r24
    13a0:	5b 01       	movw	r10, r22
    13a2:	2e 83       	std	Y+6, r18	; 0x06
    13a4:	3f 83       	std	Y+7, r19	; 0x07
    13a6:	48 87       	std	Y+8, r20	; 0x08
    13a8:	59 87       	std	Y+9, r21	; 0x09
BaseType_t xEntryTimeSet = pdFALSE;
    13aa:	10 e0       	ldi	r17, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    13ac:	99 24       	eor	r9, r9
    13ae:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    13b0:	6c 01       	movw	r12, r24
    13b2:	83 e1       	ldi	r24, 0x13	; 19
    13b4:	c8 0e       	add	r12, r24
    13b6:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    13b8:	0f b6       	in	r0, 0x3f	; 63
    13ba:	f8 94       	cli
    13bc:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    13be:	f7 01       	movw	r30, r14
    13c0:	96 8d       	ldd	r25, Z+30	; 0x1e
    13c2:	99 23       	and	r25, r25
    13c4:	11 f1       	breq	.+68     	; 0x140a <xQueueGenericReceive+0x92>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    13c6:	c6 80       	ldd	r12, Z+6	; 0x06
    13c8:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    13ca:	b5 01       	movw	r22, r10
    13cc:	c7 01       	movw	r24, r14
    13ce:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    13d2:	01 11       	cpse	r16, r1
    13d4:	0c c0       	rjmp	.+24     	; 0x13ee <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    13d6:	f7 01       	movw	r30, r14
    13d8:	86 8d       	ldd	r24, Z+30	; 0x1e
    13da:	81 50       	subi	r24, 0x01	; 1
    13dc:	86 8f       	std	Z+30, r24	; 0x1e
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13de:	80 85       	ldd	r24, Z+8	; 0x08
    13e0:	88 23       	and	r24, r24
    13e2:	79 f0       	breq	.+30     	; 0x1402 <xQueueGenericReceive+0x8a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    13e4:	c7 01       	movw	r24, r14
    13e6:	08 96       	adiw	r24, 0x08	; 8
    13e8:	0e 94 9a 11 	call	0x2334	; 0x2334 <xTaskRemoveFromEventList>
    13ec:	0a c0       	rjmp	.+20     	; 0x1402 <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    13ee:	f7 01       	movw	r30, r14
    13f0:	d7 82       	std	Z+7, r13	; 0x07
    13f2:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13f4:	83 89       	ldd	r24, Z+19	; 0x13
    13f6:	88 23       	and	r24, r24
    13f8:	21 f0       	breq	.+8      	; 0x1402 <xQueueGenericReceive+0x8a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13fa:	c7 01       	movw	r24, r14
    13fc:	43 96       	adiw	r24, 0x13	; 19
    13fe:	0e 94 9a 11 	call	0x2334	; 0x2334 <xTaskRemoveFromEventList>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1402:	0f 90       	pop	r0
    1404:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1406:	81 e0       	ldi	r24, 0x01	; 1
    1408:	55 c0       	rjmp	.+170    	; 0x14b4 <xQueueGenericReceive+0x13c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    140a:	8e 81       	ldd	r24, Y+6	; 0x06
    140c:	9f 81       	ldd	r25, Y+7	; 0x07
    140e:	a8 85       	ldd	r26, Y+8	; 0x08
    1410:	b9 85       	ldd	r27, Y+9	; 0x09
    1412:	89 2b       	or	r24, r25
    1414:	8a 2b       	or	r24, r26
    1416:	8b 2b       	or	r24, r27
    1418:	21 f4       	brne	.+8      	; 0x1422 <xQueueGenericReceive+0xaa>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    141a:	0f 90       	pop	r0
    141c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    141e:	80 e0       	ldi	r24, 0x00	; 0
    1420:	49 c0       	rjmp	.+146    	; 0x14b4 <xQueueGenericReceive+0x13c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1422:	11 11       	cpse	r17, r1
    1424:	05 c0       	rjmp	.+10     	; 0x1430 <xQueueGenericReceive+0xb8>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1426:	ce 01       	movw	r24, r28
    1428:	01 96       	adiw	r24, 0x01	; 1
    142a:	0e 94 12 12 	call	0x2424	; 0x2424 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    142e:	19 2d       	mov	r17, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1430:	0f 90       	pop	r0
    1432:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1434:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1438:	0f b6       	in	r0, 0x3f	; 63
    143a:	f8 94       	cli
    143c:	0f 92       	push	r0
    143e:	f7 01       	movw	r30, r14
    1440:	81 a1       	ldd	r24, Z+33	; 0x21
    1442:	8f 3f       	cpi	r24, 0xFF	; 255
    1444:	09 f4       	brne	.+2      	; 0x1448 <xQueueGenericReceive+0xd0>
    1446:	11 a2       	std	Z+33, r1	; 0x21
    1448:	f7 01       	movw	r30, r14
    144a:	82 a1       	ldd	r24, Z+34	; 0x22
    144c:	8f 3f       	cpi	r24, 0xFF	; 255
    144e:	09 f4       	brne	.+2      	; 0x1452 <xQueueGenericReceive+0xda>
    1450:	12 a2       	std	Z+34, r1	; 0x22
    1452:	0f 90       	pop	r0
    1454:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1456:	be 01       	movw	r22, r28
    1458:	6a 5f       	subi	r22, 0xFA	; 250
    145a:	7f 4f       	sbci	r23, 0xFF	; 255
    145c:	ce 01       	movw	r24, r28
    145e:	01 96       	adiw	r24, 0x01	; 1
    1460:	0e 94 23 12 	call	0x2446	; 0x2446 <xTaskCheckForTimeOut>
    1464:	81 11       	cpse	r24, r1
    1466:	20 c0       	rjmp	.+64     	; 0x14a8 <xQueueGenericReceive+0x130>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1468:	0f b6       	in	r0, 0x3f	; 63
    146a:	f8 94       	cli
    146c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    146e:	f7 01       	movw	r30, r14
    1470:	86 8d       	ldd	r24, Z+30	; 0x1e
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1472:	0f 90       	pop	r0
    1474:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1476:	81 11       	cpse	r24, r1
    1478:	11 c0       	rjmp	.+34     	; 0x149c <xQueueGenericReceive+0x124>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    147a:	4e 81       	ldd	r20, Y+6	; 0x06
    147c:	5f 81       	ldd	r21, Y+7	; 0x07
    147e:	68 85       	ldd	r22, Y+8	; 0x08
    1480:	79 85       	ldd	r23, Y+9	; 0x09
    1482:	c6 01       	movw	r24, r12
    1484:	0e 94 15 11 	call	0x222a	; 0x222a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1488:	c7 01       	movw	r24, r14
    148a:	0e 94 05 08 	call	0x100a	; 0x100a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    148e:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <xTaskResumeAll>
    1492:	81 11       	cpse	r24, r1
    1494:	91 cf       	rjmp	.-222    	; 0x13b8 <xQueueGenericReceive+0x40>
				{
					portYIELD_WITHIN_API();
    1496:	0e 94 81 06 	call	0xd02	; 0xd02 <vPortYield>
    149a:	8e cf       	rjmp	.-228    	; 0x13b8 <xQueueGenericReceive+0x40>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    149c:	c7 01       	movw	r24, r14
    149e:	0e 94 05 08 	call	0x100a	; 0x100a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    14a2:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <xTaskResumeAll>
    14a6:	88 cf       	rjmp	.-240    	; 0x13b8 <xQueueGenericReceive+0x40>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    14a8:	c7 01       	movw	r24, r14
    14aa:	0e 94 05 08 	call	0x100a	; 0x100a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    14ae:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    14b2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    14b4:	29 96       	adiw	r28, 0x09	; 9
    14b6:	0f b6       	in	r0, 0x3f	; 63
    14b8:	f8 94       	cli
    14ba:	de bf       	out	0x3e, r29	; 62
    14bc:	0f be       	out	0x3f, r0	; 63
    14be:	cd bf       	out	0x3d, r28	; 61
    14c0:	df 91       	pop	r29
    14c2:	cf 91       	pop	r28
    14c4:	1f 91       	pop	r17
    14c6:	0f 91       	pop	r16
    14c8:	ff 90       	pop	r15
    14ca:	ef 90       	pop	r14
    14cc:	df 90       	pop	r13
    14ce:	cf 90       	pop	r12
    14d0:	bf 90       	pop	r11
    14d2:	af 90       	pop	r10
    14d4:	9f 90       	pop	r9
    14d6:	08 95       	ret

000014d8 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    14d8:	0f 93       	push	r16
    14da:	1f 93       	push	r17
    14dc:	cf 93       	push	r28
    14de:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    14e0:	fc 01       	movw	r30, r24
    14e2:	26 8d       	ldd	r18, Z+30	; 0x1e
    14e4:	22 23       	and	r18, r18
    14e6:	f9 f0       	breq	.+62     	; 0x1526 <xQueueReceiveFromISR+0x4e>
    14e8:	8a 01       	movw	r16, r20
    14ea:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    14ec:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    14f0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14f2:	81 50       	subi	r24, 0x01	; 1
    14f4:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    14f6:	89 a1       	ldd	r24, Y+33	; 0x21
    14f8:	8f 3f       	cpi	r24, 0xFF	; 255
    14fa:	81 f4       	brne	.+32     	; 0x151c <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14fc:	88 85       	ldd	r24, Y+8	; 0x08
    14fe:	88 23       	and	r24, r24
    1500:	a1 f0       	breq	.+40     	; 0x152a <xQueueReceiveFromISR+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1502:	ce 01       	movw	r24, r28
    1504:	08 96       	adiw	r24, 0x08	; 8
    1506:	0e 94 9a 11 	call	0x2334	; 0x2334 <xTaskRemoveFromEventList>
    150a:	88 23       	and	r24, r24
    150c:	81 f0       	breq	.+32     	; 0x152e <xQueueReceiveFromISR+0x56>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    150e:	01 15       	cp	r16, r1
    1510:	11 05       	cpc	r17, r1
    1512:	79 f0       	breq	.+30     	; 0x1532 <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1514:	81 e0       	ldi	r24, 0x01	; 1
    1516:	f8 01       	movw	r30, r16
    1518:	80 83       	st	Z, r24
    151a:	0c c0       	rjmp	.+24     	; 0x1534 <xQueueReceiveFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    151c:	89 a1       	ldd	r24, Y+33	; 0x21
    151e:	8f 5f       	subi	r24, 0xFF	; 255
    1520:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    1522:	81 e0       	ldi	r24, 0x01	; 1
    1524:	07 c0       	rjmp	.+14     	; 0x1534 <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			xReturn = pdFAIL;
    1526:	80 e0       	ldi	r24, 0x00	; 0
    1528:	05 c0       	rjmp	.+10     	; 0x1534 <xQueueReceiveFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    152a:	81 e0       	ldi	r24, 0x01	; 1
    152c:	03 c0       	rjmp	.+6      	; 0x1534 <xQueueReceiveFromISR+0x5c>
    152e:	81 e0       	ldi	r24, 0x01	; 1
    1530:	01 c0       	rjmp	.+2      	; 0x1534 <xQueueReceiveFromISR+0x5c>
    1532:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1534:	df 91       	pop	r29
    1536:	cf 91       	pop	r28
    1538:	1f 91       	pop	r17
    153a:	0f 91       	pop	r16
    153c:	08 95       	ret

0000153e <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    153e:	0f 93       	push	r16
    1540:	1f 93       	push	r17
    1542:	cf 93       	push	r28
    1544:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1546:	fc 01       	movw	r30, r24
    1548:	26 8d       	ldd	r18, Z+30	; 0x1e
    154a:	22 23       	and	r18, r18
    154c:	49 f0       	breq	.+18     	; 0x1560 <xQueuePeekFromISR+0x22>
    154e:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1550:	06 81       	ldd	r16, Z+6	; 0x06
    1552:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1554:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1558:	1f 83       	std	Y+7, r17	; 0x07
    155a:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    155c:	81 e0       	ldi	r24, 0x01	; 1
    155e:	01 c0       	rjmp	.+2      	; 0x1562 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1560:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1562:	df 91       	pop	r29
    1564:	cf 91       	pop	r28
    1566:	1f 91       	pop	r17
    1568:	0f 91       	pop	r16
    156a:	08 95       	ret

0000156c <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    156c:	0f b6       	in	r0, 0x3f	; 63
    156e:	f8 94       	cli
    1570:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1572:	fc 01       	movw	r30, r24
    1574:	86 8d       	ldd	r24, Z+30	; 0x1e
	}
	taskEXIT_CRITICAL();
    1576:	0f 90       	pop	r0
    1578:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    157a:	08 95       	ret

0000157c <uxQueueSpacesAvailable>:
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    157c:	0f b6       	in	r0, 0x3f	; 63
    157e:	f8 94       	cli
    1580:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1582:	fc 01       	movw	r30, r24
    1584:	26 8d       	ldd	r18, Z+30	; 0x1e
	}
	taskEXIT_CRITICAL();
    1586:	0f 90       	pop	r0
    1588:	0f be       	out	0x3f, r0	; 63
	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    158a:	87 8d       	ldd	r24, Z+31	; 0x1f
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    158c:	82 1b       	sub	r24, r18
    158e:	08 95       	ret

00001590 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1590:	fc 01       	movw	r30, r24
    1592:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1594:	08 95       	ret

00001596 <vQueueDelete>:
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue );
    1596:	0e 94 8f 07 	call	0xf1e	; 0xf1e <vPortFree>
    159a:	08 95       	ret

0000159c <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    159c:	fc 01       	movw	r30, r24
    159e:	96 8d       	ldd	r25, Z+30	; 0x1e
    15a0:	81 e0       	ldi	r24, 0x01	; 1
    15a2:	91 11       	cpse	r25, r1
    15a4:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    15a6:	08 95       	ret

000015a8 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    15a8:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    15aa:	26 8d       	ldd	r18, Z+30	; 0x1e
    15ac:	81 e0       	ldi	r24, 0x01	; 1
    15ae:	97 8d       	ldd	r25, Z+31	; 0x1f
    15b0:	29 13       	cpse	r18, r25
    15b2:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    15b4:	08 95       	ret

000015b6 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    15b6:	0f 93       	push	r16
    15b8:	1f 93       	push	r17
    15ba:	cf 93       	push	r28
    15bc:	df 93       	push	r29
    15be:	ec 01       	movw	r28, r24
    15c0:	89 01       	movw	r16, r18
    15c2:	9a 01       	movw	r18, r20
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    15c4:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    15c6:	0f b6       	in	r0, 0x3f	; 63
    15c8:	f8 94       	cli
    15ca:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    15cc:	9e 8d       	ldd	r25, Y+30	; 0x1e
    15ce:	8f 8d       	ldd	r24, Y+31	; 0x1f
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    15d0:	0f 90       	pop	r0
    15d2:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    15d4:	98 13       	cpse	r25, r24
    15d6:	12 c0       	rjmp	.+36     	; 0x15fc <xQueueCRSend+0x46>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    15d8:	01 15       	cp	r16, r1
    15da:	11 05       	cpc	r17, r1
    15dc:	21 05       	cpc	r18, r1
    15de:	31 05       	cpc	r19, r1
    15e0:	51 f0       	breq	.+20     	; 0x15f6 <xQueueCRSend+0x40>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    15e2:	ae 01       	movw	r20, r28
    15e4:	48 5f       	subi	r20, 0xF8	; 248
    15e6:	5f 4f       	sbci	r21, 0xFF	; 255
    15e8:	c9 01       	movw	r24, r18
    15ea:	b8 01       	movw	r22, r16
    15ec:	0e 94 fe 00 	call	0x1fc	; 0x1fc <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    15f0:	78 94       	sei
					return errQUEUE_BLOCKED;
    15f2:	8c ef       	ldi	r24, 0xFC	; 252
    15f4:	1d c0       	rjmp	.+58     	; 0x1630 <xQueueCRSend+0x7a>
				}
				else
				{
					portENABLE_INTERRUPTS();
    15f6:	78 94       	sei
					return errQUEUE_FULL;
    15f8:	80 e0       	ldi	r24, 0x00	; 0
    15fa:	1a c0       	rjmp	.+52     	; 0x1630 <xQueueCRSend+0x7a>
				}
			}
		}
		portENABLE_INTERRUPTS();
    15fc:	78 94       	sei

		portDISABLE_INTERRUPTS();
    15fe:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1600:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1602:	98 17       	cp	r25, r24
    1604:	78 f4       	brcc	.+30     	; 0x1624 <xQueueCRSend+0x6e>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1606:	40 e0       	ldi	r20, 0x00	; 0
    1608:	ce 01       	movw	r24, r28
    160a:	0e 94 9e 07 	call	0xf3c	; 0xf3c <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    160e:	8b 89       	ldd	r24, Y+19	; 0x13
    1610:	88 23       	and	r24, r24
    1612:	51 f0       	breq	.+20     	; 0x1628 <xQueueCRSend+0x72>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1614:	ce 01       	movw	r24, r28
    1616:	43 96       	adiw	r24, 0x13	; 19
    1618:	0e 94 ba 02 	call	0x574	; 0x574 <xCoRoutineRemoveFromEventList>
    161c:	88 23       	and	r24, r24
    161e:	31 f0       	breq	.+12     	; 0x162c <xQueueCRSend+0x76>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1620:	8b ef       	ldi	r24, 0xFB	; 251
    1622:	05 c0       	rjmp	.+10     	; 0x162e <xQueueCRSend+0x78>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1624:	80 e0       	ldi	r24, 0x00	; 0
    1626:	03 c0       	rjmp	.+6      	; 0x162e <xQueueCRSend+0x78>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1628:	81 e0       	ldi	r24, 0x01	; 1
    162a:	01 c0       	rjmp	.+2      	; 0x162e <xQueueCRSend+0x78>
    162c:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = errQUEUE_FULL;
			}
		}
		portENABLE_INTERRUPTS();
    162e:	78 94       	sei

		return xReturn;
	}
    1630:	df 91       	pop	r29
    1632:	cf 91       	pop	r28
    1634:	1f 91       	pop	r17
    1636:	0f 91       	pop	r16
    1638:	08 95       	ret

0000163a <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    163a:	0f 93       	push	r16
    163c:	1f 93       	push	r17
    163e:	cf 93       	push	r28
    1640:	df 93       	push	r29
    1642:	ec 01       	movw	r28, r24
    1644:	fb 01       	movw	r30, r22
    1646:	89 01       	movw	r16, r18
    1648:	9a 01       	movw	r18, r20
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    164a:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    164c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    164e:	91 11       	cpse	r25, r1
    1650:	12 c0       	rjmp	.+36     	; 0x1676 <xQueueCRReceive+0x3c>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1652:	01 15       	cp	r16, r1
    1654:	11 05       	cpc	r17, r1
    1656:	21 05       	cpc	r18, r1
    1658:	31 05       	cpc	r19, r1
    165a:	51 f0       	breq	.+20     	; 0x1670 <xQueueCRReceive+0x36>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    165c:	ae 01       	movw	r20, r28
    165e:	4d 5e       	subi	r20, 0xED	; 237
    1660:	5f 4f       	sbci	r21, 0xFF	; 255
    1662:	c9 01       	movw	r24, r18
    1664:	b8 01       	movw	r22, r16
    1666:	0e 94 fe 00 	call	0x1fc	; 0x1fc <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    166a:	78 94       	sei
					return errQUEUE_BLOCKED;
    166c:	8c ef       	ldi	r24, 0xFC	; 252
    166e:	32 c0       	rjmp	.+100    	; 0x16d4 <xQueueCRReceive+0x9a>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1670:	78 94       	sei
					return errQUEUE_FULL;
    1672:	80 e0       	ldi	r24, 0x00	; 0
    1674:	2f c0       	rjmp	.+94     	; 0x16d4 <xQueueCRReceive+0x9a>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1676:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1678:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    167a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    167c:	88 23       	and	r24, r24
    167e:	21 f1       	breq	.+72     	; 0x16c8 <xQueueCRReceive+0x8e>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1680:	48 a1       	ldd	r20, Y+32	; 0x20
    1682:	50 e0       	ldi	r21, 0x00	; 0
    1684:	8e 81       	ldd	r24, Y+6	; 0x06
    1686:	9f 81       	ldd	r25, Y+7	; 0x07
    1688:	84 0f       	add	r24, r20
    168a:	95 1f       	adc	r25, r21
    168c:	9f 83       	std	Y+7, r25	; 0x07
    168e:	8e 83       	std	Y+6, r24	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1690:	2a 81       	ldd	r18, Y+2	; 0x02
    1692:	3b 81       	ldd	r19, Y+3	; 0x03
    1694:	82 17       	cp	r24, r18
    1696:	93 07       	cpc	r25, r19
    1698:	20 f0       	brcs	.+8      	; 0x16a2 <xQueueCRReceive+0x68>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    169a:	88 81       	ld	r24, Y
    169c:	99 81       	ldd	r25, Y+1	; 0x01
    169e:	9f 83       	std	Y+7, r25	; 0x07
    16a0:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    16a2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16a4:	81 50       	subi	r24, 0x01	; 1
    16a6:	8e 8f       	std	Y+30, r24	; 0x1e
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    16a8:	6e 81       	ldd	r22, Y+6	; 0x06
    16aa:	7f 81       	ldd	r23, Y+7	; 0x07
    16ac:	cf 01       	movw	r24, r30
    16ae:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16b2:	88 85       	ldd	r24, Y+8	; 0x08
    16b4:	88 23       	and	r24, r24
    16b6:	51 f0       	breq	.+20     	; 0x16cc <xQueueCRReceive+0x92>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16b8:	ce 01       	movw	r24, r28
    16ba:	08 96       	adiw	r24, 0x08	; 8
    16bc:	0e 94 ba 02 	call	0x574	; 0x574 <xCoRoutineRemoveFromEventList>
    16c0:	88 23       	and	r24, r24
    16c2:	31 f0       	breq	.+12     	; 0x16d0 <xQueueCRReceive+0x96>
					{
						xReturn = errQUEUE_YIELD;
    16c4:	8b ef       	ldi	r24, 0xFB	; 251
    16c6:	05 c0       	rjmp	.+10     	; 0x16d2 <xQueueCRReceive+0x98>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    16c8:	80 e0       	ldi	r24, 0x00	; 0
    16ca:	03 c0       	rjmp	.+6      	; 0x16d2 <xQueueCRReceive+0x98>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    16cc:	81 e0       	ldi	r24, 0x01	; 1
    16ce:	01 c0       	rjmp	.+2      	; 0x16d2 <xQueueCRReceive+0x98>
    16d0:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = pdFAIL;
			}
		}
		portENABLE_INTERRUPTS();
    16d2:	78 94       	sei

		return xReturn;
	}
    16d4:	df 91       	pop	r29
    16d6:	cf 91       	pop	r28
    16d8:	1f 91       	pop	r17
    16da:	0f 91       	pop	r16
    16dc:	08 95       	ret

000016de <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    16de:	0f 93       	push	r16
    16e0:	1f 93       	push	r17
    16e2:	cf 93       	push	r28
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    16e4:	fc 01       	movw	r30, r24
    16e6:	36 8d       	ldd	r19, Z+30	; 0x1e
    16e8:	27 8d       	ldd	r18, Z+31	; 0x1f
    16ea:	32 17       	cp	r19, r18
    16ec:	b8 f4       	brcc	.+46     	; 0x171c <xQueueCRSendFromISR+0x3e>
    16ee:	c4 2f       	mov	r28, r20
    16f0:	8c 01       	movw	r16, r24
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    16f2:	40 e0       	ldi	r20, 0x00	; 0
    16f4:	0e 94 9e 07 	call	0xf3c	; 0xf3c <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    16f8:	c1 11       	cpse	r28, r1
    16fa:	0d c0       	rjmp	.+26     	; 0x1716 <xQueueCRSendFromISR+0x38>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16fc:	f8 01       	movw	r30, r16
    16fe:	83 89       	ldd	r24, Z+19	; 0x13
    1700:	88 23       	and	r24, r24
    1702:	59 f0       	breq	.+22     	; 0x171a <xQueueCRSendFromISR+0x3c>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1704:	c8 01       	movw	r24, r16
    1706:	43 96       	adiw	r24, 0x13	; 19
    1708:	0e 94 ba 02 	call	0x574	; 0x574 <xCoRoutineRemoveFromEventList>
    170c:	41 e0       	ldi	r20, 0x01	; 1
    170e:	81 11       	cpse	r24, r1
    1710:	05 c0       	rjmp	.+10     	; 0x171c <xQueueCRSendFromISR+0x3e>
    1712:	40 e0       	ldi	r20, 0x00	; 0
    1714:	03 c0       	rjmp	.+6      	; 0x171c <xQueueCRSendFromISR+0x3e>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
    1716:	4c 2f       	mov	r20, r28
    1718:	01 c0       	rjmp	.+2      	; 0x171c <xQueueCRSendFromISR+0x3e>
    171a:	40 e0       	ldi	r20, 0x00	; 0
	}
    171c:	84 2f       	mov	r24, r20
    171e:	cf 91       	pop	r28
    1720:	1f 91       	pop	r17
    1722:	0f 91       	pop	r16
    1724:	08 95       	ret

00001726 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1726:	0f 93       	push	r16
    1728:	1f 93       	push	r17
    172a:	cf 93       	push	r28
    172c:	df 93       	push	r29
    172e:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1730:	86 8d       	ldd	r24, Z+30	; 0x1e
    1732:	88 23       	and	r24, r24
    1734:	69 f1       	breq	.+90     	; 0x1790 <xQueueCRReceiveFromISR+0x6a>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1736:	20 a1       	ldd	r18, Z+32	; 0x20
    1738:	30 e0       	ldi	r19, 0x00	; 0
    173a:	a6 81       	ldd	r26, Z+6	; 0x06
    173c:	b7 81       	ldd	r27, Z+7	; 0x07
    173e:	a2 0f       	add	r26, r18
    1740:	b3 1f       	adc	r27, r19
    1742:	b7 83       	std	Z+7, r27	; 0x07
    1744:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1746:	82 81       	ldd	r24, Z+2	; 0x02
    1748:	93 81       	ldd	r25, Z+3	; 0x03
    174a:	a8 17       	cp	r26, r24
    174c:	b9 07       	cpc	r27, r25
    174e:	20 f0       	brcs	.+8      	; 0x1758 <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1750:	80 81       	ld	r24, Z
    1752:	91 81       	ldd	r25, Z+1	; 0x01
    1754:	97 83       	std	Z+7, r25	; 0x07
    1756:	86 83       	std	Z+6, r24	; 0x06
    1758:	8a 01       	movw	r16, r20
    175a:	cb 01       	movw	r24, r22
    175c:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    175e:	46 8d       	ldd	r20, Z+30	; 0x1e
    1760:	41 50       	subi	r20, 0x01	; 1
    1762:	46 8f       	std	Z+30, r20	; 0x1e
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1764:	66 81       	ldd	r22, Z+6	; 0x06
    1766:	77 81       	ldd	r23, Z+7	; 0x07
    1768:	a9 01       	movw	r20, r18
    176a:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    176e:	f8 01       	movw	r30, r16
    1770:	80 81       	ld	r24, Z
    1772:	81 11       	cpse	r24, r1
    1774:	0f c0       	rjmp	.+30     	; 0x1794 <xQueueCRReceiveFromISR+0x6e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1776:	88 85       	ldd	r24, Y+8	; 0x08
    1778:	88 23       	and	r24, r24
    177a:	71 f0       	breq	.+28     	; 0x1798 <xQueueCRReceiveFromISR+0x72>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    177c:	ce 01       	movw	r24, r28
    177e:	08 96       	adiw	r24, 0x08	; 8
    1780:	0e 94 ba 02 	call	0x574	; 0x574 <xCoRoutineRemoveFromEventList>
    1784:	88 23       	and	r24, r24
    1786:	51 f0       	breq	.+20     	; 0x179c <xQueueCRReceiveFromISR+0x76>
					{
						*pxCoRoutineWoken = pdTRUE;
    1788:	81 e0       	ldi	r24, 0x01	; 1
    178a:	f8 01       	movw	r30, r16
    178c:	80 83       	st	Z, r24
    178e:	07 c0       	rjmp	.+14     	; 0x179e <xQueueCRReceiveFromISR+0x78>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1790:	80 e0       	ldi	r24, 0x00	; 0
    1792:	05 c0       	rjmp	.+10     	; 0x179e <xQueueCRReceiveFromISR+0x78>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1794:	81 e0       	ldi	r24, 0x01	; 1
    1796:	03 c0       	rjmp	.+6      	; 0x179e <xQueueCRReceiveFromISR+0x78>
    1798:	81 e0       	ldi	r24, 0x01	; 1
    179a:	01 c0       	rjmp	.+2      	; 0x179e <xQueueCRReceiveFromISR+0x78>
    179c:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    179e:	df 91       	pop	r29
    17a0:	cf 91       	pop	r28
    17a2:	1f 91       	pop	r17
    17a4:	0f 91       	pop	r16
    17a6:	08 95       	ret

000017a8 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    17a8:	e0 91 5c 07 	lds	r30, 0x075C
    17ac:	f0 91 5d 07 	lds	r31, 0x075D
    17b0:	80 81       	ld	r24, Z
    17b2:	81 11       	cpse	r24, r1
    17b4:	0c c0       	rjmp	.+24     	; 0x17ce <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    17b6:	8f ef       	ldi	r24, 0xFF	; 255
    17b8:	9f ef       	ldi	r25, 0xFF	; 255
    17ba:	dc 01       	movw	r26, r24
    17bc:	80 93 35 07 	sts	0x0735, r24
    17c0:	90 93 36 07 	sts	0x0736, r25
    17c4:	a0 93 37 07 	sts	0x0737, r26
    17c8:	b0 93 38 07 	sts	0x0738, r27
    17cc:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    17ce:	e0 91 5c 07 	lds	r30, 0x075C
    17d2:	f0 91 5d 07 	lds	r31, 0x075D
    17d6:	07 80       	ldd	r0, Z+7	; 0x07
    17d8:	f0 85       	ldd	r31, Z+8	; 0x08
    17da:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    17dc:	00 84       	ldd	r0, Z+8	; 0x08
    17de:	f1 85       	ldd	r31, Z+9	; 0x09
    17e0:	e0 2d       	mov	r30, r0
    17e2:	82 81       	ldd	r24, Z+2	; 0x02
    17e4:	93 81       	ldd	r25, Z+3	; 0x03
    17e6:	a4 81       	ldd	r26, Z+4	; 0x04
    17e8:	b5 81       	ldd	r27, Z+5	; 0x05
    17ea:	80 93 35 07 	sts	0x0735, r24
    17ee:	90 93 36 07 	sts	0x0736, r25
    17f2:	a0 93 37 07 	sts	0x0737, r26
    17f6:	b0 93 38 07 	sts	0x0738, r27
    17fa:	08 95       	ret

000017fc <prvIdleTask>:
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    17fc:	0e 94 81 06 	call	0xd02	; 0xd02 <vPortYield>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    1800:	fd cf       	rjmp	.-6      	; 0x17fc <prvIdleTask>

00001802 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    1802:	cf 92       	push	r12
    1804:	df 92       	push	r13
    1806:	ef 92       	push	r14
    1808:	ff 92       	push	r15
    180a:	6b 01       	movw	r12, r22
    180c:	7c 01       	movw	r14, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    180e:	e0 91 7f 07 	lds	r30, 0x077F
    1812:	f0 91 80 07 	lds	r31, 0x0780
    1816:	62 83       	std	Z+2, r22	; 0x02
    1818:	73 83       	std	Z+3, r23	; 0x03
    181a:	84 83       	std	Z+4, r24	; 0x04
    181c:	95 83       	std	Z+5, r25	; 0x05

	if( xTimeToWake < xTickCount )
    181e:	80 91 3f 07 	lds	r24, 0x073F
    1822:	90 91 40 07 	lds	r25, 0x0740
    1826:	a0 91 41 07 	lds	r26, 0x0741
    182a:	b0 91 42 07 	lds	r27, 0x0742
    182e:	c8 16       	cp	r12, r24
    1830:	d9 06       	cpc	r13, r25
    1832:	ea 06       	cpc	r14, r26
    1834:	fb 06       	cpc	r15, r27
    1836:	68 f4       	brcc	.+26     	; 0x1852 <prvAddCurrentTaskToDelayedList+0x50>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1838:	60 91 7f 07 	lds	r22, 0x077F
    183c:	70 91 80 07 	lds	r23, 0x0780
    1840:	80 91 5a 07 	lds	r24, 0x075A
    1844:	90 91 5b 07 	lds	r25, 0x075B
    1848:	6e 5f       	subi	r22, 0xFE	; 254
    184a:	7f 4f       	sbci	r23, 0xFF	; 255
    184c:	0e 94 77 05 	call	0xaee	; 0xaee <vListInsert>
    1850:	21 c0       	rjmp	.+66     	; 0x1894 <prvAddCurrentTaskToDelayedList+0x92>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1852:	60 91 7f 07 	lds	r22, 0x077F
    1856:	70 91 80 07 	lds	r23, 0x0780
    185a:	80 91 5c 07 	lds	r24, 0x075C
    185e:	90 91 5d 07 	lds	r25, 0x075D
    1862:	6e 5f       	subi	r22, 0xFE	; 254
    1864:	7f 4f       	sbci	r23, 0xFF	; 255
    1866:	0e 94 77 05 	call	0xaee	; 0xaee <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    186a:	80 91 35 07 	lds	r24, 0x0735
    186e:	90 91 36 07 	lds	r25, 0x0736
    1872:	a0 91 37 07 	lds	r26, 0x0737
    1876:	b0 91 38 07 	lds	r27, 0x0738
    187a:	c8 16       	cp	r12, r24
    187c:	d9 06       	cpc	r13, r25
    187e:	ea 06       	cpc	r14, r26
    1880:	fb 06       	cpc	r15, r27
    1882:	40 f4       	brcc	.+16     	; 0x1894 <prvAddCurrentTaskToDelayedList+0x92>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1884:	c0 92 35 07 	sts	0x0735, r12
    1888:	d0 92 36 07 	sts	0x0736, r13
    188c:	e0 92 37 07 	sts	0x0737, r14
    1890:	f0 92 38 07 	sts	0x0738, r15
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    1894:	ff 90       	pop	r15
    1896:	ef 90       	pop	r14
    1898:	df 90       	pop	r13
    189a:	cf 90       	pop	r12
    189c:	08 95       	ret

0000189e <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    189e:	4f 92       	push	r4
    18a0:	5f 92       	push	r5
    18a2:	6f 92       	push	r6
    18a4:	7f 92       	push	r7
    18a6:	8f 92       	push	r8
    18a8:	9f 92       	push	r9
    18aa:	af 92       	push	r10
    18ac:	bf 92       	push	r11
    18ae:	cf 92       	push	r12
    18b0:	df 92       	push	r13
    18b2:	ef 92       	push	r14
    18b4:	ff 92       	push	r15
    18b6:	0f 93       	push	r16
    18b8:	cf 93       	push	r28
    18ba:	df 93       	push	r29
    18bc:	4c 01       	movw	r8, r24
    18be:	eb 01       	movw	r28, r22
    18c0:	5a 01       	movw	r10, r20
    18c2:	29 01       	movw	r4, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    18c4:	c1 14       	cp	r12, r1
    18c6:	d1 04       	cpc	r13, r1
    18c8:	39 f4       	brne	.+14     	; 0x18d8 <xTaskGenericCreate+0x3a>
    18ca:	ca 01       	movw	r24, r20
    18cc:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <pvPortMalloc>
    18d0:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
    18d2:	89 2b       	or	r24, r25
    18d4:	09 f4       	brne	.+2      	; 0x18d8 <xTaskGenericCreate+0x3a>
    18d6:	a0 c0       	rjmp	.+320    	; 0x1a18 <xTaskGenericCreate+0x17a>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    18d8:	8a e2       	ldi	r24, 0x2A	; 42
    18da:	90 e0       	ldi	r25, 0x00	; 0
    18dc:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <pvPortMalloc>
    18e0:	3c 01       	movw	r6, r24

			if( pxNewTCB != NULL )
    18e2:	00 97       	sbiw	r24, 0x00	; 0
    18e4:	79 f0       	breq	.+30     	; 0x1904 <xTaskGenericCreate+0x66>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    18e6:	fc 01       	movw	r30, r24
    18e8:	d4 8e       	std	Z+28, r13	; 0x1c
    18ea:	c3 8e       	std	Z+27, r12	; 0x1b
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    18ec:	f1 e0       	ldi	r31, 0x01	; 1
    18ee:	af 1a       	sub	r10, r31
    18f0:	b1 08       	sbc	r11, r1
    18f2:	ca 0c       	add	r12, r10
    18f4:	db 1c       	adc	r13, r11
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    18f6:	88 81       	ld	r24, Y
    18f8:	f3 01       	movw	r30, r6
    18fa:	85 8f       	std	Z+29, r24	; 0x1d

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    18fc:	88 81       	ld	r24, Y
    18fe:	81 11       	cpse	r24, r1
    1900:	05 c0       	rjmp	.+10     	; 0x190c <xTaskGenericCreate+0x6e>
    1902:	14 c0       	rjmp	.+40     	; 0x192c <xTaskGenericCreate+0x8e>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    1904:	c6 01       	movw	r24, r12
    1906:	0e 94 8f 07 	call	0xf1e	; 0xf1e <vPortFree>
    190a:	86 c0       	rjmp	.+268    	; 0x1a18 <xTaskGenericCreate+0x17a>
    190c:	d3 01       	movw	r26, r6
    190e:	5e 96       	adiw	r26, 0x1e	; 30
    1910:	fe 01       	movw	r30, r28
    1912:	31 96       	adiw	r30, 0x01	; 1
    1914:	9e 01       	movw	r18, r28
    1916:	28 5f       	subi	r18, 0xF8	; 248
    1918:	3f 4f       	sbci	r19, 0xFF	; 255
    191a:	ef 01       	movw	r28, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    191c:	81 91       	ld	r24, Z+
    191e:	8d 93       	st	X+, r24

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1920:	88 81       	ld	r24, Y
    1922:	88 23       	and	r24, r24
    1924:	19 f0       	breq	.+6      	; 0x192c <xTaskGenericCreate+0x8e>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1926:	e2 17       	cp	r30, r18
    1928:	f3 07       	cpc	r31, r19
    192a:	b9 f7       	brne	.-18     	; 0x191a <xTaskGenericCreate+0x7c>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    192c:	f3 01       	movw	r30, r6
    192e:	14 a2       	std	Z+36, r1	; 0x24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    1930:	12 8e       	std	Z+26, r1	; 0x1a
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1932:	e3 01       	movw	r28, r6
    1934:	22 96       	adiw	r28, 0x02	; 2
    1936:	ce 01       	movw	r24, r28
    1938:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    193c:	c3 01       	movw	r24, r6
    193e:	0e 96       	adiw	r24, 0x0e	; 14
    1940:	0e 94 52 05 	call	0xaa4	; 0xaa4 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1944:	f3 01       	movw	r30, r6
    1946:	73 86       	std	Z+11, r7	; 0x0b
    1948:	62 86       	std	Z+10, r6	; 0x0a

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    194a:	81 e0       	ldi	r24, 0x01	; 1
    194c:	90 e0       	ldi	r25, 0x00	; 0
    194e:	a0 e0       	ldi	r26, 0x00	; 0
    1950:	b0 e0       	ldi	r27, 0x00	; 0
    1952:	86 87       	std	Z+14, r24	; 0x0e
    1954:	97 87       	std	Z+15, r25	; 0x0f
    1956:	a0 8b       	std	Z+16, r26	; 0x10
    1958:	b1 8b       	std	Z+17, r27	; 0x11
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    195a:	77 8a       	std	Z+23, r7	; 0x17
    195c:	66 8a       	std	Z+22, r6	; 0x16
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    195e:	15 a2       	std	Z+37, r1	; 0x25
    1960:	16 a2       	std	Z+38, r1	; 0x26
    1962:	17 a2       	std	Z+39, r1	; 0x27
    1964:	10 a6       	std	Z+40, r1	; 0x28
		pxTCB->eNotifyState = eNotWaitingNotification;
    1966:	11 a6       	std	Z+41, r1	; 0x29
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1968:	a2 01       	movw	r20, r4
    196a:	b4 01       	movw	r22, r8
    196c:	c6 01       	movw	r24, r12
    196e:	0e 94 da 05 	call	0xbb4	; 0xbb4 <pxPortInitialiseStack>
    1972:	f3 01       	movw	r30, r6
    1974:	91 83       	std	Z+1, r25	; 0x01
    1976:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    1978:	e1 14       	cp	r14, r1
    197a:	f1 04       	cpc	r15, r1
    197c:	19 f0       	breq	.+6      	; 0x1984 <xTaskGenericCreate+0xe6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    197e:	f7 01       	movw	r30, r14
    1980:	71 82       	std	Z+1, r7	; 0x01
    1982:	60 82       	st	Z, r6
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    1984:	0f b6       	in	r0, 0x3f	; 63
    1986:	f8 94       	cli
    1988:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    198a:	80 91 43 07 	lds	r24, 0x0743
    198e:	8f 5f       	subi	r24, 0xFF	; 255
    1990:	80 93 43 07 	sts	0x0743, r24
			if( pxCurrentTCB == NULL )
    1994:	80 91 7f 07 	lds	r24, 0x077F
    1998:	90 91 80 07 	lds	r25, 0x0780
    199c:	89 2b       	or	r24, r25
    199e:	49 f4       	brne	.+18     	; 0x19b2 <xTaskGenericCreate+0x114>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    19a0:	70 92 80 07 	sts	0x0780, r7
    19a4:	60 92 7f 07 	sts	0x077F, r6

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    19a8:	80 91 43 07 	lds	r24, 0x0743
    19ac:	81 30       	cpi	r24, 0x01	; 1
    19ae:	81 f4       	brne	.+32     	; 0x19d0 <xTaskGenericCreate+0x132>
    19b0:	35 c0       	rjmp	.+106    	; 0x1a1c <xTaskGenericCreate+0x17e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    19b2:	80 91 3d 07 	lds	r24, 0x073D
    19b6:	81 11       	cpse	r24, r1
    19b8:	0b c0       	rjmp	.+22     	; 0x19d0 <xTaskGenericCreate+0x132>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    19ba:	e0 91 7f 07 	lds	r30, 0x077F
    19be:	f0 91 80 07 	lds	r31, 0x0780
    19c2:	82 8d       	ldd	r24, Z+26	; 0x1a
    19c4:	08 17       	cp	r16, r24
    19c6:	20 f0       	brcs	.+8      	; 0x19d0 <xTaskGenericCreate+0x132>
					{
						pxCurrentTCB = pxNewTCB;
    19c8:	70 92 80 07 	sts	0x0780, r7
    19cc:	60 92 7f 07 	sts	0x077F, r6
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    19d0:	80 91 39 07 	lds	r24, 0x0739
    19d4:	8f 5f       	subi	r24, 0xFF	; 255
    19d6:	80 93 39 07 	sts	0x0739, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    19da:	f3 01       	movw	r30, r6
    19dc:	82 8d       	ldd	r24, Z+26	; 0x1a
    19de:	90 91 3e 07 	lds	r25, 0x073E
    19e2:	98 17       	cp	r25, r24
    19e4:	10 f4       	brcc	.+4      	; 0x19ea <xTaskGenericCreate+0x14c>
    19e6:	80 93 3e 07 	sts	0x073E, r24
    19ea:	fb e0       	ldi	r31, 0x0B	; 11
    19ec:	8f 9f       	mul	r24, r31
    19ee:	c0 01       	movw	r24, r0
    19f0:	11 24       	eor	r1, r1
    19f2:	be 01       	movw	r22, r28
    19f4:	8c 58       	subi	r24, 0x8C	; 140
    19f6:	98 4f       	sbci	r25, 0xF8	; 248
    19f8:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    19fc:	0f 90       	pop	r0
    19fe:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1a00:	80 91 3d 07 	lds	r24, 0x073D
    1a04:	88 23       	and	r24, r24
    1a06:	31 f0       	breq	.+12     	; 0x1a14 <xTaskGenericCreate+0x176>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1a08:	80 91 7f 07 	lds	r24, 0x077F
    1a0c:	90 91 80 07 	lds	r25, 0x0780
    1a10:	81 e0       	ldi	r24, 0x01	; 1
    1a12:	25 c0       	rjmp	.+74     	; 0x1a5e <xTaskGenericCreate+0x1c0>
    1a14:	81 e0       	ldi	r24, 0x01	; 1
    1a16:	23 c0       	rjmp	.+70     	; 0x1a5e <xTaskGenericCreate+0x1c0>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1a18:	8f ef       	ldi	r24, 0xFF	; 255
    1a1a:	21 c0       	rjmp	.+66     	; 0x1a5e <xTaskGenericCreate+0x1c0>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1a1c:	84 e7       	ldi	r24, 0x74	; 116
    1a1e:	97 e0       	ldi	r25, 0x07	; 7
    1a20:	0e 94 41 05 	call	0xa82	; 0xa82 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
    1a24:	89 e6       	ldi	r24, 0x69	; 105
    1a26:	97 e0       	ldi	r25, 0x07	; 7
    1a28:	0e 94 41 05 	call	0xa82	; 0xa82 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    1a2c:	8e e5       	ldi	r24, 0x5E	; 94
    1a2e:	97 e0       	ldi	r25, 0x07	; 7
    1a30:	0e 94 41 05 	call	0xa82	; 0xa82 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    1a34:	8f e4       	ldi	r24, 0x4F	; 79
    1a36:	97 e0       	ldi	r25, 0x07	; 7
    1a38:	0e 94 41 05 	call	0xa82	; 0xa82 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    1a3c:	84 e4       	ldi	r24, 0x44	; 68
    1a3e:	97 e0       	ldi	r25, 0x07	; 7
    1a40:	0e 94 41 05 	call	0xa82	; 0xa82 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1a44:	89 e6       	ldi	r24, 0x69	; 105
    1a46:	97 e0       	ldi	r25, 0x07	; 7
    1a48:	90 93 5d 07 	sts	0x075D, r25
    1a4c:	80 93 5c 07 	sts	0x075C, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1a50:	8e e5       	ldi	r24, 0x5E	; 94
    1a52:	97 e0       	ldi	r25, 0x07	; 7
    1a54:	90 93 5b 07 	sts	0x075B, r25
    1a58:	80 93 5a 07 	sts	0x075A, r24
    1a5c:	b9 cf       	rjmp	.-142    	; 0x19d0 <xTaskGenericCreate+0x132>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
    1a5e:	df 91       	pop	r29
    1a60:	cf 91       	pop	r28
    1a62:	0f 91       	pop	r16
    1a64:	ff 90       	pop	r15
    1a66:	ef 90       	pop	r14
    1a68:	df 90       	pop	r13
    1a6a:	cf 90       	pop	r12
    1a6c:	bf 90       	pop	r11
    1a6e:	af 90       	pop	r10
    1a70:	9f 90       	pop	r9
    1a72:	8f 90       	pop	r8
    1a74:	7f 90       	pop	r7
    1a76:	6f 90       	pop	r6
    1a78:	5f 90       	pop	r5
    1a7a:	4f 90       	pop	r4
    1a7c:	08 95       	ret

00001a7e <uxTaskPriorityGet>:
	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    1a7e:	0f b6       	in	r0, 0x3f	; 63
    1a80:	f8 94       	cli
    1a82:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1a84:	00 97       	sbiw	r24, 0x00	; 0
    1a86:	21 f4       	brne	.+8      	; 0x1a90 <uxTaskPriorityGet+0x12>
    1a88:	80 91 7f 07 	lds	r24, 0x077F
    1a8c:	90 91 80 07 	lds	r25, 0x0780
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    1a90:	0f 90       	pop	r0
    1a92:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    1a94:	fc 01       	movw	r30, r24
    1a96:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a98:	08 95       	ret

00001a9a <uxTaskPriorityGetFromISR>:

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1a9a:	00 97       	sbiw	r24, 0x00	; 0
    1a9c:	21 f4       	brne	.+8      	; 0x1aa6 <uxTaskPriorityGetFromISR+0xc>
    1a9e:	80 91 7f 07 	lds	r24, 0x077F
    1aa2:	90 91 80 07 	lds	r25, 0x0780
			uxReturn = pxTCB->uxPriority;
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
	}
    1aa6:	fc 01       	movw	r30, r24
    1aa8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1aaa:	08 95       	ret

00001aac <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    1aac:	0f 93       	push	r16
    1aae:	1f 93       	push	r17
    1ab0:	cf 93       	push	r28
    1ab2:	df 93       	push	r29
    1ab4:	ec 01       	movw	r28, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    1ab6:	0f b6       	in	r0, 0x3f	; 63
    1ab8:	f8 94       	cli
    1aba:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1abc:	89 2b       	or	r24, r25
    1abe:	21 f4       	brne	.+8      	; 0x1ac8 <vTaskPrioritySet+0x1c>
    1ac0:	c0 91 7f 07 	lds	r28, 0x077F
    1ac4:	d0 91 80 07 	lds	r29, 0x0780
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
    1ac8:	2a 8d       	ldd	r18, Y+26	; 0x1a
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    1aca:	22 23       	and	r18, r18
    1acc:	a1 f1       	breq	.+104    	; 0x1b36 <vTaskPrioritySet+0x8a>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    1ace:	80 91 7f 07 	lds	r24, 0x077F
    1ad2:	90 91 80 07 	lds	r25, 0x0780
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    1ad6:	1a 8e       	std	Y+26, r1	; 0x1a
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1ad8:	8e 85       	ldd	r24, Y+14	; 0x0e
    1ada:	9f 85       	ldd	r25, Y+15	; 0x0f
    1adc:	a8 89       	ldd	r26, Y+16	; 0x10
    1ade:	b9 89       	ldd	r27, Y+17	; 0x11
    1ae0:	bb 23       	and	r27, r27
    1ae2:	44 f0       	brlt	.+16     	; 0x1af4 <vTaskPrioritySet+0x48>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1ae4:	81 e0       	ldi	r24, 0x01	; 1
    1ae6:	90 e0       	ldi	r25, 0x00	; 0
    1ae8:	a0 e0       	ldi	r26, 0x00	; 0
    1aea:	b0 e0       	ldi	r27, 0x00	; 0
    1aec:	8e 87       	std	Y+14, r24	; 0x0e
    1aee:	9f 87       	std	Y+15, r25	; 0x0f
    1af0:	a8 8b       	std	Y+16, r26	; 0x10
    1af2:	b9 8b       	std	Y+17, r27	; 0x11

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1af4:	8b e0       	ldi	r24, 0x0B	; 11
    1af6:	28 9f       	mul	r18, r24
    1af8:	90 01       	movw	r18, r0
    1afa:	11 24       	eor	r1, r1
    1afc:	2c 58       	subi	r18, 0x8C	; 140
    1afe:	38 4f       	sbci	r19, 0xF8	; 248
    1b00:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b02:	9d 85       	ldd	r25, Y+13	; 0x0d
    1b04:	82 17       	cp	r24, r18
    1b06:	93 07       	cpc	r25, r19
    1b08:	b1 f4       	brne	.+44     	; 0x1b36 <vTaskPrioritySet+0x8a>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1b0a:	8e 01       	movw	r16, r28
    1b0c:	0e 5f       	subi	r16, 0xFE	; 254
    1b0e:	1f 4f       	sbci	r17, 0xFF	; 255
    1b10:	c8 01       	movw	r24, r16
    1b12:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    1b16:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1b18:	80 91 3e 07 	lds	r24, 0x073E
    1b1c:	89 17       	cp	r24, r25
    1b1e:	10 f4       	brcc	.+4      	; 0x1b24 <vTaskPrioritySet+0x78>
    1b20:	90 93 3e 07 	sts	0x073E, r25
    1b24:	2b e0       	ldi	r18, 0x0B	; 11
    1b26:	92 9f       	mul	r25, r18
    1b28:	c0 01       	movw	r24, r0
    1b2a:	11 24       	eor	r1, r1
    1b2c:	b8 01       	movw	r22, r16
    1b2e:	8c 58       	subi	r24, 0x8C	; 140
    1b30:	98 4f       	sbci	r25, 0xF8	; 248
    1b32:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    1b36:	0f 90       	pop	r0
    1b38:	0f be       	out	0x3f, r0	; 63
	}
    1b3a:	df 91       	pop	r29
    1b3c:	cf 91       	pop	r28
    1b3e:	1f 91       	pop	r17
    1b40:	0f 91       	pop	r16
    1b42:	08 95       	ret

00001b44 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    1b44:	0f 93       	push	r16
    1b46:	1f 93       	push	r17
    1b48:	cf 93       	push	r28
    1b4a:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    1b4c:	00 97       	sbiw	r24, 0x00	; 0
    1b4e:	b1 f1       	breq	.+108    	; 0x1bbc <vTaskResume+0x78>
    1b50:	20 91 7f 07 	lds	r18, 0x077F
    1b54:	30 91 80 07 	lds	r19, 0x0780
    1b58:	82 17       	cp	r24, r18
    1b5a:	93 07       	cpc	r25, r19
    1b5c:	79 f1       	breq	.+94     	; 0x1bbc <vTaskResume+0x78>
		{
			taskENTER_CRITICAL();
    1b5e:	0f b6       	in	r0, 0x3f	; 63
    1b60:	f8 94       	cli
    1b62:	0f 92       	push	r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1b64:	fc 01       	movw	r30, r24
    1b66:	24 85       	ldd	r18, Z+12	; 0x0c
    1b68:	35 85       	ldd	r19, Z+13	; 0x0d
    1b6a:	24 54       	subi	r18, 0x44	; 68
    1b6c:	37 40       	sbci	r19, 0x07	; 7
    1b6e:	21 f5       	brne	.+72     	; 0x1bb8 <vTaskResume+0x74>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    1b70:	fc 01       	movw	r30, r24
    1b72:	20 8d       	ldd	r18, Z+24	; 0x18
    1b74:	31 8d       	ldd	r19, Z+25	; 0x19
    1b76:	f7 e0       	ldi	r31, 0x07	; 7
    1b78:	2f 34       	cpi	r18, 0x4F	; 79
    1b7a:	3f 07       	cpc	r19, r31
    1b7c:	e9 f0       	breq	.+58     	; 0x1bb8 <vTaskResume+0x74>
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
		{
			taskENTER_CRITICAL();
			{
				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    1b7e:	23 2b       	or	r18, r19
    1b80:	d9 f4       	brne	.+54     	; 0x1bb8 <vTaskResume+0x74>
    1b82:	ec 01       	movw	r28, r24
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
    1b84:	8c 01       	movw	r16, r24
    1b86:	0e 5f       	subi	r16, 0xFE	; 254
    1b88:	1f 4f       	sbci	r17, 0xFF	; 255
    1b8a:	c8 01       	movw	r24, r16
    1b8c:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1b90:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1b92:	80 91 3e 07 	lds	r24, 0x073E
    1b96:	89 17       	cp	r24, r25
    1b98:	10 f4       	brcc	.+4      	; 0x1b9e <vTaskResume+0x5a>
    1b9a:	90 93 3e 07 	sts	0x073E, r25
    1b9e:	2b e0       	ldi	r18, 0x0B	; 11
    1ba0:	92 9f       	mul	r25, r18
    1ba2:	c0 01       	movw	r24, r0
    1ba4:	11 24       	eor	r1, r1
    1ba6:	b8 01       	movw	r22, r16
    1ba8:	8c 58       	subi	r24, 0x8C	; 140
    1baa:	98 4f       	sbci	r25, 0xF8	; 248
    1bac:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1bb0:	80 91 7f 07 	lds	r24, 0x077F
    1bb4:	90 91 80 07 	lds	r25, 0x0780
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    1bb8:	0f 90       	pop	r0
    1bba:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1bbc:	df 91       	pop	r29
    1bbe:	cf 91       	pop	r28
    1bc0:	1f 91       	pop	r17
    1bc2:	0f 91       	pop	r16
    1bc4:	08 95       	ret

00001bc6 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    1bc6:	ef 92       	push	r14
    1bc8:	ff 92       	push	r15
    1bca:	1f 93       	push	r17
    1bcc:	cf 93       	push	r28
    1bce:	df 93       	push	r29

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1bd0:	fc 01       	movw	r30, r24
    1bd2:	24 85       	ldd	r18, Z+12	; 0x0c
    1bd4:	35 85       	ldd	r19, Z+13	; 0x0d
    1bd6:	24 54       	subi	r18, 0x44	; 68
    1bd8:	37 40       	sbci	r19, 0x07	; 7
    1bda:	c9 f5       	brne	.+114    	; 0x1c4e <xTaskResumeFromISR+0x88>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    1bdc:	fc 01       	movw	r30, r24
    1bde:	20 8d       	ldd	r18, Z+24	; 0x18
    1be0:	31 8d       	ldd	r19, Z+25	; 0x19
    1be2:	f7 e0       	ldi	r31, 0x07	; 7
    1be4:	2f 34       	cpi	r18, 0x4F	; 79
    1be6:	3f 07       	cpc	r19, r31
    1be8:	a1 f1       	breq	.+104    	; 0x1c52 <xTaskResumeFromISR+0x8c>
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    1bea:	23 2b       	or	r18, r19
    1bec:	a1 f5       	brne	.+104    	; 0x1c56 <xTaskResumeFromISR+0x90>
    1bee:	ec 01       	movw	r28, r24
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1bf0:	80 91 34 07 	lds	r24, 0x0734
    1bf4:	81 11       	cpse	r24, r1
    1bf6:	22 c0       	rjmp	.+68     	; 0x1c3c <xTaskResumeFromISR+0x76>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1bf8:	e0 91 7f 07 	lds	r30, 0x077F
    1bfc:	f0 91 80 07 	lds	r31, 0x0780
    1c00:	11 e0       	ldi	r17, 0x01	; 1
    1c02:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1c04:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c06:	98 17       	cp	r25, r24
    1c08:	08 f4       	brcc	.+2      	; 0x1c0c <xTaskResumeFromISR+0x46>
    1c0a:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
    1c0c:	7e 01       	movw	r14, r28
    1c0e:	22 e0       	ldi	r18, 0x02	; 2
    1c10:	e2 0e       	add	r14, r18
    1c12:	f1 1c       	adc	r15, r1
    1c14:	c7 01       	movw	r24, r14
    1c16:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1c1a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1c1c:	80 91 3e 07 	lds	r24, 0x073E
    1c20:	89 17       	cp	r24, r25
    1c22:	10 f4       	brcc	.+4      	; 0x1c28 <xTaskResumeFromISR+0x62>
    1c24:	90 93 3e 07 	sts	0x073E, r25
    1c28:	4b e0       	ldi	r20, 0x0B	; 11
    1c2a:	94 9f       	mul	r25, r20
    1c2c:	c0 01       	movw	r24, r0
    1c2e:	11 24       	eor	r1, r1
    1c30:	b7 01       	movw	r22, r14
    1c32:	8c 58       	subi	r24, 0x8C	; 140
    1c34:	98 4f       	sbci	r25, 0xF8	; 248
    1c36:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>
    1c3a:	0e c0       	rjmp	.+28     	; 0x1c58 <xTaskResumeFromISR+0x92>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1c3c:	be 01       	movw	r22, r28
    1c3e:	62 5f       	subi	r22, 0xF2	; 242
    1c40:	7f 4f       	sbci	r23, 0xFF	; 255
    1c42:	8f e4       	ldi	r24, 0x4F	; 79
    1c44:	97 e0       	ldi	r25, 0x07	; 7
    1c46:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
    1c4a:	10 e0       	ldi	r17, 0x00	; 0
    1c4c:	05 c0       	rjmp	.+10     	; 0x1c58 <xTaskResumeFromISR+0x92>
    1c4e:	10 e0       	ldi	r17, 0x00	; 0
    1c50:	03 c0       	rjmp	.+6      	; 0x1c58 <xTaskResumeFromISR+0x92>
    1c52:	10 e0       	ldi	r17, 0x00	; 0
    1c54:	01 c0       	rjmp	.+2      	; 0x1c58 <xTaskResumeFromISR+0x92>
    1c56:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
    1c58:	81 2f       	mov	r24, r17
    1c5a:	df 91       	pop	r29
    1c5c:	cf 91       	pop	r28
    1c5e:	1f 91       	pop	r17
    1c60:	ff 90       	pop	r15
    1c62:	ef 90       	pop	r14
    1c64:	08 95       	ret

00001c66 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    1c66:	af 92       	push	r10
    1c68:	bf 92       	push	r11
    1c6a:	cf 92       	push	r12
    1c6c:	df 92       	push	r13
    1c6e:	ef 92       	push	r14
    1c70:	ff 92       	push	r15
    1c72:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    1c74:	a1 2c       	mov	r10, r1
    1c76:	b1 2c       	mov	r11, r1
    1c78:	c1 2c       	mov	r12, r1
    1c7a:	d1 2c       	mov	r13, r1
    1c7c:	e1 2c       	mov	r14, r1
    1c7e:	f1 2c       	mov	r15, r1
    1c80:	00 e0       	ldi	r16, 0x00	; 0
    1c82:	20 e0       	ldi	r18, 0x00	; 0
    1c84:	30 e0       	ldi	r19, 0x00	; 0
    1c86:	45 e5       	ldi	r20, 0x55	; 85
    1c88:	50 e0       	ldi	r21, 0x00	; 0
    1c8a:	64 e0       	ldi	r22, 0x04	; 4
    1c8c:	71 e0       	ldi	r23, 0x01	; 1
    1c8e:	8e ef       	ldi	r24, 0xFE	; 254
    1c90:	9b e0       	ldi	r25, 0x0B	; 11
    1c92:	0e 94 4f 0c 	call	0x189e	; 0x189e <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1c96:	81 30       	cpi	r24, 0x01	; 1
    1c98:	c9 f4       	brne	.+50     	; 0x1ccc <vTaskStartScheduler+0x66>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    1c9a:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    1c9c:	8f ef       	ldi	r24, 0xFF	; 255
    1c9e:	9f ef       	ldi	r25, 0xFF	; 255
    1ca0:	dc 01       	movw	r26, r24
    1ca2:	80 93 35 07 	sts	0x0735, r24
    1ca6:	90 93 36 07 	sts	0x0736, r25
    1caa:	a0 93 37 07 	sts	0x0737, r26
    1cae:	b0 93 38 07 	sts	0x0738, r27
		xSchedulerRunning = pdTRUE;
    1cb2:	81 e0       	ldi	r24, 0x01	; 1
    1cb4:	80 93 3d 07 	sts	0x073D, r24
		xTickCount = ( TickType_t ) 0U;
    1cb8:	10 92 3f 07 	sts	0x073F, r1
    1cbc:	10 92 40 07 	sts	0x0740, r1
    1cc0:	10 92 41 07 	sts	0x0741, r1
    1cc4:	10 92 42 07 	sts	0x0742, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1cc8:	0e 94 46 06 	call	0xc8c	; 0xc8c <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    1ccc:	0f 91       	pop	r16
    1cce:	ff 90       	pop	r15
    1cd0:	ef 90       	pop	r14
    1cd2:	df 90       	pop	r13
    1cd4:	cf 90       	pop	r12
    1cd6:	bf 90       	pop	r11
    1cd8:	af 90       	pop	r10
    1cda:	08 95       	ret

00001cdc <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1cdc:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1cde:	10 92 3d 07 	sts	0x073D, r1
	vPortEndScheduler();
    1ce2:	0e 94 80 06 	call	0xd00	; 0xd00 <vPortEndScheduler>
    1ce6:	08 95       	ret

00001ce8 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    1ce8:	80 91 34 07 	lds	r24, 0x0734
    1cec:	8f 5f       	subi	r24, 0xFF	; 255
    1cee:	80 93 34 07 	sts	0x0734, r24
    1cf2:	08 95       	ret

00001cf4 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    1cf4:	0f b6       	in	r0, 0x3f	; 63
    1cf6:	f8 94       	cli
    1cf8:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1cfa:	60 91 3f 07 	lds	r22, 0x073F
    1cfe:	70 91 40 07 	lds	r23, 0x0740
    1d02:	80 91 41 07 	lds	r24, 0x0741
    1d06:	90 91 42 07 	lds	r25, 0x0742
	}
	portTICK_TYPE_EXIT_CRITICAL();
    1d0a:	0f 90       	pop	r0
    1d0c:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1d0e:	08 95       	ret

00001d10 <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    1d10:	60 91 3f 07 	lds	r22, 0x073F
    1d14:	70 91 40 07 	lds	r23, 0x0740
    1d18:	80 91 41 07 	lds	r24, 0x0741
    1d1c:	90 91 42 07 	lds	r25, 0x0742
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1d20:	08 95       	ret

00001d22 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    1d22:	80 91 43 07 	lds	r24, 0x0743
}
    1d26:	08 95       	ret

00001d28 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    1d28:	bf 92       	push	r11
    1d2a:	cf 92       	push	r12
    1d2c:	df 92       	push	r13
    1d2e:	ef 92       	push	r14
    1d30:	ff 92       	push	r15
    1d32:	0f 93       	push	r16
    1d34:	1f 93       	push	r17
    1d36:	cf 93       	push	r28
    1d38:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1d3a:	80 91 34 07 	lds	r24, 0x0734
    1d3e:	81 11       	cpse	r24, r1
    1d40:	af c0       	rjmp	.+350    	; 0x1ea0 <xTaskIncrementTick+0x178>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    1d42:	80 91 3f 07 	lds	r24, 0x073F
    1d46:	90 91 40 07 	lds	r25, 0x0740
    1d4a:	a0 91 41 07 	lds	r26, 0x0741
    1d4e:	b0 91 42 07 	lds	r27, 0x0742
    1d52:	01 96       	adiw	r24, 0x01	; 1
    1d54:	a1 1d       	adc	r26, r1
    1d56:	b1 1d       	adc	r27, r1
    1d58:	80 93 3f 07 	sts	0x073F, r24
    1d5c:	90 93 40 07 	sts	0x0740, r25
    1d60:	a0 93 41 07 	sts	0x0741, r26
    1d64:	b0 93 42 07 	sts	0x0742, r27

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    1d68:	c0 90 3f 07 	lds	r12, 0x073F
    1d6c:	d0 90 40 07 	lds	r13, 0x0740
    1d70:	e0 90 41 07 	lds	r14, 0x0741
    1d74:	f0 90 42 07 	lds	r15, 0x0742

			if( xConstTickCount == ( TickType_t ) 0U )
    1d78:	c1 14       	cp	r12, r1
    1d7a:	d1 04       	cpc	r13, r1
    1d7c:	e1 04       	cpc	r14, r1
    1d7e:	f1 04       	cpc	r15, r1
    1d80:	b9 f4       	brne	.+46     	; 0x1db0 <xTaskIncrementTick+0x88>
			{
				taskSWITCH_DELAYED_LISTS();
    1d82:	80 91 5c 07 	lds	r24, 0x075C
    1d86:	90 91 5d 07 	lds	r25, 0x075D
    1d8a:	20 91 5a 07 	lds	r18, 0x075A
    1d8e:	30 91 5b 07 	lds	r19, 0x075B
    1d92:	30 93 5d 07 	sts	0x075D, r19
    1d96:	20 93 5c 07 	sts	0x075C, r18
    1d9a:	90 93 5b 07 	sts	0x075B, r25
    1d9e:	80 93 5a 07 	sts	0x075A, r24
    1da2:	80 91 3a 07 	lds	r24, 0x073A
    1da6:	8f 5f       	subi	r24, 0xFF	; 255
    1da8:	80 93 3a 07 	sts	0x073A, r24
    1dac:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    1db0:	80 91 35 07 	lds	r24, 0x0735
    1db4:	90 91 36 07 	lds	r25, 0x0736
    1db8:	a0 91 37 07 	lds	r26, 0x0737
    1dbc:	b0 91 38 07 	lds	r27, 0x0738
    1dc0:	c8 16       	cp	r12, r24
    1dc2:	d9 06       	cpc	r13, r25
    1dc4:	ea 06       	cpc	r14, r26
    1dc6:	fb 06       	cpc	r15, r27
    1dc8:	08 f4       	brcc	.+2      	; 0x1dcc <xTaskIncrementTick+0xa4>
    1dca:	6f c0       	rjmp	.+222    	; 0x1eaa <xTaskIncrementTick+0x182>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1dcc:	e0 91 5c 07 	lds	r30, 0x075C
    1dd0:	f0 91 5d 07 	lds	r31, 0x075D
    1dd4:	80 81       	ld	r24, Z
    1dd6:	88 23       	and	r24, r24
    1dd8:	b9 f0       	breq	.+46     	; 0x1e08 <xTaskIncrementTick+0xe0>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1dda:	e0 91 5c 07 	lds	r30, 0x075C
    1dde:	f0 91 5d 07 	lds	r31, 0x075D
    1de2:	07 80       	ldd	r0, Z+7	; 0x07
    1de4:	f0 85       	ldd	r31, Z+8	; 0x08
    1de6:	e0 2d       	mov	r30, r0
    1de8:	c0 85       	ldd	r28, Z+8	; 0x08
    1dea:	d1 85       	ldd	r29, Z+9	; 0x09
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1dec:	8a 81       	ldd	r24, Y+2	; 0x02
    1dee:	9b 81       	ldd	r25, Y+3	; 0x03
    1df0:	ac 81       	ldd	r26, Y+4	; 0x04
    1df2:	bd 81       	ldd	r27, Y+5	; 0x05

						if( xConstTickCount < xItemValue )
    1df4:	c8 16       	cp	r12, r24
    1df6:	d9 06       	cpc	r13, r25
    1df8:	ea 06       	cpc	r14, r26
    1dfa:	fb 06       	cpc	r15, r27
    1dfc:	18 f1       	brcs	.+70     	; 0x1e44 <xTaskIncrementTick+0x11c>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    1dfe:	0f 2e       	mov	r0, r31
    1e00:	fb e0       	ldi	r31, 0x0B	; 11
    1e02:	bf 2e       	mov	r11, r31
    1e04:	f0 2d       	mov	r31, r0
    1e06:	27 c0       	rjmp	.+78     	; 0x1e56 <xTaskIncrementTick+0x12e>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    1e08:	8f ef       	ldi	r24, 0xFF	; 255
    1e0a:	9f ef       	ldi	r25, 0xFF	; 255
    1e0c:	dc 01       	movw	r26, r24
    1e0e:	80 93 35 07 	sts	0x0735, r24
    1e12:	90 93 36 07 	sts	0x0736, r25
    1e16:	a0 93 37 07 	sts	0x0737, r26
    1e1a:	b0 93 38 07 	sts	0x0738, r27
						break;
    1e1e:	45 c0       	rjmp	.+138    	; 0x1eaa <xTaskIncrementTick+0x182>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1e20:	e0 91 5c 07 	lds	r30, 0x075C
    1e24:	f0 91 5d 07 	lds	r31, 0x075D
    1e28:	07 80       	ldd	r0, Z+7	; 0x07
    1e2a:	f0 85       	ldd	r31, Z+8	; 0x08
    1e2c:	e0 2d       	mov	r30, r0
    1e2e:	c0 85       	ldd	r28, Z+8	; 0x08
    1e30:	d1 85       	ldd	r29, Z+9	; 0x09
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1e32:	8a 81       	ldd	r24, Y+2	; 0x02
    1e34:	9b 81       	ldd	r25, Y+3	; 0x03
    1e36:	ac 81       	ldd	r26, Y+4	; 0x04
    1e38:	bd 81       	ldd	r27, Y+5	; 0x05

						if( xConstTickCount < xItemValue )
    1e3a:	c8 16       	cp	r12, r24
    1e3c:	d9 06       	cpc	r13, r25
    1e3e:	ea 06       	cpc	r14, r26
    1e40:	fb 06       	cpc	r15, r27
    1e42:	48 f4       	brcc	.+18     	; 0x1e56 <xTaskIncrementTick+0x12e>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    1e44:	80 93 35 07 	sts	0x0735, r24
    1e48:	90 93 36 07 	sts	0x0736, r25
    1e4c:	a0 93 37 07 	sts	0x0737, r26
    1e50:	b0 93 38 07 	sts	0x0738, r27
							break;
    1e54:	2a c0       	rjmp	.+84     	; 0x1eaa <xTaskIncrementTick+0x182>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1e56:	8e 01       	movw	r16, r28
    1e58:	0e 5f       	subi	r16, 0xFE	; 254
    1e5a:	1f 4f       	sbci	r17, 0xFF	; 255
    1e5c:	c8 01       	movw	r24, r16
    1e5e:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1e62:	88 8d       	ldd	r24, Y+24	; 0x18
    1e64:	99 8d       	ldd	r25, Y+25	; 0x19
    1e66:	89 2b       	or	r24, r25
    1e68:	21 f0       	breq	.+8      	; 0x1e72 <xTaskIncrementTick+0x14a>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1e6a:	ce 01       	movw	r24, r28
    1e6c:	0e 96       	adiw	r24, 0x0e	; 14
    1e6e:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    1e72:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1e74:	80 91 3e 07 	lds	r24, 0x073E
    1e78:	89 17       	cp	r24, r25
    1e7a:	10 f4       	brcc	.+4      	; 0x1e80 <xTaskIncrementTick+0x158>
    1e7c:	90 93 3e 07 	sts	0x073E, r25
    1e80:	b9 9e       	mul	r11, r25
    1e82:	c0 01       	movw	r24, r0
    1e84:	11 24       	eor	r1, r1
    1e86:	b8 01       	movw	r22, r16
    1e88:	8c 58       	subi	r24, 0x8C	; 140
    1e8a:	98 4f       	sbci	r25, 0xF8	; 248
    1e8c:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1e90:	e0 91 5c 07 	lds	r30, 0x075C
    1e94:	f0 91 5d 07 	lds	r31, 0x075D
    1e98:	80 81       	ld	r24, Z
    1e9a:	81 11       	cpse	r24, r1
    1e9c:	c1 cf       	rjmp	.-126    	; 0x1e20 <xTaskIncrementTick+0xf8>
    1e9e:	b4 cf       	rjmp	.-152    	; 0x1e08 <xTaskIncrementTick+0xe0>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    1ea0:	80 91 3c 07 	lds	r24, 0x073C
    1ea4:	8f 5f       	subi	r24, 0xFF	; 255
    1ea6:	80 93 3c 07 	sts	0x073C, r24
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    1eaa:	80 e0       	ldi	r24, 0x00	; 0
    1eac:	df 91       	pop	r29
    1eae:	cf 91       	pop	r28
    1eb0:	1f 91       	pop	r17
    1eb2:	0f 91       	pop	r16
    1eb4:	ff 90       	pop	r15
    1eb6:	ef 90       	pop	r14
    1eb8:	df 90       	pop	r13
    1eba:	cf 90       	pop	r12
    1ebc:	bf 90       	pop	r11
    1ebe:	08 95       	ret

00001ec0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    1ec0:	cf 92       	push	r12
    1ec2:	df 92       	push	r13
    1ec4:	ef 92       	push	r14
    1ec6:	ff 92       	push	r15
    1ec8:	0f 93       	push	r16
    1eca:	1f 93       	push	r17
    1ecc:	cf 93       	push	r28
    1ece:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1ed0:	0f b6       	in	r0, 0x3f	; 63
    1ed2:	f8 94       	cli
    1ed4:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1ed6:	80 91 34 07 	lds	r24, 0x0734
    1eda:	81 50       	subi	r24, 0x01	; 1
    1edc:	80 93 34 07 	sts	0x0734, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1ee0:	80 91 34 07 	lds	r24, 0x0734
    1ee4:	81 11       	cpse	r24, r1
    1ee6:	59 c0       	rjmp	.+178    	; 0x1f9a <xTaskResumeAll+0xda>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1ee8:	80 91 43 07 	lds	r24, 0x0743
    1eec:	81 11       	cpse	r24, r1
    1eee:	2c c0       	rjmp	.+88     	; 0x1f48 <xTaskResumeAll+0x88>
    1ef0:	54 c0       	rjmp	.+168    	; 0x1f9a <xTaskResumeAll+0xda>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    1ef2:	d7 01       	movw	r26, r14
    1ef4:	17 96       	adiw	r26, 0x07	; 7
    1ef6:	ed 91       	ld	r30, X+
    1ef8:	fc 91       	ld	r31, X
    1efa:	18 97       	sbiw	r26, 0x08	; 8
    1efc:	c0 85       	ldd	r28, Z+8	; 0x08
    1efe:	d1 85       	ldd	r29, Z+9	; 0x09
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1f00:	ce 01       	movw	r24, r28
    1f02:	0e 96       	adiw	r24, 0x0e	; 14
    1f04:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1f08:	8e 01       	movw	r16, r28
    1f0a:	0e 5f       	subi	r16, 0xFE	; 254
    1f0c:	1f 4f       	sbci	r17, 0xFF	; 255
    1f0e:	c8 01       	movw	r24, r16
    1f10:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1f14:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1f16:	80 91 3e 07 	lds	r24, 0x073E
    1f1a:	89 17       	cp	r24, r25
    1f1c:	10 f4       	brcc	.+4      	; 0x1f22 <xTaskResumeAll+0x62>
    1f1e:	90 93 3e 07 	sts	0x073E, r25
    1f22:	d9 9e       	mul	r13, r25
    1f24:	c0 01       	movw	r24, r0
    1f26:	11 24       	eor	r1, r1
    1f28:	b8 01       	movw	r22, r16
    1f2a:	8c 58       	subi	r24, 0x8C	; 140
    1f2c:	98 4f       	sbci	r25, 0xF8	; 248
    1f2e:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1f32:	e0 91 7f 07 	lds	r30, 0x077F
    1f36:	f0 91 80 07 	lds	r31, 0x0780
    1f3a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1f3c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f3e:	98 17       	cp	r25, r24
    1f40:	78 f0       	brcs	.+30     	; 0x1f60 <xTaskResumeAll+0xa0>
					{
						xYieldPending = pdTRUE;
    1f42:	c0 92 3b 07 	sts	0x073B, r12
    1f46:	0c c0       	rjmp	.+24     	; 0x1f60 <xTaskResumeAll+0xa0>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1f48:	0f 2e       	mov	r0, r31
    1f4a:	ff e4       	ldi	r31, 0x4F	; 79
    1f4c:	ef 2e       	mov	r14, r31
    1f4e:	f7 e0       	ldi	r31, 0x07	; 7
    1f50:	ff 2e       	mov	r15, r31
    1f52:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyList( pxTCB );
    1f54:	0f 2e       	mov	r0, r31
    1f56:	fb e0       	ldi	r31, 0x0B	; 11
    1f58:	df 2e       	mov	r13, r31
    1f5a:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    1f5c:	cc 24       	eor	r12, r12
    1f5e:	c3 94       	inc	r12
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1f60:	f7 01       	movw	r30, r14
    1f62:	80 81       	ld	r24, Z
    1f64:	81 11       	cpse	r24, r1
    1f66:	c5 cf       	rjmp	.-118    	; 0x1ef2 <xTaskResumeAll+0x32>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    1f68:	80 91 3c 07 	lds	r24, 0x073C
    1f6c:	88 23       	and	r24, r24
    1f6e:	99 f0       	breq	.+38     	; 0x1f96 <xTaskResumeAll+0xd6>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    1f70:	80 91 3c 07 	lds	r24, 0x073C
    1f74:	88 23       	and	r24, r24
    1f76:	79 f0       	breq	.+30     	; 0x1f96 <xTaskResumeAll+0xd6>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
    1f78:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    1f7a:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <xTaskIncrementTick>
    1f7e:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
    1f80:	c0 93 3b 07 	sts	0x073B, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    1f84:	80 91 3c 07 	lds	r24, 0x073C
    1f88:	81 50       	subi	r24, 0x01	; 1
    1f8a:	80 93 3c 07 	sts	0x073C, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    1f8e:	80 91 3c 07 	lds	r24, 0x073C
    1f92:	81 11       	cpse	r24, r1
    1f94:	f2 cf       	rjmp	.-28     	; 0x1f7a <xTaskResumeAll+0xba>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    1f96:	80 91 3b 07 	lds	r24, 0x073B
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1f9a:	0f 90       	pop	r0
    1f9c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1f9e:	80 e0       	ldi	r24, 0x00	; 0
    1fa0:	df 91       	pop	r29
    1fa2:	cf 91       	pop	r28
    1fa4:	1f 91       	pop	r17
    1fa6:	0f 91       	pop	r16
    1fa8:	ff 90       	pop	r15
    1faa:	ef 90       	pop	r14
    1fac:	df 90       	pop	r13
    1fae:	cf 90       	pop	r12
    1fb0:	08 95       	ret

00001fb2 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    1fb2:	cf 92       	push	r12
    1fb4:	df 92       	push	r13
    1fb6:	ef 92       	push	r14
    1fb8:	ff 92       	push	r15
    1fba:	0f 93       	push	r16
    1fbc:	1f 93       	push	r17
    1fbe:	cf 93       	push	r28
    1fc0:	df 93       	push	r29
    1fc2:	ec 01       	movw	r28, r24
    1fc4:	6a 01       	movw	r12, r20
    1fc6:	7b 01       	movw	r14, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    1fc8:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    1fcc:	80 91 3f 07 	lds	r24, 0x073F
    1fd0:	90 91 40 07 	lds	r25, 0x0740
    1fd4:	a0 91 41 07 	lds	r26, 0x0741
    1fd8:	b0 91 42 07 	lds	r27, 0x0742

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1fdc:	08 81       	ld	r16, Y
    1fde:	19 81       	ldd	r17, Y+1	; 0x01
    1fe0:	2a 81       	ldd	r18, Y+2	; 0x02
    1fe2:	3b 81       	ldd	r19, Y+3	; 0x03
    1fe4:	c0 0e       	add	r12, r16
    1fe6:	d1 1e       	adc	r13, r17
    1fe8:	e2 1e       	adc	r14, r18
    1fea:	f3 1e       	adc	r15, r19

			if( xConstTickCount < *pxPreviousWakeTime )
    1fec:	80 17       	cp	r24, r16
    1fee:	91 07       	cpc	r25, r17
    1ff0:	a2 07       	cpc	r26, r18
    1ff2:	b3 07       	cpc	r27, r19
    1ff4:	78 f4       	brcc	.+30     	; 0x2014 <vTaskDelayUntil+0x62>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    1ff6:	c0 16       	cp	r12, r16
    1ff8:	d1 06       	cpc	r13, r17
    1ffa:	e2 06       	cpc	r14, r18
    1ffc:	f3 06       	cpc	r15, r19
    1ffe:	60 f5       	brcc	.+88     	; 0x2058 <vTaskDelayUntil+0xa6>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2000:	c8 82       	st	Y, r12
    2002:	d9 82       	std	Y+1, r13	; 0x01
    2004:	ea 82       	std	Y+2, r14	; 0x02
    2006:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    2008:	8c 15       	cp	r24, r12
    200a:	9d 05       	cpc	r25, r13
    200c:	ae 05       	cpc	r26, r14
    200e:	bf 05       	cpc	r27, r15
    2010:	b8 f4       	brcc	.+46     	; 0x2040 <vTaskDelayUntil+0x8e>
    2012:	0b c0       	rjmp	.+22     	; 0x202a <vTaskDelayUntil+0x78>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    2014:	c0 16       	cp	r12, r16
    2016:	d1 06       	cpc	r13, r17
    2018:	e2 06       	cpc	r14, r18
    201a:	f3 06       	cpc	r15, r19
    201c:	c0 f0       	brcs	.+48     	; 0x204e <vTaskDelayUntil+0x9c>
    201e:	8c 15       	cp	r24, r12
    2020:	9d 05       	cpc	r25, r13
    2022:	ae 05       	cpc	r26, r14
    2024:	bf 05       	cpc	r27, r15
    2026:	98 f0       	brcs	.+38     	; 0x204e <vTaskDelayUntil+0x9c>
    2028:	17 c0       	rjmp	.+46     	; 0x2058 <vTaskDelayUntil+0xa6>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    202a:	80 91 7f 07 	lds	r24, 0x077F
    202e:	90 91 80 07 	lds	r25, 0x0780
    2032:	02 96       	adiw	r24, 0x02	; 2
    2034:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2038:	c7 01       	movw	r24, r14
    203a:	b6 01       	movw	r22, r12
    203c:	0e 94 01 0c 	call	0x1802	; 0x1802 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2040:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2044:	81 11       	cpse	r24, r1
    2046:	0d c0       	rjmp	.+26     	; 0x2062 <vTaskDelayUntil+0xb0>
		{
			portYIELD_WITHIN_API();
    2048:	0e 94 81 06 	call	0xd02	; 0xd02 <vPortYield>
    204c:	0a c0       	rjmp	.+20     	; 0x2062 <vTaskDelayUntil+0xb0>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    204e:	c8 82       	st	Y, r12
    2050:	d9 82       	std	Y+1, r13	; 0x01
    2052:	ea 82       	std	Y+2, r14	; 0x02
    2054:	fb 82       	std	Y+3, r15	; 0x03
    2056:	e9 cf       	rjmp	.-46     	; 0x202a <vTaskDelayUntil+0x78>
    2058:	c8 82       	st	Y, r12
    205a:	d9 82       	std	Y+1, r13	; 0x01
    205c:	ea 82       	std	Y+2, r14	; 0x02
    205e:	fb 82       	std	Y+3, r15	; 0x03
    2060:	ef cf       	rjmp	.-34     	; 0x2040 <vTaskDelayUntil+0x8e>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2062:	df 91       	pop	r29
    2064:	cf 91       	pop	r28
    2066:	1f 91       	pop	r17
    2068:	0f 91       	pop	r16
    206a:	ff 90       	pop	r15
    206c:	ef 90       	pop	r14
    206e:	df 90       	pop	r13
    2070:	cf 90       	pop	r12
    2072:	08 95       	ret

00002074 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2074:	cf 92       	push	r12
    2076:	df 92       	push	r13
    2078:	ef 92       	push	r14
    207a:	ff 92       	push	r15
    207c:	6b 01       	movw	r12, r22
    207e:	7c 01       	movw	r14, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2080:	67 2b       	or	r22, r23
    2082:	68 2b       	or	r22, r24
    2084:	69 2b       	or	r22, r25
    2086:	e9 f0       	breq	.+58     	; 0x20c2 <vTaskDelay+0x4e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2088:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    208c:	80 91 3f 07 	lds	r24, 0x073F
    2090:	90 91 40 07 	lds	r25, 0x0740
    2094:	a0 91 41 07 	lds	r26, 0x0741
    2098:	b0 91 42 07 	lds	r27, 0x0742
    209c:	c8 0e       	add	r12, r24
    209e:	d9 1e       	adc	r13, r25
    20a0:	ea 1e       	adc	r14, r26
    20a2:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    20a4:	80 91 7f 07 	lds	r24, 0x077F
    20a8:	90 91 80 07 	lds	r25, 0x0780
    20ac:	02 96       	adiw	r24, 0x02	; 2
    20ae:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    20b2:	c7 01       	movw	r24, r14
    20b4:	b6 01       	movw	r22, r12
    20b6:	0e 94 01 0c 	call	0x1802	; 0x1802 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    20ba:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    20be:	81 11       	cpse	r24, r1
    20c0:	02 c0       	rjmp	.+4      	; 0x20c6 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    20c2:	0e 94 81 06 	call	0xd02	; 0xd02 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    20c6:	ff 90       	pop	r15
    20c8:	ef 90       	pop	r14
    20ca:	df 90       	pop	r13
    20cc:	cf 90       	pop	r12
    20ce:	08 95       	ret

000020d0 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    20d0:	80 91 34 07 	lds	r24, 0x0734
    20d4:	88 23       	and	r24, r24
    20d6:	21 f0       	breq	.+8      	; 0x20e0 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    20d8:	81 e0       	ldi	r24, 0x01	; 1
    20da:	80 93 3b 07 	sts	0x073B, r24
    20de:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    20e0:	10 92 3b 07 	sts	0x073B, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    20e4:	e0 91 3e 07 	lds	r30, 0x073E
    20e8:	4b e0       	ldi	r20, 0x0B	; 11
    20ea:	e4 9f       	mul	r30, r20
    20ec:	f0 01       	movw	r30, r0
    20ee:	11 24       	eor	r1, r1
    20f0:	ec 58       	subi	r30, 0x8C	; 140
    20f2:	f8 4f       	sbci	r31, 0xF8	; 248
    20f4:	80 81       	ld	r24, Z
    20f6:	81 11       	cpse	r24, r1
    20f8:	10 c0       	rjmp	.+32     	; 0x211a <vTaskSwitchContext+0x4a>
    20fa:	9b e0       	ldi	r25, 0x0B	; 11
    20fc:	80 91 3e 07 	lds	r24, 0x073E
    2100:	81 50       	subi	r24, 0x01	; 1
    2102:	80 93 3e 07 	sts	0x073E, r24
    2106:	e0 91 3e 07 	lds	r30, 0x073E
    210a:	9e 9f       	mul	r25, r30
    210c:	f0 01       	movw	r30, r0
    210e:	11 24       	eor	r1, r1
    2110:	ec 58       	subi	r30, 0x8C	; 140
    2112:	f8 4f       	sbci	r31, 0xF8	; 248
    2114:	80 81       	ld	r24, Z
    2116:	88 23       	and	r24, r24
    2118:	89 f3       	breq	.-30     	; 0x20fc <vTaskSwitchContext+0x2c>
    211a:	80 91 3e 07 	lds	r24, 0x073E
    211e:	28 2f       	mov	r18, r24
    2120:	30 e0       	ldi	r19, 0x00	; 0
    2122:	4b e0       	ldi	r20, 0x0B	; 11
    2124:	84 9f       	mul	r24, r20
    2126:	c0 01       	movw	r24, r0
    2128:	11 24       	eor	r1, r1
    212a:	dc 01       	movw	r26, r24
    212c:	ac 58       	subi	r26, 0x8C	; 140
    212e:	b8 4f       	sbci	r27, 0xF8	; 248
    2130:	11 96       	adiw	r26, 0x01	; 1
    2132:	ed 91       	ld	r30, X+
    2134:	fc 91       	ld	r31, X
    2136:	12 97       	sbiw	r26, 0x02	; 2
    2138:	04 80       	ldd	r0, Z+4	; 0x04
    213a:	f5 81       	ldd	r31, Z+5	; 0x05
    213c:	e0 2d       	mov	r30, r0
    213e:	12 96       	adiw	r26, 0x02	; 2
    2140:	fc 93       	st	X, r31
    2142:	ee 93       	st	-X, r30
    2144:	11 97       	sbiw	r26, 0x01	; 1
    2146:	89 58       	subi	r24, 0x89	; 137
    2148:	98 4f       	sbci	r25, 0xF8	; 248
    214a:	e8 17       	cp	r30, r24
    214c:	f9 07       	cpc	r31, r25
    214e:	61 f4       	brne	.+24     	; 0x2168 <vTaskSwitchContext+0x98>
    2150:	84 81       	ldd	r24, Z+4	; 0x04
    2152:	95 81       	ldd	r25, Z+5	; 0x05
    2154:	4b e0       	ldi	r20, 0x0B	; 11
    2156:	42 9f       	mul	r20, r18
    2158:	f0 01       	movw	r30, r0
    215a:	43 9f       	mul	r20, r19
    215c:	f0 0d       	add	r31, r0
    215e:	11 24       	eor	r1, r1
    2160:	ec 58       	subi	r30, 0x8C	; 140
    2162:	f8 4f       	sbci	r31, 0xF8	; 248
    2164:	92 83       	std	Z+2, r25	; 0x02
    2166:	81 83       	std	Z+1, r24	; 0x01
    2168:	8b e0       	ldi	r24, 0x0B	; 11
    216a:	82 9f       	mul	r24, r18
    216c:	f0 01       	movw	r30, r0
    216e:	83 9f       	mul	r24, r19
    2170:	f0 0d       	add	r31, r0
    2172:	11 24       	eor	r1, r1
    2174:	ec 58       	subi	r30, 0x8C	; 140
    2176:	f8 4f       	sbci	r31, 0xF8	; 248
    2178:	01 80       	ldd	r0, Z+1	; 0x01
    217a:	f2 81       	ldd	r31, Z+2	; 0x02
    217c:	e0 2d       	mov	r30, r0
    217e:	80 85       	ldd	r24, Z+8	; 0x08
    2180:	91 85       	ldd	r25, Z+9	; 0x09
    2182:	90 93 80 07 	sts	0x0780, r25
    2186:	80 93 7f 07 	sts	0x077F, r24
    218a:	08 95       	ret

0000218c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    218c:	0f 93       	push	r16
    218e:	1f 93       	push	r17
    2190:	cf 93       	push	r28
    2192:	df 93       	push	r29
    2194:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    2196:	0f b6       	in	r0, 0x3f	; 63
    2198:	f8 94       	cli
    219a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    219c:	89 2b       	or	r24, r25
    219e:	21 f4       	brne	.+8      	; 0x21a8 <vTaskSuspend+0x1c>
    21a0:	c0 91 7f 07 	lds	r28, 0x077F
    21a4:	d0 91 80 07 	lds	r29, 0x0780

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    21a8:	8e 01       	movw	r16, r28
    21aa:	0e 5f       	subi	r16, 0xFE	; 254
    21ac:	1f 4f       	sbci	r17, 0xFF	; 255
    21ae:	c8 01       	movw	r24, r16
    21b0:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    21b4:	88 8d       	ldd	r24, Y+24	; 0x18
    21b6:	99 8d       	ldd	r25, Y+25	; 0x19
    21b8:	89 2b       	or	r24, r25
    21ba:	21 f0       	breq	.+8      	; 0x21c4 <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    21bc:	ce 01       	movw	r24, r28
    21be:	0e 96       	adiw	r24, 0x0e	; 14
    21c0:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    21c4:	b8 01       	movw	r22, r16
    21c6:	84 e4       	ldi	r24, 0x44	; 68
    21c8:	97 e0       	ldi	r25, 0x07	; 7
    21ca:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    21ce:	0f 90       	pop	r0
    21d0:	0f be       	out	0x3f, r0	; 63

		if( pxTCB == pxCurrentTCB )
    21d2:	80 91 7f 07 	lds	r24, 0x077F
    21d6:	90 91 80 07 	lds	r25, 0x0780
    21da:	c8 17       	cp	r28, r24
    21dc:	d9 07       	cpc	r29, r25
    21de:	a9 f4       	brne	.+42     	; 0x220a <vTaskSuspend+0x7e>
		{
			if( xSchedulerRunning != pdFALSE )
    21e0:	80 91 3d 07 	lds	r24, 0x073D
    21e4:	88 23       	and	r24, r24
    21e6:	19 f0       	breq	.+6      	; 0x21ee <vTaskSuspend+0x62>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    21e8:	0e 94 81 06 	call	0xd02	; 0xd02 <vPortYield>
    21ec:	19 c0       	rjmp	.+50     	; 0x2220 <vTaskSuspend+0x94>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    21ee:	80 91 43 07 	lds	r24, 0x0743
    21f2:	90 91 44 07 	lds	r25, 0x0744
    21f6:	98 13       	cpse	r25, r24
    21f8:	05 c0       	rjmp	.+10     	; 0x2204 <vTaskSuspend+0x78>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    21fa:	10 92 80 07 	sts	0x0780, r1
    21fe:	10 92 7f 07 	sts	0x077F, r1
    2202:	0e c0       	rjmp	.+28     	; 0x2220 <vTaskSuspend+0x94>
				}
				else
				{
					vTaskSwitchContext();
    2204:	0e 94 68 10 	call	0x20d0	; 0x20d0 <vTaskSwitchContext>
    2208:	0b c0       	rjmp	.+22     	; 0x2220 <vTaskSuspend+0x94>
				}
			}
		}
		else
		{
			if( xSchedulerRunning != pdFALSE )
    220a:	80 91 3d 07 	lds	r24, 0x073D
    220e:	88 23       	and	r24, r24
    2210:	39 f0       	breq	.+14     	; 0x2220 <vTaskSuspend+0x94>
			{
				/* A task other than the currently running task was suspended,
				reset the next expected unblock time in case it referred to the
				task that is now in the Suspended state. */
				taskENTER_CRITICAL();
    2212:	0f b6       	in	r0, 0x3f	; 63
    2214:	f8 94       	cli
    2216:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    2218:	0e 94 d4 0b 	call	0x17a8	; 0x17a8 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    221c:	0f 90       	pop	r0
    221e:	0f be       	out	0x3f, r0	; 63
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    2220:	df 91       	pop	r29
    2222:	cf 91       	pop	r28
    2224:	1f 91       	pop	r17
    2226:	0f 91       	pop	r16
    2228:	08 95       	ret

0000222a <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    222a:	cf 92       	push	r12
    222c:	df 92       	push	r13
    222e:	ef 92       	push	r14
    2230:	ff 92       	push	r15
    2232:	6a 01       	movw	r12, r20
    2234:	7b 01       	movw	r14, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2236:	20 91 7f 07 	lds	r18, 0x077F
    223a:	30 91 80 07 	lds	r19, 0x0780
    223e:	b9 01       	movw	r22, r18
    2240:	62 5f       	subi	r22, 0xF2	; 242
    2242:	7f 4f       	sbci	r23, 0xFF	; 255
    2244:	0e 94 77 05 	call	0xaee	; 0xaee <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2248:	80 91 7f 07 	lds	r24, 0x077F
    224c:	90 91 80 07 	lds	r25, 0x0780
    2250:	02 96       	adiw	r24, 0x02	; 2
    2252:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    2256:	8f ef       	ldi	r24, 0xFF	; 255
    2258:	c8 16       	cp	r12, r24
    225a:	d8 06       	cpc	r13, r24
    225c:	e8 06       	cpc	r14, r24
    225e:	f8 06       	cpc	r15, r24
    2260:	59 f4       	brne	.+22     	; 0x2278 <vTaskPlaceOnEventList+0x4e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    2262:	60 91 7f 07 	lds	r22, 0x077F
    2266:	70 91 80 07 	lds	r23, 0x0780
    226a:	6e 5f       	subi	r22, 0xFE	; 254
    226c:	7f 4f       	sbci	r23, 0xFF	; 255
    226e:	84 e4       	ldi	r24, 0x44	; 68
    2270:	97 e0       	ldi	r25, 0x07	; 7
    2272:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>
    2276:	10 c0       	rjmp	.+32     	; 0x2298 <vTaskPlaceOnEventList+0x6e>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    2278:	80 91 3f 07 	lds	r24, 0x073F
    227c:	90 91 40 07 	lds	r25, 0x0740
    2280:	a0 91 41 07 	lds	r26, 0x0741
    2284:	b0 91 42 07 	lds	r27, 0x0742
    2288:	bc 01       	movw	r22, r24
    228a:	cd 01       	movw	r24, r26
    228c:	6c 0d       	add	r22, r12
    228e:	7d 1d       	adc	r23, r13
    2290:	8e 1d       	adc	r24, r14
    2292:	9f 1d       	adc	r25, r15
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2294:	0e 94 01 0c 	call	0x1802	; 0x1802 <prvAddCurrentTaskToDelayedList>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    2298:	ff 90       	pop	r15
    229a:	ef 90       	pop	r14
    229c:	df 90       	pop	r13
    229e:	cf 90       	pop	r12
    22a0:	08 95       	ret

000022a2 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    22a2:	cf 92       	push	r12
    22a4:	df 92       	push	r13
    22a6:	ef 92       	push	r14
    22a8:	ff 92       	push	r15
    22aa:	0f 93       	push	r16
    22ac:	1f 93       	push	r17
    22ae:	68 01       	movw	r12, r16
    22b0:	79 01       	movw	r14, r18
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    22b2:	e0 91 7f 07 	lds	r30, 0x077F
    22b6:	f0 91 80 07 	lds	r31, 0x0780
    22ba:	70 68       	ori	r23, 0x80	; 128
    22bc:	46 87       	std	Z+14, r20	; 0x0e
    22be:	57 87       	std	Z+15, r21	; 0x0f
    22c0:	60 8b       	std	Z+16, r22	; 0x10
    22c2:	71 8b       	std	Z+17, r23	; 0x11
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    22c4:	20 91 7f 07 	lds	r18, 0x077F
    22c8:	30 91 80 07 	lds	r19, 0x0780
    22cc:	b9 01       	movw	r22, r18
    22ce:	62 5f       	subi	r22, 0xF2	; 242
    22d0:	7f 4f       	sbci	r23, 0xFF	; 255
    22d2:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    22d6:	80 91 7f 07 	lds	r24, 0x077F
    22da:	90 91 80 07 	lds	r25, 0x0780
    22de:	02 96       	adiw	r24, 0x02	; 2
    22e0:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    22e4:	8f ef       	ldi	r24, 0xFF	; 255
    22e6:	c8 16       	cp	r12, r24
    22e8:	d8 06       	cpc	r13, r24
    22ea:	e8 06       	cpc	r14, r24
    22ec:	f8 06       	cpc	r15, r24
    22ee:	59 f4       	brne	.+22     	; 0x2306 <vTaskPlaceOnUnorderedEventList+0x64>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    22f0:	60 91 7f 07 	lds	r22, 0x077F
    22f4:	70 91 80 07 	lds	r23, 0x0780
    22f8:	6e 5f       	subi	r22, 0xFE	; 254
    22fa:	7f 4f       	sbci	r23, 0xFF	; 255
    22fc:	84 e4       	ldi	r24, 0x44	; 68
    22fe:	97 e0       	ldi	r25, 0x07	; 7
    2300:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>
    2304:	10 c0       	rjmp	.+32     	; 0x2326 <vTaskPlaceOnUnorderedEventList+0x84>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    2306:	80 91 3f 07 	lds	r24, 0x073F
    230a:	90 91 40 07 	lds	r25, 0x0740
    230e:	a0 91 41 07 	lds	r26, 0x0741
    2312:	b0 91 42 07 	lds	r27, 0x0742
    2316:	bc 01       	movw	r22, r24
    2318:	cd 01       	movw	r24, r26
    231a:	6c 0d       	add	r22, r12
    231c:	7d 1d       	adc	r23, r13
    231e:	8e 1d       	adc	r24, r14
    2320:	9f 1d       	adc	r25, r15
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2322:	0e 94 01 0c 	call	0x1802	; 0x1802 <prvAddCurrentTaskToDelayedList>
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    2326:	1f 91       	pop	r17
    2328:	0f 91       	pop	r16
    232a:	ff 90       	pop	r15
    232c:	ef 90       	pop	r14
    232e:	df 90       	pop	r13
    2330:	cf 90       	pop	r12
    2332:	08 95       	ret

00002334 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    2334:	0f 93       	push	r16
    2336:	1f 93       	push	r17
    2338:	cf 93       	push	r28
    233a:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    233c:	dc 01       	movw	r26, r24
    233e:	17 96       	adiw	r26, 0x07	; 7
    2340:	ed 91       	ld	r30, X+
    2342:	fc 91       	ld	r31, X
    2344:	18 97       	sbiw	r26, 0x08	; 8
    2346:	c0 85       	ldd	r28, Z+8	; 0x08
    2348:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    234a:	8e 01       	movw	r16, r28
    234c:	02 5f       	subi	r16, 0xF2	; 242
    234e:	1f 4f       	sbci	r17, 0xFF	; 255
    2350:	c8 01       	movw	r24, r16
    2352:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2356:	80 91 34 07 	lds	r24, 0x0734
    235a:	81 11       	cpse	r24, r1
    235c:	16 c0       	rjmp	.+44     	; 0x238a <xTaskRemoveFromEventList+0x56>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    235e:	0c 50       	subi	r16, 0x0C	; 12
    2360:	11 09       	sbc	r17, r1
    2362:	c8 01       	movw	r24, r16
    2364:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    2368:	9a 8d       	ldd	r25, Y+26	; 0x1a
    236a:	80 91 3e 07 	lds	r24, 0x073E
    236e:	89 17       	cp	r24, r25
    2370:	10 f4       	brcc	.+4      	; 0x2376 <xTaskRemoveFromEventList+0x42>
    2372:	90 93 3e 07 	sts	0x073E, r25
    2376:	bb e0       	ldi	r27, 0x0B	; 11
    2378:	9b 9f       	mul	r25, r27
    237a:	c0 01       	movw	r24, r0
    237c:	11 24       	eor	r1, r1
    237e:	b8 01       	movw	r22, r16
    2380:	8c 58       	subi	r24, 0x8C	; 140
    2382:	98 4f       	sbci	r25, 0xF8	; 248
    2384:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>
    2388:	05 c0       	rjmp	.+10     	; 0x2394 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    238a:	b8 01       	movw	r22, r16
    238c:	8f e4       	ldi	r24, 0x4F	; 79
    238e:	97 e0       	ldi	r25, 0x07	; 7
    2390:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2394:	e0 91 7f 07 	lds	r30, 0x077F
    2398:	f0 91 80 07 	lds	r31, 0x0780
    239c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    239e:	82 8d       	ldd	r24, Z+26	; 0x1a
    23a0:	89 17       	cp	r24, r25
    23a2:	20 f4       	brcc	.+8      	; 0x23ac <xTaskRemoveFromEventList+0x78>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    23a4:	81 e0       	ldi	r24, 0x01	; 1
    23a6:	80 93 3b 07 	sts	0x073B, r24
    23aa:	01 c0       	rjmp	.+2      	; 0x23ae <xTaskRemoveFromEventList+0x7a>
	}
	else
	{
		xReturn = pdFALSE;
    23ac:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    23ae:	df 91       	pop	r29
    23b0:	cf 91       	pop	r28
    23b2:	1f 91       	pop	r17
    23b4:	0f 91       	pop	r16
    23b6:	08 95       	ret

000023b8 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    23b8:	0f 93       	push	r16
    23ba:	1f 93       	push	r17
    23bc:	cf 93       	push	r28
    23be:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    23c0:	70 68       	ori	r23, 0x80	; 128
    23c2:	fc 01       	movw	r30, r24
    23c4:	40 83       	st	Z, r20
    23c6:	51 83       	std	Z+1, r21	; 0x01
    23c8:	62 83       	std	Z+2, r22	; 0x02
    23ca:	73 83       	std	Z+3, r23	; 0x03

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    23cc:	c0 85       	ldd	r28, Z+8	; 0x08
    23ce:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    23d0:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    23d4:	8e 01       	movw	r16, r28
    23d6:	0e 5f       	subi	r16, 0xFE	; 254
    23d8:	1f 4f       	sbci	r17, 0xFF	; 255
    23da:	c8 01       	movw	r24, r16
    23dc:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    23e0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    23e2:	80 91 3e 07 	lds	r24, 0x073E
    23e6:	89 17       	cp	r24, r25
    23e8:	10 f4       	brcc	.+4      	; 0x23ee <xTaskRemoveFromUnorderedEventList+0x36>
    23ea:	90 93 3e 07 	sts	0x073E, r25
    23ee:	fb e0       	ldi	r31, 0x0B	; 11
    23f0:	9f 9f       	mul	r25, r31
    23f2:	c0 01       	movw	r24, r0
    23f4:	11 24       	eor	r1, r1
    23f6:	b8 01       	movw	r22, r16
    23f8:	8c 58       	subi	r24, 0x8C	; 140
    23fa:	98 4f       	sbci	r25, 0xF8	; 248
    23fc:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2400:	e0 91 7f 07 	lds	r30, 0x077F
    2404:	f0 91 80 07 	lds	r31, 0x0780
    2408:	9a 8d       	ldd	r25, Y+26	; 0x1a
    240a:	82 8d       	ldd	r24, Z+26	; 0x1a
    240c:	89 17       	cp	r24, r25
    240e:	20 f4       	brcc	.+8      	; 0x2418 <xTaskRemoveFromUnorderedEventList+0x60>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2410:	81 e0       	ldi	r24, 0x01	; 1
    2412:	80 93 3b 07 	sts	0x073B, r24
    2416:	01 c0       	rjmp	.+2      	; 0x241a <xTaskRemoveFromUnorderedEventList+0x62>
	}
	else
	{
		xReturn = pdFALSE;
    2418:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    241a:	df 91       	pop	r29
    241c:	cf 91       	pop	r28
    241e:	1f 91       	pop	r17
    2420:	0f 91       	pop	r16
    2422:	08 95       	ret

00002424 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2424:	20 91 3a 07 	lds	r18, 0x073A
    2428:	fc 01       	movw	r30, r24
    242a:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    242c:	40 91 3f 07 	lds	r20, 0x073F
    2430:	50 91 40 07 	lds	r21, 0x0740
    2434:	60 91 41 07 	lds	r22, 0x0741
    2438:	70 91 42 07 	lds	r23, 0x0742
    243c:	41 83       	std	Z+1, r20	; 0x01
    243e:	52 83       	std	Z+2, r21	; 0x02
    2440:	63 83       	std	Z+3, r22	; 0x03
    2442:	74 83       	std	Z+4, r23	; 0x04
    2444:	08 95       	ret

00002446 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2446:	8f 92       	push	r8
    2448:	9f 92       	push	r9
    244a:	af 92       	push	r10
    244c:	bf 92       	push	r11
    244e:	cf 92       	push	r12
    2450:	df 92       	push	r13
    2452:	ef 92       	push	r14
    2454:	ff 92       	push	r15
    2456:	0f 93       	push	r16
    2458:	1f 93       	push	r17
    245a:	cf 93       	push	r28
    245c:	df 93       	push	r29
    245e:	fb 01       	movw	r30, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2460:	0f b6       	in	r0, 0x3f	; 63
    2462:	f8 94       	cli
    2464:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2466:	00 91 3f 07 	lds	r16, 0x073F
    246a:	10 91 40 07 	lds	r17, 0x0740
    246e:	20 91 41 07 	lds	r18, 0x0741
    2472:	30 91 42 07 	lds	r19, 0x0742

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    2476:	40 81       	ld	r20, Z
    2478:	51 81       	ldd	r21, Z+1	; 0x01
    247a:	62 81       	ldd	r22, Z+2	; 0x02
    247c:	73 81       	ldd	r23, Z+3	; 0x03
    247e:	4f 3f       	cpi	r20, 0xFF	; 255
    2480:	af ef       	ldi	r26, 0xFF	; 255
    2482:	5a 07       	cpc	r21, r26
    2484:	6a 07       	cpc	r22, r26
    2486:	7a 07       	cpc	r23, r26
    2488:	89 f1       	breq	.+98     	; 0x24ec <xTaskCheckForTimeOut+0xa6>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    248a:	a0 91 3a 07 	lds	r26, 0x073A
    248e:	ec 01       	movw	r28, r24
    2490:	b8 81       	ld	r27, Y
    2492:	ba 17       	cp	r27, r26
    2494:	49 f0       	breq	.+18     	; 0x24a8 <xTaskCheckForTimeOut+0x62>
    2496:	c9 80       	ldd	r12, Y+1	; 0x01
    2498:	da 80       	ldd	r13, Y+2	; 0x02
    249a:	eb 80       	ldd	r14, Y+3	; 0x03
    249c:	fc 80       	ldd	r15, Y+4	; 0x04
    249e:	0c 15       	cp	r16, r12
    24a0:	1d 05       	cpc	r17, r13
    24a2:	2e 05       	cpc	r18, r14
    24a4:	3f 05       	cpc	r19, r15
    24a6:	20 f5       	brcc	.+72     	; 0x24f0 <xTaskCheckForTimeOut+0xaa>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    24a8:	dc 01       	movw	r26, r24
    24aa:	11 96       	adiw	r26, 0x01	; 1
    24ac:	cd 90       	ld	r12, X+
    24ae:	dd 90       	ld	r13, X+
    24b0:	ed 90       	ld	r14, X+
    24b2:	fc 90       	ld	r15, X
    24b4:	14 97       	sbiw	r26, 0x04	; 4
    24b6:	48 01       	movw	r8, r16
    24b8:	59 01       	movw	r10, r18
    24ba:	8c 18       	sub	r8, r12
    24bc:	9d 08       	sbc	r9, r13
    24be:	ae 08       	sbc	r10, r14
    24c0:	bf 08       	sbc	r11, r15
    24c2:	84 16       	cp	r8, r20
    24c4:	95 06       	cpc	r9, r21
    24c6:	a6 06       	cpc	r10, r22
    24c8:	b7 06       	cpc	r11, r23
    24ca:	a0 f4       	brcc	.+40     	; 0x24f4 <xTaskCheckForTimeOut+0xae>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    24cc:	c0 1a       	sub	r12, r16
    24ce:	d1 0a       	sbc	r13, r17
    24d0:	e2 0a       	sbc	r14, r18
    24d2:	f3 0a       	sbc	r15, r19
    24d4:	4c 0d       	add	r20, r12
    24d6:	5d 1d       	adc	r21, r13
    24d8:	6e 1d       	adc	r22, r14
    24da:	7f 1d       	adc	r23, r15
    24dc:	40 83       	st	Z, r20
    24de:	51 83       	std	Z+1, r21	; 0x01
    24e0:	62 83       	std	Z+2, r22	; 0x02
    24e2:	73 83       	std	Z+3, r23	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    24e4:	0e 94 12 12 	call	0x2424	; 0x2424 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    24e8:	80 e0       	ldi	r24, 0x00	; 0
    24ea:	05 c0       	rjmp	.+10     	; 0x24f6 <xTaskCheckForTimeOut+0xb0>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    24ec:	80 e0       	ldi	r24, 0x00	; 0
    24ee:	03 c0       	rjmp	.+6      	; 0x24f6 <xTaskCheckForTimeOut+0xb0>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    24f0:	81 e0       	ldi	r24, 0x01	; 1
    24f2:	01 c0       	rjmp	.+2      	; 0x24f6 <xTaskCheckForTimeOut+0xb0>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    24f4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    24f6:	0f 90       	pop	r0
    24f8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    24fa:	df 91       	pop	r29
    24fc:	cf 91       	pop	r28
    24fe:	1f 91       	pop	r17
    2500:	0f 91       	pop	r16
    2502:	ff 90       	pop	r15
    2504:	ef 90       	pop	r14
    2506:	df 90       	pop	r13
    2508:	cf 90       	pop	r12
    250a:	bf 90       	pop	r11
    250c:	af 90       	pop	r10
    250e:	9f 90       	pop	r9
    2510:	8f 90       	pop	r8
    2512:	08 95       	ret

00002514 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    2514:	81 e0       	ldi	r24, 0x01	; 1
    2516:	80 93 3b 07 	sts	0x073B, r24
    251a:	08 95       	ret

0000251c <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    251c:	cf 92       	push	r12
    251e:	df 92       	push	r13
    2520:	ef 92       	push	r14
    2522:	ff 92       	push	r15
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    2524:	e0 91 7f 07 	lds	r30, 0x077F
    2528:	f0 91 80 07 	lds	r31, 0x0780
    252c:	66 85       	ldd	r22, Z+14	; 0x0e
    252e:	77 85       	ldd	r23, Z+15	; 0x0f
    2530:	80 89       	ldd	r24, Z+16	; 0x10
    2532:	91 89       	ldd	r25, Z+17	; 0x11

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2534:	e0 91 7f 07 	lds	r30, 0x077F
    2538:	f0 91 80 07 	lds	r31, 0x0780
    253c:	a0 91 7f 07 	lds	r26, 0x077F
    2540:	b0 91 80 07 	lds	r27, 0x0780
    2544:	5a 96       	adiw	r26, 0x1a	; 26
    2546:	2c 91       	ld	r18, X
    2548:	c1 2c       	mov	r12, r1
    254a:	d1 2c       	mov	r13, r1
    254c:	76 01       	movw	r14, r12
    254e:	c3 94       	inc	r12
    2550:	c2 1a       	sub	r12, r18
    2552:	d1 08       	sbc	r13, r1
    2554:	e1 08       	sbc	r14, r1
    2556:	f1 08       	sbc	r15, r1
    2558:	c6 86       	std	Z+14, r12	; 0x0e
    255a:	d7 86       	std	Z+15, r13	; 0x0f
    255c:	e0 8a       	std	Z+16, r14	; 0x10
    255e:	f1 8a       	std	Z+17, r15	; 0x11

	return uxReturn;
}
    2560:	ff 90       	pop	r15
    2562:	ef 90       	pop	r14
    2564:	df 90       	pop	r13
    2566:	cf 90       	pop	r12
    2568:	08 95       	ret

0000256a <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    256a:	cf 92       	push	r12
    256c:	df 92       	push	r13
    256e:	ef 92       	push	r14
    2570:	ff 92       	push	r15
    2572:	0f 93       	push	r16
    2574:	1f 93       	push	r17
    2576:	cf 93       	push	r28
    2578:	c8 2f       	mov	r28, r24
    257a:	6a 01       	movw	r12, r20
    257c:	7b 01       	movw	r14, r22
	TickType_t xTimeToWake;
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    257e:	0f b6       	in	r0, 0x3f	; 63
    2580:	f8 94       	cli
    2582:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    2584:	e0 91 7f 07 	lds	r30, 0x077F
    2588:	f0 91 80 07 	lds	r31, 0x0780
    258c:	05 a1       	ldd	r16, Z+37	; 0x25
    258e:	16 a1       	ldd	r17, Z+38	; 0x26
    2590:	27 a1       	ldd	r18, Z+39	; 0x27
    2592:	30 a5       	ldd	r19, Z+40	; 0x28
    2594:	01 2b       	or	r16, r17
    2596:	02 2b       	or	r16, r18
    2598:	03 2b       	or	r16, r19
    259a:	a1 f5       	brne	.+104    	; 0x2604 <ulTaskNotifyTake+0x9a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    259c:	e0 91 7f 07 	lds	r30, 0x077F
    25a0:	f0 91 80 07 	lds	r31, 0x0780
    25a4:	81 e0       	ldi	r24, 0x01	; 1
    25a6:	81 a7       	std	Z+41, r24	; 0x29

				if( xTicksToWait > ( TickType_t ) 0 )
    25a8:	45 2b       	or	r20, r21
    25aa:	46 2b       	or	r20, r22
    25ac:	47 2b       	or	r20, r23
    25ae:	51 f1       	breq	.+84     	; 0x2604 <ulTaskNotifyTake+0x9a>
				{
					/* The task is going to block.  First it must be removed
					from the ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    25b0:	80 91 7f 07 	lds	r24, 0x077F
    25b4:	90 91 80 07 	lds	r25, 0x0780
    25b8:	02 96       	adiw	r24, 0x02	; 2
    25ba:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					#if ( INCLUDE_vTaskSuspend == 1 )
					{
						if( xTicksToWait == portMAX_DELAY )
    25be:	8f ef       	ldi	r24, 0xFF	; 255
    25c0:	c8 16       	cp	r12, r24
    25c2:	d8 06       	cpc	r13, r24
    25c4:	e8 06       	cpc	r14, r24
    25c6:	f8 06       	cpc	r15, r24
    25c8:	59 f4       	brne	.+22     	; 0x25e0 <ulTaskNotifyTake+0x76>
						{
							/* Add the task to the suspended task list instead
							of a delayed task list to ensure the task is not
							woken by a timing event.  It will block
							indefinitely. */
							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    25ca:	60 91 7f 07 	lds	r22, 0x077F
    25ce:	70 91 80 07 	lds	r23, 0x0780
    25d2:	6e 5f       	subi	r22, 0xFE	; 254
    25d4:	7f 4f       	sbci	r23, 0xFF	; 255
    25d6:	84 e4       	ldi	r24, 0x44	; 68
    25d8:	97 e0       	ldi	r25, 0x07	; 7
    25da:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>
    25de:	10 c0       	rjmp	.+32     	; 0x2600 <ulTaskNotifyTake+0x96>
						{
							/* Calculate the time at which the task should be
							woken if no notification events occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    25e0:	80 91 3f 07 	lds	r24, 0x073F
    25e4:	90 91 40 07 	lds	r25, 0x0740
    25e8:	a0 91 41 07 	lds	r26, 0x0741
    25ec:	b0 91 42 07 	lds	r27, 0x0742
    25f0:	bc 01       	movw	r22, r24
    25f2:	cd 01       	movw	r24, r26
    25f4:	6c 0d       	add	r22, r12
    25f6:	7d 1d       	adc	r23, r13
    25f8:	8e 1d       	adc	r24, r14
    25fa:	9f 1d       	adc	r25, r15
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    25fc:	0e 94 01 0c 	call	0x1802	; 0x1802 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2600:	0e 94 81 06 	call	0xd02	; 0xd02 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2604:	0f 90       	pop	r0
    2606:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    2608:	0f b6       	in	r0, 0x3f	; 63
    260a:	f8 94       	cli
    260c:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    260e:	e0 91 7f 07 	lds	r30, 0x077F
    2612:	f0 91 80 07 	lds	r31, 0x0780
    2616:	65 a1       	ldd	r22, Z+37	; 0x25
    2618:	76 a1       	ldd	r23, Z+38	; 0x26
    261a:	87 a1       	ldd	r24, Z+39	; 0x27
    261c:	90 a5       	ldd	r25, Z+40	; 0x28

			if( ulReturn != 0UL )
    261e:	61 15       	cp	r22, r1
    2620:	71 05       	cpc	r23, r1
    2622:	81 05       	cpc	r24, r1
    2624:	91 05       	cpc	r25, r1
    2626:	d9 f0       	breq	.+54     	; 0x265e <ulTaskNotifyTake+0xf4>
			{
				if( xClearCountOnExit != pdFALSE )
    2628:	cc 23       	and	r28, r28
    262a:	49 f0       	breq	.+18     	; 0x263e <ulTaskNotifyTake+0xd4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    262c:	e0 91 7f 07 	lds	r30, 0x077F
    2630:	f0 91 80 07 	lds	r31, 0x0780
    2634:	15 a2       	std	Z+37, r1	; 0x25
    2636:	16 a2       	std	Z+38, r1	; 0x26
    2638:	17 a2       	std	Z+39, r1	; 0x27
    263a:	10 a6       	std	Z+40, r1	; 0x28
    263c:	10 c0       	rjmp	.+32     	; 0x265e <ulTaskNotifyTake+0xf4>
				}
				else
				{
					( pxCurrentTCB->ulNotifiedValue )--;
    263e:	e0 91 7f 07 	lds	r30, 0x077F
    2642:	f0 91 80 07 	lds	r31, 0x0780
    2646:	05 a1       	ldd	r16, Z+37	; 0x25
    2648:	16 a1       	ldd	r17, Z+38	; 0x26
    264a:	27 a1       	ldd	r18, Z+39	; 0x27
    264c:	30 a5       	ldd	r19, Z+40	; 0x28
    264e:	01 50       	subi	r16, 0x01	; 1
    2650:	11 09       	sbc	r17, r1
    2652:	21 09       	sbc	r18, r1
    2654:	31 09       	sbc	r19, r1
    2656:	05 a3       	std	Z+37, r16	; 0x25
    2658:	16 a3       	std	Z+38, r17	; 0x26
    265a:	27 a3       	std	Z+39, r18	; 0x27
    265c:	30 a7       	std	Z+40, r19	; 0x28
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    265e:	e0 91 7f 07 	lds	r30, 0x077F
    2662:	f0 91 80 07 	lds	r31, 0x0780
    2666:	11 a6       	std	Z+41, r1	; 0x29
		}
		taskEXIT_CRITICAL();
    2668:	0f 90       	pop	r0
    266a:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    266c:	cf 91       	pop	r28
    266e:	1f 91       	pop	r17
    2670:	0f 91       	pop	r16
    2672:	ff 90       	pop	r15
    2674:	ef 90       	pop	r14
    2676:	df 90       	pop	r13
    2678:	cf 90       	pop	r12
    267a:	08 95       	ret

0000267c <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    267c:	4f 92       	push	r4
    267e:	5f 92       	push	r5
    2680:	6f 92       	push	r6
    2682:	7f 92       	push	r7
    2684:	8f 92       	push	r8
    2686:	9f 92       	push	r9
    2688:	af 92       	push	r10
    268a:	bf 92       	push	r11
    268c:	cf 92       	push	r12
    268e:	df 92       	push	r13
    2690:	ef 92       	push	r14
    2692:	ff 92       	push	r15
    2694:	0f 93       	push	r16
    2696:	1f 93       	push	r17
    2698:	49 01       	movw	r8, r18
    269a:	5a 01       	movw	r10, r20
	TickType_t xTimeToWake;
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    269c:	0f b6       	in	r0, 0x3f	; 63
    269e:	f8 94       	cli
    26a0:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->eNotifyState != eNotified )
    26a2:	e0 91 7f 07 	lds	r30, 0x077F
    26a6:	f0 91 80 07 	lds	r31, 0x0780
    26aa:	21 a5       	ldd	r18, Z+41	; 0x29
    26ac:	22 30       	cpi	r18, 0x02	; 2
    26ae:	09 f4       	brne	.+2      	; 0x26b2 <xTaskNotifyWait+0x36>
    26b0:	4b c0       	rjmp	.+150    	; 0x2748 <xTaskNotifyWait+0xcc>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    26b2:	e0 91 7f 07 	lds	r30, 0x077F
    26b6:	f0 91 80 07 	lds	r31, 0x0780
    26ba:	45 a0       	ldd	r4, Z+37	; 0x25
    26bc:	56 a0       	ldd	r5, Z+38	; 0x26
    26be:	67 a0       	ldd	r6, Z+39	; 0x27
    26c0:	70 a4       	ldd	r7, Z+40	; 0x28
    26c2:	dc 01       	movw	r26, r24
    26c4:	cb 01       	movw	r24, r22
    26c6:	80 95       	com	r24
    26c8:	90 95       	com	r25
    26ca:	a0 95       	com	r26
    26cc:	b0 95       	com	r27
    26ce:	84 21       	and	r24, r4
    26d0:	95 21       	and	r25, r5
    26d2:	a6 21       	and	r26, r6
    26d4:	b7 21       	and	r27, r7
    26d6:	85 a3       	std	Z+37, r24	; 0x25
    26d8:	96 a3       	std	Z+38, r25	; 0x26
    26da:	a7 a3       	std	Z+39, r26	; 0x27
    26dc:	b0 a7       	std	Z+40, r27	; 0x28

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    26de:	e0 91 7f 07 	lds	r30, 0x077F
    26e2:	f0 91 80 07 	lds	r31, 0x0780
    26e6:	81 e0       	ldi	r24, 0x01	; 1
    26e8:	81 a7       	std	Z+41, r24	; 0x29

				if( xTicksToWait > ( TickType_t ) 0 )
    26ea:	c1 14       	cp	r12, r1
    26ec:	d1 04       	cpc	r13, r1
    26ee:	e1 04       	cpc	r14, r1
    26f0:	f1 04       	cpc	r15, r1
    26f2:	51 f1       	breq	.+84     	; 0x2748 <xTaskNotifyWait+0xcc>
				{
					/* The task is going to block.  First it must be removed
					from the	ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    26f4:	80 91 7f 07 	lds	r24, 0x077F
    26f8:	90 91 80 07 	lds	r25, 0x0780
    26fc:	02 96       	adiw	r24, 0x02	; 2
    26fe:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					#if ( INCLUDE_vTaskSuspend == 1 )
					{
						if( xTicksToWait == portMAX_DELAY )
    2702:	8f ef       	ldi	r24, 0xFF	; 255
    2704:	c8 16       	cp	r12, r24
    2706:	d8 06       	cpc	r13, r24
    2708:	e8 06       	cpc	r14, r24
    270a:	f8 06       	cpc	r15, r24
    270c:	59 f4       	brne	.+22     	; 0x2724 <xTaskNotifyWait+0xa8>
						{
							/* Add the task to the suspended task list instead
							of a delayed task list to ensure the task is not
							woken by a timing event.  It will block
							indefinitely. */
							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    270e:	60 91 7f 07 	lds	r22, 0x077F
    2712:	70 91 80 07 	lds	r23, 0x0780
    2716:	6e 5f       	subi	r22, 0xFE	; 254
    2718:	7f 4f       	sbci	r23, 0xFF	; 255
    271a:	84 e4       	ldi	r24, 0x44	; 68
    271c:	97 e0       	ldi	r25, 0x07	; 7
    271e:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>
    2722:	10 c0       	rjmp	.+32     	; 0x2744 <xTaskNotifyWait+0xc8>
						{
							/* Calculate the time at which the task should be
							woken if no notification events occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    2724:	80 91 3f 07 	lds	r24, 0x073F
    2728:	90 91 40 07 	lds	r25, 0x0740
    272c:	a0 91 41 07 	lds	r26, 0x0741
    2730:	b0 91 42 07 	lds	r27, 0x0742
    2734:	bc 01       	movw	r22, r24
    2736:	cd 01       	movw	r24, r26
    2738:	6c 0d       	add	r22, r12
    273a:	7d 1d       	adc	r23, r13
    273c:	8e 1d       	adc	r24, r14
    273e:	9f 1d       	adc	r25, r15
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    2740:	0e 94 01 0c 	call	0x1802	; 0x1802 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2744:	0e 94 81 06 	call	0xd02	; 0xd02 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2748:	0f 90       	pop	r0
    274a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    274c:	0f b6       	in	r0, 0x3f	; 63
    274e:	f8 94       	cli
    2750:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    2752:	01 15       	cp	r16, r1
    2754:	11 05       	cpc	r17, r1
    2756:	69 f0       	breq	.+26     	; 0x2772 <xTaskNotifyWait+0xf6>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    2758:	e0 91 7f 07 	lds	r30, 0x077F
    275c:	f0 91 80 07 	lds	r31, 0x0780
    2760:	85 a1       	ldd	r24, Z+37	; 0x25
    2762:	96 a1       	ldd	r25, Z+38	; 0x26
    2764:	a7 a1       	ldd	r26, Z+39	; 0x27
    2766:	b0 a5       	ldd	r27, Z+40	; 0x28
    2768:	f8 01       	movw	r30, r16
    276a:	80 83       	st	Z, r24
    276c:	91 83       	std	Z+1, r25	; 0x01
    276e:	a2 83       	std	Z+2, r26	; 0x02
    2770:	b3 83       	std	Z+3, r27	; 0x03

			/* If eNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
    2772:	e0 91 7f 07 	lds	r30, 0x077F
    2776:	f0 91 80 07 	lds	r31, 0x0780
    277a:	81 a5       	ldd	r24, Z+41	; 0x29
    277c:	81 30       	cpi	r24, 0x01	; 1
    277e:	b1 f0       	breq	.+44     	; 0x27ac <xTaskNotifyWait+0x130>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    2780:	e0 91 7f 07 	lds	r30, 0x077F
    2784:	f0 91 80 07 	lds	r31, 0x0780
    2788:	85 a1       	ldd	r24, Z+37	; 0x25
    278a:	96 a1       	ldd	r25, Z+38	; 0x26
    278c:	a7 a1       	ldd	r26, Z+39	; 0x27
    278e:	b0 a5       	ldd	r27, Z+40	; 0x28
    2790:	80 94       	com	r8
    2792:	90 94       	com	r9
    2794:	a0 94       	com	r10
    2796:	b0 94       	com	r11
    2798:	88 22       	and	r8, r24
    279a:	99 22       	and	r9, r25
    279c:	aa 22       	and	r10, r26
    279e:	bb 22       	and	r11, r27
    27a0:	85 a2       	std	Z+37, r8	; 0x25
    27a2:	96 a2       	std	Z+38, r9	; 0x26
    27a4:	a7 a2       	std	Z+39, r10	; 0x27
    27a6:	b0 a6       	std	Z+40, r11	; 0x28
				xReturn = pdTRUE;
    27a8:	81 e0       	ldi	r24, 0x01	; 1
    27aa:	01 c0       	rjmp	.+2      	; 0x27ae <xTaskNotifyWait+0x132>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    27ac:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    27ae:	e0 91 7f 07 	lds	r30, 0x077F
    27b2:	f0 91 80 07 	lds	r31, 0x0780
    27b6:	11 a6       	std	Z+41, r1	; 0x29
		}
		taskEXIT_CRITICAL();
    27b8:	0f 90       	pop	r0
    27ba:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    27bc:	1f 91       	pop	r17
    27be:	0f 91       	pop	r16
    27c0:	ff 90       	pop	r15
    27c2:	ef 90       	pop	r14
    27c4:	df 90       	pop	r13
    27c6:	cf 90       	pop	r12
    27c8:	bf 90       	pop	r11
    27ca:	af 90       	pop	r10
    27cc:	9f 90       	pop	r9
    27ce:	8f 90       	pop	r8
    27d0:	7f 90       	pop	r7
    27d2:	6f 90       	pop	r6
    27d4:	5f 90       	pop	r5
    27d6:	4f 90       	pop	r4
    27d8:	08 95       	ret

000027da <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    27da:	0f 93       	push	r16
    27dc:	1f 93       	push	r17
    27de:	cf 93       	push	r28
    27e0:	df 93       	push	r29
    27e2:	fc 01       	movw	r30, r24
	BaseType_t xReturn = pdPASS;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    27e4:	0f b6       	in	r0, 0x3f	; 63
    27e6:	f8 94       	cli
    27e8:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    27ea:	01 15       	cp	r16, r1
    27ec:	11 05       	cpc	r17, r1
    27ee:	49 f0       	breq	.+18     	; 0x2802 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    27f0:	85 a1       	ldd	r24, Z+37	; 0x25
    27f2:	96 a1       	ldd	r25, Z+38	; 0x26
    27f4:	a7 a1       	ldd	r26, Z+39	; 0x27
    27f6:	b0 a5       	ldd	r27, Z+40	; 0x28
    27f8:	e8 01       	movw	r28, r16
    27fa:	88 83       	st	Y, r24
    27fc:	99 83       	std	Y+1, r25	; 0x01
    27fe:	aa 83       	std	Y+2, r26	; 0x02
    2800:	bb 83       	std	Y+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    2802:	81 a5       	ldd	r24, Z+41	; 0x29

			pxTCB->eNotifyState = eNotified;
    2804:	92 e0       	ldi	r25, 0x02	; 2
    2806:	91 a7       	std	Z+41, r25	; 0x29

			switch( eAction )
    2808:	22 30       	cpi	r18, 0x02	; 2
    280a:	b1 f0       	breq	.+44     	; 0x2838 <xTaskGenericNotify+0x5e>
    280c:	18 f4       	brcc	.+6      	; 0x2814 <xTaskGenericNotify+0x3a>
    280e:	21 30       	cpi	r18, 0x01	; 1
    2810:	31 f0       	breq	.+12     	; 0x281e <xTaskGenericNotify+0x44>
    2812:	2a c0       	rjmp	.+84     	; 0x2868 <xTaskGenericNotify+0x8e>
    2814:	23 30       	cpi	r18, 0x03	; 3
    2816:	e9 f0       	breq	.+58     	; 0x2852 <xTaskGenericNotify+0x78>
    2818:	24 30       	cpi	r18, 0x04	; 4
    281a:	01 f1       	breq	.+64     	; 0x285c <xTaskGenericNotify+0x82>
    281c:	25 c0       	rjmp	.+74     	; 0x2868 <xTaskGenericNotify+0x8e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    281e:	05 a1       	ldd	r16, Z+37	; 0x25
    2820:	16 a1       	ldd	r17, Z+38	; 0x26
    2822:	27 a1       	ldd	r18, Z+39	; 0x27
    2824:	30 a5       	ldd	r19, Z+40	; 0x28
    2826:	40 2b       	or	r20, r16
    2828:	51 2b       	or	r21, r17
    282a:	62 2b       	or	r22, r18
    282c:	73 2b       	or	r23, r19
    282e:	45 a3       	std	Z+37, r20	; 0x25
    2830:	56 a3       	std	Z+38, r21	; 0x26
    2832:	67 a3       	std	Z+39, r22	; 0x27
    2834:	70 a7       	std	Z+40, r23	; 0x28
					break;
    2836:	18 c0       	rjmp	.+48     	; 0x2868 <xTaskGenericNotify+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    2838:	45 a1       	ldd	r20, Z+37	; 0x25
    283a:	56 a1       	ldd	r21, Z+38	; 0x26
    283c:	67 a1       	ldd	r22, Z+39	; 0x27
    283e:	70 a5       	ldd	r23, Z+40	; 0x28
    2840:	4f 5f       	subi	r20, 0xFF	; 255
    2842:	5f 4f       	sbci	r21, 0xFF	; 255
    2844:	6f 4f       	sbci	r22, 0xFF	; 255
    2846:	7f 4f       	sbci	r23, 0xFF	; 255
    2848:	45 a3       	std	Z+37, r20	; 0x25
    284a:	56 a3       	std	Z+38, r21	; 0x26
    284c:	67 a3       	std	Z+39, r22	; 0x27
    284e:	70 a7       	std	Z+40, r23	; 0x28
					break;
    2850:	0b c0       	rjmp	.+22     	; 0x2868 <xTaskGenericNotify+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    2852:	45 a3       	std	Z+37, r20	; 0x25
    2854:	56 a3       	std	Z+38, r21	; 0x26
    2856:	67 a3       	std	Z+39, r22	; 0x27
    2858:	70 a7       	std	Z+40, r23	; 0x28
					break;
    285a:	06 c0       	rjmp	.+12     	; 0x2868 <xTaskGenericNotify+0x8e>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    285c:	82 30       	cpi	r24, 0x02	; 2
    285e:	19 f1       	breq	.+70     	; 0x28a6 <xTaskGenericNotify+0xcc>
					{
						pxTCB->ulNotifiedValue = ulValue;
    2860:	45 a3       	std	Z+37, r20	; 0x25
    2862:	56 a3       	std	Z+38, r21	; 0x26
    2864:	67 a3       	std	Z+39, r22	; 0x27
    2866:	70 a7       	std	Z+40, r23	; 0x28

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    2868:	81 30       	cpi	r24, 0x01	; 1
    286a:	f9 f4       	brne	.+62     	; 0x28aa <xTaskGenericNotify+0xd0>
    286c:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    286e:	8f 01       	movw	r16, r30
    2870:	0e 5f       	subi	r16, 0xFE	; 254
    2872:	1f 4f       	sbci	r17, 0xFF	; 255
    2874:	c8 01       	movw	r24, r16
    2876:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    287a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    287c:	80 91 3e 07 	lds	r24, 0x073E
    2880:	89 17       	cp	r24, r25
    2882:	10 f4       	brcc	.+4      	; 0x2888 <xTaskGenericNotify+0xae>
    2884:	90 93 3e 07 	sts	0x073E, r25
    2888:	db e0       	ldi	r29, 0x0B	; 11
    288a:	9d 9f       	mul	r25, r29
    288c:	c0 01       	movw	r24, r0
    288e:	11 24       	eor	r1, r1
    2890:	b8 01       	movw	r22, r16
    2892:	8c 58       	subi	r24, 0x8C	; 140
    2894:	98 4f       	sbci	r25, 0xF8	; 248
    2896:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    289a:	80 91 7f 07 	lds	r24, 0x077F
    289e:	90 91 80 07 	lds	r25, 0x0780
    28a2:	81 e0       	ldi	r24, 0x01	; 1
    28a4:	03 c0       	rjmp	.+6      	; 0x28ac <xTaskGenericNotify+0xd2>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    28a6:	80 e0       	ldi	r24, 0x00	; 0
    28a8:	01 c0       	rjmp	.+2      	; 0x28ac <xTaskGenericNotify+0xd2>
    28aa:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    28ac:	0f 90       	pop	r0
    28ae:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    28b0:	df 91       	pop	r29
    28b2:	cf 91       	pop	r28
    28b4:	1f 91       	pop	r17
    28b6:	0f 91       	pop	r16
    28b8:	08 95       	ret

000028ba <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    28ba:	ef 92       	push	r14
    28bc:	ff 92       	push	r15
    28be:	0f 93       	push	r16
    28c0:	1f 93       	push	r17
    28c2:	cf 93       	push	r28
    28c4:	df 93       	push	r29
    28c6:	fc 01       	movw	r30, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    28c8:	01 15       	cp	r16, r1
    28ca:	11 05       	cpc	r17, r1
    28cc:	49 f0       	breq	.+18     	; 0x28e0 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    28ce:	85 a1       	ldd	r24, Z+37	; 0x25
    28d0:	96 a1       	ldd	r25, Z+38	; 0x26
    28d2:	a7 a1       	ldd	r26, Z+39	; 0x27
    28d4:	b0 a5       	ldd	r27, Z+40	; 0x28
    28d6:	e8 01       	movw	r28, r16
    28d8:	88 83       	st	Y, r24
    28da:	99 83       	std	Y+1, r25	; 0x01
    28dc:	aa 83       	std	Y+2, r26	; 0x02
    28de:	bb 83       	std	Y+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    28e0:	81 a5       	ldd	r24, Z+41	; 0x29
			pxTCB->eNotifyState = eNotified;
    28e2:	92 e0       	ldi	r25, 0x02	; 2
    28e4:	91 a7       	std	Z+41, r25	; 0x29

			switch( eAction )
    28e6:	22 30       	cpi	r18, 0x02	; 2
    28e8:	b1 f0       	breq	.+44     	; 0x2916 <xTaskGenericNotifyFromISR+0x5c>
    28ea:	18 f4       	brcc	.+6      	; 0x28f2 <xTaskGenericNotifyFromISR+0x38>
    28ec:	21 30       	cpi	r18, 0x01	; 1
    28ee:	31 f0       	breq	.+12     	; 0x28fc <xTaskGenericNotifyFromISR+0x42>
    28f0:	2a c0       	rjmp	.+84     	; 0x2946 <xTaskGenericNotifyFromISR+0x8c>
    28f2:	23 30       	cpi	r18, 0x03	; 3
    28f4:	e9 f0       	breq	.+58     	; 0x2930 <xTaskGenericNotifyFromISR+0x76>
    28f6:	24 30       	cpi	r18, 0x04	; 4
    28f8:	01 f1       	breq	.+64     	; 0x293a <xTaskGenericNotifyFromISR+0x80>
    28fa:	25 c0       	rjmp	.+74     	; 0x2946 <xTaskGenericNotifyFromISR+0x8c>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    28fc:	05 a1       	ldd	r16, Z+37	; 0x25
    28fe:	16 a1       	ldd	r17, Z+38	; 0x26
    2900:	27 a1       	ldd	r18, Z+39	; 0x27
    2902:	30 a5       	ldd	r19, Z+40	; 0x28
    2904:	40 2b       	or	r20, r16
    2906:	51 2b       	or	r21, r17
    2908:	62 2b       	or	r22, r18
    290a:	73 2b       	or	r23, r19
    290c:	45 a3       	std	Z+37, r20	; 0x25
    290e:	56 a3       	std	Z+38, r21	; 0x26
    2910:	67 a3       	std	Z+39, r22	; 0x27
    2912:	70 a7       	std	Z+40, r23	; 0x28
					break;
    2914:	18 c0       	rjmp	.+48     	; 0x2946 <xTaskGenericNotifyFromISR+0x8c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    2916:	45 a1       	ldd	r20, Z+37	; 0x25
    2918:	56 a1       	ldd	r21, Z+38	; 0x26
    291a:	67 a1       	ldd	r22, Z+39	; 0x27
    291c:	70 a5       	ldd	r23, Z+40	; 0x28
    291e:	4f 5f       	subi	r20, 0xFF	; 255
    2920:	5f 4f       	sbci	r21, 0xFF	; 255
    2922:	6f 4f       	sbci	r22, 0xFF	; 255
    2924:	7f 4f       	sbci	r23, 0xFF	; 255
    2926:	45 a3       	std	Z+37, r20	; 0x25
    2928:	56 a3       	std	Z+38, r21	; 0x26
    292a:	67 a3       	std	Z+39, r22	; 0x27
    292c:	70 a7       	std	Z+40, r23	; 0x28
					break;
    292e:	0b c0       	rjmp	.+22     	; 0x2946 <xTaskGenericNotifyFromISR+0x8c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    2930:	45 a3       	std	Z+37, r20	; 0x25
    2932:	56 a3       	std	Z+38, r21	; 0x26
    2934:	67 a3       	std	Z+39, r22	; 0x27
    2936:	70 a7       	std	Z+40, r23	; 0x28
					break;
    2938:	06 c0       	rjmp	.+12     	; 0x2946 <xTaskGenericNotifyFromISR+0x8c>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    293a:	82 30       	cpi	r24, 0x02	; 2
    293c:	c1 f1       	breq	.+112    	; 0x29ae <xTaskGenericNotifyFromISR+0xf4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    293e:	45 a3       	std	Z+37, r20	; 0x25
    2940:	56 a3       	std	Z+38, r21	; 0x26
    2942:	67 a3       	std	Z+39, r22	; 0x27
    2944:	70 a7       	std	Z+40, r23	; 0x28

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    2946:	81 30       	cpi	r24, 0x01	; 1
    2948:	a1 f5       	brne	.+104    	; 0x29b2 <xTaskGenericNotifyFromISR+0xf8>
    294a:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    294c:	80 91 34 07 	lds	r24, 0x0734
    2950:	81 11       	cpse	r24, r1
    2952:	17 c0       	rjmp	.+46     	; 0x2982 <xTaskGenericNotifyFromISR+0xc8>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    2954:	8f 01       	movw	r16, r30
    2956:	0e 5f       	subi	r16, 0xFE	; 254
    2958:	1f 4f       	sbci	r17, 0xFF	; 255
    295a:	c8 01       	movw	r24, r16
    295c:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2960:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2962:	80 91 3e 07 	lds	r24, 0x073E
    2966:	89 17       	cp	r24, r25
    2968:	10 f4       	brcc	.+4      	; 0x296e <xTaskGenericNotifyFromISR+0xb4>
    296a:	90 93 3e 07 	sts	0x073E, r25
    296e:	eb e0       	ldi	r30, 0x0B	; 11
    2970:	9e 9f       	mul	r25, r30
    2972:	c0 01       	movw	r24, r0
    2974:	11 24       	eor	r1, r1
    2976:	b8 01       	movw	r22, r16
    2978:	8c 58       	subi	r24, 0x8C	; 140
    297a:	98 4f       	sbci	r25, 0xF8	; 248
    297c:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>
    2980:	07 c0       	rjmp	.+14     	; 0x2990 <xTaskGenericNotifyFromISR+0xd6>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2982:	bf 01       	movw	r22, r30
    2984:	62 5f       	subi	r22, 0xF2	; 242
    2986:	7f 4f       	sbci	r23, 0xFF	; 255
    2988:	8f e4       	ldi	r24, 0x4F	; 79
    298a:	97 e0       	ldi	r25, 0x07	; 7
    298c:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2990:	e0 91 7f 07 	lds	r30, 0x077F
    2994:	f0 91 80 07 	lds	r31, 0x0780
    2998:	9a 8d       	ldd	r25, Y+26	; 0x1a
    299a:	82 8d       	ldd	r24, Z+26	; 0x1a
    299c:	89 17       	cp	r24, r25
    299e:	58 f4       	brcc	.+22     	; 0x29b6 <xTaskGenericNotifyFromISR+0xfc>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    29a0:	e1 14       	cp	r14, r1
    29a2:	f1 04       	cpc	r15, r1
    29a4:	51 f0       	breq	.+20     	; 0x29ba <xTaskGenericNotifyFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    29a6:	81 e0       	ldi	r24, 0x01	; 1
    29a8:	e7 01       	movw	r28, r14
    29aa:	88 83       	st	Y, r24
    29ac:	07 c0       	rjmp	.+14     	; 0x29bc <xTaskGenericNotifyFromISR+0x102>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    29ae:	80 e0       	ldi	r24, 0x00	; 0
    29b0:	05 c0       	rjmp	.+10     	; 0x29bc <xTaskGenericNotifyFromISR+0x102>
    29b2:	81 e0       	ldi	r24, 0x01	; 1
    29b4:	03 c0       	rjmp	.+6      	; 0x29bc <xTaskGenericNotifyFromISR+0x102>
    29b6:	81 e0       	ldi	r24, 0x01	; 1
    29b8:	01 c0       	rjmp	.+2      	; 0x29bc <xTaskGenericNotifyFromISR+0x102>
    29ba:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    29bc:	df 91       	pop	r29
    29be:	cf 91       	pop	r28
    29c0:	1f 91       	pop	r17
    29c2:	0f 91       	pop	r16
    29c4:	ff 90       	pop	r15
    29c6:	ef 90       	pop	r14
    29c8:	08 95       	ret

000029ca <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    29ca:	ef 92       	push	r14
    29cc:	ff 92       	push	r15
    29ce:	0f 93       	push	r16
    29d0:	1f 93       	push	r17
    29d2:	cf 93       	push	r28
    29d4:	df 93       	push	r29
    29d6:	fc 01       	movw	r30, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			eOriginalNotifyState = pxTCB->eNotifyState;
    29d8:	21 a5       	ldd	r18, Z+41	; 0x29
			pxTCB->eNotifyState = eNotified;
    29da:	82 e0       	ldi	r24, 0x02	; 2
    29dc:	81 a7       	std	Z+41, r24	; 0x29

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    29de:	85 a1       	ldd	r24, Z+37	; 0x25
    29e0:	96 a1       	ldd	r25, Z+38	; 0x26
    29e2:	a7 a1       	ldd	r26, Z+39	; 0x27
    29e4:	b0 a5       	ldd	r27, Z+40	; 0x28
    29e6:	01 96       	adiw	r24, 0x01	; 1
    29e8:	a1 1d       	adc	r26, r1
    29ea:	b1 1d       	adc	r27, r1
    29ec:	85 a3       	std	Z+37, r24	; 0x25
    29ee:	96 a3       	std	Z+38, r25	; 0x26
    29f0:	a7 a3       	std	Z+39, r26	; 0x27
    29f2:	b0 a7       	std	Z+40, r27	; 0x28

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    29f4:	21 30       	cpi	r18, 0x01	; 1
    29f6:	99 f5       	brne	.+102    	; 0x2a5e <vTaskNotifyGiveFromISR+0x94>
    29f8:	8b 01       	movw	r16, r22
    29fa:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    29fc:	80 91 34 07 	lds	r24, 0x0734
    2a00:	81 11       	cpse	r24, r1
    2a02:	18 c0       	rjmp	.+48     	; 0x2a34 <vTaskNotifyGiveFromISR+0x6a>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    2a04:	7f 01       	movw	r14, r30
    2a06:	22 e0       	ldi	r18, 0x02	; 2
    2a08:	e2 0e       	add	r14, r18
    2a0a:	f1 1c       	adc	r15, r1
    2a0c:	c7 01       	movw	r24, r14
    2a0e:	0e 94 b4 05 	call	0xb68	; 0xb68 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2a12:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2a14:	80 91 3e 07 	lds	r24, 0x073E
    2a18:	89 17       	cp	r24, r25
    2a1a:	10 f4       	brcc	.+4      	; 0x2a20 <vTaskNotifyGiveFromISR+0x56>
    2a1c:	90 93 3e 07 	sts	0x073E, r25
    2a20:	eb e0       	ldi	r30, 0x0B	; 11
    2a22:	9e 9f       	mul	r25, r30
    2a24:	c0 01       	movw	r24, r0
    2a26:	11 24       	eor	r1, r1
    2a28:	b7 01       	movw	r22, r14
    2a2a:	8c 58       	subi	r24, 0x8C	; 140
    2a2c:	98 4f       	sbci	r25, 0xF8	; 248
    2a2e:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>
    2a32:	07 c0       	rjmp	.+14     	; 0x2a42 <vTaskNotifyGiveFromISR+0x78>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2a34:	bf 01       	movw	r22, r30
    2a36:	62 5f       	subi	r22, 0xF2	; 242
    2a38:	7f 4f       	sbci	r23, 0xFF	; 255
    2a3a:	8f e4       	ldi	r24, 0x4F	; 79
    2a3c:	97 e0       	ldi	r25, 0x07	; 7
    2a3e:	0e 94 56 05 	call	0xaac	; 0xaac <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2a42:	e0 91 7f 07 	lds	r30, 0x077F
    2a46:	f0 91 80 07 	lds	r31, 0x0780
    2a4a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2a4c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a4e:	89 17       	cp	r24, r25
    2a50:	30 f4       	brcc	.+12     	; 0x2a5e <vTaskNotifyGiveFromISR+0x94>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    2a52:	01 15       	cp	r16, r1
    2a54:	11 05       	cpc	r17, r1
    2a56:	19 f0       	breq	.+6      	; 0x2a5e <vTaskNotifyGiveFromISR+0x94>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    2a58:	81 e0       	ldi	r24, 0x01	; 1
    2a5a:	f8 01       	movw	r30, r16
    2a5c:	80 83       	st	Z, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    2a5e:	df 91       	pop	r29
    2a60:	cf 91       	pop	r28
    2a62:	1f 91       	pop	r17
    2a64:	0f 91       	pop	r16
    2a66:	ff 90       	pop	r15
    2a68:	ef 90       	pop	r14
    2a6a:	08 95       	ret

00002a6c <xTaskNotifyStateClear>:

		pxTCB = ( TCB_t * ) xTask;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( pxTCB );
    2a6c:	00 97       	sbiw	r24, 0x00	; 0
    2a6e:	21 f4       	brne	.+8      	; 0x2a78 <xTaskNotifyStateClear+0xc>
    2a70:	80 91 7f 07 	lds	r24, 0x077F
    2a74:	90 91 80 07 	lds	r25, 0x0780

		taskENTER_CRITICAL();
    2a78:	0f b6       	in	r0, 0x3f	; 63
    2a7a:	f8 94       	cli
    2a7c:	0f 92       	push	r0
		{
			if( pxTCB->eNotifyState == eNotified )
    2a7e:	fc 01       	movw	r30, r24
    2a80:	21 a5       	ldd	r18, Z+41	; 0x29
    2a82:	22 30       	cpi	r18, 0x02	; 2
    2a84:	19 f4       	brne	.+6      	; 0x2a8c <xTaskNotifyStateClear+0x20>
			{
				pxTCB->eNotifyState = eNotWaitingNotification;
    2a86:	11 a6       	std	Z+41, r1	; 0x29
				xReturn = pdPASS;
    2a88:	81 e0       	ldi	r24, 0x01	; 1
    2a8a:	01 c0       	rjmp	.+2      	; 0x2a8e <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    2a8c:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    2a8e:	0f 90       	pop	r0
    2a90:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2a92:	08 95       	ret

00002a94 <config_io_pin>:

#include "node_tasks.h"
#include <avr/io.h>

void config_io_pin(uint8_t port, uint8_t port_ch, uint8_t dir){
	switch(port){
    2a94:	81 30       	cpi	r24, 0x01	; 1
    2a96:	b9 f0       	breq	.+46     	; 0x2ac6 <config_io_pin+0x32>
    2a98:	18 f0       	brcs	.+6      	; 0x2aa0 <config_io_pin+0xc>
    2a9a:	82 30       	cpi	r24, 0x02	; 2
    2a9c:	39 f1       	breq	.+78     	; 0x2aec <config_io_pin+0x58>
    2a9e:	08 95       	ret
		case IO_PORT_B:
		//Crazy bit trickery that sets the port_ch bit of DDRB to dir
		DDRB ^= ((-dir) ^ DDRB) & (1 << port_ch);
    2aa0:	84 b1       	in	r24, 0x04	; 4
    2aa2:	24 b1       	in	r18, 0x04	; 4
    2aa4:	50 e0       	ldi	r21, 0x00	; 0
    2aa6:	51 95       	neg	r21
    2aa8:	41 95       	neg	r20
    2aaa:	51 09       	sbc	r21, r1
    2aac:	48 27       	eor	r20, r24
    2aae:	81 e0       	ldi	r24, 0x01	; 1
    2ab0:	90 e0       	ldi	r25, 0x00	; 0
    2ab2:	02 c0       	rjmp	.+4      	; 0x2ab8 <config_io_pin+0x24>
    2ab4:	88 0f       	add	r24, r24
    2ab6:	99 1f       	adc	r25, r25
    2ab8:	6a 95       	dec	r22
    2aba:	e2 f7       	brpl	.-8      	; 0x2ab4 <config_io_pin+0x20>
    2abc:	48 23       	and	r20, r24
    2abe:	59 23       	and	r21, r25
    2ac0:	42 27       	eor	r20, r18
    2ac2:	44 b9       	out	0x04, r20	; 4
		break;
    2ac4:	08 95       	ret
		case IO_PORT_C:
		DDRC ^= ((-dir) ^ DDRC) & (1 << port_ch);
    2ac6:	87 b1       	in	r24, 0x07	; 7
    2ac8:	27 b1       	in	r18, 0x07	; 7
    2aca:	50 e0       	ldi	r21, 0x00	; 0
    2acc:	51 95       	neg	r21
    2ace:	41 95       	neg	r20
    2ad0:	51 09       	sbc	r21, r1
    2ad2:	48 27       	eor	r20, r24
    2ad4:	81 e0       	ldi	r24, 0x01	; 1
    2ad6:	90 e0       	ldi	r25, 0x00	; 0
    2ad8:	02 c0       	rjmp	.+4      	; 0x2ade <config_io_pin+0x4a>
    2ada:	88 0f       	add	r24, r24
    2adc:	99 1f       	adc	r25, r25
    2ade:	6a 95       	dec	r22
    2ae0:	e2 f7       	brpl	.-8      	; 0x2ada <config_io_pin+0x46>
    2ae2:	48 23       	and	r20, r24
    2ae4:	59 23       	and	r21, r25
    2ae6:	42 27       	eor	r20, r18
    2ae8:	47 b9       	out	0x07, r20	; 7
		break;
    2aea:	08 95       	ret
		case IO_PORT_D:
		DDRD ^= ((-dir) ^ DDRD) & (1 << port_ch);
    2aec:	8a b1       	in	r24, 0x0a	; 10
    2aee:	2a b1       	in	r18, 0x0a	; 10
    2af0:	50 e0       	ldi	r21, 0x00	; 0
    2af2:	51 95       	neg	r21
    2af4:	41 95       	neg	r20
    2af6:	51 09       	sbc	r21, r1
    2af8:	48 27       	eor	r20, r24
    2afa:	81 e0       	ldi	r24, 0x01	; 1
    2afc:	90 e0       	ldi	r25, 0x00	; 0
    2afe:	02 c0       	rjmp	.+4      	; 0x2b04 <config_io_pin+0x70>
    2b00:	88 0f       	add	r24, r24
    2b02:	99 1f       	adc	r25, r25
    2b04:	6a 95       	dec	r22
    2b06:	e2 f7       	brpl	.-8      	; 0x2b00 <config_io_pin+0x6c>
    2b08:	48 23       	and	r20, r24
    2b0a:	59 23       	and	r21, r25
    2b0c:	42 27       	eor	r20, r18
    2b0e:	4a b9       	out	0x0a, r20	; 10
    2b10:	08 95       	ret

00002b12 <set_io_pin>:
		break;
	}
}

void set_io_pin(uint8_t port, uint8_t port_ch, uint8_t val) {
	switch(port){
    2b12:	81 30       	cpi	r24, 0x01	; 1
    2b14:	b9 f0       	breq	.+46     	; 0x2b44 <set_io_pin+0x32>
    2b16:	18 f0       	brcs	.+6      	; 0x2b1e <set_io_pin+0xc>
    2b18:	82 30       	cpi	r24, 0x02	; 2
    2b1a:	39 f1       	breq	.+78     	; 0x2b6a <set_io_pin+0x58>
    2b1c:	08 95       	ret
		case IO_PORT_B:
		PORTB ^= ((-val) ^ PORTB) & (1 << port_ch);
    2b1e:	85 b1       	in	r24, 0x05	; 5
    2b20:	25 b1       	in	r18, 0x05	; 5
    2b22:	50 e0       	ldi	r21, 0x00	; 0
    2b24:	51 95       	neg	r21
    2b26:	41 95       	neg	r20
    2b28:	51 09       	sbc	r21, r1
    2b2a:	48 27       	eor	r20, r24
    2b2c:	81 e0       	ldi	r24, 0x01	; 1
    2b2e:	90 e0       	ldi	r25, 0x00	; 0
    2b30:	02 c0       	rjmp	.+4      	; 0x2b36 <set_io_pin+0x24>
    2b32:	88 0f       	add	r24, r24
    2b34:	99 1f       	adc	r25, r25
    2b36:	6a 95       	dec	r22
    2b38:	e2 f7       	brpl	.-8      	; 0x2b32 <set_io_pin+0x20>
    2b3a:	48 23       	and	r20, r24
    2b3c:	59 23       	and	r21, r25
    2b3e:	42 27       	eor	r20, r18
    2b40:	45 b9       	out	0x05, r20	; 5
		break;
    2b42:	08 95       	ret
		case IO_PORT_C:
		PORTC ^= ((-val) ^ PORTC) & (1 << port_ch);
    2b44:	88 b1       	in	r24, 0x08	; 8
    2b46:	28 b1       	in	r18, 0x08	; 8
    2b48:	50 e0       	ldi	r21, 0x00	; 0
    2b4a:	51 95       	neg	r21
    2b4c:	41 95       	neg	r20
    2b4e:	51 09       	sbc	r21, r1
    2b50:	48 27       	eor	r20, r24
    2b52:	81 e0       	ldi	r24, 0x01	; 1
    2b54:	90 e0       	ldi	r25, 0x00	; 0
    2b56:	02 c0       	rjmp	.+4      	; 0x2b5c <set_io_pin+0x4a>
    2b58:	88 0f       	add	r24, r24
    2b5a:	99 1f       	adc	r25, r25
    2b5c:	6a 95       	dec	r22
    2b5e:	e2 f7       	brpl	.-8      	; 0x2b58 <set_io_pin+0x46>
    2b60:	48 23       	and	r20, r24
    2b62:	59 23       	and	r21, r25
    2b64:	42 27       	eor	r20, r18
    2b66:	48 b9       	out	0x08, r20	; 8
		break;
    2b68:	08 95       	ret
		case IO_PORT_D:
		PORTD ^= ((-val) ^ PORTD) & (1 << port_ch);
    2b6a:	8b b1       	in	r24, 0x0b	; 11
    2b6c:	2b b1       	in	r18, 0x0b	; 11
    2b6e:	50 e0       	ldi	r21, 0x00	; 0
    2b70:	51 95       	neg	r21
    2b72:	41 95       	neg	r20
    2b74:	51 09       	sbc	r21, r1
    2b76:	48 27       	eor	r20, r24
    2b78:	81 e0       	ldi	r24, 0x01	; 1
    2b7a:	90 e0       	ldi	r25, 0x00	; 0
    2b7c:	02 c0       	rjmp	.+4      	; 0x2b82 <set_io_pin+0x70>
    2b7e:	88 0f       	add	r24, r24
    2b80:	99 1f       	adc	r25, r25
    2b82:	6a 95       	dec	r22
    2b84:	e2 f7       	brpl	.-8      	; 0x2b7e <set_io_pin+0x6c>
    2b86:	48 23       	and	r20, r24
    2b88:	59 23       	and	r21, r25
    2b8a:	42 27       	eor	r20, r18
    2b8c:	4b b9       	out	0x0b, r20	; 11
    2b8e:	08 95       	ret

00002b90 <vLEDFlashTask>:
}

void vLEDFlashTask(void *pvParameters) {
	
	for(;;) {
		PORTC ^= (1 << 0);
    2b90:	c1 e0       	ldi	r28, 0x01	; 1
    2b92:	88 b1       	in	r24, 0x08	; 8
    2b94:	8c 27       	eor	r24, r28
    2b96:	88 b9       	out	0x08, r24	; 8
		vTaskDelay(1000);
    2b98:	68 ee       	ldi	r22, 0xE8	; 232
    2b9a:	73 e0       	ldi	r23, 0x03	; 3
    2b9c:	80 e0       	ldi	r24, 0x00	; 0
    2b9e:	90 e0       	ldi	r25, 0x00	; 0
    2ba0:	0e 94 3a 10 	call	0x2074	; 0x2074 <vTaskDelay>
	}
    2ba4:	f6 cf       	rjmp	.-20     	; 0x2b92 <vLEDFlashTask+0x2>

00002ba6 <memcpy>:
    2ba6:	fb 01       	movw	r30, r22
    2ba8:	dc 01       	movw	r26, r24
    2baa:	02 c0       	rjmp	.+4      	; 0x2bb0 <memcpy+0xa>
    2bac:	01 90       	ld	r0, Z+
    2bae:	0d 92       	st	X+, r0
    2bb0:	41 50       	subi	r20, 0x01	; 1
    2bb2:	50 40       	sbci	r21, 0x00	; 0
    2bb4:	d8 f7       	brcc	.-10     	; 0x2bac <memcpy+0x6>
    2bb6:	08 95       	ret

00002bb8 <_exit>:
    2bb8:	f8 94       	cli

00002bba <__stop_program>:
    2bba:	ff cf       	rjmp	.-2      	; 0x2bba <__stop_program>
