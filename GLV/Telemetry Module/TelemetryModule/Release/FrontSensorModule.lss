
FrontSensorModule.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000012  00800100  000050da  0000516e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000050da  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000045b  00800112  00800112  00005180  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00005180  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000051b0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000138  00000000  00000000  000051f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000029d2  00000000  00000000  00005328  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000a34  00000000  00000000  00007cfa  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002561  00000000  00000000  0000872e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000bf0  00000000  00000000  0000ac90  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00010102  00000000  00000000  0000b880  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001883  00000000  00000000  0001b982  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000018  00000000  00000000  0001d205  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000534b  00000000  00000000  0001d21d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 49 00 	jmp	0x92	; 0x92 <__ctors_end>
       4:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
       8:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
       c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      10:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      14:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      18:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      1c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      20:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      24:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      28:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      2c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      30:	0c 94 a5 14 	jmp	0x294a	; 0x294a <__vector_12>
      34:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      38:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      3c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      40:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      44:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      48:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      4c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      50:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      54:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      58:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      5c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      60:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      64:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      68:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      6c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      70:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      74:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      78:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      7c:	57 04       	cpc	r5, r7
      7e:	4d 05       	cpc	r20, r13
      80:	37 06       	cpc	r3, r23
      82:	05 07       	cpc	r16, r21
      84:	88 07       	cpc	r24, r24
      86:	18 08       	sbc	r1, r8
      88:	b2 08       	sbc	r11, r2
      8a:	d8 09       	sbc	r29, r8
      8c:	0b 0b       	sbc	r16, r27
      8e:	48 0c       	add	r4, r8
      90:	fe 0c       	add	r15, r14

00000092 <__ctors_end>:
      92:	11 24       	eor	r1, r1
      94:	1f be       	out	0x3f, r1	; 63
      96:	cf ef       	ldi	r28, 0xFF	; 255
      98:	d0 e1       	ldi	r29, 0x10	; 16
      9a:	de bf       	out	0x3e, r29	; 62
      9c:	cd bf       	out	0x3d, r28	; 61

0000009e <__do_copy_data>:
      9e:	11 e0       	ldi	r17, 0x01	; 1
      a0:	a0 e0       	ldi	r26, 0x00	; 0
      a2:	b1 e0       	ldi	r27, 0x01	; 1
      a4:	ea ed       	ldi	r30, 0xDA	; 218
      a6:	f0 e5       	ldi	r31, 0x50	; 80
      a8:	02 c0       	rjmp	.+4      	; 0xae <__do_copy_data+0x10>
      aa:	05 90       	lpm	r0, Z+
      ac:	0d 92       	st	X+, r0
      ae:	a2 31       	cpi	r26, 0x12	; 18
      b0:	b1 07       	cpc	r27, r17
      b2:	d9 f7       	brne	.-10     	; 0xaa <__do_copy_data+0xc>

000000b4 <__do_clear_bss>:
      b4:	25 e0       	ldi	r18, 0x05	; 5
      b6:	a2 e1       	ldi	r26, 0x12	; 18
      b8:	b1 e0       	ldi	r27, 0x01	; 1
      ba:	01 c0       	rjmp	.+2      	; 0xbe <.do_clear_bss_start>

000000bc <.do_clear_bss_loop>:
      bc:	1d 92       	st	X+, r1

000000be <.do_clear_bss_start>:
      be:	ad 36       	cpi	r26, 0x6D	; 109
      c0:	b2 07       	cpc	r27, r18
      c2:	e1 f7       	brne	.-8      	; 0xbc <.do_clear_bss_loop>
      c4:	0e 94 04 10 	call	0x2008	; 0x2008 <main>
      c8:	0c 94 6b 28 	jmp	0x50d6	; 0x50d6 <_exit>

000000cc <__bad_interrupt>:
      cc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d0 <can_clear_all_mob>:
//! @param none
//!
//! @return none
//------------------------------------------------------------------------------
void can_clear_all_mob(void)
{
      d0:	cf 93       	push	r28
      d2:	df 93       	push	r29
      d4:	00 d0       	rcall	.+0      	; 0xd6 <can_clear_all_mob+0x6>
      d6:	1f 92       	push	r1
      d8:	cd b7       	in	r28, 0x3d	; 61
      da:	de b7       	in	r29, 0x3e	; 62
uint8_t  mob_number;
/*
    uint8_t  data_index;
*/

    for (mob_number = 0; mob_number < NB_MOB; mob_number++)
      dc:	19 82       	std	Y+1, r1	; 0x01
      de:	1d c0       	rjmp	.+58     	; 0x11a <can_clear_all_mob+0x4a>
    {
        CANPAGE = (mob_number << 4);    //! Page index
      e0:	8d ee       	ldi	r24, 0xED	; 237
      e2:	90 e0       	ldi	r25, 0x00	; 0
      e4:	29 81       	ldd	r18, Y+1	; 0x01
      e6:	22 95       	swap	r18
      e8:	20 7f       	andi	r18, 0xF0	; 240
      ea:	fc 01       	movw	r30, r24
      ec:	20 83       	st	Z, r18
        Can_clear_mob();                //! All MOb Registers=0
      ee:	8e ee       	ldi	r24, 0xEE	; 238
      f0:	90 e0       	ldi	r25, 0x00	; 0
      f2:	9b 83       	std	Y+3, r25	; 0x03
      f4:	8a 83       	std	Y+2, r24	; 0x02
      f6:	09 c0       	rjmp	.+18     	; 0x10a <can_clear_all_mob+0x3a>
      f8:	8a 81       	ldd	r24, Y+2	; 0x02
      fa:	9b 81       	ldd	r25, Y+3	; 0x03
      fc:	fc 01       	movw	r30, r24
      fe:	10 82       	st	Z, r1
     100:	8a 81       	ldd	r24, Y+2	; 0x02
     102:	9b 81       	ldd	r25, Y+3	; 0x03
     104:	01 96       	adiw	r24, 0x01	; 1
     106:	9b 83       	std	Y+3, r25	; 0x03
     108:	8a 83       	std	Y+2, r24	; 0x02
     10a:	8a 81       	ldd	r24, Y+2	; 0x02
     10c:	9b 81       	ldd	r25, Y+3	; 0x03
     10e:	88 3f       	cpi	r24, 0xF8	; 248
     110:	91 05       	cpc	r25, r1
     112:	90 f3       	brcs	.-28     	; 0xf8 <can_clear_all_mob+0x28>
uint8_t  mob_number;
/*
    uint8_t  data_index;
*/

    for (mob_number = 0; mob_number < NB_MOB; mob_number++)
     114:	89 81       	ldd	r24, Y+1	; 0x01
     116:	8f 5f       	subi	r24, 0xFF	; 255
     118:	89 83       	std	Y+1, r24	; 0x01
     11a:	89 81       	ldd	r24, Y+1	; 0x01
     11c:	86 30       	cpi	r24, 0x06	; 6
     11e:	00 f3       	brcs	.-64     	; 0xe0 <can_clear_all_mob+0x10>
        {
            CANMSG = 0;                 //! MOb data FIFO
        }
*/
    }
}
     120:	0f 90       	pop	r0
     122:	0f 90       	pop	r0
     124:	0f 90       	pop	r0
     126:	df 91       	pop	r29
     128:	cf 91       	pop	r28
     12a:	08 95       	ret

0000012c <can_get_mob_free>:
//! @return Handle of MOb.
//!          - MOb[0] upto MOb[LAST_MOB_NB]
//!          - 0xFF if no MOb
//------------------------------------------------------------------------------
uint8_t can_get_mob_free(void)
{
     12c:	cf 93       	push	r28
     12e:	df 93       	push	r29
     130:	00 d0       	rcall	.+0      	; 0x132 <can_get_mob_free+0x6>
     132:	cd b7       	in	r28, 0x3d	; 61
     134:	de b7       	in	r29, 0x3e	; 62
    uint8_t mob_number, page_saved;

    page_saved = CANPAGE;
     136:	8d ee       	ldi	r24, 0xED	; 237
     138:	90 e0       	ldi	r25, 0x00	; 0
     13a:	fc 01       	movw	r30, r24
     13c:	80 81       	ld	r24, Z
     13e:	8a 83       	std	Y+2, r24	; 0x02
    for (mob_number = 0; mob_number < NB_MOB; mob_number++)
     140:	19 82       	std	Y+1, r1	; 0x01
     142:	1b c0       	rjmp	.+54     	; 0x17a <can_get_mob_free+0x4e>
    {
        Can_set_mob(mob_number);
     144:	8d ee       	ldi	r24, 0xED	; 237
     146:	90 e0       	ldi	r25, 0x00	; 0
     148:	29 81       	ldd	r18, Y+1	; 0x01
     14a:	22 95       	swap	r18
     14c:	20 7f       	andi	r18, 0xF0	; 240
     14e:	fc 01       	movw	r30, r24
     150:	20 83       	st	Z, r18
        if ((CANCDMOB & 0xC0) == 0x00) //! Disable configuration
     152:	8f ee       	ldi	r24, 0xEF	; 239
     154:	90 e0       	ldi	r25, 0x00	; 0
     156:	fc 01       	movw	r30, r24
     158:	80 81       	ld	r24, Z
     15a:	88 2f       	mov	r24, r24
     15c:	90 e0       	ldi	r25, 0x00	; 0
     15e:	80 7c       	andi	r24, 0xC0	; 192
     160:	99 27       	eor	r25, r25
     162:	89 2b       	or	r24, r25
     164:	39 f4       	brne	.+14     	; 0x174 <can_get_mob_free+0x48>
        {
            CANPAGE = page_saved;
     166:	8d ee       	ldi	r24, 0xED	; 237
     168:	90 e0       	ldi	r25, 0x00	; 0
     16a:	2a 81       	ldd	r18, Y+2	; 0x02
     16c:	fc 01       	movw	r30, r24
     16e:	20 83       	st	Z, r18
            return (mob_number);
     170:	89 81       	ldd	r24, Y+1	; 0x01
     172:	0c c0       	rjmp	.+24     	; 0x18c <can_get_mob_free+0x60>
uint8_t can_get_mob_free(void)
{
    uint8_t mob_number, page_saved;

    page_saved = CANPAGE;
    for (mob_number = 0; mob_number < NB_MOB; mob_number++)
     174:	89 81       	ldd	r24, Y+1	; 0x01
     176:	8f 5f       	subi	r24, 0xFF	; 255
     178:	89 83       	std	Y+1, r24	; 0x01
     17a:	89 81       	ldd	r24, Y+1	; 0x01
     17c:	86 30       	cpi	r24, 0x06	; 6
     17e:	10 f3       	brcs	.-60     	; 0x144 <can_get_mob_free+0x18>
        {
            CANPAGE = page_saved;
            return (mob_number);
        }
    }
    CANPAGE = page_saved;
     180:	8d ee       	ldi	r24, 0xED	; 237
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	2a 81       	ldd	r18, Y+2	; 0x02
     186:	fc 01       	movw	r30, r24
     188:	20 83       	st	Z, r18
    return (NO_MOB);
     18a:	8f ef       	ldi	r24, 0xFF	; 255
}
     18c:	0f 90       	pop	r0
     18e:	0f 90       	pop	r0
     190:	df 91       	pop	r29
     192:	cf 91       	pop	r28
     194:	08 95       	ret

00000196 <can_get_mob_status>:
//!          -  MOB_CRC_ERROR
//!          -  MOB_STUFF_ERROR
//!          -  MOB_BIT_ERROR
//------------------------------------------------------------------------------
uint8_t can_get_mob_status(void)
{
     196:	cf 93       	push	r28
     198:	df 93       	push	r29
     19a:	00 d0       	rcall	.+0      	; 0x19c <can_get_mob_status+0x6>
     19c:	cd b7       	in	r28, 0x3d	; 61
     19e:	de b7       	in	r29, 0x3e	; 62
    uint8_t mob_status, canstmob_copy;

    // Test if MOb ENABLE or DISABLE
    if ((CANCDMOB & 0xC0) == 0x00) {return(MOB_DISABLE);}
     1a0:	8f ee       	ldi	r24, 0xEF	; 239
     1a2:	90 e0       	ldi	r25, 0x00	; 0
     1a4:	fc 01       	movw	r30, r24
     1a6:	80 81       	ld	r24, Z
     1a8:	88 2f       	mov	r24, r24
     1aa:	90 e0       	ldi	r25, 0x00	; 0
     1ac:	80 7c       	andi	r24, 0xC0	; 192
     1ae:	99 27       	eor	r25, r25
     1b0:	89 2b       	or	r24, r25
     1b2:	11 f4       	brne	.+4      	; 0x1b8 <can_get_mob_status+0x22>
     1b4:	8f ef       	ldi	r24, 0xFF	; 255
     1b6:	1c c0       	rjmp	.+56     	; 0x1f0 <can_get_mob_status+0x5a>

    canstmob_copy = CANSTMOB; // Copy for test integrity
     1b8:	8e ee       	ldi	r24, 0xEE	; 238
     1ba:	90 e0       	ldi	r25, 0x00	; 0
     1bc:	fc 01       	movw	r30, r24
     1be:	80 81       	ld	r24, Z
     1c0:	89 83       	std	Y+1, r24	; 0x01

    // If MOb is ENABLE, test if MOb is COMPLETED
    // - MOb Status = 0x20 then MOB_RX_COMPLETED
    // - MOb Status = 0x40 then MOB_TX_COMPLETED
    // - MOb Status = 0xA0 then MOB_RX_COMPLETED_DLCW
    mob_status = canstmob_copy & ((1<<DLCW)|(1<<TXOK)|(1<<RXOK));
     1c2:	89 81       	ldd	r24, Y+1	; 0x01
     1c4:	80 7e       	andi	r24, 0xE0	; 224
     1c6:	8a 83       	std	Y+2, r24	; 0x02
    if ( (mob_status==MOB_RX_COMPLETED) ||   \
     1c8:	8a 81       	ldd	r24, Y+2	; 0x02
     1ca:	80 32       	cpi	r24, 0x20	; 32
     1cc:	31 f0       	breq	.+12     	; 0x1da <can_get_mob_status+0x44>
     1ce:	8a 81       	ldd	r24, Y+2	; 0x02
     1d0:	80 34       	cpi	r24, 0x40	; 64
     1d2:	19 f0       	breq	.+6      	; 0x1da <can_get_mob_status+0x44>
         (mob_status==MOB_TX_COMPLETED) ||   \
     1d4:	8a 81       	ldd	r24, Y+2	; 0x02
     1d6:	80 3a       	cpi	r24, 0xA0	; 160
     1d8:	11 f4       	brne	.+4      	; 0x1de <can_get_mob_status+0x48>
         (mob_status==MOB_RX_COMPLETED_DLCW) ) { return(mob_status); }
     1da:	8a 81       	ldd	r24, Y+2	; 0x02
     1dc:	09 c0       	rjmp	.+18     	; 0x1f0 <can_get_mob_status+0x5a>
    // - MOb Status bit_0 = MOB_ACK_ERROR
    // - MOb Status bit_1 = MOB_FORM_ERROR
    // - MOb Status bit_2 = MOB_CRC_ERROR
    // - MOb Status bit_3 = MOB_STUFF_ERROR
    // - MOb Status bit_4 = MOB_BIT_ERROR
    mob_status = canstmob_copy & ERR_MOB_MSK;
     1de:	89 81       	ldd	r24, Y+1	; 0x01
     1e0:	8f 71       	andi	r24, 0x1F	; 31
     1e2:	8a 83       	std	Y+2, r24	; 0x02
    if (mob_status != 0) { return(mob_status); }
     1e4:	8a 81       	ldd	r24, Y+2	; 0x02
     1e6:	88 23       	and	r24, r24
     1e8:	11 f0       	breq	.+4      	; 0x1ee <can_get_mob_status+0x58>
     1ea:	8a 81       	ldd	r24, Y+2	; 0x02
     1ec:	01 c0       	rjmp	.+2      	; 0x1f0 <can_get_mob_status+0x5a>

    // If CANSTMOB = 0 then MOB_NOT_COMPLETED
    return(MOB_NOT_COMPLETED);
     1ee:	80 e0       	ldi	r24, 0x00	; 0
}
     1f0:	0f 90       	pop	r0
     1f2:	0f 90       	pop	r0
     1f4:	df 91       	pop	r29
     1f6:	cf 91       	pop	r28
     1f8:	08 95       	ret

000001fa <can_get_data>:
//! @param CAN message data address.
//!
//! @return none.
//------------------------------------------------------------------------------
void can_get_data(uint8_t* p_can_message_data)
{
     1fa:	cf 93       	push	r28
     1fc:	df 93       	push	r29
     1fe:	00 d0       	rcall	.+0      	; 0x200 <can_get_data+0x6>
     200:	1f 92       	push	r1
     202:	cd b7       	in	r28, 0x3d	; 61
     204:	de b7       	in	r29, 0x3e	; 62
     206:	9b 83       	std	Y+3, r25	; 0x03
     208:	8a 83       	std	Y+2, r24	; 0x02
    uint8_t data_index;

    for (data_index = 0; data_index < (Can_get_dlc()); data_index++)
     20a:	19 82       	std	Y+1, r1	; 0x01
     20c:	10 c0       	rjmp	.+32     	; 0x22e <can_get_data+0x34>
    {
        *(p_can_message_data + data_index) = CANMSG;
     20e:	89 81       	ldd	r24, Y+1	; 0x01
     210:	88 2f       	mov	r24, r24
     212:	90 e0       	ldi	r25, 0x00	; 0
     214:	2a 81       	ldd	r18, Y+2	; 0x02
     216:	3b 81       	ldd	r19, Y+3	; 0x03
     218:	82 0f       	add	r24, r18
     21a:	93 1f       	adc	r25, r19
     21c:	2a ef       	ldi	r18, 0xFA	; 250
     21e:	30 e0       	ldi	r19, 0x00	; 0
     220:	f9 01       	movw	r30, r18
     222:	20 81       	ld	r18, Z
     224:	fc 01       	movw	r30, r24
     226:	20 83       	st	Z, r18
//------------------------------------------------------------------------------
void can_get_data(uint8_t* p_can_message_data)
{
    uint8_t data_index;

    for (data_index = 0; data_index < (Can_get_dlc()); data_index++)
     228:	89 81       	ldd	r24, Y+1	; 0x01
     22a:	8f 5f       	subi	r24, 0xFF	; 255
     22c:	89 83       	std	Y+1, r24	; 0x01
     22e:	89 81       	ldd	r24, Y+1	; 0x01
     230:	28 2f       	mov	r18, r24
     232:	30 e0       	ldi	r19, 0x00	; 0
     234:	8f ee       	ldi	r24, 0xEF	; 239
     236:	90 e0       	ldi	r25, 0x00	; 0
     238:	fc 01       	movw	r30, r24
     23a:	80 81       	ld	r24, Z
     23c:	88 2f       	mov	r24, r24
     23e:	90 e0       	ldi	r25, 0x00	; 0
     240:	8f 70       	andi	r24, 0x0F	; 15
     242:	99 27       	eor	r25, r25
     244:	28 17       	cp	r18, r24
     246:	39 07       	cpc	r19, r25
     248:	14 f3       	brlt	.-60     	; 0x20e <can_get_data+0x14>
    {
        *(p_can_message_data + data_index) = CANMSG;
    }
}
     24a:	0f 90       	pop	r0
     24c:	0f 90       	pop	r0
     24e:	0f 90       	pop	r0
     250:	df 91       	pop	r29
     252:	cf 91       	pop	r28
     254:	08 95       	ret

00000256 <can_auto_baudrate>:
//! @return Baudrate Status
//!         ==0: research of bit timing configuration failed
//!         ==1: baudrate performed
//------------------------------------------------------------------------------
uint8_t can_auto_baudrate (uint8_t mode)
{
     256:	cf 93       	push	r28
     258:	df 93       	push	r29
     25a:	cd b7       	in	r28, 0x3d	; 61
     25c:	de b7       	in	r29, 0x3e	; 62
     25e:	62 97       	sbiw	r28, 0x12	; 18
     260:	0f b6       	in	r0, 0x3f	; 63
     262:	f8 94       	cli
     264:	de bf       	out	0x3e, r29	; 62
     266:	0f be       	out	0x3f, r0	; 63
     268:	cd bf       	out	0x3d, r28	; 61
     26a:	8a 8b       	std	Y+18, r24	; 0x12
    uint8_t  u8_temp0;                               //! Temporary variable
    uint8_t  brp, prs, ntq, phs1, phs2;              //! Bit timing segment variables
    uint8_t  phs1_inc;                               //! Computing needed
    uint8_t  bt_not_found, wait_for_rx, evaluate;    //! Keys for "while()" loops
    uint8_t  try_conf;                               //! Key for configurate CAN
    uint8_t  ovrtim_flag=0;                          //! Timer overflow count
     26c:	1c 86       	std	Y+12, r1	; 0x0c
    uint16_t conf_index;                             //! Count of bit timing configuration tried
    uint8_t  bt_performed;                           //! Return flag

    //! --- Default setting
    phs1_inc = evaluate = 0;
     26e:	1a 86       	std	Y+10, r1	; 0x0a
     270:	8a 85       	ldd	r24, Y+10	; 0x0a
     272:	8f 83       	std	Y+7, r24	; 0x07
    bt_performed = 0;
     274:	1f 86       	std	Y+15, r1	; 0x0f
    conf_index = 0;
     276:	1e 86       	std	Y+14, r1	; 0x0e
     278:	1d 86       	std	Y+13, r1	; 0x0d
    bt_not_found = 1;
     27a:	81 e0       	ldi	r24, 0x01	; 1
     27c:	88 87       	std	Y+8, r24	; 0x08

    //! --- Init segment variables with MIN values if mode=0
    //!     or init segment variables with CANBTx if mode=1
    if (mode==0)
     27e:	8a 89       	ldd	r24, Y+18	; 0x12
     280:	88 23       	and	r24, r24
     282:	b1 f4       	brne	.+44     	; 0x2b0 <can_auto_baudrate+0x5a>
    {
        brp  = BRP_MIN;
     284:	81 e0       	ldi	r24, 0x01	; 1
     286:	8a 83       	std	Y+2, r24	; 0x02
        ntq  = NTQ_MIN;
     288:	88 e0       	ldi	r24, 0x08	; 8
     28a:	8c 83       	std	Y+4, r24	; 0x04
        phs1 = PHS1_MIN;
     28c:	82 e0       	ldi	r24, 0x02	; 2
     28e:	8d 83       	std	Y+5, r24	; 0x05
        phs2 = PHS2_MIN;
     290:	82 e0       	ldi	r24, 0x02	; 2
     292:	8e 83       	std	Y+6, r24	; 0x06
        prs  = ntq - ( phs1 + phs2 + 1 );
     294:	9d 81       	ldd	r25, Y+5	; 0x05
     296:	8e 81       	ldd	r24, Y+6	; 0x06
     298:	89 0f       	add	r24, r25
     29a:	9c 81       	ldd	r25, Y+4	; 0x04
     29c:	29 2f       	mov	r18, r25
     29e:	28 1b       	sub	r18, r24
     2a0:	82 2f       	mov	r24, r18
     2a2:	81 50       	subi	r24, 0x01	; 1
     2a4:	8b 83       	std	Y+3, r24	; 0x03
        try_conf = 1;       //! Try this configuration
     2a6:	81 e0       	ldi	r24, 0x01	; 1
     2a8:	8b 87       	std	Y+11, r24	; 0x0b
        wait_for_rx = 1;    //! Enable "while (wait_for_rx ..." loop
     2aa:	81 e0       	ldi	r24, 0x01	; 1
     2ac:	89 87       	std	Y+9, r24	; 0x09
     2ae:	92 c0       	rjmp	.+292    	; 0x3d4 <can_auto_baudrate+0x17e>
    }
    else //! mode = 1
    {
        brp  = Max ((((CANBT1 &  BRP_MSK) >> 1) +1) , BRP_MIN );
     2b0:	82 ee       	ldi	r24, 0xE2	; 226
     2b2:	90 e0       	ldi	r25, 0x00	; 0
     2b4:	fc 01       	movw	r30, r24
     2b6:	80 81       	ld	r24, Z
     2b8:	88 2f       	mov	r24, r24
     2ba:	90 e0       	ldi	r25, 0x00	; 0
     2bc:	8e 77       	andi	r24, 0x7E	; 126
     2be:	99 27       	eor	r25, r25
     2c0:	95 95       	asr	r25
     2c2:	87 95       	ror	r24
     2c4:	01 96       	adiw	r24, 0x01	; 1
     2c6:	02 97       	sbiw	r24, 0x02	; 2
     2c8:	64 f0       	brlt	.+24     	; 0x2e2 <can_auto_baudrate+0x8c>
     2ca:	82 ee       	ldi	r24, 0xE2	; 226
     2cc:	90 e0       	ldi	r25, 0x00	; 0
     2ce:	fc 01       	movw	r30, r24
     2d0:	80 81       	ld	r24, Z
     2d2:	88 2f       	mov	r24, r24
     2d4:	90 e0       	ldi	r25, 0x00	; 0
     2d6:	8e 77       	andi	r24, 0x7E	; 126
     2d8:	99 27       	eor	r25, r25
     2da:	95 95       	asr	r25
     2dc:	87 95       	ror	r24
     2de:	8f 5f       	subi	r24, 0xFF	; 255
     2e0:	01 c0       	rjmp	.+2      	; 0x2e4 <can_auto_baudrate+0x8e>
     2e2:	81 e0       	ldi	r24, 0x01	; 1
     2e4:	8a 83       	std	Y+2, r24	; 0x02
        prs  = Max ((((CANBT2 &  PRS_MSK) >> 1) +1) , PRS_MIN );
     2e6:	83 ee       	ldi	r24, 0xE3	; 227
     2e8:	90 e0       	ldi	r25, 0x00	; 0
     2ea:	fc 01       	movw	r30, r24
     2ec:	80 81       	ld	r24, Z
     2ee:	88 2f       	mov	r24, r24
     2f0:	90 e0       	ldi	r25, 0x00	; 0
     2f2:	8e 70       	andi	r24, 0x0E	; 14
     2f4:	99 27       	eor	r25, r25
     2f6:	95 95       	asr	r25
     2f8:	87 95       	ror	r24
     2fa:	01 96       	adiw	r24, 0x01	; 1
     2fc:	02 97       	sbiw	r24, 0x02	; 2
     2fe:	64 f0       	brlt	.+24     	; 0x318 <can_auto_baudrate+0xc2>
     300:	83 ee       	ldi	r24, 0xE3	; 227
     302:	90 e0       	ldi	r25, 0x00	; 0
     304:	fc 01       	movw	r30, r24
     306:	80 81       	ld	r24, Z
     308:	88 2f       	mov	r24, r24
     30a:	90 e0       	ldi	r25, 0x00	; 0
     30c:	8e 70       	andi	r24, 0x0E	; 14
     30e:	99 27       	eor	r25, r25
     310:	95 95       	asr	r25
     312:	87 95       	ror	r24
     314:	8f 5f       	subi	r24, 0xFF	; 255
     316:	01 c0       	rjmp	.+2      	; 0x31a <can_auto_baudrate+0xc4>
     318:	81 e0       	ldi	r24, 0x01	; 1
     31a:	8b 83       	std	Y+3, r24	; 0x03
        phs1 = Max ((((CANBT3 & PHS1_MSK) >> 1) +1) , PHS1_MIN);
     31c:	84 ee       	ldi	r24, 0xE4	; 228
     31e:	90 e0       	ldi	r25, 0x00	; 0
     320:	fc 01       	movw	r30, r24
     322:	80 81       	ld	r24, Z
     324:	88 2f       	mov	r24, r24
     326:	90 e0       	ldi	r25, 0x00	; 0
     328:	8e 70       	andi	r24, 0x0E	; 14
     32a:	99 27       	eor	r25, r25
     32c:	95 95       	asr	r25
     32e:	87 95       	ror	r24
     330:	01 96       	adiw	r24, 0x01	; 1
     332:	03 97       	sbiw	r24, 0x03	; 3
     334:	64 f0       	brlt	.+24     	; 0x34e <can_auto_baudrate+0xf8>
     336:	84 ee       	ldi	r24, 0xE4	; 228
     338:	90 e0       	ldi	r25, 0x00	; 0
     33a:	fc 01       	movw	r30, r24
     33c:	80 81       	ld	r24, Z
     33e:	88 2f       	mov	r24, r24
     340:	90 e0       	ldi	r25, 0x00	; 0
     342:	8e 70       	andi	r24, 0x0E	; 14
     344:	99 27       	eor	r25, r25
     346:	95 95       	asr	r25
     348:	87 95       	ror	r24
     34a:	8f 5f       	subi	r24, 0xFF	; 255
     34c:	01 c0       	rjmp	.+2      	; 0x350 <can_auto_baudrate+0xfa>
     34e:	82 e0       	ldi	r24, 0x02	; 2
     350:	8d 83       	std	Y+5, r24	; 0x05
        phs2 = Max ((((CANBT3 & PHS2_MSK) >> 4) +1) , PHS2_MIN);
     352:	84 ee       	ldi	r24, 0xE4	; 228
     354:	90 e0       	ldi	r25, 0x00	; 0
     356:	fc 01       	movw	r30, r24
     358:	80 81       	ld	r24, Z
     35a:	88 2f       	mov	r24, r24
     35c:	90 e0       	ldi	r25, 0x00	; 0
     35e:	80 77       	andi	r24, 0x70	; 112
     360:	99 27       	eor	r25, r25
     362:	95 95       	asr	r25
     364:	87 95       	ror	r24
     366:	95 95       	asr	r25
     368:	87 95       	ror	r24
     36a:	95 95       	asr	r25
     36c:	87 95       	ror	r24
     36e:	95 95       	asr	r25
     370:	87 95       	ror	r24
     372:	01 96       	adiw	r24, 0x01	; 1
     374:	03 97       	sbiw	r24, 0x03	; 3
     376:	94 f0       	brlt	.+36     	; 0x39c <can_auto_baudrate+0x146>
     378:	84 ee       	ldi	r24, 0xE4	; 228
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	fc 01       	movw	r30, r24
     37e:	80 81       	ld	r24, Z
     380:	88 2f       	mov	r24, r24
     382:	90 e0       	ldi	r25, 0x00	; 0
     384:	80 77       	andi	r24, 0x70	; 112
     386:	99 27       	eor	r25, r25
     388:	95 95       	asr	r25
     38a:	87 95       	ror	r24
     38c:	95 95       	asr	r25
     38e:	87 95       	ror	r24
     390:	95 95       	asr	r25
     392:	87 95       	ror	r24
     394:	95 95       	asr	r25
     396:	87 95       	ror	r24
     398:	8f 5f       	subi	r24, 0xFF	; 255
     39a:	01 c0       	rjmp	.+2      	; 0x39e <can_auto_baudrate+0x148>
     39c:	82 e0       	ldi	r24, 0x02	; 2
     39e:	8e 83       	std	Y+6, r24	; 0x06
        ntq  = Max ((prs + phs1 + phs2 + 1) , NTQ_MIN);
     3a0:	8b 81       	ldd	r24, Y+3	; 0x03
     3a2:	28 2f       	mov	r18, r24
     3a4:	30 e0       	ldi	r19, 0x00	; 0
     3a6:	8d 81       	ldd	r24, Y+5	; 0x05
     3a8:	88 2f       	mov	r24, r24
     3aa:	90 e0       	ldi	r25, 0x00	; 0
     3ac:	28 0f       	add	r18, r24
     3ae:	39 1f       	adc	r19, r25
     3b0:	8e 81       	ldd	r24, Y+6	; 0x06
     3b2:	88 2f       	mov	r24, r24
     3b4:	90 e0       	ldi	r25, 0x00	; 0
     3b6:	82 0f       	add	r24, r18
     3b8:	93 1f       	adc	r25, r19
     3ba:	01 96       	adiw	r24, 0x01	; 1
     3bc:	88 30       	cpi	r24, 0x08	; 8
     3be:	91 05       	cpc	r25, r1
     3c0:	14 f4       	brge	.+4      	; 0x3c6 <can_auto_baudrate+0x170>
     3c2:	88 e0       	ldi	r24, 0x08	; 8
     3c4:	90 e0       	ldi	r25, 0x00	; 0
     3c6:	8c 83       	std	Y+4, r24	; 0x04
        phs1_inc = evaluate = 1;   //! To enter in "while (evaluate ..." loop
     3c8:	81 e0       	ldi	r24, 0x01	; 1
     3ca:	8a 87       	std	Y+10, r24	; 0x0a
     3cc:	8a 85       	ldd	r24, Y+10	; 0x0a
     3ce:	8f 83       	std	Y+7, r24	; 0x07
        try_conf = 0;       //! Look for the next configuration
     3d0:	1b 86       	std	Y+11, r1	; 0x0b
        wait_for_rx = 0;    //! Skip "while (wait_for_rx ..." loop
     3d2:	19 86       	std	Y+9, r1	; 0x09
    }

    //! --- Clear all MOb's (CANMSG not cleared)
    for (u8_temp0 = 0; u8_temp0 < NB_MOB; u8_temp0++)
     3d4:	19 82       	std	Y+1, r1	; 0x01
     3d6:	1d c0       	rjmp	.+58     	; 0x412 <can_auto_baudrate+0x1bc>
    {
        Can_set_mob(u8_temp0);  //! Page index
     3d8:	8d ee       	ldi	r24, 0xED	; 237
     3da:	90 e0       	ldi	r25, 0x00	; 0
     3dc:	29 81       	ldd	r18, Y+1	; 0x01
     3de:	22 95       	swap	r18
     3e0:	20 7f       	andi	r18, 0xF0	; 240
     3e2:	fc 01       	movw	r30, r24
     3e4:	20 83       	st	Z, r18
        Can_clear_mob();        //! All MOb Registers = 0x00
     3e6:	8e ee       	ldi	r24, 0xEE	; 238
     3e8:	90 e0       	ldi	r25, 0x00	; 0
     3ea:	99 8b       	std	Y+17, r25	; 0x11
     3ec:	88 8b       	std	Y+16, r24	; 0x10
     3ee:	09 c0       	rjmp	.+18     	; 0x402 <can_auto_baudrate+0x1ac>
     3f0:	88 89       	ldd	r24, Y+16	; 0x10
     3f2:	99 89       	ldd	r25, Y+17	; 0x11
     3f4:	fc 01       	movw	r30, r24
     3f6:	10 82       	st	Z, r1
     3f8:	88 89       	ldd	r24, Y+16	; 0x10
     3fa:	99 89       	ldd	r25, Y+17	; 0x11
     3fc:	01 96       	adiw	r24, 0x01	; 1
     3fe:	99 8b       	std	Y+17, r25	; 0x11
     400:	88 8b       	std	Y+16, r24	; 0x10
     402:	88 89       	ldd	r24, Y+16	; 0x10
     404:	99 89       	ldd	r25, Y+17	; 0x11
     406:	88 3f       	cpi	r24, 0xF8	; 248
     408:	91 05       	cpc	r25, r1
     40a:	90 f3       	brcs	.-28     	; 0x3f0 <can_auto_baudrate+0x19a>
        try_conf = 0;       //! Look for the next configuration
        wait_for_rx = 0;    //! Skip "while (wait_for_rx ..." loop
    }

    //! --- Clear all MOb's (CANMSG not cleared)
    for (u8_temp0 = 0; u8_temp0 < NB_MOB; u8_temp0++)
     40c:	89 81       	ldd	r24, Y+1	; 0x01
     40e:	8f 5f       	subi	r24, 0xFF	; 255
     410:	89 83       	std	Y+1, r24	; 0x01
     412:	89 81       	ldd	r24, Y+1	; 0x01
     414:	86 30       	cpi	r24, 0x06	; 6
     416:	00 f3       	brcs	.-64     	; 0x3d8 <can_auto_baudrate+0x182>
    {
        Can_set_mob(u8_temp0);  //! Page index
        Can_clear_mob();        //! All MOb Registers = 0x00
    }

    while (bt_not_found == 1)
     418:	81 c1       	rjmp	.+770    	; 0x71c <can_auto_baudrate+0x4c6>
    {
        if (try_conf == 1)
     41a:	8b 85       	ldd	r24, Y+11	; 0x0b
     41c:	81 30       	cpi	r24, 0x01	; 1
     41e:	09 f0       	breq	.+2      	; 0x422 <can_auto_baudrate+0x1cc>
     420:	74 c0       	rjmp	.+232    	; 0x50a <can_auto_baudrate+0x2b4>
        {
            Can_reset();
     422:	88 ed       	ldi	r24, 0xD8	; 216
     424:	90 e0       	ldi	r25, 0x00	; 0
     426:	21 e0       	ldi	r18, 0x01	; 1
     428:	fc 01       	movw	r30, r24
     42a:	20 83       	st	Z, r18
            conf_index++;
     42c:	8d 85       	ldd	r24, Y+13	; 0x0d
     42e:	9e 85       	ldd	r25, Y+14	; 0x0e
     430:	01 96       	adiw	r24, 0x01	; 1
     432:	9e 87       	std	Y+14, r25	; 0x0e
     434:	8d 87       	std	Y+13, r24	; 0x0d
            ovrtim_flag=0;
     436:	1c 86       	std	Y+12, r1	; 0x0c

            //! --- CANBTx registers update (sjw = phs2/2, 3 sample points)
            CANBT1 = ((brp-1) << BRP);
     438:	82 ee       	ldi	r24, 0xE2	; 226
     43a:	90 e0       	ldi	r25, 0x00	; 0
     43c:	2a 81       	ldd	r18, Y+2	; 0x02
     43e:	21 50       	subi	r18, 0x01	; 1
     440:	22 0f       	add	r18, r18
     442:	fc 01       	movw	r30, r24
     444:	20 83       	st	Z, r18
            CANBT2 = (((phs2 >> 1)-1) << SJW) |((prs-1) << PRS);
     446:	83 ee       	ldi	r24, 0xE3	; 227
     448:	90 e0       	ldi	r25, 0x00	; 0
     44a:	2e 81       	ldd	r18, Y+6	; 0x06
     44c:	26 95       	lsr	r18
     44e:	22 2f       	mov	r18, r18
     450:	30 e0       	ldi	r19, 0x00	; 0
     452:	21 50       	subi	r18, 0x01	; 1
     454:	31 09       	sbc	r19, r1
     456:	22 0f       	add	r18, r18
     458:	33 1f       	adc	r19, r19
     45a:	22 95       	swap	r18
     45c:	32 95       	swap	r19
     45e:	30 7f       	andi	r19, 0xF0	; 240
     460:	32 27       	eor	r19, r18
     462:	20 7f       	andi	r18, 0xF0	; 240
     464:	32 27       	eor	r19, r18
     466:	42 2f       	mov	r20, r18
     468:	2b 81       	ldd	r18, Y+3	; 0x03
     46a:	22 2f       	mov	r18, r18
     46c:	30 e0       	ldi	r19, 0x00	; 0
     46e:	21 50       	subi	r18, 0x01	; 1
     470:	31 09       	sbc	r19, r1
     472:	22 0f       	add	r18, r18
     474:	33 1f       	adc	r19, r19
     476:	24 2b       	or	r18, r20
     478:	fc 01       	movw	r30, r24
     47a:	20 83       	st	Z, r18
            CANBT3 = (((phs2-1) << PHS2) | ((phs1-1) << PHS1) | (1<<SMP));
     47c:	84 ee       	ldi	r24, 0xE4	; 228
     47e:	90 e0       	ldi	r25, 0x00	; 0
     480:	2e 81       	ldd	r18, Y+6	; 0x06
     482:	22 2f       	mov	r18, r18
     484:	30 e0       	ldi	r19, 0x00	; 0
     486:	21 50       	subi	r18, 0x01	; 1
     488:	31 09       	sbc	r19, r1
     48a:	22 95       	swap	r18
     48c:	32 95       	swap	r19
     48e:	30 7f       	andi	r19, 0xF0	; 240
     490:	32 27       	eor	r19, r18
     492:	20 7f       	andi	r18, 0xF0	; 240
     494:	32 27       	eor	r19, r18
     496:	42 2f       	mov	r20, r18
     498:	2d 81       	ldd	r18, Y+5	; 0x05
     49a:	22 2f       	mov	r18, r18
     49c:	30 e0       	ldi	r19, 0x00	; 0
     49e:	21 50       	subi	r18, 0x01	; 1
     4a0:	31 09       	sbc	r19, r1
     4a2:	22 0f       	add	r18, r18
     4a4:	33 1f       	adc	r19, r19
     4a6:	24 2b       	or	r18, r20
     4a8:	21 60       	ori	r18, 0x01	; 1
     4aa:	fc 01       	movw	r30, r24
     4ac:	20 83       	st	Z, r18

            //! --- Set CAN-Timer - Used for time-out
            //!     There are 641 (0x281) possible evaluations. The first one provides the faster
            //!         the faster bit timing, the last one gives the slower. It is necessary to
            //!         modulate the time-out versus bit timing (0x281>>3=0x50, matching an U8).
            CANTCON = (uint8_t)(conf_index >> 3);
     4ae:	85 ee       	ldi	r24, 0xE5	; 229
     4b0:	90 e0       	ldi	r25, 0x00	; 0
     4b2:	2d 85       	ldd	r18, Y+13	; 0x0d
     4b4:	3e 85       	ldd	r19, Y+14	; 0x0e
     4b6:	36 95       	lsr	r19
     4b8:	27 95       	ror	r18
     4ba:	36 95       	lsr	r19
     4bc:	27 95       	ror	r18
     4be:	36 95       	lsr	r19
     4c0:	27 95       	ror	r18
     4c2:	fc 01       	movw	r30, r24
     4c4:	20 83       	st	Z, r18

            //! --- MOb configuration
            Can_set_mob(MOB_0);                 //! Use MOb-0
     4c6:	8d ee       	ldi	r24, 0xED	; 237
     4c8:	90 e0       	ldi	r25, 0x00	; 0
     4ca:	fc 01       	movw	r30, r24
     4cc:	10 82       	st	Z, r1
            CANSTMOB = 0;                       //! Reset MOb status (undone by "Can_reset()")
     4ce:	8e ee       	ldi	r24, 0xEE	; 238
     4d0:	90 e0       	ldi	r25, 0x00	; 0
     4d2:	fc 01       	movw	r30, r24
     4d4:	10 82       	st	Z, r1
            CANCDMOB = (MOB_Rx_ENA  << CONMOB); //! MOb 0 in receive mode
     4d6:	8f ee       	ldi	r24, 0xEF	; 239
     4d8:	90 e0       	ldi	r25, 0x00	; 0
     4da:	20 e8       	ldi	r18, 0x80	; 128
     4dc:	fc 01       	movw	r30, r24
     4de:	20 83       	st	Z, r18

            //! CAN controller configuration
            CANGCON = (1<<LISTEN) | (1<<ENASTB);//! Enable CAN controller in "listen" mode
     4e0:	88 ed       	ldi	r24, 0xD8	; 216
     4e2:	90 e0       	ldi	r25, 0x00	; 0
     4e4:	2a e0       	ldi	r18, 0x0A	; 10
     4e6:	fc 01       	movw	r30, r24
     4e8:	20 83       	st	Z, r18
            while ((CANGSTA & (1<<ENFG)) == 0); //! Wait for Enable OK
     4ea:	00 00       	nop
     4ec:	89 ed       	ldi	r24, 0xD9	; 217
     4ee:	90 e0       	ldi	r25, 0x00	; 0
     4f0:	fc 01       	movw	r30, r24
     4f2:	80 81       	ld	r24, Z
     4f4:	88 2f       	mov	r24, r24
     4f6:	90 e0       	ldi	r25, 0x00	; 0
     4f8:	84 70       	andi	r24, 0x04	; 4
     4fa:	99 27       	eor	r25, r25
     4fc:	89 2b       	or	r24, r25
     4fe:	b1 f3       	breq	.-20     	; 0x4ec <can_auto_baudrate+0x296>
            CANGIT = 0xFF;                      //! Reset General errors and OVRTIM flag
     500:	8a ed       	ldi	r24, 0xDA	; 218
     502:	90 e0       	ldi	r25, 0x00	; 0
     504:	2f ef       	ldi	r18, 0xFF	; 255
     506:	fc 01       	movw	r30, r24
     508:	20 83       	st	Z, r18
        //! --- WAIT_FOR_RX LOOP:
        //!     ================
        //!     Try to perform a CAN message reception in "LISTEN" mode without error and
        //!     before a time_out done by CAN-Timer.
        //!     Else gives the hand to "EVALUATE LOOP" to have a new set of bit timing.
        while (wait_for_rx == 1)
     50a:	68 c0       	rjmp	.+208    	; 0x5dc <can_auto_baudrate+0x386>
        {
            u8_temp0 = CANSTMOB;
     50c:	8e ee       	ldi	r24, 0xEE	; 238
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	fc 01       	movw	r30, r24
     512:	80 81       	ld	r24, Z
     514:	89 83       	std	Y+1, r24	; 0x01
            //! --- RxOK received ?
            if ((u8_temp0 & (1<<RXOK)) != 0)
     516:	89 81       	ldd	r24, Y+1	; 0x01
     518:	88 2f       	mov	r24, r24
     51a:	90 e0       	ldi	r25, 0x00	; 0
     51c:	80 72       	andi	r24, 0x20	; 32
     51e:	99 27       	eor	r25, r25
     520:	89 2b       	or	r24, r25
     522:	f1 f0       	breq	.+60     	; 0x560 <can_auto_baudrate+0x30a>
            {   //! --- It is the successful output of "can_auto_baudrate" function
                wait_for_rx = 0;    //! Out of "while (wait_for_rx ..." loop
     524:	19 86       	std	Y+9, r1	; 0x09
                evaluate = 0;       //! Will skip "while (evaluate ..." loop
     526:	1a 86       	std	Y+10, r1	; 0x0a
                bt_not_found = 0;   //! Out of "while (bt_not_found ..." loop
     528:	18 86       	std	Y+8, r1	; 0x08
                bt_performed = 1;   //! Return flag = TRUE
     52a:	81 e0       	ldi	r24, 0x01	; 1
     52c:	8f 87       	std	Y+15, r24	; 0x0f
                DISABLE_MOB;        //! Disable MOb-0
     52e:	8f ee       	ldi	r24, 0xEF	; 239
     530:	90 e0       	ldi	r25, 0x00	; 0
     532:	2f ee       	ldi	r18, 0xEF	; 239
     534:	30 e0       	ldi	r19, 0x00	; 0
     536:	f9 01       	movw	r30, r18
     538:	20 81       	ld	r18, Z
     53a:	2f 73       	andi	r18, 0x3F	; 63
     53c:	fc 01       	movw	r30, r24
     53e:	20 83       	st	Z, r18
                CANGCON = 0x00;     //! Disable CAN controller & reset "listen" mode
     540:	88 ed       	ldi	r24, 0xD8	; 216
     542:	90 e0       	ldi	r25, 0x00	; 0
     544:	fc 01       	movw	r30, r24
     546:	10 82       	st	Z, r1
                while ((CANGSTA & (1<<ENFG)) != 0); //! Wait for Disable OK
     548:	00 00       	nop
     54a:	89 ed       	ldi	r24, 0xD9	; 217
     54c:	90 e0       	ldi	r25, 0x00	; 0
     54e:	fc 01       	movw	r30, r24
     550:	80 81       	ld	r24, Z
     552:	88 2f       	mov	r24, r24
     554:	90 e0       	ldi	r25, 0x00	; 0
     556:	84 70       	andi	r24, 0x04	; 4
     558:	99 27       	eor	r25, r25
     55a:	89 2b       	or	r24, r25
     55c:	b1 f7       	brne	.-20     	; 0x54a <can_auto_baudrate+0x2f4>
     55e:	3e c0       	rjmp	.+124    	; 0x5dc <can_auto_baudrate+0x386>
            }
             //! --- Else stop if any errors
             else
            {
                //! --- MOb error ?
                if ((u8_temp0 & ((1<<BERR)|(1<<SERR)|(1<<CERR)|(1<<FERR)|(1<<AERR))) !=0)
     560:	89 81       	ldd	r24, Y+1	; 0x01
     562:	88 2f       	mov	r24, r24
     564:	90 e0       	ldi	r25, 0x00	; 0
     566:	8f 71       	andi	r24, 0x1F	; 31
     568:	99 27       	eor	r25, r25
     56a:	89 2b       	or	r24, r25
     56c:	19 f0       	breq	.+6      	; 0x574 <can_auto_baudrate+0x31e>
                {
                    evaluate = 1;       //! Will enter in "while (evaluate ..." loop
     56e:	81 e0       	ldi	r24, 0x01	; 1
     570:	8a 87       	std	Y+10, r24	; 0x0a
                    wait_for_rx = 0;    //! Out of "while (wait_for_rx ..." loop
     572:	19 86       	std	Y+9, r1	; 0x09
                }

                u8_temp0 = CANGIT;
     574:	8a ed       	ldi	r24, 0xDA	; 218
     576:	90 e0       	ldi	r25, 0x00	; 0
     578:	fc 01       	movw	r30, r24
     57a:	80 81       	ld	r24, Z
     57c:	89 83       	std	Y+1, r24	; 0x01

                //! --- Time_out reached ?
                if ((u8_temp0 & (1<<OVRTIM)) !=0 )
     57e:	89 81       	ldd	r24, Y+1	; 0x01
     580:	88 2f       	mov	r24, r24
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	80 72       	andi	r24, 0x20	; 32
     586:	99 27       	eor	r25, r25
     588:	89 2b       	or	r24, r25
     58a:	e1 f0       	breq	.+56     	; 0x5c4 <can_auto_baudrate+0x36e>
                {
                    if (ovrtim_flag==0)
     58c:	8c 85       	ldd	r24, Y+12	; 0x0c
     58e:	88 23       	and	r24, r24
     590:	69 f4       	brne	.+26     	; 0x5ac <can_auto_baudrate+0x356>
                    {
                        //! --- First Time_out
                        CANGIT |= (1<<OVRTIM);  // Reset OVRTIM
     592:	8a ed       	ldi	r24, 0xDA	; 218
     594:	90 e0       	ldi	r25, 0x00	; 0
     596:	2a ed       	ldi	r18, 0xDA	; 218
     598:	30 e0       	ldi	r19, 0x00	; 0
     59a:	f9 01       	movw	r30, r18
     59c:	20 81       	ld	r18, Z
     59e:	20 62       	ori	r18, 0x20	; 32
     5a0:	fc 01       	movw	r30, r24
     5a2:	20 83       	st	Z, r18
                        ovrtim_flag++;
     5a4:	8c 85       	ldd	r24, Y+12	; 0x0c
     5a6:	8f 5f       	subi	r24, 0xFF	; 255
     5a8:	8c 87       	std	Y+12, r24	; 0x0c
     5aa:	0c c0       	rjmp	.+24     	; 0x5c4 <can_auto_baudrate+0x36e>
                    }
                    else
                    {
                        //! --- Second Time_out
                        CANGIT |= (1<<OVRTIM);  // Reset OVRTIM
     5ac:	8a ed       	ldi	r24, 0xDA	; 218
     5ae:	90 e0       	ldi	r25, 0x00	; 0
     5b0:	2a ed       	ldi	r18, 0xDA	; 218
     5b2:	30 e0       	ldi	r19, 0x00	; 0
     5b4:	f9 01       	movw	r30, r18
     5b6:	20 81       	ld	r18, Z
     5b8:	20 62       	ori	r18, 0x20	; 32
     5ba:	fc 01       	movw	r30, r24
     5bc:	20 83       	st	Z, r18
                        evaluate = 1;           //! Will enter in "while (evaluate ..." loop
     5be:	81 e0       	ldi	r24, 0x01	; 1
     5c0:	8a 87       	std	Y+10, r24	; 0x0a
                        wait_for_rx = 0;        //! Out of "while (wait_for_rx ..." loop
     5c2:	19 86       	std	Y+9, r1	; 0x09
                    }
                }

                //! --- General error ?
                if ((u8_temp0 & ((1<<SERG)|(1<<CERG)|(1<<FERG)|(1<<AERG))) !=0)
     5c4:	89 81       	ldd	r24, Y+1	; 0x01
     5c6:	88 2f       	mov	r24, r24
     5c8:	90 e0       	ldi	r25, 0x00	; 0
     5ca:	8f 70       	andi	r24, 0x0F	; 15
     5cc:	99 27       	eor	r25, r25
     5ce:	89 2b       	or	r24, r25
     5d0:	29 f0       	breq	.+10     	; 0x5dc <can_auto_baudrate+0x386>
                {
                    evaluate = 1;       //! Will enter in "while (evaluate ..." loop
     5d2:	81 e0       	ldi	r24, 0x01	; 1
     5d4:	8a 87       	std	Y+10, r24	; 0x0a
                    wait_for_rx = 0;    //! Out of "while (wait_for_rx ..." loop
     5d6:	19 86       	std	Y+9, r1	; 0x09
                    try_conf = 1;       //! Try this configuration
     5d8:	81 e0       	ldi	r24, 0x01	; 1
     5da:	8b 87       	std	Y+11, r24	; 0x0b
        //! --- WAIT_FOR_RX LOOP:
        //!     ================
        //!     Try to perform a CAN message reception in "LISTEN" mode without error and
        //!     before a time_out done by CAN-Timer.
        //!     Else gives the hand to "EVALUATE LOOP" to have a new set of bit timing.
        while (wait_for_rx == 1)
     5dc:	89 85       	ldd	r24, Y+9	; 0x09
     5de:	81 30       	cpi	r24, 0x01	; 1
     5e0:	09 f4       	brne	.+2      	; 0x5e4 <can_auto_baudrate+0x38e>
     5e2:	94 cf       	rjmp	.-216    	; 0x50c <can_auto_baudrate+0x2b6>
        //!     then Phase2=Phase1 and if Phase1>5, Phase1 can be equal to Phase2 or
        //!     Phase2+1. After this, the number of TQ is increased up to its high
        //!     limit and after it is the Prescaler. During the computing high (80%)
        //!     and low (75%) limits of sampling point location are tested. SJW and
        //!     the number of sampling points are not calculated in this loop.
        while (evaluate == 1)
     5e4:	97 c0       	rjmp	.+302    	; 0x714 <can_auto_baudrate+0x4be>
        {
            if (phs1_inc != 0) phs1++;
     5e6:	8f 81       	ldd	r24, Y+7	; 0x07
     5e8:	88 23       	and	r24, r24
     5ea:	19 f0       	breq	.+6      	; 0x5f2 <can_auto_baudrate+0x39c>
     5ec:	8d 81       	ldd	r24, Y+5	; 0x05
     5ee:	8f 5f       	subi	r24, 0xFF	; 255
     5f0:	8d 83       	std	Y+5, r24	; 0x05
            phs1_inc = 1;
     5f2:	81 e0       	ldi	r24, 0x01	; 1
     5f4:	8f 83       	std	Y+7, r24	; 0x07

            // --- The following test takes into account the previous incrementation of phs1
            if ((phs1 > PHS1_MAX) && (phs2 >= PHS2_MAX))
     5f6:	8d 81       	ldd	r24, Y+5	; 0x05
     5f8:	89 30       	cpi	r24, 0x09	; 9
     5fa:	a0 f1       	brcs	.+104    	; 0x664 <can_auto_baudrate+0x40e>
     5fc:	8e 81       	ldd	r24, Y+6	; 0x06
     5fe:	88 30       	cpi	r24, 0x08	; 8
     600:	88 f1       	brcs	.+98     	; 0x664 <can_auto_baudrate+0x40e>
            {
                phs1 = PHS1_MIN;
     602:	82 e0       	ldi	r24, 0x02	; 2
     604:	8d 83       	std	Y+5, r24	; 0x05
                phs2 = PHS2_MIN;
     606:	82 e0       	ldi	r24, 0x02	; 2
     608:	8e 83       	std	Y+6, r24	; 0x06
                phs1_inc = 0;
     60a:	1f 82       	std	Y+7, r1	; 0x07
                if (ntq != NTQ_MAX) ntq++;
     60c:	8c 81       	ldd	r24, Y+4	; 0x04
     60e:	89 31       	cpi	r24, 0x19	; 25
     610:	21 f0       	breq	.+8      	; 0x61a <can_auto_baudrate+0x3c4>
     612:	8c 81       	ldd	r24, Y+4	; 0x04
     614:	8f 5f       	subi	r24, 0xFF	; 255
     616:	8c 83       	std	Y+4, r24	; 0x04
     618:	24 c0       	rjmp	.+72     	; 0x662 <can_auto_baudrate+0x40c>
                else
                {
                    ntq = NTQ_MIN;
     61a:	88 e0       	ldi	r24, 0x08	; 8
     61c:	8c 83       	std	Y+4, r24	; 0x04
                    if (brp != BRP_MAX) brp++;
     61e:	8a 81       	ldd	r24, Y+2	; 0x02
     620:	80 34       	cpi	r24, 0x40	; 64
     622:	21 f0       	breq	.+8      	; 0x62c <can_auto_baudrate+0x3d6>
     624:	8a 81       	ldd	r24, Y+2	; 0x02
     626:	8f 5f       	subi	r24, 0xFF	; 255
     628:	8a 83       	std	Y+2, r24	; 0x02
     62a:	1b c0       	rjmp	.+54     	; 0x662 <can_auto_baudrate+0x40c>
                    else
                    {
                        //! --- It is the failing of "can_auto_baudrate" function
                        evaluate = 0;       //! Out of "while (evaluate ..." loop
     62c:	1a 86       	std	Y+10, r1	; 0x0a
                        bt_performed = 0;   //! Return flag = FALSE
     62e:	1f 86       	std	Y+15, r1	; 0x0f
                        bt_not_found = 0;   //! Out of "while (bt_not_found ..." loop
     630:	18 86       	std	Y+8, r1	; 0x08
                        DISABLE_MOB;        //! Disable MOb-0
     632:	8f ee       	ldi	r24, 0xEF	; 239
     634:	90 e0       	ldi	r25, 0x00	; 0
     636:	2f ee       	ldi	r18, 0xEF	; 239
     638:	30 e0       	ldi	r19, 0x00	; 0
     63a:	f9 01       	movw	r30, r18
     63c:	20 81       	ld	r18, Z
     63e:	2f 73       	andi	r18, 0x3F	; 63
     640:	fc 01       	movw	r30, r24
     642:	20 83       	st	Z, r18
                        CANGCON = 0x00;     //! Disable CAN controller & reset "listen" mode
     644:	88 ed       	ldi	r24, 0xD8	; 216
     646:	90 e0       	ldi	r25, 0x00	; 0
     648:	fc 01       	movw	r30, r24
     64a:	10 82       	st	Z, r1
                        while ((CANGSTA & (1<<ENFG)) != 0); //! Wait for Disable OK
     64c:	00 00       	nop
     64e:	89 ed       	ldi	r24, 0xD9	; 217
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	fc 01       	movw	r30, r24
     654:	80 81       	ld	r24, Z
     656:	88 2f       	mov	r24, r24
     658:	90 e0       	ldi	r25, 0x00	; 0
     65a:	84 70       	andi	r24, 0x04	; 4
     65c:	99 27       	eor	r25, r25
     65e:	89 2b       	or	r24, r25
     660:	b1 f7       	brne	.-20     	; 0x64e <can_auto_baudrate+0x3f8>
            if ((phs1 > PHS1_MAX) && (phs2 >= PHS2_MAX))
            {
                phs1 = PHS1_MIN;
                phs2 = PHS2_MIN;
                phs1_inc = 0;
                if (ntq != NTQ_MAX) ntq++;
     662:	58 c0       	rjmp	.+176    	; 0x714 <can_auto_baudrate+0x4be>
                }
            }
            else    // if (phs1 > PHS1_MAX ...
            {
                //! --- If psh1 > 5 then phs1 =phs2 or =phs2+1, else phs1=phs2
                if (phs1>5)
     664:	8d 81       	ldd	r24, Y+5	; 0x05
     666:	86 30       	cpi	r24, 0x06	; 6
     668:	80 f0       	brcs	.+32     	; 0x68a <can_auto_baudrate+0x434>
                {
                    if (phs1>(phs2+1)) phs1=(++phs2);
     66a:	8d 81       	ldd	r24, Y+5	; 0x05
     66c:	28 2f       	mov	r18, r24
     66e:	30 e0       	ldi	r19, 0x00	; 0
     670:	8e 81       	ldd	r24, Y+6	; 0x06
     672:	88 2f       	mov	r24, r24
     674:	90 e0       	ldi	r25, 0x00	; 0
     676:	01 96       	adiw	r24, 0x01	; 1
     678:	82 17       	cp	r24, r18
     67a:	93 07       	cpc	r25, r19
     67c:	44 f4       	brge	.+16     	; 0x68e <can_auto_baudrate+0x438>
     67e:	8e 81       	ldd	r24, Y+6	; 0x06
     680:	8f 5f       	subi	r24, 0xFF	; 255
     682:	8e 83       	std	Y+6, r24	; 0x06
     684:	8e 81       	ldd	r24, Y+6	; 0x06
     686:	8d 83       	std	Y+5, r24	; 0x05
     688:	02 c0       	rjmp	.+4      	; 0x68e <can_auto_baudrate+0x438>
                }
                else
                {
                phs2=phs1;
     68a:	8d 81       	ldd	r24, Y+5	; 0x05
     68c:	8e 83       	std	Y+6, r24	; 0x06
                }
                prs = ntq - ( phs1 + phs2 + 1 );
     68e:	9d 81       	ldd	r25, Y+5	; 0x05
     690:	8e 81       	ldd	r24, Y+6	; 0x06
     692:	89 0f       	add	r24, r25
     694:	9c 81       	ldd	r25, Y+4	; 0x04
     696:	f9 2f       	mov	r31, r25
     698:	f8 1b       	sub	r31, r24
     69a:	8f 2f       	mov	r24, r31
     69c:	81 50       	subi	r24, 0x01	; 1
     69e:	8b 83       	std	Y+3, r24	; 0x03

                //! --- Test PRS limits
                if ((prs <= PRS_MAX) && (prs >= PRS_MIN))
     6a0:	8b 81       	ldd	r24, Y+3	; 0x03
     6a2:	89 30       	cpi	r24, 0x09	; 9
     6a4:	b8 f5       	brcc	.+110    	; 0x714 <can_auto_baudrate+0x4be>
     6a6:	8b 81       	ldd	r24, Y+3	; 0x03
     6a8:	88 23       	and	r24, r24
     6aa:	a1 f1       	breq	.+104    	; 0x714 <can_auto_baudrate+0x4be>
                {
                    //! --- Values  accepted if  80% >= sampling point >= 75%
                    if (((phs2<<2) >= (1+prs+phs1)) && ((phs2+phs2+phs2) <= (1+prs+phs1)))
     6ac:	8e 81       	ldd	r24, Y+6	; 0x06
     6ae:	88 2f       	mov	r24, r24
     6b0:	90 e0       	ldi	r25, 0x00	; 0
     6b2:	9c 01       	movw	r18, r24
     6b4:	22 0f       	add	r18, r18
     6b6:	33 1f       	adc	r19, r19
     6b8:	22 0f       	add	r18, r18
     6ba:	33 1f       	adc	r19, r19
     6bc:	8b 81       	ldd	r24, Y+3	; 0x03
     6be:	88 2f       	mov	r24, r24
     6c0:	90 e0       	ldi	r25, 0x00	; 0
     6c2:	ac 01       	movw	r20, r24
     6c4:	4f 5f       	subi	r20, 0xFF	; 255
     6c6:	5f 4f       	sbci	r21, 0xFF	; 255
     6c8:	8d 81       	ldd	r24, Y+5	; 0x05
     6ca:	88 2f       	mov	r24, r24
     6cc:	90 e0       	ldi	r25, 0x00	; 0
     6ce:	84 0f       	add	r24, r20
     6d0:	95 1f       	adc	r25, r21
     6d2:	28 17       	cp	r18, r24
     6d4:	39 07       	cpc	r19, r25
     6d6:	f4 f0       	brlt	.+60     	; 0x714 <can_auto_baudrate+0x4be>
     6d8:	8e 81       	ldd	r24, Y+6	; 0x06
     6da:	28 2f       	mov	r18, r24
     6dc:	30 e0       	ldi	r19, 0x00	; 0
     6de:	8e 81       	ldd	r24, Y+6	; 0x06
     6e0:	88 2f       	mov	r24, r24
     6e2:	90 e0       	ldi	r25, 0x00	; 0
     6e4:	28 0f       	add	r18, r24
     6e6:	39 1f       	adc	r19, r25
     6e8:	8e 81       	ldd	r24, Y+6	; 0x06
     6ea:	88 2f       	mov	r24, r24
     6ec:	90 e0       	ldi	r25, 0x00	; 0
     6ee:	28 0f       	add	r18, r24
     6f0:	39 1f       	adc	r19, r25
     6f2:	8b 81       	ldd	r24, Y+3	; 0x03
     6f4:	88 2f       	mov	r24, r24
     6f6:	90 e0       	ldi	r25, 0x00	; 0
     6f8:	ac 01       	movw	r20, r24
     6fa:	4f 5f       	subi	r20, 0xFF	; 255
     6fc:	5f 4f       	sbci	r21, 0xFF	; 255
     6fe:	8d 81       	ldd	r24, Y+5	; 0x05
     700:	88 2f       	mov	r24, r24
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	84 0f       	add	r24, r20
     706:	95 1f       	adc	r25, r21
     708:	82 17       	cp	r24, r18
     70a:	93 07       	cpc	r25, r19
     70c:	1c f0       	brlt	.+6      	; 0x714 <can_auto_baudrate+0x4be>
                    {
                        evaluate = 0;     //! Out of "while (evaluate ..." loop &
     70e:	1a 86       	std	Y+10, r1	; 0x0a
                        wait_for_rx = 1;  //!    new "while (bt_not_found ..." loop
     710:	81 e0       	ldi	r24, 0x01	; 1
     712:	89 87       	std	Y+9, r24	; 0x09
        //!     then Phase2=Phase1 and if Phase1>5, Phase1 can be equal to Phase2 or
        //!     Phase2+1. After this, the number of TQ is increased up to its high
        //!     limit and after it is the Prescaler. During the computing high (80%)
        //!     and low (75%) limits of sampling point location are tested. SJW and
        //!     the number of sampling points are not calculated in this loop.
        while (evaluate == 1)
     714:	8a 85       	ldd	r24, Y+10	; 0x0a
     716:	81 30       	cpi	r24, 0x01	; 1
     718:	09 f4       	brne	.+2      	; 0x71c <can_auto_baudrate+0x4c6>
     71a:	65 cf       	rjmp	.-310    	; 0x5e6 <can_auto_baudrate+0x390>
    {
        Can_set_mob(u8_temp0);  //! Page index
        Can_clear_mob();        //! All MOb Registers = 0x00
    }

    while (bt_not_found == 1)
     71c:	88 85       	ldd	r24, Y+8	; 0x08
     71e:	81 30       	cpi	r24, 0x01	; 1
     720:	09 f4       	brne	.+2      	; 0x724 <can_auto_baudrate+0x4ce>
     722:	7b ce       	rjmp	.-778    	; 0x41a <can_auto_baudrate+0x1c4>
                }
            }
        } // while (evaluate ...
    } // while (bt_not_found ...

    return (bt_performed);
     724:	8f 85       	ldd	r24, Y+15	; 0x0f
}
     726:	62 96       	adiw	r28, 0x12	; 18
     728:	0f b6       	in	r0, 0x3f	; 63
     72a:	f8 94       	cli
     72c:	de bf       	out	0x3e, r29	; 62
     72e:	0f be       	out	0x3f, r0	; 63
     730:	cd bf       	out	0x3d, r28	; 61
     732:	df 91       	pop	r29
     734:	cf 91       	pop	r28
     736:	08 95       	ret

00000738 <can_fixed_baudrate>:
//!
//! @return Baudrate Status
//!         fixed = 1: baudrate performed
//------------------------------------------------------------------------------
uint8_t can_fixed_baudrate(uint8_t mode)
{
     738:	cf 93       	push	r28
     73a:	df 93       	push	r29
     73c:	1f 92       	push	r1
     73e:	cd b7       	in	r28, 0x3d	; 61
     740:	de b7       	in	r29, 0x3e	; 62
     742:	89 83       	std	Y+1, r24	; 0x01
    Can_reset();
     744:	88 ed       	ldi	r24, 0xD8	; 216
     746:	90 e0       	ldi	r25, 0x00	; 0
     748:	21 e0       	ldi	r18, 0x01	; 1
     74a:	fc 01       	movw	r30, r24
     74c:	20 83       	st	Z, r18
    Can_conf_bt();
     74e:	82 ee       	ldi	r24, 0xE2	; 226
     750:	90 e0       	ldi	r25, 0x00	; 0
     752:	26 e0       	ldi	r18, 0x06	; 6
     754:	fc 01       	movw	r30, r24
     756:	20 83       	st	Z, r18
     758:	83 ee       	ldi	r24, 0xE3	; 227
     75a:	90 e0       	ldi	r25, 0x00	; 0
     75c:	24 e0       	ldi	r18, 0x04	; 4
     75e:	fc 01       	movw	r30, r24
     760:	20 83       	st	Z, r18
     762:	84 ee       	ldi	r24, 0xE4	; 228
     764:	90 e0       	ldi	r25, 0x00	; 0
     766:	23 e1       	ldi	r18, 0x13	; 19
     768:	fc 01       	movw	r30, r24
     76a:	20 83       	st	Z, r18
    return 1;
     76c:	81 e0       	ldi	r24, 0x01	; 1
     76e:	0f 90       	pop	r0
     770:	df 91       	pop	r29
     772:	cf 91       	pop	r28
     774:	08 95       	ret

00000776 <can_init>:
//!         ==0: research of bit timing configuration failed
//!         ==1: baudrate performed 
//!
//------------------------------------------------------------------------------
uint8_t can_init(uint8_t mode)
{
     776:	cf 93       	push	r28
     778:	df 93       	push	r29
     77a:	1f 92       	push	r1
     77c:	cd b7       	in	r28, 0x3d	; 61
     77e:	de b7       	in	r29, 0x3e	; 62
     780:	89 83       	std	Y+1, r24	; 0x01
    if ((Can_bit_timing(mode))==0) return (0);  // c.f. macro in "can_drv.h"
     782:	89 81       	ldd	r24, Y+1	; 0x01
     784:	0e 94 9c 03 	call	0x738	; 0x738 <can_fixed_baudrate>
     788:	88 23       	and	r24, r24
     78a:	11 f4       	brne	.+4      	; 0x790 <can_init+0x1a>
     78c:	80 e0       	ldi	r24, 0x00	; 0
     78e:	0c c0       	rjmp	.+24     	; 0x7a8 <can_init+0x32>
    can_clear_all_mob();                        // c.f. function in "can_drv.c"
     790:	0e 94 68 00 	call	0xd0	; 0xd0 <can_clear_all_mob>
    Can_enable();                               // c.f. macro in "can_drv.h" 
     794:	88 ed       	ldi	r24, 0xD8	; 216
     796:	90 e0       	ldi	r25, 0x00	; 0
     798:	28 ed       	ldi	r18, 0xD8	; 216
     79a:	30 e0       	ldi	r19, 0x00	; 0
     79c:	f9 01       	movw	r30, r18
     79e:	20 81       	ld	r18, Z
     7a0:	22 60       	ori	r18, 0x02	; 2
     7a2:	fc 01       	movw	r30, r24
     7a4:	20 83       	st	Z, r18
    return (1);
     7a6:	81 e0       	ldi	r24, 0x01	; 1
}
     7a8:	0f 90       	pop	r0
     7aa:	df 91       	pop	r29
     7ac:	cf 91       	pop	r28
     7ae:	08 95       	ret

000007b0 <can_cmd>:
//! @return CAN_CMD_ACCEPTED - command is accepted
//!         CAN_CMD_REFUSED  - command is refused
//!
//------------------------------------------------------------------------------
uint8_t can_cmd(st_cmd_t* cmd)
{
     7b0:	cf 93       	push	r28
     7b2:	df 93       	push	r29
     7b4:	cd b7       	in	r28, 0x3d	; 61
     7b6:	de b7       	in	r29, 0x3e	; 62
     7b8:	2a 97       	sbiw	r28, 0x0a	; 10
     7ba:	0f b6       	in	r0, 0x3f	; 63
     7bc:	f8 94       	cli
     7be:	de bf       	out	0x3e, r29	; 62
     7c0:	0f be       	out	0x3f, r0	; 63
     7c2:	cd bf       	out	0x3d, r28	; 61
     7c4:	9a 87       	std	Y+10, r25	; 0x0a
     7c6:	89 87       	std	Y+9, r24	; 0x09
  uint8_t mob_handle, cpt;
  uint32_t u32_temp;
  
  if (cmd->cmd == CMD_ABORT)
     7c8:	89 85       	ldd	r24, Y+9	; 0x09
     7ca:	9a 85       	ldd	r25, Y+10	; 0x0a
     7cc:	fc 01       	movw	r30, r24
     7ce:	81 81       	ldd	r24, Z+1	; 0x01
     7d0:	8c 30       	cpi	r24, 0x0C	; 12
     7d2:	39 f5       	brne	.+78     	; 0x822 <can_cmd+0x72>
  {
    if (cmd->status == MOB_PENDING)
     7d4:	89 85       	ldd	r24, Y+9	; 0x09
     7d6:	9a 85       	ldd	r25, Y+10	; 0x0a
     7d8:	fc 01       	movw	r30, r24
     7da:	81 85       	ldd	r24, Z+9	; 0x09
     7dc:	80 36       	cpi	r24, 0x60	; 96
     7de:	d9 f4       	brne	.+54     	; 0x816 <can_cmd+0x66>
    {
      // Rx or Tx not yet performed
      Can_set_mob(cmd->handle);
     7e0:	8d ee       	ldi	r24, 0xED	; 237
     7e2:	90 e0       	ldi	r25, 0x00	; 0
     7e4:	29 85       	ldd	r18, Y+9	; 0x09
     7e6:	3a 85       	ldd	r19, Y+10	; 0x0a
     7e8:	f9 01       	movw	r30, r18
     7ea:	20 81       	ld	r18, Z
     7ec:	22 95       	swap	r18
     7ee:	20 7f       	andi	r18, 0xF0	; 240
     7f0:	fc 01       	movw	r30, r24
     7f2:	20 83       	st	Z, r18
      Can_mob_abort();
     7f4:	8f ee       	ldi	r24, 0xEF	; 239
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	2f ee       	ldi	r18, 0xEF	; 239
     7fa:	30 e0       	ldi	r19, 0x00	; 0
     7fc:	f9 01       	movw	r30, r18
     7fe:	20 81       	ld	r18, Z
     800:	2f 73       	andi	r18, 0x3F	; 63
     802:	fc 01       	movw	r30, r24
     804:	20 83       	st	Z, r18
      Can_clear_status_mob();       // To be sure !
     806:	8e ee       	ldi	r24, 0xEE	; 238
     808:	90 e0       	ldi	r25, 0x00	; 0
     80a:	fc 01       	movw	r30, r24
     80c:	10 82       	st	Z, r1
      cmd->handle = 0;
     80e:	89 85       	ldd	r24, Y+9	; 0x09
     810:	9a 85       	ldd	r25, Y+10	; 0x0a
     812:	fc 01       	movw	r30, r24
     814:	10 82       	st	Z, r1
    }
    cmd->status = STATUS_CLEARED; 
     816:	89 85       	ldd	r24, Y+9	; 0x09
     818:	9a 85       	ldd	r25, Y+10	; 0x0a
     81a:	fc 01       	movw	r30, r24
     81c:	11 86       	std	Z+9, r1	; 0x09
     81e:	0c 94 64 0e 	jmp	0x1cc8	; 0x1cc8 <__stack+0xbc9>
  }
  else
  {
    mob_handle = can_get_mob_free();
     822:	0e 94 96 00 	call	0x12c	; 0x12c <can_get_mob_free>
     826:	8c 83       	std	Y+4, r24	; 0x04
    if (mob_handle!= NO_MOB)
     828:	8c 81       	ldd	r24, Y+4	; 0x04
     82a:	8f 3f       	cpi	r24, 0xFF	; 255
     82c:	11 f4       	brne	.+4      	; 0x832 <can_cmd+0x82>
     82e:	0c 94 5d 0e 	jmp	0x1cba	; 0x1cba <__stack+0xbbb>
    {
      cmd->status = MOB_PENDING; 
     832:	89 85       	ldd	r24, Y+9	; 0x09
     834:	9a 85       	ldd	r25, Y+10	; 0x0a
     836:	20 e6       	ldi	r18, 0x60	; 96
     838:	fc 01       	movw	r30, r24
     83a:	21 87       	std	Z+9, r18	; 0x09
      cmd->handle = mob_handle;
     83c:	89 85       	ldd	r24, Y+9	; 0x09
     83e:	9a 85       	ldd	r25, Y+10	; 0x0a
     840:	2c 81       	ldd	r18, Y+4	; 0x04
     842:	fc 01       	movw	r30, r24
     844:	20 83       	st	Z, r18
      Can_set_mob(mob_handle);
     846:	8d ee       	ldi	r24, 0xED	; 237
     848:	90 e0       	ldi	r25, 0x00	; 0
     84a:	2c 81       	ldd	r18, Y+4	; 0x04
     84c:	22 95       	swap	r18
     84e:	20 7f       	andi	r18, 0xF0	; 240
     850:	fc 01       	movw	r30, r24
     852:	20 83       	st	Z, r18
      Can_clear_mob();
     854:	8e ee       	ldi	r24, 0xEE	; 238
     856:	90 e0       	ldi	r25, 0x00	; 0
     858:	9b 83       	std	Y+3, r25	; 0x03
     85a:	8a 83       	std	Y+2, r24	; 0x02
     85c:	09 c0       	rjmp	.+18     	; 0x870 <can_cmd+0xc0>
     85e:	8a 81       	ldd	r24, Y+2	; 0x02
     860:	9b 81       	ldd	r25, Y+3	; 0x03
     862:	fc 01       	movw	r30, r24
     864:	10 82       	st	Z, r1
     866:	8a 81       	ldd	r24, Y+2	; 0x02
     868:	9b 81       	ldd	r25, Y+3	; 0x03
     86a:	01 96       	adiw	r24, 0x01	; 1
     86c:	9b 83       	std	Y+3, r25	; 0x03
     86e:	8a 83       	std	Y+2, r24	; 0x02
     870:	8a 81       	ldd	r24, Y+2	; 0x02
     872:	9b 81       	ldd	r25, Y+3	; 0x03
     874:	88 3f       	cpi	r24, 0xF8	; 248
     876:	91 05       	cpc	r25, r1
     878:	90 f3       	brcs	.-28     	; 0x85e <can_cmd+0xae>
          
      switch (cmd->cmd)
     87a:	89 85       	ldd	r24, Y+9	; 0x09
     87c:	9a 85       	ldd	r25, Y+10	; 0x0a
     87e:	fc 01       	movw	r30, r24
     880:	81 81       	ldd	r24, Z+1	; 0x01
     882:	88 2f       	mov	r24, r24
     884:	90 e0       	ldi	r25, 0x00	; 0
     886:	09 2e       	mov	r0, r25
     888:	00 0c       	add	r0, r0
     88a:	aa 0b       	sbc	r26, r26
     88c:	bb 0b       	sbc	r27, r27
     88e:	41 e0       	ldi	r20, 0x01	; 1
     890:	50 e0       	ldi	r21, 0x00	; 0
     892:	2a e0       	ldi	r18, 0x0A	; 10
     894:	30 e0       	ldi	r19, 0x00	; 0
     896:	84 1b       	sub	r24, r20
     898:	95 0b       	sbc	r25, r21
     89a:	28 17       	cp	r18, r24
     89c:	39 07       	cpc	r19, r25
     89e:	10 f4       	brcc	.+4      	; 0x8a4 <can_cmd+0xf4>
     8a0:	0c 94 57 0e 	jmp	0x1cae	; 0x1cae <__stack+0xbaf>
     8a4:	82 5c       	subi	r24, 0xC2	; 194
     8a6:	9f 4f       	sbci	r25, 0xFF	; 255
     8a8:	fc 01       	movw	r30, r24
     8aa:	0c 94 5c 28 	jmp	0x50b8	; 0x50b8 <__tablejump2__>
      {
        //------------      
        case CMD_TX:    
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
     8ae:	89 85       	ldd	r24, Y+9	; 0x09
     8b0:	9a 85       	ldd	r25, Y+10	; 0x0a
     8b2:	fc 01       	movw	r30, r24
     8b4:	83 85       	ldd	r24, Z+11	; 0x0b
     8b6:	88 23       	and	r24, r24
     8b8:	09 f4       	brne	.+2      	; 0x8bc <can_cmd+0x10c>
     8ba:	69 c0       	rjmp	.+210    	; 0x98e <can_cmd+0x1de>
     8bc:	83 ef       	ldi	r24, 0xF3	; 243
     8be:	90 e0       	ldi	r25, 0x00	; 0
     8c0:	29 85       	ldd	r18, Y+9	; 0x09
     8c2:	3a 85       	ldd	r19, Y+10	; 0x0a
     8c4:	2e 5f       	subi	r18, 0xFE	; 254
     8c6:	3f 4f       	sbci	r19, 0xFF	; 255
     8c8:	2d 5f       	subi	r18, 0xFD	; 253
     8ca:	3f 4f       	sbci	r19, 0xFF	; 255
     8cc:	f9 01       	movw	r30, r18
     8ce:	20 81       	ld	r18, Z
     8d0:	42 2f       	mov	r20, r18
     8d2:	44 0f       	add	r20, r20
     8d4:	44 0f       	add	r20, r20
     8d6:	44 0f       	add	r20, r20
     8d8:	29 85       	ldd	r18, Y+9	; 0x09
     8da:	3a 85       	ldd	r19, Y+10	; 0x0a
     8dc:	2e 5f       	subi	r18, 0xFE	; 254
     8de:	3f 4f       	sbci	r19, 0xFF	; 255
     8e0:	2e 5f       	subi	r18, 0xFE	; 254
     8e2:	3f 4f       	sbci	r19, 0xFF	; 255
     8e4:	f9 01       	movw	r30, r18
     8e6:	20 81       	ld	r18, Z
     8e8:	22 95       	swap	r18
     8ea:	26 95       	lsr	r18
     8ec:	27 70       	andi	r18, 0x07	; 7
     8ee:	24 0f       	add	r18, r20
     8f0:	fc 01       	movw	r30, r24
     8f2:	20 83       	st	Z, r18
     8f4:	82 ef       	ldi	r24, 0xF2	; 242
     8f6:	90 e0       	ldi	r25, 0x00	; 0
     8f8:	29 85       	ldd	r18, Y+9	; 0x09
     8fa:	3a 85       	ldd	r19, Y+10	; 0x0a
     8fc:	2e 5f       	subi	r18, 0xFE	; 254
     8fe:	3f 4f       	sbci	r19, 0xFF	; 255
     900:	2e 5f       	subi	r18, 0xFE	; 254
     902:	3f 4f       	sbci	r19, 0xFF	; 255
     904:	f9 01       	movw	r30, r18
     906:	20 81       	ld	r18, Z
     908:	42 2f       	mov	r20, r18
     90a:	44 0f       	add	r20, r20
     90c:	44 0f       	add	r20, r20
     90e:	44 0f       	add	r20, r20
     910:	29 85       	ldd	r18, Y+9	; 0x09
     912:	3a 85       	ldd	r19, Y+10	; 0x0a
     914:	2e 5f       	subi	r18, 0xFE	; 254
     916:	3f 4f       	sbci	r19, 0xFF	; 255
     918:	2f 5f       	subi	r18, 0xFF	; 255
     91a:	3f 4f       	sbci	r19, 0xFF	; 255
     91c:	f9 01       	movw	r30, r18
     91e:	20 81       	ld	r18, Z
     920:	22 95       	swap	r18
     922:	26 95       	lsr	r18
     924:	27 70       	andi	r18, 0x07	; 7
     926:	24 0f       	add	r18, r20
     928:	fc 01       	movw	r30, r24
     92a:	20 83       	st	Z, r18
     92c:	81 ef       	ldi	r24, 0xF1	; 241
     92e:	90 e0       	ldi	r25, 0x00	; 0
     930:	29 85       	ldd	r18, Y+9	; 0x09
     932:	3a 85       	ldd	r19, Y+10	; 0x0a
     934:	2e 5f       	subi	r18, 0xFE	; 254
     936:	3f 4f       	sbci	r19, 0xFF	; 255
     938:	2f 5f       	subi	r18, 0xFF	; 255
     93a:	3f 4f       	sbci	r19, 0xFF	; 255
     93c:	f9 01       	movw	r30, r18
     93e:	20 81       	ld	r18, Z
     940:	42 2f       	mov	r20, r18
     942:	44 0f       	add	r20, r20
     944:	44 0f       	add	r20, r20
     946:	44 0f       	add	r20, r20
     948:	29 85       	ldd	r18, Y+9	; 0x09
     94a:	3a 85       	ldd	r19, Y+10	; 0x0a
     94c:	2e 5f       	subi	r18, 0xFE	; 254
     94e:	3f 4f       	sbci	r19, 0xFF	; 255
     950:	f9 01       	movw	r30, r18
     952:	20 81       	ld	r18, Z
     954:	22 95       	swap	r18
     956:	26 95       	lsr	r18
     958:	27 70       	andi	r18, 0x07	; 7
     95a:	24 0f       	add	r18, r20
     95c:	fc 01       	movw	r30, r24
     95e:	20 83       	st	Z, r18
     960:	80 ef       	ldi	r24, 0xF0	; 240
     962:	90 e0       	ldi	r25, 0x00	; 0
     964:	29 85       	ldd	r18, Y+9	; 0x09
     966:	3a 85       	ldd	r19, Y+10	; 0x0a
     968:	2e 5f       	subi	r18, 0xFE	; 254
     96a:	3f 4f       	sbci	r19, 0xFF	; 255
     96c:	f9 01       	movw	r30, r18
     96e:	20 81       	ld	r18, Z
     970:	22 0f       	add	r18, r18
     972:	22 0f       	add	r18, r18
     974:	22 0f       	add	r18, r18
     976:	fc 01       	movw	r30, r24
     978:	20 83       	st	Z, r18
     97a:	8f ee       	ldi	r24, 0xEF	; 239
     97c:	90 e0       	ldi	r25, 0x00	; 0
     97e:	2f ee       	ldi	r18, 0xEF	; 239
     980:	30 e0       	ldi	r19, 0x00	; 0
     982:	f9 01       	movw	r30, r18
     984:	20 81       	ld	r18, Z
     986:	20 61       	ori	r18, 0x10	; 16
     988:	fc 01       	movw	r30, r24
     98a:	20 83       	st	Z, r18
     98c:	30 c0       	rjmp	.+96     	; 0x9ee <can_cmd+0x23e>
          else              { Can_set_std_id(cmd->id.std);}
     98e:	83 ef       	ldi	r24, 0xF3	; 243
     990:	90 e0       	ldi	r25, 0x00	; 0
     992:	29 85       	ldd	r18, Y+9	; 0x09
     994:	3a 85       	ldd	r19, Y+10	; 0x0a
     996:	2e 5f       	subi	r18, 0xFE	; 254
     998:	3f 4f       	sbci	r19, 0xFF	; 255
     99a:	2f 5f       	subi	r18, 0xFF	; 255
     99c:	3f 4f       	sbci	r19, 0xFF	; 255
     99e:	f9 01       	movw	r30, r18
     9a0:	20 81       	ld	r18, Z
     9a2:	42 2f       	mov	r20, r18
     9a4:	42 95       	swap	r20
     9a6:	44 0f       	add	r20, r20
     9a8:	40 7e       	andi	r20, 0xE0	; 224
     9aa:	29 85       	ldd	r18, Y+9	; 0x09
     9ac:	3a 85       	ldd	r19, Y+10	; 0x0a
     9ae:	2e 5f       	subi	r18, 0xFE	; 254
     9b0:	3f 4f       	sbci	r19, 0xFF	; 255
     9b2:	f9 01       	movw	r30, r18
     9b4:	20 81       	ld	r18, Z
     9b6:	26 95       	lsr	r18
     9b8:	26 95       	lsr	r18
     9ba:	26 95       	lsr	r18
     9bc:	24 0f       	add	r18, r20
     9be:	fc 01       	movw	r30, r24
     9c0:	20 83       	st	Z, r18
     9c2:	82 ef       	ldi	r24, 0xF2	; 242
     9c4:	90 e0       	ldi	r25, 0x00	; 0
     9c6:	29 85       	ldd	r18, Y+9	; 0x09
     9c8:	3a 85       	ldd	r19, Y+10	; 0x0a
     9ca:	2e 5f       	subi	r18, 0xFE	; 254
     9cc:	3f 4f       	sbci	r19, 0xFF	; 255
     9ce:	f9 01       	movw	r30, r18
     9d0:	20 81       	ld	r18, Z
     9d2:	22 95       	swap	r18
     9d4:	22 0f       	add	r18, r18
     9d6:	20 7e       	andi	r18, 0xE0	; 224
     9d8:	fc 01       	movw	r30, r24
     9da:	20 83       	st	Z, r18
     9dc:	8f ee       	ldi	r24, 0xEF	; 239
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	2f ee       	ldi	r18, 0xEF	; 239
     9e2:	30 e0       	ldi	r19, 0x00	; 0
     9e4:	f9 01       	movw	r30, r18
     9e6:	20 81       	ld	r18, Z
     9e8:	2f 7e       	andi	r18, 0xEF	; 239
     9ea:	fc 01       	movw	r30, r24
     9ec:	20 83       	st	Z, r18
          for (cpt=0;cpt<cmd->dlc;cpt++) CANMSG = *(cmd->pt_data + cpt);
     9ee:	19 82       	std	Y+1, r1	; 0x01
     9f0:	13 c0       	rjmp	.+38     	; 0xa18 <can_cmd+0x268>
     9f2:	8a ef       	ldi	r24, 0xFA	; 250
     9f4:	90 e0       	ldi	r25, 0x00	; 0
     9f6:	29 85       	ldd	r18, Y+9	; 0x09
     9f8:	3a 85       	ldd	r19, Y+10	; 0x0a
     9fa:	f9 01       	movw	r30, r18
     9fc:	47 81       	ldd	r20, Z+7	; 0x07
     9fe:	50 85       	ldd	r21, Z+8	; 0x08
     a00:	29 81       	ldd	r18, Y+1	; 0x01
     a02:	22 2f       	mov	r18, r18
     a04:	30 e0       	ldi	r19, 0x00	; 0
     a06:	24 0f       	add	r18, r20
     a08:	35 1f       	adc	r19, r21
     a0a:	f9 01       	movw	r30, r18
     a0c:	20 81       	ld	r18, Z
     a0e:	fc 01       	movw	r30, r24
     a10:	20 83       	st	Z, r18
     a12:	89 81       	ldd	r24, Y+1	; 0x01
     a14:	8f 5f       	subi	r24, 0xFF	; 255
     a16:	89 83       	std	Y+1, r24	; 0x01
     a18:	89 85       	ldd	r24, Y+9	; 0x09
     a1a:	9a 85       	ldd	r25, Y+10	; 0x0a
     a1c:	fc 01       	movw	r30, r24
     a1e:	96 81       	ldd	r25, Z+6	; 0x06
     a20:	89 81       	ldd	r24, Y+1	; 0x01
     a22:	89 17       	cp	r24, r25
     a24:	30 f3       	brcs	.-52     	; 0x9f2 <can_cmd+0x242>
          if (cmd->ctrl.rtr) Can_set_rtr(); 
     a26:	89 85       	ldd	r24, Y+9	; 0x09
     a28:	9a 85       	ldd	r25, Y+10	; 0x0a
     a2a:	fc 01       	movw	r30, r24
     a2c:	82 85       	ldd	r24, Z+10	; 0x0a
     a2e:	88 23       	and	r24, r24
     a30:	51 f0       	breq	.+20     	; 0xa46 <can_cmd+0x296>
     a32:	80 ef       	ldi	r24, 0xF0	; 240
     a34:	90 e0       	ldi	r25, 0x00	; 0
     a36:	20 ef       	ldi	r18, 0xF0	; 240
     a38:	30 e0       	ldi	r19, 0x00	; 0
     a3a:	f9 01       	movw	r30, r18
     a3c:	20 81       	ld	r18, Z
     a3e:	24 60       	ori	r18, 0x04	; 4
     a40:	fc 01       	movw	r30, r24
     a42:	20 83       	st	Z, r18
     a44:	09 c0       	rjmp	.+18     	; 0xa58 <can_cmd+0x2a8>
            else Can_clear_rtr();    
     a46:	80 ef       	ldi	r24, 0xF0	; 240
     a48:	90 e0       	ldi	r25, 0x00	; 0
     a4a:	20 ef       	ldi	r18, 0xF0	; 240
     a4c:	30 e0       	ldi	r19, 0x00	; 0
     a4e:	f9 01       	movw	r30, r18
     a50:	20 81       	ld	r18, Z
     a52:	2b 7f       	andi	r18, 0xFB	; 251
     a54:	fc 01       	movw	r30, r24
     a56:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
     a58:	8f ee       	ldi	r24, 0xEF	; 239
     a5a:	90 e0       	ldi	r25, 0x00	; 0
     a5c:	2f ee       	ldi	r18, 0xEF	; 239
     a5e:	30 e0       	ldi	r19, 0x00	; 0
     a60:	f9 01       	movw	r30, r18
     a62:	40 81       	ld	r20, Z
     a64:	29 85       	ldd	r18, Y+9	; 0x09
     a66:	3a 85       	ldd	r19, Y+10	; 0x0a
     a68:	f9 01       	movw	r30, r18
     a6a:	26 81       	ldd	r18, Z+6	; 0x06
     a6c:	24 2b       	or	r18, r20
     a6e:	fc 01       	movw	r30, r24
     a70:	20 83       	st	Z, r18
          Can_config_tx();
     a72:	8f ee       	ldi	r24, 0xEF	; 239
     a74:	90 e0       	ldi	r25, 0x00	; 0
     a76:	2f ee       	ldi	r18, 0xEF	; 239
     a78:	30 e0       	ldi	r19, 0x00	; 0
     a7a:	f9 01       	movw	r30, r18
     a7c:	20 81       	ld	r18, Z
     a7e:	2f 73       	andi	r18, 0x3F	; 63
     a80:	fc 01       	movw	r30, r24
     a82:	20 83       	st	Z, r18
     a84:	8f ee       	ldi	r24, 0xEF	; 239
     a86:	90 e0       	ldi	r25, 0x00	; 0
     a88:	2f ee       	ldi	r18, 0xEF	; 239
     a8a:	30 e0       	ldi	r19, 0x00	; 0
     a8c:	f9 01       	movw	r30, r18
     a8e:	20 81       	ld	r18, Z
     a90:	20 64       	ori	r18, 0x40	; 64
     a92:	fc 01       	movw	r30, r24
     a94:	20 83       	st	Z, r18
          break;
     a96:	0c 94 5c 0e 	jmp	0x1cb8	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_TX_DATA:    
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
     a9a:	89 85       	ldd	r24, Y+9	; 0x09
     a9c:	9a 85       	ldd	r25, Y+10	; 0x0a
     a9e:	fc 01       	movw	r30, r24
     aa0:	83 85       	ldd	r24, Z+11	; 0x0b
     aa2:	88 23       	and	r24, r24
     aa4:	09 f4       	brne	.+2      	; 0xaa8 <can_cmd+0x2f8>
     aa6:	69 c0       	rjmp	.+210    	; 0xb7a <can_cmd+0x3ca>
     aa8:	83 ef       	ldi	r24, 0xF3	; 243
     aaa:	90 e0       	ldi	r25, 0x00	; 0
     aac:	29 85       	ldd	r18, Y+9	; 0x09
     aae:	3a 85       	ldd	r19, Y+10	; 0x0a
     ab0:	2e 5f       	subi	r18, 0xFE	; 254
     ab2:	3f 4f       	sbci	r19, 0xFF	; 255
     ab4:	2d 5f       	subi	r18, 0xFD	; 253
     ab6:	3f 4f       	sbci	r19, 0xFF	; 255
     ab8:	f9 01       	movw	r30, r18
     aba:	20 81       	ld	r18, Z
     abc:	42 2f       	mov	r20, r18
     abe:	44 0f       	add	r20, r20
     ac0:	44 0f       	add	r20, r20
     ac2:	44 0f       	add	r20, r20
     ac4:	29 85       	ldd	r18, Y+9	; 0x09
     ac6:	3a 85       	ldd	r19, Y+10	; 0x0a
     ac8:	2e 5f       	subi	r18, 0xFE	; 254
     aca:	3f 4f       	sbci	r19, 0xFF	; 255
     acc:	2e 5f       	subi	r18, 0xFE	; 254
     ace:	3f 4f       	sbci	r19, 0xFF	; 255
     ad0:	f9 01       	movw	r30, r18
     ad2:	20 81       	ld	r18, Z
     ad4:	22 95       	swap	r18
     ad6:	26 95       	lsr	r18
     ad8:	27 70       	andi	r18, 0x07	; 7
     ada:	24 0f       	add	r18, r20
     adc:	fc 01       	movw	r30, r24
     ade:	20 83       	st	Z, r18
     ae0:	82 ef       	ldi	r24, 0xF2	; 242
     ae2:	90 e0       	ldi	r25, 0x00	; 0
     ae4:	29 85       	ldd	r18, Y+9	; 0x09
     ae6:	3a 85       	ldd	r19, Y+10	; 0x0a
     ae8:	2e 5f       	subi	r18, 0xFE	; 254
     aea:	3f 4f       	sbci	r19, 0xFF	; 255
     aec:	2e 5f       	subi	r18, 0xFE	; 254
     aee:	3f 4f       	sbci	r19, 0xFF	; 255
     af0:	f9 01       	movw	r30, r18
     af2:	20 81       	ld	r18, Z
     af4:	42 2f       	mov	r20, r18
     af6:	44 0f       	add	r20, r20
     af8:	44 0f       	add	r20, r20
     afa:	44 0f       	add	r20, r20
     afc:	29 85       	ldd	r18, Y+9	; 0x09
     afe:	3a 85       	ldd	r19, Y+10	; 0x0a
     b00:	2e 5f       	subi	r18, 0xFE	; 254
     b02:	3f 4f       	sbci	r19, 0xFF	; 255
     b04:	2f 5f       	subi	r18, 0xFF	; 255
     b06:	3f 4f       	sbci	r19, 0xFF	; 255
     b08:	f9 01       	movw	r30, r18
     b0a:	20 81       	ld	r18, Z
     b0c:	22 95       	swap	r18
     b0e:	26 95       	lsr	r18
     b10:	27 70       	andi	r18, 0x07	; 7
     b12:	24 0f       	add	r18, r20
     b14:	fc 01       	movw	r30, r24
     b16:	20 83       	st	Z, r18
     b18:	81 ef       	ldi	r24, 0xF1	; 241
     b1a:	90 e0       	ldi	r25, 0x00	; 0
     b1c:	29 85       	ldd	r18, Y+9	; 0x09
     b1e:	3a 85       	ldd	r19, Y+10	; 0x0a
     b20:	2e 5f       	subi	r18, 0xFE	; 254
     b22:	3f 4f       	sbci	r19, 0xFF	; 255
     b24:	2f 5f       	subi	r18, 0xFF	; 255
     b26:	3f 4f       	sbci	r19, 0xFF	; 255
     b28:	f9 01       	movw	r30, r18
     b2a:	20 81       	ld	r18, Z
     b2c:	42 2f       	mov	r20, r18
     b2e:	44 0f       	add	r20, r20
     b30:	44 0f       	add	r20, r20
     b32:	44 0f       	add	r20, r20
     b34:	29 85       	ldd	r18, Y+9	; 0x09
     b36:	3a 85       	ldd	r19, Y+10	; 0x0a
     b38:	2e 5f       	subi	r18, 0xFE	; 254
     b3a:	3f 4f       	sbci	r19, 0xFF	; 255
     b3c:	f9 01       	movw	r30, r18
     b3e:	20 81       	ld	r18, Z
     b40:	22 95       	swap	r18
     b42:	26 95       	lsr	r18
     b44:	27 70       	andi	r18, 0x07	; 7
     b46:	24 0f       	add	r18, r20
     b48:	fc 01       	movw	r30, r24
     b4a:	20 83       	st	Z, r18
     b4c:	80 ef       	ldi	r24, 0xF0	; 240
     b4e:	90 e0       	ldi	r25, 0x00	; 0
     b50:	29 85       	ldd	r18, Y+9	; 0x09
     b52:	3a 85       	ldd	r19, Y+10	; 0x0a
     b54:	2e 5f       	subi	r18, 0xFE	; 254
     b56:	3f 4f       	sbci	r19, 0xFF	; 255
     b58:	f9 01       	movw	r30, r18
     b5a:	20 81       	ld	r18, Z
     b5c:	22 0f       	add	r18, r18
     b5e:	22 0f       	add	r18, r18
     b60:	22 0f       	add	r18, r18
     b62:	fc 01       	movw	r30, r24
     b64:	20 83       	st	Z, r18
     b66:	8f ee       	ldi	r24, 0xEF	; 239
     b68:	90 e0       	ldi	r25, 0x00	; 0
     b6a:	2f ee       	ldi	r18, 0xEF	; 239
     b6c:	30 e0       	ldi	r19, 0x00	; 0
     b6e:	f9 01       	movw	r30, r18
     b70:	20 81       	ld	r18, Z
     b72:	20 61       	ori	r18, 0x10	; 16
     b74:	fc 01       	movw	r30, r24
     b76:	20 83       	st	Z, r18
     b78:	30 c0       	rjmp	.+96     	; 0xbda <can_cmd+0x42a>
          else              { Can_set_std_id(cmd->id.std);}
     b7a:	83 ef       	ldi	r24, 0xF3	; 243
     b7c:	90 e0       	ldi	r25, 0x00	; 0
     b7e:	29 85       	ldd	r18, Y+9	; 0x09
     b80:	3a 85       	ldd	r19, Y+10	; 0x0a
     b82:	2e 5f       	subi	r18, 0xFE	; 254
     b84:	3f 4f       	sbci	r19, 0xFF	; 255
     b86:	2f 5f       	subi	r18, 0xFF	; 255
     b88:	3f 4f       	sbci	r19, 0xFF	; 255
     b8a:	f9 01       	movw	r30, r18
     b8c:	20 81       	ld	r18, Z
     b8e:	42 2f       	mov	r20, r18
     b90:	42 95       	swap	r20
     b92:	44 0f       	add	r20, r20
     b94:	40 7e       	andi	r20, 0xE0	; 224
     b96:	29 85       	ldd	r18, Y+9	; 0x09
     b98:	3a 85       	ldd	r19, Y+10	; 0x0a
     b9a:	2e 5f       	subi	r18, 0xFE	; 254
     b9c:	3f 4f       	sbci	r19, 0xFF	; 255
     b9e:	f9 01       	movw	r30, r18
     ba0:	20 81       	ld	r18, Z
     ba2:	26 95       	lsr	r18
     ba4:	26 95       	lsr	r18
     ba6:	26 95       	lsr	r18
     ba8:	24 0f       	add	r18, r20
     baa:	fc 01       	movw	r30, r24
     bac:	20 83       	st	Z, r18
     bae:	82 ef       	ldi	r24, 0xF2	; 242
     bb0:	90 e0       	ldi	r25, 0x00	; 0
     bb2:	29 85       	ldd	r18, Y+9	; 0x09
     bb4:	3a 85       	ldd	r19, Y+10	; 0x0a
     bb6:	2e 5f       	subi	r18, 0xFE	; 254
     bb8:	3f 4f       	sbci	r19, 0xFF	; 255
     bba:	f9 01       	movw	r30, r18
     bbc:	20 81       	ld	r18, Z
     bbe:	22 95       	swap	r18
     bc0:	22 0f       	add	r18, r18
     bc2:	20 7e       	andi	r18, 0xE0	; 224
     bc4:	fc 01       	movw	r30, r24
     bc6:	20 83       	st	Z, r18
     bc8:	8f ee       	ldi	r24, 0xEF	; 239
     bca:	90 e0       	ldi	r25, 0x00	; 0
     bcc:	2f ee       	ldi	r18, 0xEF	; 239
     bce:	30 e0       	ldi	r19, 0x00	; 0
     bd0:	f9 01       	movw	r30, r18
     bd2:	20 81       	ld	r18, Z
     bd4:	2f 7e       	andi	r18, 0xEF	; 239
     bd6:	fc 01       	movw	r30, r24
     bd8:	20 83       	st	Z, r18
          for (cpt=0;cpt<cmd->dlc;cpt++) CANMSG = *(cmd->pt_data + cpt);
     bda:	19 82       	std	Y+1, r1	; 0x01
     bdc:	13 c0       	rjmp	.+38     	; 0xc04 <can_cmd+0x454>
     bde:	8a ef       	ldi	r24, 0xFA	; 250
     be0:	90 e0       	ldi	r25, 0x00	; 0
     be2:	29 85       	ldd	r18, Y+9	; 0x09
     be4:	3a 85       	ldd	r19, Y+10	; 0x0a
     be6:	f9 01       	movw	r30, r18
     be8:	47 81       	ldd	r20, Z+7	; 0x07
     bea:	50 85       	ldd	r21, Z+8	; 0x08
     bec:	29 81       	ldd	r18, Y+1	; 0x01
     bee:	22 2f       	mov	r18, r18
     bf0:	30 e0       	ldi	r19, 0x00	; 0
     bf2:	24 0f       	add	r18, r20
     bf4:	35 1f       	adc	r19, r21
     bf6:	f9 01       	movw	r30, r18
     bf8:	20 81       	ld	r18, Z
     bfa:	fc 01       	movw	r30, r24
     bfc:	20 83       	st	Z, r18
     bfe:	89 81       	ldd	r24, Y+1	; 0x01
     c00:	8f 5f       	subi	r24, 0xFF	; 255
     c02:	89 83       	std	Y+1, r24	; 0x01
     c04:	89 85       	ldd	r24, Y+9	; 0x09
     c06:	9a 85       	ldd	r25, Y+10	; 0x0a
     c08:	fc 01       	movw	r30, r24
     c0a:	96 81       	ldd	r25, Z+6	; 0x06
     c0c:	89 81       	ldd	r24, Y+1	; 0x01
     c0e:	89 17       	cp	r24, r25
     c10:	30 f3       	brcs	.-52     	; 0xbde <can_cmd+0x42e>
          cmd->ctrl.rtr=0; Can_clear_rtr();
     c12:	89 85       	ldd	r24, Y+9	; 0x09
     c14:	9a 85       	ldd	r25, Y+10	; 0x0a
     c16:	fc 01       	movw	r30, r24
     c18:	12 86       	std	Z+10, r1	; 0x0a
     c1a:	80 ef       	ldi	r24, 0xF0	; 240
     c1c:	90 e0       	ldi	r25, 0x00	; 0
     c1e:	20 ef       	ldi	r18, 0xF0	; 240
     c20:	30 e0       	ldi	r19, 0x00	; 0
     c22:	f9 01       	movw	r30, r18
     c24:	20 81       	ld	r18, Z
     c26:	2b 7f       	andi	r18, 0xFB	; 251
     c28:	fc 01       	movw	r30, r24
     c2a:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
     c2c:	8f ee       	ldi	r24, 0xEF	; 239
     c2e:	90 e0       	ldi	r25, 0x00	; 0
     c30:	2f ee       	ldi	r18, 0xEF	; 239
     c32:	30 e0       	ldi	r19, 0x00	; 0
     c34:	f9 01       	movw	r30, r18
     c36:	40 81       	ld	r20, Z
     c38:	29 85       	ldd	r18, Y+9	; 0x09
     c3a:	3a 85       	ldd	r19, Y+10	; 0x0a
     c3c:	f9 01       	movw	r30, r18
     c3e:	26 81       	ldd	r18, Z+6	; 0x06
     c40:	24 2b       	or	r18, r20
     c42:	fc 01       	movw	r30, r24
     c44:	20 83       	st	Z, r18
          Can_config_tx();
     c46:	8f ee       	ldi	r24, 0xEF	; 239
     c48:	90 e0       	ldi	r25, 0x00	; 0
     c4a:	2f ee       	ldi	r18, 0xEF	; 239
     c4c:	30 e0       	ldi	r19, 0x00	; 0
     c4e:	f9 01       	movw	r30, r18
     c50:	20 81       	ld	r18, Z
     c52:	2f 73       	andi	r18, 0x3F	; 63
     c54:	fc 01       	movw	r30, r24
     c56:	20 83       	st	Z, r18
     c58:	8f ee       	ldi	r24, 0xEF	; 239
     c5a:	90 e0       	ldi	r25, 0x00	; 0
     c5c:	2f ee       	ldi	r18, 0xEF	; 239
     c5e:	30 e0       	ldi	r19, 0x00	; 0
     c60:	f9 01       	movw	r30, r18
     c62:	20 81       	ld	r18, Z
     c64:	20 64       	ori	r18, 0x40	; 64
     c66:	fc 01       	movw	r30, r24
     c68:	20 83       	st	Z, r18
          break;
     c6a:	0c 94 5c 0e 	jmp	0x1cb8	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_TX_REMOTE:       
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
     c6e:	89 85       	ldd	r24, Y+9	; 0x09
     c70:	9a 85       	ldd	r25, Y+10	; 0x0a
     c72:	fc 01       	movw	r30, r24
     c74:	83 85       	ldd	r24, Z+11	; 0x0b
     c76:	88 23       	and	r24, r24
     c78:	09 f4       	brne	.+2      	; 0xc7c <can_cmd+0x4cc>
     c7a:	69 c0       	rjmp	.+210    	; 0xd4e <can_cmd+0x59e>
     c7c:	83 ef       	ldi	r24, 0xF3	; 243
     c7e:	90 e0       	ldi	r25, 0x00	; 0
     c80:	29 85       	ldd	r18, Y+9	; 0x09
     c82:	3a 85       	ldd	r19, Y+10	; 0x0a
     c84:	2e 5f       	subi	r18, 0xFE	; 254
     c86:	3f 4f       	sbci	r19, 0xFF	; 255
     c88:	2d 5f       	subi	r18, 0xFD	; 253
     c8a:	3f 4f       	sbci	r19, 0xFF	; 255
     c8c:	f9 01       	movw	r30, r18
     c8e:	20 81       	ld	r18, Z
     c90:	42 2f       	mov	r20, r18
     c92:	44 0f       	add	r20, r20
     c94:	44 0f       	add	r20, r20
     c96:	44 0f       	add	r20, r20
     c98:	29 85       	ldd	r18, Y+9	; 0x09
     c9a:	3a 85       	ldd	r19, Y+10	; 0x0a
     c9c:	2e 5f       	subi	r18, 0xFE	; 254
     c9e:	3f 4f       	sbci	r19, 0xFF	; 255
     ca0:	2e 5f       	subi	r18, 0xFE	; 254
     ca2:	3f 4f       	sbci	r19, 0xFF	; 255
     ca4:	f9 01       	movw	r30, r18
     ca6:	20 81       	ld	r18, Z
     ca8:	22 95       	swap	r18
     caa:	26 95       	lsr	r18
     cac:	27 70       	andi	r18, 0x07	; 7
     cae:	24 0f       	add	r18, r20
     cb0:	fc 01       	movw	r30, r24
     cb2:	20 83       	st	Z, r18
     cb4:	82 ef       	ldi	r24, 0xF2	; 242
     cb6:	90 e0       	ldi	r25, 0x00	; 0
     cb8:	29 85       	ldd	r18, Y+9	; 0x09
     cba:	3a 85       	ldd	r19, Y+10	; 0x0a
     cbc:	2e 5f       	subi	r18, 0xFE	; 254
     cbe:	3f 4f       	sbci	r19, 0xFF	; 255
     cc0:	2e 5f       	subi	r18, 0xFE	; 254
     cc2:	3f 4f       	sbci	r19, 0xFF	; 255
     cc4:	f9 01       	movw	r30, r18
     cc6:	20 81       	ld	r18, Z
     cc8:	42 2f       	mov	r20, r18
     cca:	44 0f       	add	r20, r20
     ccc:	44 0f       	add	r20, r20
     cce:	44 0f       	add	r20, r20
     cd0:	29 85       	ldd	r18, Y+9	; 0x09
     cd2:	3a 85       	ldd	r19, Y+10	; 0x0a
     cd4:	2e 5f       	subi	r18, 0xFE	; 254
     cd6:	3f 4f       	sbci	r19, 0xFF	; 255
     cd8:	2f 5f       	subi	r18, 0xFF	; 255
     cda:	3f 4f       	sbci	r19, 0xFF	; 255
     cdc:	f9 01       	movw	r30, r18
     cde:	20 81       	ld	r18, Z
     ce0:	22 95       	swap	r18
     ce2:	26 95       	lsr	r18
     ce4:	27 70       	andi	r18, 0x07	; 7
     ce6:	24 0f       	add	r18, r20
     ce8:	fc 01       	movw	r30, r24
     cea:	20 83       	st	Z, r18
     cec:	81 ef       	ldi	r24, 0xF1	; 241
     cee:	90 e0       	ldi	r25, 0x00	; 0
     cf0:	29 85       	ldd	r18, Y+9	; 0x09
     cf2:	3a 85       	ldd	r19, Y+10	; 0x0a
     cf4:	2e 5f       	subi	r18, 0xFE	; 254
     cf6:	3f 4f       	sbci	r19, 0xFF	; 255
     cf8:	2f 5f       	subi	r18, 0xFF	; 255
     cfa:	3f 4f       	sbci	r19, 0xFF	; 255
     cfc:	f9 01       	movw	r30, r18
     cfe:	20 81       	ld	r18, Z
     d00:	42 2f       	mov	r20, r18
     d02:	44 0f       	add	r20, r20
     d04:	44 0f       	add	r20, r20
     d06:	44 0f       	add	r20, r20
     d08:	29 85       	ldd	r18, Y+9	; 0x09
     d0a:	3a 85       	ldd	r19, Y+10	; 0x0a
     d0c:	2e 5f       	subi	r18, 0xFE	; 254
     d0e:	3f 4f       	sbci	r19, 0xFF	; 255
     d10:	f9 01       	movw	r30, r18
     d12:	20 81       	ld	r18, Z
     d14:	22 95       	swap	r18
     d16:	26 95       	lsr	r18
     d18:	27 70       	andi	r18, 0x07	; 7
     d1a:	24 0f       	add	r18, r20
     d1c:	fc 01       	movw	r30, r24
     d1e:	20 83       	st	Z, r18
     d20:	80 ef       	ldi	r24, 0xF0	; 240
     d22:	90 e0       	ldi	r25, 0x00	; 0
     d24:	29 85       	ldd	r18, Y+9	; 0x09
     d26:	3a 85       	ldd	r19, Y+10	; 0x0a
     d28:	2e 5f       	subi	r18, 0xFE	; 254
     d2a:	3f 4f       	sbci	r19, 0xFF	; 255
     d2c:	f9 01       	movw	r30, r18
     d2e:	20 81       	ld	r18, Z
     d30:	22 0f       	add	r18, r18
     d32:	22 0f       	add	r18, r18
     d34:	22 0f       	add	r18, r18
     d36:	fc 01       	movw	r30, r24
     d38:	20 83       	st	Z, r18
     d3a:	8f ee       	ldi	r24, 0xEF	; 239
     d3c:	90 e0       	ldi	r25, 0x00	; 0
     d3e:	2f ee       	ldi	r18, 0xEF	; 239
     d40:	30 e0       	ldi	r19, 0x00	; 0
     d42:	f9 01       	movw	r30, r18
     d44:	20 81       	ld	r18, Z
     d46:	20 61       	ori	r18, 0x10	; 16
     d48:	fc 01       	movw	r30, r24
     d4a:	20 83       	st	Z, r18
     d4c:	30 c0       	rjmp	.+96     	; 0xdae <can_cmd+0x5fe>
          else              { Can_set_std_id(cmd->id.std);}
     d4e:	83 ef       	ldi	r24, 0xF3	; 243
     d50:	90 e0       	ldi	r25, 0x00	; 0
     d52:	29 85       	ldd	r18, Y+9	; 0x09
     d54:	3a 85       	ldd	r19, Y+10	; 0x0a
     d56:	2e 5f       	subi	r18, 0xFE	; 254
     d58:	3f 4f       	sbci	r19, 0xFF	; 255
     d5a:	2f 5f       	subi	r18, 0xFF	; 255
     d5c:	3f 4f       	sbci	r19, 0xFF	; 255
     d5e:	f9 01       	movw	r30, r18
     d60:	20 81       	ld	r18, Z
     d62:	42 2f       	mov	r20, r18
     d64:	42 95       	swap	r20
     d66:	44 0f       	add	r20, r20
     d68:	40 7e       	andi	r20, 0xE0	; 224
     d6a:	29 85       	ldd	r18, Y+9	; 0x09
     d6c:	3a 85       	ldd	r19, Y+10	; 0x0a
     d6e:	2e 5f       	subi	r18, 0xFE	; 254
     d70:	3f 4f       	sbci	r19, 0xFF	; 255
     d72:	f9 01       	movw	r30, r18
     d74:	20 81       	ld	r18, Z
     d76:	26 95       	lsr	r18
     d78:	26 95       	lsr	r18
     d7a:	26 95       	lsr	r18
     d7c:	24 0f       	add	r18, r20
     d7e:	fc 01       	movw	r30, r24
     d80:	20 83       	st	Z, r18
     d82:	82 ef       	ldi	r24, 0xF2	; 242
     d84:	90 e0       	ldi	r25, 0x00	; 0
     d86:	29 85       	ldd	r18, Y+9	; 0x09
     d88:	3a 85       	ldd	r19, Y+10	; 0x0a
     d8a:	2e 5f       	subi	r18, 0xFE	; 254
     d8c:	3f 4f       	sbci	r19, 0xFF	; 255
     d8e:	f9 01       	movw	r30, r18
     d90:	20 81       	ld	r18, Z
     d92:	22 95       	swap	r18
     d94:	22 0f       	add	r18, r18
     d96:	20 7e       	andi	r18, 0xE0	; 224
     d98:	fc 01       	movw	r30, r24
     d9a:	20 83       	st	Z, r18
     d9c:	8f ee       	ldi	r24, 0xEF	; 239
     d9e:	90 e0       	ldi	r25, 0x00	; 0
     da0:	2f ee       	ldi	r18, 0xEF	; 239
     da2:	30 e0       	ldi	r19, 0x00	; 0
     da4:	f9 01       	movw	r30, r18
     da6:	20 81       	ld	r18, Z
     da8:	2f 7e       	andi	r18, 0xEF	; 239
     daa:	fc 01       	movw	r30, r24
     dac:	20 83       	st	Z, r18
          cmd->ctrl.rtr=1; Can_set_rtr();
     dae:	89 85       	ldd	r24, Y+9	; 0x09
     db0:	9a 85       	ldd	r25, Y+10	; 0x0a
     db2:	21 e0       	ldi	r18, 0x01	; 1
     db4:	fc 01       	movw	r30, r24
     db6:	22 87       	std	Z+10, r18	; 0x0a
     db8:	80 ef       	ldi	r24, 0xF0	; 240
     dba:	90 e0       	ldi	r25, 0x00	; 0
     dbc:	20 ef       	ldi	r18, 0xF0	; 240
     dbe:	30 e0       	ldi	r19, 0x00	; 0
     dc0:	f9 01       	movw	r30, r18
     dc2:	20 81       	ld	r18, Z
     dc4:	24 60       	ori	r18, 0x04	; 4
     dc6:	fc 01       	movw	r30, r24
     dc8:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
     dca:	8f ee       	ldi	r24, 0xEF	; 239
     dcc:	90 e0       	ldi	r25, 0x00	; 0
     dce:	2f ee       	ldi	r18, 0xEF	; 239
     dd0:	30 e0       	ldi	r19, 0x00	; 0
     dd2:	f9 01       	movw	r30, r18
     dd4:	40 81       	ld	r20, Z
     dd6:	29 85       	ldd	r18, Y+9	; 0x09
     dd8:	3a 85       	ldd	r19, Y+10	; 0x0a
     dda:	f9 01       	movw	r30, r18
     ddc:	26 81       	ldd	r18, Z+6	; 0x06
     dde:	24 2b       	or	r18, r20
     de0:	fc 01       	movw	r30, r24
     de2:	20 83       	st	Z, r18
          Can_config_tx();
     de4:	8f ee       	ldi	r24, 0xEF	; 239
     de6:	90 e0       	ldi	r25, 0x00	; 0
     de8:	2f ee       	ldi	r18, 0xEF	; 239
     dea:	30 e0       	ldi	r19, 0x00	; 0
     dec:	f9 01       	movw	r30, r18
     dee:	20 81       	ld	r18, Z
     df0:	2f 73       	andi	r18, 0x3F	; 63
     df2:	fc 01       	movw	r30, r24
     df4:	20 83       	st	Z, r18
     df6:	8f ee       	ldi	r24, 0xEF	; 239
     df8:	90 e0       	ldi	r25, 0x00	; 0
     dfa:	2f ee       	ldi	r18, 0xEF	; 239
     dfc:	30 e0       	ldi	r19, 0x00	; 0
     dfe:	f9 01       	movw	r30, r18
     e00:	20 81       	ld	r18, Z
     e02:	20 64       	ori	r18, 0x40	; 64
     e04:	fc 01       	movw	r30, r24
     e06:	20 83       	st	Z, r18
          break;
     e08:	57 c7       	rjmp	.+3758   	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_RX:
          u32_temp=0; Can_set_ext_msk(u32_temp);
     e0a:	1d 82       	std	Y+5, r1	; 0x05
     e0c:	1e 82       	std	Y+6, r1	; 0x06
     e0e:	1f 82       	std	Y+7, r1	; 0x07
     e10:	18 86       	std	Y+8, r1	; 0x08
     e12:	27 ef       	ldi	r18, 0xF7	; 247
     e14:	30 e0       	ldi	r19, 0x00	; 0
     e16:	ce 01       	movw	r24, r28
     e18:	05 96       	adiw	r24, 0x05	; 5
     e1a:	03 96       	adiw	r24, 0x03	; 3
     e1c:	fc 01       	movw	r30, r24
     e1e:	80 81       	ld	r24, Z
     e20:	48 2f       	mov	r20, r24
     e22:	44 0f       	add	r20, r20
     e24:	44 0f       	add	r20, r20
     e26:	44 0f       	add	r20, r20
     e28:	ce 01       	movw	r24, r28
     e2a:	05 96       	adiw	r24, 0x05	; 5
     e2c:	02 96       	adiw	r24, 0x02	; 2
     e2e:	fc 01       	movw	r30, r24
     e30:	80 81       	ld	r24, Z
     e32:	82 95       	swap	r24
     e34:	86 95       	lsr	r24
     e36:	87 70       	andi	r24, 0x07	; 7
     e38:	84 0f       	add	r24, r20
     e3a:	f9 01       	movw	r30, r18
     e3c:	80 83       	st	Z, r24
     e3e:	26 ef       	ldi	r18, 0xF6	; 246
     e40:	30 e0       	ldi	r19, 0x00	; 0
     e42:	ce 01       	movw	r24, r28
     e44:	05 96       	adiw	r24, 0x05	; 5
     e46:	02 96       	adiw	r24, 0x02	; 2
     e48:	fc 01       	movw	r30, r24
     e4a:	80 81       	ld	r24, Z
     e4c:	48 2f       	mov	r20, r24
     e4e:	44 0f       	add	r20, r20
     e50:	44 0f       	add	r20, r20
     e52:	44 0f       	add	r20, r20
     e54:	ce 01       	movw	r24, r28
     e56:	05 96       	adiw	r24, 0x05	; 5
     e58:	01 96       	adiw	r24, 0x01	; 1
     e5a:	fc 01       	movw	r30, r24
     e5c:	80 81       	ld	r24, Z
     e5e:	82 95       	swap	r24
     e60:	86 95       	lsr	r24
     e62:	87 70       	andi	r24, 0x07	; 7
     e64:	84 0f       	add	r24, r20
     e66:	f9 01       	movw	r30, r18
     e68:	80 83       	st	Z, r24
     e6a:	25 ef       	ldi	r18, 0xF5	; 245
     e6c:	30 e0       	ldi	r19, 0x00	; 0
     e6e:	ce 01       	movw	r24, r28
     e70:	05 96       	adiw	r24, 0x05	; 5
     e72:	01 96       	adiw	r24, 0x01	; 1
     e74:	fc 01       	movw	r30, r24
     e76:	80 81       	ld	r24, Z
     e78:	48 2f       	mov	r20, r24
     e7a:	44 0f       	add	r20, r20
     e7c:	44 0f       	add	r20, r20
     e7e:	44 0f       	add	r20, r20
     e80:	ce 01       	movw	r24, r28
     e82:	05 96       	adiw	r24, 0x05	; 5
     e84:	fc 01       	movw	r30, r24
     e86:	80 81       	ld	r24, Z
     e88:	82 95       	swap	r24
     e8a:	86 95       	lsr	r24
     e8c:	87 70       	andi	r24, 0x07	; 7
     e8e:	84 0f       	add	r24, r20
     e90:	f9 01       	movw	r30, r18
     e92:	80 83       	st	Z, r24
     e94:	84 ef       	ldi	r24, 0xF4	; 244
     e96:	90 e0       	ldi	r25, 0x00	; 0
     e98:	9e 01       	movw	r18, r28
     e9a:	2b 5f       	subi	r18, 0xFB	; 251
     e9c:	3f 4f       	sbci	r19, 0xFF	; 255
     e9e:	f9 01       	movw	r30, r18
     ea0:	20 81       	ld	r18, Z
     ea2:	22 0f       	add	r18, r18
     ea4:	22 0f       	add	r18, r18
     ea6:	22 0f       	add	r18, r18
     ea8:	fc 01       	movw	r30, r24
     eaa:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
     eac:	8f ee       	ldi	r24, 0xEF	; 239
     eae:	90 e0       	ldi	r25, 0x00	; 0
     eb0:	2f ee       	ldi	r18, 0xEF	; 239
     eb2:	30 e0       	ldi	r19, 0x00	; 0
     eb4:	f9 01       	movw	r30, r18
     eb6:	40 81       	ld	r20, Z
     eb8:	29 85       	ldd	r18, Y+9	; 0x09
     eba:	3a 85       	ldd	r19, Y+10	; 0x0a
     ebc:	f9 01       	movw	r30, r18
     ebe:	26 81       	ldd	r18, Z+6	; 0x06
     ec0:	24 2b       	or	r18, r20
     ec2:	fc 01       	movw	r30, r24
     ec4:	20 83       	st	Z, r18
          Can_clear_rtrmsk();
     ec6:	84 ef       	ldi	r24, 0xF4	; 244
     ec8:	90 e0       	ldi	r25, 0x00	; 0
     eca:	24 ef       	ldi	r18, 0xF4	; 244
     ecc:	30 e0       	ldi	r19, 0x00	; 0
     ece:	f9 01       	movw	r30, r18
     ed0:	20 81       	ld	r18, Z
     ed2:	2b 7f       	andi	r18, 0xFB	; 251
     ed4:	fc 01       	movw	r30, r24
     ed6:	20 83       	st	Z, r18
          Can_clear_idemsk();
     ed8:	84 ef       	ldi	r24, 0xF4	; 244
     eda:	90 e0       	ldi	r25, 0x00	; 0
     edc:	24 ef       	ldi	r18, 0xF4	; 244
     ede:	30 e0       	ldi	r19, 0x00	; 0
     ee0:	f9 01       	movw	r30, r18
     ee2:	20 81       	ld	r18, Z
     ee4:	2e 7f       	andi	r18, 0xFE	; 254
     ee6:	fc 01       	movw	r30, r24
     ee8:	20 83       	st	Z, r18
          Can_config_rx();       
     eea:	8f ee       	ldi	r24, 0xEF	; 239
     eec:	90 e0       	ldi	r25, 0x00	; 0
     eee:	2f ee       	ldi	r18, 0xEF	; 239
     ef0:	30 e0       	ldi	r19, 0x00	; 0
     ef2:	f9 01       	movw	r30, r18
     ef4:	20 81       	ld	r18, Z
     ef6:	2f 73       	andi	r18, 0x3F	; 63
     ef8:	fc 01       	movw	r30, r24
     efa:	20 83       	st	Z, r18
     efc:	8f ee       	ldi	r24, 0xEF	; 239
     efe:	90 e0       	ldi	r25, 0x00	; 0
     f00:	2f ee       	ldi	r18, 0xEF	; 239
     f02:	30 e0       	ldi	r19, 0x00	; 0
     f04:	f9 01       	movw	r30, r18
     f06:	20 81       	ld	r18, Z
     f08:	20 68       	ori	r18, 0x80	; 128
     f0a:	fc 01       	movw	r30, r24
     f0c:	20 83       	st	Z, r18
          break;
     f0e:	d4 c6       	rjmp	.+3496   	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_RX_DATA:
          u32_temp=0; Can_set_ext_msk(u32_temp);
     f10:	1d 82       	std	Y+5, r1	; 0x05
     f12:	1e 82       	std	Y+6, r1	; 0x06
     f14:	1f 82       	std	Y+7, r1	; 0x07
     f16:	18 86       	std	Y+8, r1	; 0x08
     f18:	27 ef       	ldi	r18, 0xF7	; 247
     f1a:	30 e0       	ldi	r19, 0x00	; 0
     f1c:	ce 01       	movw	r24, r28
     f1e:	05 96       	adiw	r24, 0x05	; 5
     f20:	03 96       	adiw	r24, 0x03	; 3
     f22:	fc 01       	movw	r30, r24
     f24:	80 81       	ld	r24, Z
     f26:	48 2f       	mov	r20, r24
     f28:	44 0f       	add	r20, r20
     f2a:	44 0f       	add	r20, r20
     f2c:	44 0f       	add	r20, r20
     f2e:	ce 01       	movw	r24, r28
     f30:	05 96       	adiw	r24, 0x05	; 5
     f32:	02 96       	adiw	r24, 0x02	; 2
     f34:	fc 01       	movw	r30, r24
     f36:	80 81       	ld	r24, Z
     f38:	82 95       	swap	r24
     f3a:	86 95       	lsr	r24
     f3c:	87 70       	andi	r24, 0x07	; 7
     f3e:	84 0f       	add	r24, r20
     f40:	f9 01       	movw	r30, r18
     f42:	80 83       	st	Z, r24
     f44:	26 ef       	ldi	r18, 0xF6	; 246
     f46:	30 e0       	ldi	r19, 0x00	; 0
     f48:	ce 01       	movw	r24, r28
     f4a:	05 96       	adiw	r24, 0x05	; 5
     f4c:	02 96       	adiw	r24, 0x02	; 2
     f4e:	fc 01       	movw	r30, r24
     f50:	80 81       	ld	r24, Z
     f52:	48 2f       	mov	r20, r24
     f54:	44 0f       	add	r20, r20
     f56:	44 0f       	add	r20, r20
     f58:	44 0f       	add	r20, r20
     f5a:	ce 01       	movw	r24, r28
     f5c:	05 96       	adiw	r24, 0x05	; 5
     f5e:	01 96       	adiw	r24, 0x01	; 1
     f60:	fc 01       	movw	r30, r24
     f62:	80 81       	ld	r24, Z
     f64:	82 95       	swap	r24
     f66:	86 95       	lsr	r24
     f68:	87 70       	andi	r24, 0x07	; 7
     f6a:	84 0f       	add	r24, r20
     f6c:	f9 01       	movw	r30, r18
     f6e:	80 83       	st	Z, r24
     f70:	25 ef       	ldi	r18, 0xF5	; 245
     f72:	30 e0       	ldi	r19, 0x00	; 0
     f74:	ce 01       	movw	r24, r28
     f76:	05 96       	adiw	r24, 0x05	; 5
     f78:	01 96       	adiw	r24, 0x01	; 1
     f7a:	fc 01       	movw	r30, r24
     f7c:	80 81       	ld	r24, Z
     f7e:	48 2f       	mov	r20, r24
     f80:	44 0f       	add	r20, r20
     f82:	44 0f       	add	r20, r20
     f84:	44 0f       	add	r20, r20
     f86:	ce 01       	movw	r24, r28
     f88:	05 96       	adiw	r24, 0x05	; 5
     f8a:	fc 01       	movw	r30, r24
     f8c:	80 81       	ld	r24, Z
     f8e:	82 95       	swap	r24
     f90:	86 95       	lsr	r24
     f92:	87 70       	andi	r24, 0x07	; 7
     f94:	84 0f       	add	r24, r20
     f96:	f9 01       	movw	r30, r18
     f98:	80 83       	st	Z, r24
     f9a:	84 ef       	ldi	r24, 0xF4	; 244
     f9c:	90 e0       	ldi	r25, 0x00	; 0
     f9e:	9e 01       	movw	r18, r28
     fa0:	2b 5f       	subi	r18, 0xFB	; 251
     fa2:	3f 4f       	sbci	r19, 0xFF	; 255
     fa4:	f9 01       	movw	r30, r18
     fa6:	20 81       	ld	r18, Z
     fa8:	22 0f       	add	r18, r18
     faa:	22 0f       	add	r18, r18
     fac:	22 0f       	add	r18, r18
     fae:	fc 01       	movw	r30, r24
     fb0:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
     fb2:	8f ee       	ldi	r24, 0xEF	; 239
     fb4:	90 e0       	ldi	r25, 0x00	; 0
     fb6:	2f ee       	ldi	r18, 0xEF	; 239
     fb8:	30 e0       	ldi	r19, 0x00	; 0
     fba:	f9 01       	movw	r30, r18
     fbc:	40 81       	ld	r20, Z
     fbe:	29 85       	ldd	r18, Y+9	; 0x09
     fc0:	3a 85       	ldd	r19, Y+10	; 0x0a
     fc2:	f9 01       	movw	r30, r18
     fc4:	26 81       	ldd	r18, Z+6	; 0x06
     fc6:	24 2b       	or	r18, r20
     fc8:	fc 01       	movw	r30, r24
     fca:	20 83       	st	Z, r18
          cmd->ctrl.rtr=0; Can_set_rtrmsk(); Can_clear_rtr();
     fcc:	89 85       	ldd	r24, Y+9	; 0x09
     fce:	9a 85       	ldd	r25, Y+10	; 0x0a
     fd0:	fc 01       	movw	r30, r24
     fd2:	12 86       	std	Z+10, r1	; 0x0a
     fd4:	84 ef       	ldi	r24, 0xF4	; 244
     fd6:	90 e0       	ldi	r25, 0x00	; 0
     fd8:	24 ef       	ldi	r18, 0xF4	; 244
     fda:	30 e0       	ldi	r19, 0x00	; 0
     fdc:	f9 01       	movw	r30, r18
     fde:	20 81       	ld	r18, Z
     fe0:	24 60       	ori	r18, 0x04	; 4
     fe2:	fc 01       	movw	r30, r24
     fe4:	20 83       	st	Z, r18
     fe6:	80 ef       	ldi	r24, 0xF0	; 240
     fe8:	90 e0       	ldi	r25, 0x00	; 0
     fea:	20 ef       	ldi	r18, 0xF0	; 240
     fec:	30 e0       	ldi	r19, 0x00	; 0
     fee:	f9 01       	movw	r30, r18
     ff0:	20 81       	ld	r18, Z
     ff2:	2b 7f       	andi	r18, 0xFB	; 251
     ff4:	fc 01       	movw	r30, r24
     ff6:	20 83       	st	Z, r18
          Can_clear_idemsk();
     ff8:	84 ef       	ldi	r24, 0xF4	; 244
     ffa:	90 e0       	ldi	r25, 0x00	; 0
     ffc:	24 ef       	ldi	r18, 0xF4	; 244
     ffe:	30 e0       	ldi	r19, 0x00	; 0
    1000:	f9 01       	movw	r30, r18
    1002:	20 81       	ld	r18, Z
    1004:	2e 7f       	andi	r18, 0xFE	; 254
    1006:	fc 01       	movw	r30, r24
    1008:	20 83       	st	Z, r18
          Can_config_rx();       
    100a:	8f ee       	ldi	r24, 0xEF	; 239
    100c:	90 e0       	ldi	r25, 0x00	; 0
    100e:	2f ee       	ldi	r18, 0xEF	; 239
    1010:	30 e0       	ldi	r19, 0x00	; 0
    1012:	f9 01       	movw	r30, r18
    1014:	20 81       	ld	r18, Z
    1016:	2f 73       	andi	r18, 0x3F	; 63
    1018:	fc 01       	movw	r30, r24
    101a:	20 83       	st	Z, r18
    101c:	8f ee       	ldi	r24, 0xEF	; 239
    101e:	90 e0       	ldi	r25, 0x00	; 0
    1020:	2f ee       	ldi	r18, 0xEF	; 239
    1022:	30 e0       	ldi	r19, 0x00	; 0
    1024:	f9 01       	movw	r30, r18
    1026:	20 81       	ld	r18, Z
    1028:	20 68       	ori	r18, 0x80	; 128
    102a:	fc 01       	movw	r30, r24
    102c:	20 83       	st	Z, r18
          break;
    102e:	44 c6       	rjmp	.+3208   	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_RX_REMOTE:
          u32_temp=0; Can_set_ext_msk(u32_temp);
    1030:	1d 82       	std	Y+5, r1	; 0x05
    1032:	1e 82       	std	Y+6, r1	; 0x06
    1034:	1f 82       	std	Y+7, r1	; 0x07
    1036:	18 86       	std	Y+8, r1	; 0x08
    1038:	27 ef       	ldi	r18, 0xF7	; 247
    103a:	30 e0       	ldi	r19, 0x00	; 0
    103c:	ce 01       	movw	r24, r28
    103e:	05 96       	adiw	r24, 0x05	; 5
    1040:	03 96       	adiw	r24, 0x03	; 3
    1042:	fc 01       	movw	r30, r24
    1044:	80 81       	ld	r24, Z
    1046:	48 2f       	mov	r20, r24
    1048:	44 0f       	add	r20, r20
    104a:	44 0f       	add	r20, r20
    104c:	44 0f       	add	r20, r20
    104e:	ce 01       	movw	r24, r28
    1050:	05 96       	adiw	r24, 0x05	; 5
    1052:	02 96       	adiw	r24, 0x02	; 2
    1054:	fc 01       	movw	r30, r24
    1056:	80 81       	ld	r24, Z
    1058:	82 95       	swap	r24
    105a:	86 95       	lsr	r24
    105c:	87 70       	andi	r24, 0x07	; 7
    105e:	84 0f       	add	r24, r20
    1060:	f9 01       	movw	r30, r18
    1062:	80 83       	st	Z, r24
    1064:	26 ef       	ldi	r18, 0xF6	; 246
    1066:	30 e0       	ldi	r19, 0x00	; 0
    1068:	ce 01       	movw	r24, r28
    106a:	05 96       	adiw	r24, 0x05	; 5
    106c:	02 96       	adiw	r24, 0x02	; 2
    106e:	fc 01       	movw	r30, r24
    1070:	80 81       	ld	r24, Z
    1072:	48 2f       	mov	r20, r24
    1074:	44 0f       	add	r20, r20
    1076:	44 0f       	add	r20, r20
    1078:	44 0f       	add	r20, r20
    107a:	ce 01       	movw	r24, r28
    107c:	05 96       	adiw	r24, 0x05	; 5
    107e:	01 96       	adiw	r24, 0x01	; 1
    1080:	fc 01       	movw	r30, r24
    1082:	80 81       	ld	r24, Z
    1084:	82 95       	swap	r24
    1086:	86 95       	lsr	r24
    1088:	87 70       	andi	r24, 0x07	; 7
    108a:	84 0f       	add	r24, r20
    108c:	f9 01       	movw	r30, r18
    108e:	80 83       	st	Z, r24
    1090:	25 ef       	ldi	r18, 0xF5	; 245
    1092:	30 e0       	ldi	r19, 0x00	; 0
    1094:	ce 01       	movw	r24, r28
    1096:	05 96       	adiw	r24, 0x05	; 5
    1098:	01 96       	adiw	r24, 0x01	; 1
    109a:	fc 01       	movw	r30, r24
    109c:	80 81       	ld	r24, Z
    109e:	48 2f       	mov	r20, r24
    10a0:	44 0f       	add	r20, r20
    10a2:	44 0f       	add	r20, r20
    10a4:	44 0f       	add	r20, r20
    10a6:	ce 01       	movw	r24, r28
    10a8:	05 96       	adiw	r24, 0x05	; 5
    10aa:	fc 01       	movw	r30, r24
    10ac:	80 81       	ld	r24, Z
    10ae:	82 95       	swap	r24
    10b0:	86 95       	lsr	r24
    10b2:	87 70       	andi	r24, 0x07	; 7
    10b4:	84 0f       	add	r24, r20
    10b6:	f9 01       	movw	r30, r18
    10b8:	80 83       	st	Z, r24
    10ba:	84 ef       	ldi	r24, 0xF4	; 244
    10bc:	90 e0       	ldi	r25, 0x00	; 0
    10be:	9e 01       	movw	r18, r28
    10c0:	2b 5f       	subi	r18, 0xFB	; 251
    10c2:	3f 4f       	sbci	r19, 0xFF	; 255
    10c4:	f9 01       	movw	r30, r18
    10c6:	20 81       	ld	r18, Z
    10c8:	22 0f       	add	r18, r18
    10ca:	22 0f       	add	r18, r18
    10cc:	22 0f       	add	r18, r18
    10ce:	fc 01       	movw	r30, r24
    10d0:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    10d2:	8f ee       	ldi	r24, 0xEF	; 239
    10d4:	90 e0       	ldi	r25, 0x00	; 0
    10d6:	2f ee       	ldi	r18, 0xEF	; 239
    10d8:	30 e0       	ldi	r19, 0x00	; 0
    10da:	f9 01       	movw	r30, r18
    10dc:	40 81       	ld	r20, Z
    10de:	29 85       	ldd	r18, Y+9	; 0x09
    10e0:	3a 85       	ldd	r19, Y+10	; 0x0a
    10e2:	f9 01       	movw	r30, r18
    10e4:	26 81       	ldd	r18, Z+6	; 0x06
    10e6:	24 2b       	or	r18, r20
    10e8:	fc 01       	movw	r30, r24
    10ea:	20 83       	st	Z, r18
          cmd->ctrl.rtr=1; Can_set_rtrmsk(); Can_set_rtr();
    10ec:	89 85       	ldd	r24, Y+9	; 0x09
    10ee:	9a 85       	ldd	r25, Y+10	; 0x0a
    10f0:	21 e0       	ldi	r18, 0x01	; 1
    10f2:	fc 01       	movw	r30, r24
    10f4:	22 87       	std	Z+10, r18	; 0x0a
    10f6:	84 ef       	ldi	r24, 0xF4	; 244
    10f8:	90 e0       	ldi	r25, 0x00	; 0
    10fa:	24 ef       	ldi	r18, 0xF4	; 244
    10fc:	30 e0       	ldi	r19, 0x00	; 0
    10fe:	f9 01       	movw	r30, r18
    1100:	20 81       	ld	r18, Z
    1102:	24 60       	ori	r18, 0x04	; 4
    1104:	fc 01       	movw	r30, r24
    1106:	20 83       	st	Z, r18
    1108:	80 ef       	ldi	r24, 0xF0	; 240
    110a:	90 e0       	ldi	r25, 0x00	; 0
    110c:	20 ef       	ldi	r18, 0xF0	; 240
    110e:	30 e0       	ldi	r19, 0x00	; 0
    1110:	f9 01       	movw	r30, r18
    1112:	20 81       	ld	r18, Z
    1114:	24 60       	ori	r18, 0x04	; 4
    1116:	fc 01       	movw	r30, r24
    1118:	20 83       	st	Z, r18
          Can_clear_rplv();
    111a:	8f ee       	ldi	r24, 0xEF	; 239
    111c:	90 e0       	ldi	r25, 0x00	; 0
    111e:	2f ee       	ldi	r18, 0xEF	; 239
    1120:	30 e0       	ldi	r19, 0x00	; 0
    1122:	f9 01       	movw	r30, r18
    1124:	20 81       	ld	r18, Z
    1126:	2f 7d       	andi	r18, 0xDF	; 223
    1128:	fc 01       	movw	r30, r24
    112a:	20 83       	st	Z, r18
          Can_clear_idemsk();
    112c:	84 ef       	ldi	r24, 0xF4	; 244
    112e:	90 e0       	ldi	r25, 0x00	; 0
    1130:	24 ef       	ldi	r18, 0xF4	; 244
    1132:	30 e0       	ldi	r19, 0x00	; 0
    1134:	f9 01       	movw	r30, r18
    1136:	20 81       	ld	r18, Z
    1138:	2e 7f       	andi	r18, 0xFE	; 254
    113a:	fc 01       	movw	r30, r24
    113c:	20 83       	st	Z, r18
          Can_config_rx();       
    113e:	8f ee       	ldi	r24, 0xEF	; 239
    1140:	90 e0       	ldi	r25, 0x00	; 0
    1142:	2f ee       	ldi	r18, 0xEF	; 239
    1144:	30 e0       	ldi	r19, 0x00	; 0
    1146:	f9 01       	movw	r30, r18
    1148:	20 81       	ld	r18, Z
    114a:	2f 73       	andi	r18, 0x3F	; 63
    114c:	fc 01       	movw	r30, r24
    114e:	20 83       	st	Z, r18
    1150:	8f ee       	ldi	r24, 0xEF	; 239
    1152:	90 e0       	ldi	r25, 0x00	; 0
    1154:	2f ee       	ldi	r18, 0xEF	; 239
    1156:	30 e0       	ldi	r19, 0x00	; 0
    1158:	f9 01       	movw	r30, r18
    115a:	20 81       	ld	r18, Z
    115c:	20 68       	ori	r18, 0x80	; 128
    115e:	fc 01       	movw	r30, r24
    1160:	20 83       	st	Z, r18
          break;
    1162:	aa c5       	rjmp	.+2900   	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_RX_MASKED:
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
    1164:	89 85       	ldd	r24, Y+9	; 0x09
    1166:	9a 85       	ldd	r25, Y+10	; 0x0a
    1168:	fc 01       	movw	r30, r24
    116a:	83 85       	ldd	r24, Z+11	; 0x0b
    116c:	88 23       	and	r24, r24
    116e:	09 f4       	brne	.+2      	; 0x1172 <__stack+0x73>
    1170:	69 c0       	rjmp	.+210    	; 0x1244 <__stack+0x145>
    1172:	83 ef       	ldi	r24, 0xF3	; 243
    1174:	90 e0       	ldi	r25, 0x00	; 0
    1176:	29 85       	ldd	r18, Y+9	; 0x09
    1178:	3a 85       	ldd	r19, Y+10	; 0x0a
    117a:	2e 5f       	subi	r18, 0xFE	; 254
    117c:	3f 4f       	sbci	r19, 0xFF	; 255
    117e:	2d 5f       	subi	r18, 0xFD	; 253
    1180:	3f 4f       	sbci	r19, 0xFF	; 255
    1182:	f9 01       	movw	r30, r18
    1184:	20 81       	ld	r18, Z
    1186:	42 2f       	mov	r20, r18
    1188:	44 0f       	add	r20, r20
    118a:	44 0f       	add	r20, r20
    118c:	44 0f       	add	r20, r20
    118e:	29 85       	ldd	r18, Y+9	; 0x09
    1190:	3a 85       	ldd	r19, Y+10	; 0x0a
    1192:	2e 5f       	subi	r18, 0xFE	; 254
    1194:	3f 4f       	sbci	r19, 0xFF	; 255
    1196:	2e 5f       	subi	r18, 0xFE	; 254
    1198:	3f 4f       	sbci	r19, 0xFF	; 255
    119a:	f9 01       	movw	r30, r18
    119c:	20 81       	ld	r18, Z
    119e:	22 95       	swap	r18
    11a0:	26 95       	lsr	r18
    11a2:	27 70       	andi	r18, 0x07	; 7
    11a4:	24 0f       	add	r18, r20
    11a6:	fc 01       	movw	r30, r24
    11a8:	20 83       	st	Z, r18
    11aa:	82 ef       	ldi	r24, 0xF2	; 242
    11ac:	90 e0       	ldi	r25, 0x00	; 0
    11ae:	29 85       	ldd	r18, Y+9	; 0x09
    11b0:	3a 85       	ldd	r19, Y+10	; 0x0a
    11b2:	2e 5f       	subi	r18, 0xFE	; 254
    11b4:	3f 4f       	sbci	r19, 0xFF	; 255
    11b6:	2e 5f       	subi	r18, 0xFE	; 254
    11b8:	3f 4f       	sbci	r19, 0xFF	; 255
    11ba:	f9 01       	movw	r30, r18
    11bc:	20 81       	ld	r18, Z
    11be:	42 2f       	mov	r20, r18
    11c0:	44 0f       	add	r20, r20
    11c2:	44 0f       	add	r20, r20
    11c4:	44 0f       	add	r20, r20
    11c6:	29 85       	ldd	r18, Y+9	; 0x09
    11c8:	3a 85       	ldd	r19, Y+10	; 0x0a
    11ca:	2e 5f       	subi	r18, 0xFE	; 254
    11cc:	3f 4f       	sbci	r19, 0xFF	; 255
    11ce:	2f 5f       	subi	r18, 0xFF	; 255
    11d0:	3f 4f       	sbci	r19, 0xFF	; 255
    11d2:	f9 01       	movw	r30, r18
    11d4:	20 81       	ld	r18, Z
    11d6:	22 95       	swap	r18
    11d8:	26 95       	lsr	r18
    11da:	27 70       	andi	r18, 0x07	; 7
    11dc:	24 0f       	add	r18, r20
    11de:	fc 01       	movw	r30, r24
    11e0:	20 83       	st	Z, r18
    11e2:	81 ef       	ldi	r24, 0xF1	; 241
    11e4:	90 e0       	ldi	r25, 0x00	; 0
    11e6:	29 85       	ldd	r18, Y+9	; 0x09
    11e8:	3a 85       	ldd	r19, Y+10	; 0x0a
    11ea:	2e 5f       	subi	r18, 0xFE	; 254
    11ec:	3f 4f       	sbci	r19, 0xFF	; 255
    11ee:	2f 5f       	subi	r18, 0xFF	; 255
    11f0:	3f 4f       	sbci	r19, 0xFF	; 255
    11f2:	f9 01       	movw	r30, r18
    11f4:	20 81       	ld	r18, Z
    11f6:	42 2f       	mov	r20, r18
    11f8:	44 0f       	add	r20, r20
    11fa:	44 0f       	add	r20, r20
    11fc:	44 0f       	add	r20, r20
    11fe:	29 85       	ldd	r18, Y+9	; 0x09
    1200:	3a 85       	ldd	r19, Y+10	; 0x0a
    1202:	2e 5f       	subi	r18, 0xFE	; 254
    1204:	3f 4f       	sbci	r19, 0xFF	; 255
    1206:	f9 01       	movw	r30, r18
    1208:	20 81       	ld	r18, Z
    120a:	22 95       	swap	r18
    120c:	26 95       	lsr	r18
    120e:	27 70       	andi	r18, 0x07	; 7
    1210:	24 0f       	add	r18, r20
    1212:	fc 01       	movw	r30, r24
    1214:	20 83       	st	Z, r18
    1216:	80 ef       	ldi	r24, 0xF0	; 240
    1218:	90 e0       	ldi	r25, 0x00	; 0
    121a:	29 85       	ldd	r18, Y+9	; 0x09
    121c:	3a 85       	ldd	r19, Y+10	; 0x0a
    121e:	2e 5f       	subi	r18, 0xFE	; 254
    1220:	3f 4f       	sbci	r19, 0xFF	; 255
    1222:	f9 01       	movw	r30, r18
    1224:	20 81       	ld	r18, Z
    1226:	22 0f       	add	r18, r18
    1228:	22 0f       	add	r18, r18
    122a:	22 0f       	add	r18, r18
    122c:	fc 01       	movw	r30, r24
    122e:	20 83       	st	Z, r18
    1230:	8f ee       	ldi	r24, 0xEF	; 239
    1232:	90 e0       	ldi	r25, 0x00	; 0
    1234:	2f ee       	ldi	r18, 0xEF	; 239
    1236:	30 e0       	ldi	r19, 0x00	; 0
    1238:	f9 01       	movw	r30, r18
    123a:	20 81       	ld	r18, Z
    123c:	20 61       	ori	r18, 0x10	; 16
    123e:	fc 01       	movw	r30, r24
    1240:	20 83       	st	Z, r18
    1242:	30 c0       	rjmp	.+96     	; 0x12a4 <__stack+0x1a5>
          else              { Can_set_std_id(cmd->id.std);}
    1244:	83 ef       	ldi	r24, 0xF3	; 243
    1246:	90 e0       	ldi	r25, 0x00	; 0
    1248:	29 85       	ldd	r18, Y+9	; 0x09
    124a:	3a 85       	ldd	r19, Y+10	; 0x0a
    124c:	2e 5f       	subi	r18, 0xFE	; 254
    124e:	3f 4f       	sbci	r19, 0xFF	; 255
    1250:	2f 5f       	subi	r18, 0xFF	; 255
    1252:	3f 4f       	sbci	r19, 0xFF	; 255
    1254:	f9 01       	movw	r30, r18
    1256:	20 81       	ld	r18, Z
    1258:	42 2f       	mov	r20, r18
    125a:	42 95       	swap	r20
    125c:	44 0f       	add	r20, r20
    125e:	40 7e       	andi	r20, 0xE0	; 224
    1260:	29 85       	ldd	r18, Y+9	; 0x09
    1262:	3a 85       	ldd	r19, Y+10	; 0x0a
    1264:	2e 5f       	subi	r18, 0xFE	; 254
    1266:	3f 4f       	sbci	r19, 0xFF	; 255
    1268:	f9 01       	movw	r30, r18
    126a:	20 81       	ld	r18, Z
    126c:	26 95       	lsr	r18
    126e:	26 95       	lsr	r18
    1270:	26 95       	lsr	r18
    1272:	24 0f       	add	r18, r20
    1274:	fc 01       	movw	r30, r24
    1276:	20 83       	st	Z, r18
    1278:	82 ef       	ldi	r24, 0xF2	; 242
    127a:	90 e0       	ldi	r25, 0x00	; 0
    127c:	29 85       	ldd	r18, Y+9	; 0x09
    127e:	3a 85       	ldd	r19, Y+10	; 0x0a
    1280:	2e 5f       	subi	r18, 0xFE	; 254
    1282:	3f 4f       	sbci	r19, 0xFF	; 255
    1284:	f9 01       	movw	r30, r18
    1286:	20 81       	ld	r18, Z
    1288:	22 95       	swap	r18
    128a:	22 0f       	add	r18, r18
    128c:	20 7e       	andi	r18, 0xE0	; 224
    128e:	fc 01       	movw	r30, r24
    1290:	20 83       	st	Z, r18
    1292:	8f ee       	ldi	r24, 0xEF	; 239
    1294:	90 e0       	ldi	r25, 0x00	; 0
    1296:	2f ee       	ldi	r18, 0xEF	; 239
    1298:	30 e0       	ldi	r19, 0x00	; 0
    129a:	f9 01       	movw	r30, r18
    129c:	20 81       	ld	r18, Z
    129e:	2f 7e       	andi	r18, 0xEF	; 239
    12a0:	fc 01       	movw	r30, r24
    12a2:	20 83       	st	Z, r18
          u32_temp=~0; Can_set_ext_msk(u32_temp);
    12a4:	8f ef       	ldi	r24, 0xFF	; 255
    12a6:	9f ef       	ldi	r25, 0xFF	; 255
    12a8:	dc 01       	movw	r26, r24
    12aa:	8d 83       	std	Y+5, r24	; 0x05
    12ac:	9e 83       	std	Y+6, r25	; 0x06
    12ae:	af 83       	std	Y+7, r26	; 0x07
    12b0:	b8 87       	std	Y+8, r27	; 0x08
    12b2:	27 ef       	ldi	r18, 0xF7	; 247
    12b4:	30 e0       	ldi	r19, 0x00	; 0
    12b6:	ce 01       	movw	r24, r28
    12b8:	05 96       	adiw	r24, 0x05	; 5
    12ba:	03 96       	adiw	r24, 0x03	; 3
    12bc:	fc 01       	movw	r30, r24
    12be:	80 81       	ld	r24, Z
    12c0:	48 2f       	mov	r20, r24
    12c2:	44 0f       	add	r20, r20
    12c4:	44 0f       	add	r20, r20
    12c6:	44 0f       	add	r20, r20
    12c8:	ce 01       	movw	r24, r28
    12ca:	05 96       	adiw	r24, 0x05	; 5
    12cc:	02 96       	adiw	r24, 0x02	; 2
    12ce:	fc 01       	movw	r30, r24
    12d0:	80 81       	ld	r24, Z
    12d2:	82 95       	swap	r24
    12d4:	86 95       	lsr	r24
    12d6:	87 70       	andi	r24, 0x07	; 7
    12d8:	84 0f       	add	r24, r20
    12da:	f9 01       	movw	r30, r18
    12dc:	80 83       	st	Z, r24
    12de:	26 ef       	ldi	r18, 0xF6	; 246
    12e0:	30 e0       	ldi	r19, 0x00	; 0
    12e2:	ce 01       	movw	r24, r28
    12e4:	05 96       	adiw	r24, 0x05	; 5
    12e6:	02 96       	adiw	r24, 0x02	; 2
    12e8:	fc 01       	movw	r30, r24
    12ea:	80 81       	ld	r24, Z
    12ec:	48 2f       	mov	r20, r24
    12ee:	44 0f       	add	r20, r20
    12f0:	44 0f       	add	r20, r20
    12f2:	44 0f       	add	r20, r20
    12f4:	ce 01       	movw	r24, r28
    12f6:	05 96       	adiw	r24, 0x05	; 5
    12f8:	01 96       	adiw	r24, 0x01	; 1
    12fa:	fc 01       	movw	r30, r24
    12fc:	80 81       	ld	r24, Z
    12fe:	82 95       	swap	r24
    1300:	86 95       	lsr	r24
    1302:	87 70       	andi	r24, 0x07	; 7
    1304:	84 0f       	add	r24, r20
    1306:	f9 01       	movw	r30, r18
    1308:	80 83       	st	Z, r24
    130a:	25 ef       	ldi	r18, 0xF5	; 245
    130c:	30 e0       	ldi	r19, 0x00	; 0
    130e:	ce 01       	movw	r24, r28
    1310:	05 96       	adiw	r24, 0x05	; 5
    1312:	01 96       	adiw	r24, 0x01	; 1
    1314:	fc 01       	movw	r30, r24
    1316:	80 81       	ld	r24, Z
    1318:	48 2f       	mov	r20, r24
    131a:	44 0f       	add	r20, r20
    131c:	44 0f       	add	r20, r20
    131e:	44 0f       	add	r20, r20
    1320:	ce 01       	movw	r24, r28
    1322:	05 96       	adiw	r24, 0x05	; 5
    1324:	fc 01       	movw	r30, r24
    1326:	80 81       	ld	r24, Z
    1328:	82 95       	swap	r24
    132a:	86 95       	lsr	r24
    132c:	87 70       	andi	r24, 0x07	; 7
    132e:	84 0f       	add	r24, r20
    1330:	f9 01       	movw	r30, r18
    1332:	80 83       	st	Z, r24
    1334:	84 ef       	ldi	r24, 0xF4	; 244
    1336:	90 e0       	ldi	r25, 0x00	; 0
    1338:	9e 01       	movw	r18, r28
    133a:	2b 5f       	subi	r18, 0xFB	; 251
    133c:	3f 4f       	sbci	r19, 0xFF	; 255
    133e:	f9 01       	movw	r30, r18
    1340:	20 81       	ld	r18, Z
    1342:	22 0f       	add	r18, r18
    1344:	22 0f       	add	r18, r18
    1346:	22 0f       	add	r18, r18
    1348:	fc 01       	movw	r30, r24
    134a:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    134c:	8f ee       	ldi	r24, 0xEF	; 239
    134e:	90 e0       	ldi	r25, 0x00	; 0
    1350:	2f ee       	ldi	r18, 0xEF	; 239
    1352:	30 e0       	ldi	r19, 0x00	; 0
    1354:	f9 01       	movw	r30, r18
    1356:	40 81       	ld	r20, Z
    1358:	29 85       	ldd	r18, Y+9	; 0x09
    135a:	3a 85       	ldd	r19, Y+10	; 0x0a
    135c:	f9 01       	movw	r30, r18
    135e:	26 81       	ldd	r18, Z+6	; 0x06
    1360:	24 2b       	or	r18, r20
    1362:	fc 01       	movw	r30, r24
    1364:	20 83       	st	Z, r18
          Can_clear_rtrmsk();
    1366:	84 ef       	ldi	r24, 0xF4	; 244
    1368:	90 e0       	ldi	r25, 0x00	; 0
    136a:	24 ef       	ldi	r18, 0xF4	; 244
    136c:	30 e0       	ldi	r19, 0x00	; 0
    136e:	f9 01       	movw	r30, r18
    1370:	20 81       	ld	r18, Z
    1372:	2b 7f       	andi	r18, 0xFB	; 251
    1374:	fc 01       	movw	r30, r24
    1376:	20 83       	st	Z, r18
          Can_set_idemsk();
    1378:	84 ef       	ldi	r24, 0xF4	; 244
    137a:	90 e0       	ldi	r25, 0x00	; 0
    137c:	24 ef       	ldi	r18, 0xF4	; 244
    137e:	30 e0       	ldi	r19, 0x00	; 0
    1380:	f9 01       	movw	r30, r18
    1382:	20 81       	ld	r18, Z
    1384:	21 60       	ori	r18, 0x01	; 1
    1386:	fc 01       	movw	r30, r24
    1388:	20 83       	st	Z, r18
          Can_config_rx();       
    138a:	8f ee       	ldi	r24, 0xEF	; 239
    138c:	90 e0       	ldi	r25, 0x00	; 0
    138e:	2f ee       	ldi	r18, 0xEF	; 239
    1390:	30 e0       	ldi	r19, 0x00	; 0
    1392:	f9 01       	movw	r30, r18
    1394:	20 81       	ld	r18, Z
    1396:	2f 73       	andi	r18, 0x3F	; 63
    1398:	fc 01       	movw	r30, r24
    139a:	20 83       	st	Z, r18
    139c:	8f ee       	ldi	r24, 0xEF	; 239
    139e:	90 e0       	ldi	r25, 0x00	; 0
    13a0:	2f ee       	ldi	r18, 0xEF	; 239
    13a2:	30 e0       	ldi	r19, 0x00	; 0
    13a4:	f9 01       	movw	r30, r18
    13a6:	20 81       	ld	r18, Z
    13a8:	20 68       	ori	r18, 0x80	; 128
    13aa:	fc 01       	movw	r30, r24
    13ac:	20 83       	st	Z, r18
          break;
    13ae:	84 c4       	rjmp	.+2312   	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_RX_DATA_MASKED:
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
    13b0:	89 85       	ldd	r24, Y+9	; 0x09
    13b2:	9a 85       	ldd	r25, Y+10	; 0x0a
    13b4:	fc 01       	movw	r30, r24
    13b6:	83 85       	ldd	r24, Z+11	; 0x0b
    13b8:	88 23       	and	r24, r24
    13ba:	09 f4       	brne	.+2      	; 0x13be <__stack+0x2bf>
    13bc:	69 c0       	rjmp	.+210    	; 0x1490 <__stack+0x391>
    13be:	83 ef       	ldi	r24, 0xF3	; 243
    13c0:	90 e0       	ldi	r25, 0x00	; 0
    13c2:	29 85       	ldd	r18, Y+9	; 0x09
    13c4:	3a 85       	ldd	r19, Y+10	; 0x0a
    13c6:	2e 5f       	subi	r18, 0xFE	; 254
    13c8:	3f 4f       	sbci	r19, 0xFF	; 255
    13ca:	2d 5f       	subi	r18, 0xFD	; 253
    13cc:	3f 4f       	sbci	r19, 0xFF	; 255
    13ce:	f9 01       	movw	r30, r18
    13d0:	20 81       	ld	r18, Z
    13d2:	42 2f       	mov	r20, r18
    13d4:	44 0f       	add	r20, r20
    13d6:	44 0f       	add	r20, r20
    13d8:	44 0f       	add	r20, r20
    13da:	29 85       	ldd	r18, Y+9	; 0x09
    13dc:	3a 85       	ldd	r19, Y+10	; 0x0a
    13de:	2e 5f       	subi	r18, 0xFE	; 254
    13e0:	3f 4f       	sbci	r19, 0xFF	; 255
    13e2:	2e 5f       	subi	r18, 0xFE	; 254
    13e4:	3f 4f       	sbci	r19, 0xFF	; 255
    13e6:	f9 01       	movw	r30, r18
    13e8:	20 81       	ld	r18, Z
    13ea:	22 95       	swap	r18
    13ec:	26 95       	lsr	r18
    13ee:	27 70       	andi	r18, 0x07	; 7
    13f0:	24 0f       	add	r18, r20
    13f2:	fc 01       	movw	r30, r24
    13f4:	20 83       	st	Z, r18
    13f6:	82 ef       	ldi	r24, 0xF2	; 242
    13f8:	90 e0       	ldi	r25, 0x00	; 0
    13fa:	29 85       	ldd	r18, Y+9	; 0x09
    13fc:	3a 85       	ldd	r19, Y+10	; 0x0a
    13fe:	2e 5f       	subi	r18, 0xFE	; 254
    1400:	3f 4f       	sbci	r19, 0xFF	; 255
    1402:	2e 5f       	subi	r18, 0xFE	; 254
    1404:	3f 4f       	sbci	r19, 0xFF	; 255
    1406:	f9 01       	movw	r30, r18
    1408:	20 81       	ld	r18, Z
    140a:	42 2f       	mov	r20, r18
    140c:	44 0f       	add	r20, r20
    140e:	44 0f       	add	r20, r20
    1410:	44 0f       	add	r20, r20
    1412:	29 85       	ldd	r18, Y+9	; 0x09
    1414:	3a 85       	ldd	r19, Y+10	; 0x0a
    1416:	2e 5f       	subi	r18, 0xFE	; 254
    1418:	3f 4f       	sbci	r19, 0xFF	; 255
    141a:	2f 5f       	subi	r18, 0xFF	; 255
    141c:	3f 4f       	sbci	r19, 0xFF	; 255
    141e:	f9 01       	movw	r30, r18
    1420:	20 81       	ld	r18, Z
    1422:	22 95       	swap	r18
    1424:	26 95       	lsr	r18
    1426:	27 70       	andi	r18, 0x07	; 7
    1428:	24 0f       	add	r18, r20
    142a:	fc 01       	movw	r30, r24
    142c:	20 83       	st	Z, r18
    142e:	81 ef       	ldi	r24, 0xF1	; 241
    1430:	90 e0       	ldi	r25, 0x00	; 0
    1432:	29 85       	ldd	r18, Y+9	; 0x09
    1434:	3a 85       	ldd	r19, Y+10	; 0x0a
    1436:	2e 5f       	subi	r18, 0xFE	; 254
    1438:	3f 4f       	sbci	r19, 0xFF	; 255
    143a:	2f 5f       	subi	r18, 0xFF	; 255
    143c:	3f 4f       	sbci	r19, 0xFF	; 255
    143e:	f9 01       	movw	r30, r18
    1440:	20 81       	ld	r18, Z
    1442:	42 2f       	mov	r20, r18
    1444:	44 0f       	add	r20, r20
    1446:	44 0f       	add	r20, r20
    1448:	44 0f       	add	r20, r20
    144a:	29 85       	ldd	r18, Y+9	; 0x09
    144c:	3a 85       	ldd	r19, Y+10	; 0x0a
    144e:	2e 5f       	subi	r18, 0xFE	; 254
    1450:	3f 4f       	sbci	r19, 0xFF	; 255
    1452:	f9 01       	movw	r30, r18
    1454:	20 81       	ld	r18, Z
    1456:	22 95       	swap	r18
    1458:	26 95       	lsr	r18
    145a:	27 70       	andi	r18, 0x07	; 7
    145c:	24 0f       	add	r18, r20
    145e:	fc 01       	movw	r30, r24
    1460:	20 83       	st	Z, r18
    1462:	80 ef       	ldi	r24, 0xF0	; 240
    1464:	90 e0       	ldi	r25, 0x00	; 0
    1466:	29 85       	ldd	r18, Y+9	; 0x09
    1468:	3a 85       	ldd	r19, Y+10	; 0x0a
    146a:	2e 5f       	subi	r18, 0xFE	; 254
    146c:	3f 4f       	sbci	r19, 0xFF	; 255
    146e:	f9 01       	movw	r30, r18
    1470:	20 81       	ld	r18, Z
    1472:	22 0f       	add	r18, r18
    1474:	22 0f       	add	r18, r18
    1476:	22 0f       	add	r18, r18
    1478:	fc 01       	movw	r30, r24
    147a:	20 83       	st	Z, r18
    147c:	8f ee       	ldi	r24, 0xEF	; 239
    147e:	90 e0       	ldi	r25, 0x00	; 0
    1480:	2f ee       	ldi	r18, 0xEF	; 239
    1482:	30 e0       	ldi	r19, 0x00	; 0
    1484:	f9 01       	movw	r30, r18
    1486:	20 81       	ld	r18, Z
    1488:	20 61       	ori	r18, 0x10	; 16
    148a:	fc 01       	movw	r30, r24
    148c:	20 83       	st	Z, r18
    148e:	30 c0       	rjmp	.+96     	; 0x14f0 <__stack+0x3f1>
          else              { Can_set_std_id(cmd->id.std);}
    1490:	83 ef       	ldi	r24, 0xF3	; 243
    1492:	90 e0       	ldi	r25, 0x00	; 0
    1494:	29 85       	ldd	r18, Y+9	; 0x09
    1496:	3a 85       	ldd	r19, Y+10	; 0x0a
    1498:	2e 5f       	subi	r18, 0xFE	; 254
    149a:	3f 4f       	sbci	r19, 0xFF	; 255
    149c:	2f 5f       	subi	r18, 0xFF	; 255
    149e:	3f 4f       	sbci	r19, 0xFF	; 255
    14a0:	f9 01       	movw	r30, r18
    14a2:	20 81       	ld	r18, Z
    14a4:	42 2f       	mov	r20, r18
    14a6:	42 95       	swap	r20
    14a8:	44 0f       	add	r20, r20
    14aa:	40 7e       	andi	r20, 0xE0	; 224
    14ac:	29 85       	ldd	r18, Y+9	; 0x09
    14ae:	3a 85       	ldd	r19, Y+10	; 0x0a
    14b0:	2e 5f       	subi	r18, 0xFE	; 254
    14b2:	3f 4f       	sbci	r19, 0xFF	; 255
    14b4:	f9 01       	movw	r30, r18
    14b6:	20 81       	ld	r18, Z
    14b8:	26 95       	lsr	r18
    14ba:	26 95       	lsr	r18
    14bc:	26 95       	lsr	r18
    14be:	24 0f       	add	r18, r20
    14c0:	fc 01       	movw	r30, r24
    14c2:	20 83       	st	Z, r18
    14c4:	82 ef       	ldi	r24, 0xF2	; 242
    14c6:	90 e0       	ldi	r25, 0x00	; 0
    14c8:	29 85       	ldd	r18, Y+9	; 0x09
    14ca:	3a 85       	ldd	r19, Y+10	; 0x0a
    14cc:	2e 5f       	subi	r18, 0xFE	; 254
    14ce:	3f 4f       	sbci	r19, 0xFF	; 255
    14d0:	f9 01       	movw	r30, r18
    14d2:	20 81       	ld	r18, Z
    14d4:	22 95       	swap	r18
    14d6:	22 0f       	add	r18, r18
    14d8:	20 7e       	andi	r18, 0xE0	; 224
    14da:	fc 01       	movw	r30, r24
    14dc:	20 83       	st	Z, r18
    14de:	8f ee       	ldi	r24, 0xEF	; 239
    14e0:	90 e0       	ldi	r25, 0x00	; 0
    14e2:	2f ee       	ldi	r18, 0xEF	; 239
    14e4:	30 e0       	ldi	r19, 0x00	; 0
    14e6:	f9 01       	movw	r30, r18
    14e8:	20 81       	ld	r18, Z
    14ea:	2f 7e       	andi	r18, 0xEF	; 239
    14ec:	fc 01       	movw	r30, r24
    14ee:	20 83       	st	Z, r18
          u32_temp=~0; Can_set_ext_msk(u32_temp);
    14f0:	8f ef       	ldi	r24, 0xFF	; 255
    14f2:	9f ef       	ldi	r25, 0xFF	; 255
    14f4:	dc 01       	movw	r26, r24
    14f6:	8d 83       	std	Y+5, r24	; 0x05
    14f8:	9e 83       	std	Y+6, r25	; 0x06
    14fa:	af 83       	std	Y+7, r26	; 0x07
    14fc:	b8 87       	std	Y+8, r27	; 0x08
    14fe:	27 ef       	ldi	r18, 0xF7	; 247
    1500:	30 e0       	ldi	r19, 0x00	; 0
    1502:	ce 01       	movw	r24, r28
    1504:	05 96       	adiw	r24, 0x05	; 5
    1506:	03 96       	adiw	r24, 0x03	; 3
    1508:	fc 01       	movw	r30, r24
    150a:	80 81       	ld	r24, Z
    150c:	48 2f       	mov	r20, r24
    150e:	44 0f       	add	r20, r20
    1510:	44 0f       	add	r20, r20
    1512:	44 0f       	add	r20, r20
    1514:	ce 01       	movw	r24, r28
    1516:	05 96       	adiw	r24, 0x05	; 5
    1518:	02 96       	adiw	r24, 0x02	; 2
    151a:	fc 01       	movw	r30, r24
    151c:	80 81       	ld	r24, Z
    151e:	82 95       	swap	r24
    1520:	86 95       	lsr	r24
    1522:	87 70       	andi	r24, 0x07	; 7
    1524:	84 0f       	add	r24, r20
    1526:	f9 01       	movw	r30, r18
    1528:	80 83       	st	Z, r24
    152a:	26 ef       	ldi	r18, 0xF6	; 246
    152c:	30 e0       	ldi	r19, 0x00	; 0
    152e:	ce 01       	movw	r24, r28
    1530:	05 96       	adiw	r24, 0x05	; 5
    1532:	02 96       	adiw	r24, 0x02	; 2
    1534:	fc 01       	movw	r30, r24
    1536:	80 81       	ld	r24, Z
    1538:	48 2f       	mov	r20, r24
    153a:	44 0f       	add	r20, r20
    153c:	44 0f       	add	r20, r20
    153e:	44 0f       	add	r20, r20
    1540:	ce 01       	movw	r24, r28
    1542:	05 96       	adiw	r24, 0x05	; 5
    1544:	01 96       	adiw	r24, 0x01	; 1
    1546:	fc 01       	movw	r30, r24
    1548:	80 81       	ld	r24, Z
    154a:	82 95       	swap	r24
    154c:	86 95       	lsr	r24
    154e:	87 70       	andi	r24, 0x07	; 7
    1550:	84 0f       	add	r24, r20
    1552:	f9 01       	movw	r30, r18
    1554:	80 83       	st	Z, r24
    1556:	25 ef       	ldi	r18, 0xF5	; 245
    1558:	30 e0       	ldi	r19, 0x00	; 0
    155a:	ce 01       	movw	r24, r28
    155c:	05 96       	adiw	r24, 0x05	; 5
    155e:	01 96       	adiw	r24, 0x01	; 1
    1560:	fc 01       	movw	r30, r24
    1562:	80 81       	ld	r24, Z
    1564:	48 2f       	mov	r20, r24
    1566:	44 0f       	add	r20, r20
    1568:	44 0f       	add	r20, r20
    156a:	44 0f       	add	r20, r20
    156c:	ce 01       	movw	r24, r28
    156e:	05 96       	adiw	r24, 0x05	; 5
    1570:	fc 01       	movw	r30, r24
    1572:	80 81       	ld	r24, Z
    1574:	82 95       	swap	r24
    1576:	86 95       	lsr	r24
    1578:	87 70       	andi	r24, 0x07	; 7
    157a:	84 0f       	add	r24, r20
    157c:	f9 01       	movw	r30, r18
    157e:	80 83       	st	Z, r24
    1580:	84 ef       	ldi	r24, 0xF4	; 244
    1582:	90 e0       	ldi	r25, 0x00	; 0
    1584:	9e 01       	movw	r18, r28
    1586:	2b 5f       	subi	r18, 0xFB	; 251
    1588:	3f 4f       	sbci	r19, 0xFF	; 255
    158a:	f9 01       	movw	r30, r18
    158c:	20 81       	ld	r18, Z
    158e:	22 0f       	add	r18, r18
    1590:	22 0f       	add	r18, r18
    1592:	22 0f       	add	r18, r18
    1594:	fc 01       	movw	r30, r24
    1596:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    1598:	8f ee       	ldi	r24, 0xEF	; 239
    159a:	90 e0       	ldi	r25, 0x00	; 0
    159c:	2f ee       	ldi	r18, 0xEF	; 239
    159e:	30 e0       	ldi	r19, 0x00	; 0
    15a0:	f9 01       	movw	r30, r18
    15a2:	40 81       	ld	r20, Z
    15a4:	29 85       	ldd	r18, Y+9	; 0x09
    15a6:	3a 85       	ldd	r19, Y+10	; 0x0a
    15a8:	f9 01       	movw	r30, r18
    15aa:	26 81       	ldd	r18, Z+6	; 0x06
    15ac:	24 2b       	or	r18, r20
    15ae:	fc 01       	movw	r30, r24
    15b0:	20 83       	st	Z, r18
          cmd->ctrl.rtr=0; Can_set_rtrmsk(); Can_clear_rtr();
    15b2:	89 85       	ldd	r24, Y+9	; 0x09
    15b4:	9a 85       	ldd	r25, Y+10	; 0x0a
    15b6:	fc 01       	movw	r30, r24
    15b8:	12 86       	std	Z+10, r1	; 0x0a
    15ba:	84 ef       	ldi	r24, 0xF4	; 244
    15bc:	90 e0       	ldi	r25, 0x00	; 0
    15be:	24 ef       	ldi	r18, 0xF4	; 244
    15c0:	30 e0       	ldi	r19, 0x00	; 0
    15c2:	f9 01       	movw	r30, r18
    15c4:	20 81       	ld	r18, Z
    15c6:	24 60       	ori	r18, 0x04	; 4
    15c8:	fc 01       	movw	r30, r24
    15ca:	20 83       	st	Z, r18
    15cc:	80 ef       	ldi	r24, 0xF0	; 240
    15ce:	90 e0       	ldi	r25, 0x00	; 0
    15d0:	20 ef       	ldi	r18, 0xF0	; 240
    15d2:	30 e0       	ldi	r19, 0x00	; 0
    15d4:	f9 01       	movw	r30, r18
    15d6:	20 81       	ld	r18, Z
    15d8:	2b 7f       	andi	r18, 0xFB	; 251
    15da:	fc 01       	movw	r30, r24
    15dc:	20 83       	st	Z, r18
          Can_set_idemsk();
    15de:	84 ef       	ldi	r24, 0xF4	; 244
    15e0:	90 e0       	ldi	r25, 0x00	; 0
    15e2:	24 ef       	ldi	r18, 0xF4	; 244
    15e4:	30 e0       	ldi	r19, 0x00	; 0
    15e6:	f9 01       	movw	r30, r18
    15e8:	20 81       	ld	r18, Z
    15ea:	21 60       	ori	r18, 0x01	; 1
    15ec:	fc 01       	movw	r30, r24
    15ee:	20 83       	st	Z, r18
          Can_config_rx();       
    15f0:	8f ee       	ldi	r24, 0xEF	; 239
    15f2:	90 e0       	ldi	r25, 0x00	; 0
    15f4:	2f ee       	ldi	r18, 0xEF	; 239
    15f6:	30 e0       	ldi	r19, 0x00	; 0
    15f8:	f9 01       	movw	r30, r18
    15fa:	20 81       	ld	r18, Z
    15fc:	2f 73       	andi	r18, 0x3F	; 63
    15fe:	fc 01       	movw	r30, r24
    1600:	20 83       	st	Z, r18
    1602:	8f ee       	ldi	r24, 0xEF	; 239
    1604:	90 e0       	ldi	r25, 0x00	; 0
    1606:	2f ee       	ldi	r18, 0xEF	; 239
    1608:	30 e0       	ldi	r19, 0x00	; 0
    160a:	f9 01       	movw	r30, r18
    160c:	20 81       	ld	r18, Z
    160e:	20 68       	ori	r18, 0x80	; 128
    1610:	fc 01       	movw	r30, r24
    1612:	20 83       	st	Z, r18
          break;
    1614:	51 c3       	rjmp	.+1698   	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_RX_REMOTE_MASKED:
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
    1616:	89 85       	ldd	r24, Y+9	; 0x09
    1618:	9a 85       	ldd	r25, Y+10	; 0x0a
    161a:	fc 01       	movw	r30, r24
    161c:	83 85       	ldd	r24, Z+11	; 0x0b
    161e:	88 23       	and	r24, r24
    1620:	09 f4       	brne	.+2      	; 0x1624 <__stack+0x525>
    1622:	69 c0       	rjmp	.+210    	; 0x16f6 <__stack+0x5f7>
    1624:	83 ef       	ldi	r24, 0xF3	; 243
    1626:	90 e0       	ldi	r25, 0x00	; 0
    1628:	29 85       	ldd	r18, Y+9	; 0x09
    162a:	3a 85       	ldd	r19, Y+10	; 0x0a
    162c:	2e 5f       	subi	r18, 0xFE	; 254
    162e:	3f 4f       	sbci	r19, 0xFF	; 255
    1630:	2d 5f       	subi	r18, 0xFD	; 253
    1632:	3f 4f       	sbci	r19, 0xFF	; 255
    1634:	f9 01       	movw	r30, r18
    1636:	20 81       	ld	r18, Z
    1638:	42 2f       	mov	r20, r18
    163a:	44 0f       	add	r20, r20
    163c:	44 0f       	add	r20, r20
    163e:	44 0f       	add	r20, r20
    1640:	29 85       	ldd	r18, Y+9	; 0x09
    1642:	3a 85       	ldd	r19, Y+10	; 0x0a
    1644:	2e 5f       	subi	r18, 0xFE	; 254
    1646:	3f 4f       	sbci	r19, 0xFF	; 255
    1648:	2e 5f       	subi	r18, 0xFE	; 254
    164a:	3f 4f       	sbci	r19, 0xFF	; 255
    164c:	f9 01       	movw	r30, r18
    164e:	20 81       	ld	r18, Z
    1650:	22 95       	swap	r18
    1652:	26 95       	lsr	r18
    1654:	27 70       	andi	r18, 0x07	; 7
    1656:	24 0f       	add	r18, r20
    1658:	fc 01       	movw	r30, r24
    165a:	20 83       	st	Z, r18
    165c:	82 ef       	ldi	r24, 0xF2	; 242
    165e:	90 e0       	ldi	r25, 0x00	; 0
    1660:	29 85       	ldd	r18, Y+9	; 0x09
    1662:	3a 85       	ldd	r19, Y+10	; 0x0a
    1664:	2e 5f       	subi	r18, 0xFE	; 254
    1666:	3f 4f       	sbci	r19, 0xFF	; 255
    1668:	2e 5f       	subi	r18, 0xFE	; 254
    166a:	3f 4f       	sbci	r19, 0xFF	; 255
    166c:	f9 01       	movw	r30, r18
    166e:	20 81       	ld	r18, Z
    1670:	42 2f       	mov	r20, r18
    1672:	44 0f       	add	r20, r20
    1674:	44 0f       	add	r20, r20
    1676:	44 0f       	add	r20, r20
    1678:	29 85       	ldd	r18, Y+9	; 0x09
    167a:	3a 85       	ldd	r19, Y+10	; 0x0a
    167c:	2e 5f       	subi	r18, 0xFE	; 254
    167e:	3f 4f       	sbci	r19, 0xFF	; 255
    1680:	2f 5f       	subi	r18, 0xFF	; 255
    1682:	3f 4f       	sbci	r19, 0xFF	; 255
    1684:	f9 01       	movw	r30, r18
    1686:	20 81       	ld	r18, Z
    1688:	22 95       	swap	r18
    168a:	26 95       	lsr	r18
    168c:	27 70       	andi	r18, 0x07	; 7
    168e:	24 0f       	add	r18, r20
    1690:	fc 01       	movw	r30, r24
    1692:	20 83       	st	Z, r18
    1694:	81 ef       	ldi	r24, 0xF1	; 241
    1696:	90 e0       	ldi	r25, 0x00	; 0
    1698:	29 85       	ldd	r18, Y+9	; 0x09
    169a:	3a 85       	ldd	r19, Y+10	; 0x0a
    169c:	2e 5f       	subi	r18, 0xFE	; 254
    169e:	3f 4f       	sbci	r19, 0xFF	; 255
    16a0:	2f 5f       	subi	r18, 0xFF	; 255
    16a2:	3f 4f       	sbci	r19, 0xFF	; 255
    16a4:	f9 01       	movw	r30, r18
    16a6:	20 81       	ld	r18, Z
    16a8:	42 2f       	mov	r20, r18
    16aa:	44 0f       	add	r20, r20
    16ac:	44 0f       	add	r20, r20
    16ae:	44 0f       	add	r20, r20
    16b0:	29 85       	ldd	r18, Y+9	; 0x09
    16b2:	3a 85       	ldd	r19, Y+10	; 0x0a
    16b4:	2e 5f       	subi	r18, 0xFE	; 254
    16b6:	3f 4f       	sbci	r19, 0xFF	; 255
    16b8:	f9 01       	movw	r30, r18
    16ba:	20 81       	ld	r18, Z
    16bc:	22 95       	swap	r18
    16be:	26 95       	lsr	r18
    16c0:	27 70       	andi	r18, 0x07	; 7
    16c2:	24 0f       	add	r18, r20
    16c4:	fc 01       	movw	r30, r24
    16c6:	20 83       	st	Z, r18
    16c8:	80 ef       	ldi	r24, 0xF0	; 240
    16ca:	90 e0       	ldi	r25, 0x00	; 0
    16cc:	29 85       	ldd	r18, Y+9	; 0x09
    16ce:	3a 85       	ldd	r19, Y+10	; 0x0a
    16d0:	2e 5f       	subi	r18, 0xFE	; 254
    16d2:	3f 4f       	sbci	r19, 0xFF	; 255
    16d4:	f9 01       	movw	r30, r18
    16d6:	20 81       	ld	r18, Z
    16d8:	22 0f       	add	r18, r18
    16da:	22 0f       	add	r18, r18
    16dc:	22 0f       	add	r18, r18
    16de:	fc 01       	movw	r30, r24
    16e0:	20 83       	st	Z, r18
    16e2:	8f ee       	ldi	r24, 0xEF	; 239
    16e4:	90 e0       	ldi	r25, 0x00	; 0
    16e6:	2f ee       	ldi	r18, 0xEF	; 239
    16e8:	30 e0       	ldi	r19, 0x00	; 0
    16ea:	f9 01       	movw	r30, r18
    16ec:	20 81       	ld	r18, Z
    16ee:	20 61       	ori	r18, 0x10	; 16
    16f0:	fc 01       	movw	r30, r24
    16f2:	20 83       	st	Z, r18
    16f4:	30 c0       	rjmp	.+96     	; 0x1756 <__stack+0x657>
          else              { Can_set_std_id(cmd->id.std);}
    16f6:	83 ef       	ldi	r24, 0xF3	; 243
    16f8:	90 e0       	ldi	r25, 0x00	; 0
    16fa:	29 85       	ldd	r18, Y+9	; 0x09
    16fc:	3a 85       	ldd	r19, Y+10	; 0x0a
    16fe:	2e 5f       	subi	r18, 0xFE	; 254
    1700:	3f 4f       	sbci	r19, 0xFF	; 255
    1702:	2f 5f       	subi	r18, 0xFF	; 255
    1704:	3f 4f       	sbci	r19, 0xFF	; 255
    1706:	f9 01       	movw	r30, r18
    1708:	20 81       	ld	r18, Z
    170a:	42 2f       	mov	r20, r18
    170c:	42 95       	swap	r20
    170e:	44 0f       	add	r20, r20
    1710:	40 7e       	andi	r20, 0xE0	; 224
    1712:	29 85       	ldd	r18, Y+9	; 0x09
    1714:	3a 85       	ldd	r19, Y+10	; 0x0a
    1716:	2e 5f       	subi	r18, 0xFE	; 254
    1718:	3f 4f       	sbci	r19, 0xFF	; 255
    171a:	f9 01       	movw	r30, r18
    171c:	20 81       	ld	r18, Z
    171e:	26 95       	lsr	r18
    1720:	26 95       	lsr	r18
    1722:	26 95       	lsr	r18
    1724:	24 0f       	add	r18, r20
    1726:	fc 01       	movw	r30, r24
    1728:	20 83       	st	Z, r18
    172a:	82 ef       	ldi	r24, 0xF2	; 242
    172c:	90 e0       	ldi	r25, 0x00	; 0
    172e:	29 85       	ldd	r18, Y+9	; 0x09
    1730:	3a 85       	ldd	r19, Y+10	; 0x0a
    1732:	2e 5f       	subi	r18, 0xFE	; 254
    1734:	3f 4f       	sbci	r19, 0xFF	; 255
    1736:	f9 01       	movw	r30, r18
    1738:	20 81       	ld	r18, Z
    173a:	22 95       	swap	r18
    173c:	22 0f       	add	r18, r18
    173e:	20 7e       	andi	r18, 0xE0	; 224
    1740:	fc 01       	movw	r30, r24
    1742:	20 83       	st	Z, r18
    1744:	8f ee       	ldi	r24, 0xEF	; 239
    1746:	90 e0       	ldi	r25, 0x00	; 0
    1748:	2f ee       	ldi	r18, 0xEF	; 239
    174a:	30 e0       	ldi	r19, 0x00	; 0
    174c:	f9 01       	movw	r30, r18
    174e:	20 81       	ld	r18, Z
    1750:	2f 7e       	andi	r18, 0xEF	; 239
    1752:	fc 01       	movw	r30, r24
    1754:	20 83       	st	Z, r18
          u32_temp=~0; Can_set_ext_msk(u32_temp);
    1756:	8f ef       	ldi	r24, 0xFF	; 255
    1758:	9f ef       	ldi	r25, 0xFF	; 255
    175a:	dc 01       	movw	r26, r24
    175c:	8d 83       	std	Y+5, r24	; 0x05
    175e:	9e 83       	std	Y+6, r25	; 0x06
    1760:	af 83       	std	Y+7, r26	; 0x07
    1762:	b8 87       	std	Y+8, r27	; 0x08
    1764:	27 ef       	ldi	r18, 0xF7	; 247
    1766:	30 e0       	ldi	r19, 0x00	; 0
    1768:	ce 01       	movw	r24, r28
    176a:	05 96       	adiw	r24, 0x05	; 5
    176c:	03 96       	adiw	r24, 0x03	; 3
    176e:	fc 01       	movw	r30, r24
    1770:	80 81       	ld	r24, Z
    1772:	48 2f       	mov	r20, r24
    1774:	44 0f       	add	r20, r20
    1776:	44 0f       	add	r20, r20
    1778:	44 0f       	add	r20, r20
    177a:	ce 01       	movw	r24, r28
    177c:	05 96       	adiw	r24, 0x05	; 5
    177e:	02 96       	adiw	r24, 0x02	; 2
    1780:	fc 01       	movw	r30, r24
    1782:	80 81       	ld	r24, Z
    1784:	82 95       	swap	r24
    1786:	86 95       	lsr	r24
    1788:	87 70       	andi	r24, 0x07	; 7
    178a:	84 0f       	add	r24, r20
    178c:	f9 01       	movw	r30, r18
    178e:	80 83       	st	Z, r24
    1790:	26 ef       	ldi	r18, 0xF6	; 246
    1792:	30 e0       	ldi	r19, 0x00	; 0
    1794:	ce 01       	movw	r24, r28
    1796:	05 96       	adiw	r24, 0x05	; 5
    1798:	02 96       	adiw	r24, 0x02	; 2
    179a:	fc 01       	movw	r30, r24
    179c:	80 81       	ld	r24, Z
    179e:	48 2f       	mov	r20, r24
    17a0:	44 0f       	add	r20, r20
    17a2:	44 0f       	add	r20, r20
    17a4:	44 0f       	add	r20, r20
    17a6:	ce 01       	movw	r24, r28
    17a8:	05 96       	adiw	r24, 0x05	; 5
    17aa:	01 96       	adiw	r24, 0x01	; 1
    17ac:	fc 01       	movw	r30, r24
    17ae:	80 81       	ld	r24, Z
    17b0:	82 95       	swap	r24
    17b2:	86 95       	lsr	r24
    17b4:	87 70       	andi	r24, 0x07	; 7
    17b6:	84 0f       	add	r24, r20
    17b8:	f9 01       	movw	r30, r18
    17ba:	80 83       	st	Z, r24
    17bc:	25 ef       	ldi	r18, 0xF5	; 245
    17be:	30 e0       	ldi	r19, 0x00	; 0
    17c0:	ce 01       	movw	r24, r28
    17c2:	05 96       	adiw	r24, 0x05	; 5
    17c4:	01 96       	adiw	r24, 0x01	; 1
    17c6:	fc 01       	movw	r30, r24
    17c8:	80 81       	ld	r24, Z
    17ca:	48 2f       	mov	r20, r24
    17cc:	44 0f       	add	r20, r20
    17ce:	44 0f       	add	r20, r20
    17d0:	44 0f       	add	r20, r20
    17d2:	ce 01       	movw	r24, r28
    17d4:	05 96       	adiw	r24, 0x05	; 5
    17d6:	fc 01       	movw	r30, r24
    17d8:	80 81       	ld	r24, Z
    17da:	82 95       	swap	r24
    17dc:	86 95       	lsr	r24
    17de:	87 70       	andi	r24, 0x07	; 7
    17e0:	84 0f       	add	r24, r20
    17e2:	f9 01       	movw	r30, r18
    17e4:	80 83       	st	Z, r24
    17e6:	84 ef       	ldi	r24, 0xF4	; 244
    17e8:	90 e0       	ldi	r25, 0x00	; 0
    17ea:	9e 01       	movw	r18, r28
    17ec:	2b 5f       	subi	r18, 0xFB	; 251
    17ee:	3f 4f       	sbci	r19, 0xFF	; 255
    17f0:	f9 01       	movw	r30, r18
    17f2:	20 81       	ld	r18, Z
    17f4:	22 0f       	add	r18, r18
    17f6:	22 0f       	add	r18, r18
    17f8:	22 0f       	add	r18, r18
    17fa:	fc 01       	movw	r30, r24
    17fc:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    17fe:	8f ee       	ldi	r24, 0xEF	; 239
    1800:	90 e0       	ldi	r25, 0x00	; 0
    1802:	2f ee       	ldi	r18, 0xEF	; 239
    1804:	30 e0       	ldi	r19, 0x00	; 0
    1806:	f9 01       	movw	r30, r18
    1808:	40 81       	ld	r20, Z
    180a:	29 85       	ldd	r18, Y+9	; 0x09
    180c:	3a 85       	ldd	r19, Y+10	; 0x0a
    180e:	f9 01       	movw	r30, r18
    1810:	26 81       	ldd	r18, Z+6	; 0x06
    1812:	24 2b       	or	r18, r20
    1814:	fc 01       	movw	r30, r24
    1816:	20 83       	st	Z, r18
          cmd->ctrl.rtr=1; Can_set_rtrmsk(); Can_set_rtr();
    1818:	89 85       	ldd	r24, Y+9	; 0x09
    181a:	9a 85       	ldd	r25, Y+10	; 0x0a
    181c:	21 e0       	ldi	r18, 0x01	; 1
    181e:	fc 01       	movw	r30, r24
    1820:	22 87       	std	Z+10, r18	; 0x0a
    1822:	84 ef       	ldi	r24, 0xF4	; 244
    1824:	90 e0       	ldi	r25, 0x00	; 0
    1826:	24 ef       	ldi	r18, 0xF4	; 244
    1828:	30 e0       	ldi	r19, 0x00	; 0
    182a:	f9 01       	movw	r30, r18
    182c:	20 81       	ld	r18, Z
    182e:	24 60       	ori	r18, 0x04	; 4
    1830:	fc 01       	movw	r30, r24
    1832:	20 83       	st	Z, r18
    1834:	80 ef       	ldi	r24, 0xF0	; 240
    1836:	90 e0       	ldi	r25, 0x00	; 0
    1838:	20 ef       	ldi	r18, 0xF0	; 240
    183a:	30 e0       	ldi	r19, 0x00	; 0
    183c:	f9 01       	movw	r30, r18
    183e:	20 81       	ld	r18, Z
    1840:	24 60       	ori	r18, 0x04	; 4
    1842:	fc 01       	movw	r30, r24
    1844:	20 83       	st	Z, r18
          Can_clear_rplv();
    1846:	8f ee       	ldi	r24, 0xEF	; 239
    1848:	90 e0       	ldi	r25, 0x00	; 0
    184a:	2f ee       	ldi	r18, 0xEF	; 239
    184c:	30 e0       	ldi	r19, 0x00	; 0
    184e:	f9 01       	movw	r30, r18
    1850:	20 81       	ld	r18, Z
    1852:	2f 7d       	andi	r18, 0xDF	; 223
    1854:	fc 01       	movw	r30, r24
    1856:	20 83       	st	Z, r18
          Can_set_idemsk();
    1858:	84 ef       	ldi	r24, 0xF4	; 244
    185a:	90 e0       	ldi	r25, 0x00	; 0
    185c:	24 ef       	ldi	r18, 0xF4	; 244
    185e:	30 e0       	ldi	r19, 0x00	; 0
    1860:	f9 01       	movw	r30, r18
    1862:	20 81       	ld	r18, Z
    1864:	21 60       	ori	r18, 0x01	; 1
    1866:	fc 01       	movw	r30, r24
    1868:	20 83       	st	Z, r18
          Can_config_rx();       
    186a:	8f ee       	ldi	r24, 0xEF	; 239
    186c:	90 e0       	ldi	r25, 0x00	; 0
    186e:	2f ee       	ldi	r18, 0xEF	; 239
    1870:	30 e0       	ldi	r19, 0x00	; 0
    1872:	f9 01       	movw	r30, r18
    1874:	20 81       	ld	r18, Z
    1876:	2f 73       	andi	r18, 0x3F	; 63
    1878:	fc 01       	movw	r30, r24
    187a:	20 83       	st	Z, r18
    187c:	8f ee       	ldi	r24, 0xEF	; 239
    187e:	90 e0       	ldi	r25, 0x00	; 0
    1880:	2f ee       	ldi	r18, 0xEF	; 239
    1882:	30 e0       	ldi	r19, 0x00	; 0
    1884:	f9 01       	movw	r30, r18
    1886:	20 81       	ld	r18, Z
    1888:	20 68       	ori	r18, 0x80	; 128
    188a:	fc 01       	movw	r30, r24
    188c:	20 83       	st	Z, r18
          break;
    188e:	14 c2       	rjmp	.+1064   	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_REPLY:
          for (cpt=0;cpt<cmd->dlc;cpt++) CANMSG = *(cmd->pt_data + cpt);
    1890:	19 82       	std	Y+1, r1	; 0x01
    1892:	13 c0       	rjmp	.+38     	; 0x18ba <__stack+0x7bb>
    1894:	8a ef       	ldi	r24, 0xFA	; 250
    1896:	90 e0       	ldi	r25, 0x00	; 0
    1898:	29 85       	ldd	r18, Y+9	; 0x09
    189a:	3a 85       	ldd	r19, Y+10	; 0x0a
    189c:	f9 01       	movw	r30, r18
    189e:	47 81       	ldd	r20, Z+7	; 0x07
    18a0:	50 85       	ldd	r21, Z+8	; 0x08
    18a2:	29 81       	ldd	r18, Y+1	; 0x01
    18a4:	22 2f       	mov	r18, r18
    18a6:	30 e0       	ldi	r19, 0x00	; 0
    18a8:	24 0f       	add	r18, r20
    18aa:	35 1f       	adc	r19, r21
    18ac:	f9 01       	movw	r30, r18
    18ae:	20 81       	ld	r18, Z
    18b0:	fc 01       	movw	r30, r24
    18b2:	20 83       	st	Z, r18
    18b4:	89 81       	ldd	r24, Y+1	; 0x01
    18b6:	8f 5f       	subi	r24, 0xFF	; 255
    18b8:	89 83       	std	Y+1, r24	; 0x01
    18ba:	89 85       	ldd	r24, Y+9	; 0x09
    18bc:	9a 85       	ldd	r25, Y+10	; 0x0a
    18be:	fc 01       	movw	r30, r24
    18c0:	96 81       	ldd	r25, Z+6	; 0x06
    18c2:	89 81       	ldd	r24, Y+1	; 0x01
    18c4:	89 17       	cp	r24, r25
    18c6:	30 f3       	brcs	.-52     	; 0x1894 <__stack+0x795>
          u32_temp=0; Can_set_ext_msk(u32_temp);
    18c8:	1d 82       	std	Y+5, r1	; 0x05
    18ca:	1e 82       	std	Y+6, r1	; 0x06
    18cc:	1f 82       	std	Y+7, r1	; 0x07
    18ce:	18 86       	std	Y+8, r1	; 0x08
    18d0:	27 ef       	ldi	r18, 0xF7	; 247
    18d2:	30 e0       	ldi	r19, 0x00	; 0
    18d4:	ce 01       	movw	r24, r28
    18d6:	05 96       	adiw	r24, 0x05	; 5
    18d8:	03 96       	adiw	r24, 0x03	; 3
    18da:	fc 01       	movw	r30, r24
    18dc:	80 81       	ld	r24, Z
    18de:	48 2f       	mov	r20, r24
    18e0:	44 0f       	add	r20, r20
    18e2:	44 0f       	add	r20, r20
    18e4:	44 0f       	add	r20, r20
    18e6:	ce 01       	movw	r24, r28
    18e8:	05 96       	adiw	r24, 0x05	; 5
    18ea:	02 96       	adiw	r24, 0x02	; 2
    18ec:	fc 01       	movw	r30, r24
    18ee:	80 81       	ld	r24, Z
    18f0:	82 95       	swap	r24
    18f2:	86 95       	lsr	r24
    18f4:	87 70       	andi	r24, 0x07	; 7
    18f6:	84 0f       	add	r24, r20
    18f8:	f9 01       	movw	r30, r18
    18fa:	80 83       	st	Z, r24
    18fc:	26 ef       	ldi	r18, 0xF6	; 246
    18fe:	30 e0       	ldi	r19, 0x00	; 0
    1900:	ce 01       	movw	r24, r28
    1902:	05 96       	adiw	r24, 0x05	; 5
    1904:	02 96       	adiw	r24, 0x02	; 2
    1906:	fc 01       	movw	r30, r24
    1908:	80 81       	ld	r24, Z
    190a:	48 2f       	mov	r20, r24
    190c:	44 0f       	add	r20, r20
    190e:	44 0f       	add	r20, r20
    1910:	44 0f       	add	r20, r20
    1912:	ce 01       	movw	r24, r28
    1914:	05 96       	adiw	r24, 0x05	; 5
    1916:	01 96       	adiw	r24, 0x01	; 1
    1918:	fc 01       	movw	r30, r24
    191a:	80 81       	ld	r24, Z
    191c:	82 95       	swap	r24
    191e:	86 95       	lsr	r24
    1920:	87 70       	andi	r24, 0x07	; 7
    1922:	84 0f       	add	r24, r20
    1924:	f9 01       	movw	r30, r18
    1926:	80 83       	st	Z, r24
    1928:	25 ef       	ldi	r18, 0xF5	; 245
    192a:	30 e0       	ldi	r19, 0x00	; 0
    192c:	ce 01       	movw	r24, r28
    192e:	05 96       	adiw	r24, 0x05	; 5
    1930:	01 96       	adiw	r24, 0x01	; 1
    1932:	fc 01       	movw	r30, r24
    1934:	80 81       	ld	r24, Z
    1936:	48 2f       	mov	r20, r24
    1938:	44 0f       	add	r20, r20
    193a:	44 0f       	add	r20, r20
    193c:	44 0f       	add	r20, r20
    193e:	ce 01       	movw	r24, r28
    1940:	05 96       	adiw	r24, 0x05	; 5
    1942:	fc 01       	movw	r30, r24
    1944:	80 81       	ld	r24, Z
    1946:	82 95       	swap	r24
    1948:	86 95       	lsr	r24
    194a:	87 70       	andi	r24, 0x07	; 7
    194c:	84 0f       	add	r24, r20
    194e:	f9 01       	movw	r30, r18
    1950:	80 83       	st	Z, r24
    1952:	84 ef       	ldi	r24, 0xF4	; 244
    1954:	90 e0       	ldi	r25, 0x00	; 0
    1956:	9e 01       	movw	r18, r28
    1958:	2b 5f       	subi	r18, 0xFB	; 251
    195a:	3f 4f       	sbci	r19, 0xFF	; 255
    195c:	f9 01       	movw	r30, r18
    195e:	20 81       	ld	r18, Z
    1960:	22 0f       	add	r18, r18
    1962:	22 0f       	add	r18, r18
    1964:	22 0f       	add	r18, r18
    1966:	fc 01       	movw	r30, r24
    1968:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    196a:	8f ee       	ldi	r24, 0xEF	; 239
    196c:	90 e0       	ldi	r25, 0x00	; 0
    196e:	2f ee       	ldi	r18, 0xEF	; 239
    1970:	30 e0       	ldi	r19, 0x00	; 0
    1972:	f9 01       	movw	r30, r18
    1974:	40 81       	ld	r20, Z
    1976:	29 85       	ldd	r18, Y+9	; 0x09
    1978:	3a 85       	ldd	r19, Y+10	; 0x0a
    197a:	f9 01       	movw	r30, r18
    197c:	26 81       	ldd	r18, Z+6	; 0x06
    197e:	24 2b       	or	r18, r20
    1980:	fc 01       	movw	r30, r24
    1982:	20 83       	st	Z, r18
          cmd->ctrl.rtr=1; Can_set_rtrmsk(); Can_set_rtr();
    1984:	89 85       	ldd	r24, Y+9	; 0x09
    1986:	9a 85       	ldd	r25, Y+10	; 0x0a
    1988:	21 e0       	ldi	r18, 0x01	; 1
    198a:	fc 01       	movw	r30, r24
    198c:	22 87       	std	Z+10, r18	; 0x0a
    198e:	84 ef       	ldi	r24, 0xF4	; 244
    1990:	90 e0       	ldi	r25, 0x00	; 0
    1992:	24 ef       	ldi	r18, 0xF4	; 244
    1994:	30 e0       	ldi	r19, 0x00	; 0
    1996:	f9 01       	movw	r30, r18
    1998:	20 81       	ld	r18, Z
    199a:	24 60       	ori	r18, 0x04	; 4
    199c:	fc 01       	movw	r30, r24
    199e:	20 83       	st	Z, r18
    19a0:	80 ef       	ldi	r24, 0xF0	; 240
    19a2:	90 e0       	ldi	r25, 0x00	; 0
    19a4:	20 ef       	ldi	r18, 0xF0	; 240
    19a6:	30 e0       	ldi	r19, 0x00	; 0
    19a8:	f9 01       	movw	r30, r18
    19aa:	20 81       	ld	r18, Z
    19ac:	24 60       	ori	r18, 0x04	; 4
    19ae:	fc 01       	movw	r30, r24
    19b0:	20 83       	st	Z, r18
          Can_set_rplv();
    19b2:	8f ee       	ldi	r24, 0xEF	; 239
    19b4:	90 e0       	ldi	r25, 0x00	; 0
    19b6:	2f ee       	ldi	r18, 0xEF	; 239
    19b8:	30 e0       	ldi	r19, 0x00	; 0
    19ba:	f9 01       	movw	r30, r18
    19bc:	20 81       	ld	r18, Z
    19be:	20 62       	ori	r18, 0x20	; 32
    19c0:	fc 01       	movw	r30, r24
    19c2:	20 83       	st	Z, r18
          Can_clear_idemsk();
    19c4:	84 ef       	ldi	r24, 0xF4	; 244
    19c6:	90 e0       	ldi	r25, 0x00	; 0
    19c8:	24 ef       	ldi	r18, 0xF4	; 244
    19ca:	30 e0       	ldi	r19, 0x00	; 0
    19cc:	f9 01       	movw	r30, r18
    19ce:	20 81       	ld	r18, Z
    19d0:	2e 7f       	andi	r18, 0xFE	; 254
    19d2:	fc 01       	movw	r30, r24
    19d4:	20 83       	st	Z, r18
          Can_config_rx();       
    19d6:	8f ee       	ldi	r24, 0xEF	; 239
    19d8:	90 e0       	ldi	r25, 0x00	; 0
    19da:	2f ee       	ldi	r18, 0xEF	; 239
    19dc:	30 e0       	ldi	r19, 0x00	; 0
    19de:	f9 01       	movw	r30, r18
    19e0:	20 81       	ld	r18, Z
    19e2:	2f 73       	andi	r18, 0x3F	; 63
    19e4:	fc 01       	movw	r30, r24
    19e6:	20 83       	st	Z, r18
    19e8:	8f ee       	ldi	r24, 0xEF	; 239
    19ea:	90 e0       	ldi	r25, 0x00	; 0
    19ec:	2f ee       	ldi	r18, 0xEF	; 239
    19ee:	30 e0       	ldi	r19, 0x00	; 0
    19f0:	f9 01       	movw	r30, r18
    19f2:	20 81       	ld	r18, Z
    19f4:	20 68       	ori	r18, 0x80	; 128
    19f6:	fc 01       	movw	r30, r24
    19f8:	20 83       	st	Z, r18
          break;
    19fa:	5e c1       	rjmp	.+700    	; 0x1cb8 <__stack+0xbb9>
        //------------      
        case CMD_REPLY_MASKED:
          if (cmd->ctrl.ide){ Can_set_ext_id(cmd->id.ext);}
    19fc:	89 85       	ldd	r24, Y+9	; 0x09
    19fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a00:	fc 01       	movw	r30, r24
    1a02:	83 85       	ldd	r24, Z+11	; 0x0b
    1a04:	88 23       	and	r24, r24
    1a06:	09 f4       	brne	.+2      	; 0x1a0a <__stack+0x90b>
    1a08:	69 c0       	rjmp	.+210    	; 0x1adc <__stack+0x9dd>
    1a0a:	83 ef       	ldi	r24, 0xF3	; 243
    1a0c:	90 e0       	ldi	r25, 0x00	; 0
    1a0e:	29 85       	ldd	r18, Y+9	; 0x09
    1a10:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a12:	2e 5f       	subi	r18, 0xFE	; 254
    1a14:	3f 4f       	sbci	r19, 0xFF	; 255
    1a16:	2d 5f       	subi	r18, 0xFD	; 253
    1a18:	3f 4f       	sbci	r19, 0xFF	; 255
    1a1a:	f9 01       	movw	r30, r18
    1a1c:	20 81       	ld	r18, Z
    1a1e:	42 2f       	mov	r20, r18
    1a20:	44 0f       	add	r20, r20
    1a22:	44 0f       	add	r20, r20
    1a24:	44 0f       	add	r20, r20
    1a26:	29 85       	ldd	r18, Y+9	; 0x09
    1a28:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a2a:	2e 5f       	subi	r18, 0xFE	; 254
    1a2c:	3f 4f       	sbci	r19, 0xFF	; 255
    1a2e:	2e 5f       	subi	r18, 0xFE	; 254
    1a30:	3f 4f       	sbci	r19, 0xFF	; 255
    1a32:	f9 01       	movw	r30, r18
    1a34:	20 81       	ld	r18, Z
    1a36:	22 95       	swap	r18
    1a38:	26 95       	lsr	r18
    1a3a:	27 70       	andi	r18, 0x07	; 7
    1a3c:	24 0f       	add	r18, r20
    1a3e:	fc 01       	movw	r30, r24
    1a40:	20 83       	st	Z, r18
    1a42:	82 ef       	ldi	r24, 0xF2	; 242
    1a44:	90 e0       	ldi	r25, 0x00	; 0
    1a46:	29 85       	ldd	r18, Y+9	; 0x09
    1a48:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a4a:	2e 5f       	subi	r18, 0xFE	; 254
    1a4c:	3f 4f       	sbci	r19, 0xFF	; 255
    1a4e:	2e 5f       	subi	r18, 0xFE	; 254
    1a50:	3f 4f       	sbci	r19, 0xFF	; 255
    1a52:	f9 01       	movw	r30, r18
    1a54:	20 81       	ld	r18, Z
    1a56:	42 2f       	mov	r20, r18
    1a58:	44 0f       	add	r20, r20
    1a5a:	44 0f       	add	r20, r20
    1a5c:	44 0f       	add	r20, r20
    1a5e:	29 85       	ldd	r18, Y+9	; 0x09
    1a60:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a62:	2e 5f       	subi	r18, 0xFE	; 254
    1a64:	3f 4f       	sbci	r19, 0xFF	; 255
    1a66:	2f 5f       	subi	r18, 0xFF	; 255
    1a68:	3f 4f       	sbci	r19, 0xFF	; 255
    1a6a:	f9 01       	movw	r30, r18
    1a6c:	20 81       	ld	r18, Z
    1a6e:	22 95       	swap	r18
    1a70:	26 95       	lsr	r18
    1a72:	27 70       	andi	r18, 0x07	; 7
    1a74:	24 0f       	add	r18, r20
    1a76:	fc 01       	movw	r30, r24
    1a78:	20 83       	st	Z, r18
    1a7a:	81 ef       	ldi	r24, 0xF1	; 241
    1a7c:	90 e0       	ldi	r25, 0x00	; 0
    1a7e:	29 85       	ldd	r18, Y+9	; 0x09
    1a80:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a82:	2e 5f       	subi	r18, 0xFE	; 254
    1a84:	3f 4f       	sbci	r19, 0xFF	; 255
    1a86:	2f 5f       	subi	r18, 0xFF	; 255
    1a88:	3f 4f       	sbci	r19, 0xFF	; 255
    1a8a:	f9 01       	movw	r30, r18
    1a8c:	20 81       	ld	r18, Z
    1a8e:	42 2f       	mov	r20, r18
    1a90:	44 0f       	add	r20, r20
    1a92:	44 0f       	add	r20, r20
    1a94:	44 0f       	add	r20, r20
    1a96:	29 85       	ldd	r18, Y+9	; 0x09
    1a98:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a9a:	2e 5f       	subi	r18, 0xFE	; 254
    1a9c:	3f 4f       	sbci	r19, 0xFF	; 255
    1a9e:	f9 01       	movw	r30, r18
    1aa0:	20 81       	ld	r18, Z
    1aa2:	22 95       	swap	r18
    1aa4:	26 95       	lsr	r18
    1aa6:	27 70       	andi	r18, 0x07	; 7
    1aa8:	24 0f       	add	r18, r20
    1aaa:	fc 01       	movw	r30, r24
    1aac:	20 83       	st	Z, r18
    1aae:	80 ef       	ldi	r24, 0xF0	; 240
    1ab0:	90 e0       	ldi	r25, 0x00	; 0
    1ab2:	29 85       	ldd	r18, Y+9	; 0x09
    1ab4:	3a 85       	ldd	r19, Y+10	; 0x0a
    1ab6:	2e 5f       	subi	r18, 0xFE	; 254
    1ab8:	3f 4f       	sbci	r19, 0xFF	; 255
    1aba:	f9 01       	movw	r30, r18
    1abc:	20 81       	ld	r18, Z
    1abe:	22 0f       	add	r18, r18
    1ac0:	22 0f       	add	r18, r18
    1ac2:	22 0f       	add	r18, r18
    1ac4:	fc 01       	movw	r30, r24
    1ac6:	20 83       	st	Z, r18
    1ac8:	8f ee       	ldi	r24, 0xEF	; 239
    1aca:	90 e0       	ldi	r25, 0x00	; 0
    1acc:	2f ee       	ldi	r18, 0xEF	; 239
    1ace:	30 e0       	ldi	r19, 0x00	; 0
    1ad0:	f9 01       	movw	r30, r18
    1ad2:	20 81       	ld	r18, Z
    1ad4:	20 61       	ori	r18, 0x10	; 16
    1ad6:	fc 01       	movw	r30, r24
    1ad8:	20 83       	st	Z, r18
    1ada:	30 c0       	rjmp	.+96     	; 0x1b3c <__stack+0xa3d>
          else              { Can_set_std_id(cmd->id.std);}
    1adc:	83 ef       	ldi	r24, 0xF3	; 243
    1ade:	90 e0       	ldi	r25, 0x00	; 0
    1ae0:	29 85       	ldd	r18, Y+9	; 0x09
    1ae2:	3a 85       	ldd	r19, Y+10	; 0x0a
    1ae4:	2e 5f       	subi	r18, 0xFE	; 254
    1ae6:	3f 4f       	sbci	r19, 0xFF	; 255
    1ae8:	2f 5f       	subi	r18, 0xFF	; 255
    1aea:	3f 4f       	sbci	r19, 0xFF	; 255
    1aec:	f9 01       	movw	r30, r18
    1aee:	20 81       	ld	r18, Z
    1af0:	42 2f       	mov	r20, r18
    1af2:	42 95       	swap	r20
    1af4:	44 0f       	add	r20, r20
    1af6:	40 7e       	andi	r20, 0xE0	; 224
    1af8:	29 85       	ldd	r18, Y+9	; 0x09
    1afa:	3a 85       	ldd	r19, Y+10	; 0x0a
    1afc:	2e 5f       	subi	r18, 0xFE	; 254
    1afe:	3f 4f       	sbci	r19, 0xFF	; 255
    1b00:	f9 01       	movw	r30, r18
    1b02:	20 81       	ld	r18, Z
    1b04:	26 95       	lsr	r18
    1b06:	26 95       	lsr	r18
    1b08:	26 95       	lsr	r18
    1b0a:	24 0f       	add	r18, r20
    1b0c:	fc 01       	movw	r30, r24
    1b0e:	20 83       	st	Z, r18
    1b10:	82 ef       	ldi	r24, 0xF2	; 242
    1b12:	90 e0       	ldi	r25, 0x00	; 0
    1b14:	29 85       	ldd	r18, Y+9	; 0x09
    1b16:	3a 85       	ldd	r19, Y+10	; 0x0a
    1b18:	2e 5f       	subi	r18, 0xFE	; 254
    1b1a:	3f 4f       	sbci	r19, 0xFF	; 255
    1b1c:	f9 01       	movw	r30, r18
    1b1e:	20 81       	ld	r18, Z
    1b20:	22 95       	swap	r18
    1b22:	22 0f       	add	r18, r18
    1b24:	20 7e       	andi	r18, 0xE0	; 224
    1b26:	fc 01       	movw	r30, r24
    1b28:	20 83       	st	Z, r18
    1b2a:	8f ee       	ldi	r24, 0xEF	; 239
    1b2c:	90 e0       	ldi	r25, 0x00	; 0
    1b2e:	2f ee       	ldi	r18, 0xEF	; 239
    1b30:	30 e0       	ldi	r19, 0x00	; 0
    1b32:	f9 01       	movw	r30, r18
    1b34:	20 81       	ld	r18, Z
    1b36:	2f 7e       	andi	r18, 0xEF	; 239
    1b38:	fc 01       	movw	r30, r24
    1b3a:	20 83       	st	Z, r18
          for (cpt=0;cpt<cmd->dlc;cpt++) CANMSG = *(cmd->pt_data + cpt);
    1b3c:	19 82       	std	Y+1, r1	; 0x01
    1b3e:	13 c0       	rjmp	.+38     	; 0x1b66 <__stack+0xa67>
    1b40:	8a ef       	ldi	r24, 0xFA	; 250
    1b42:	90 e0       	ldi	r25, 0x00	; 0
    1b44:	29 85       	ldd	r18, Y+9	; 0x09
    1b46:	3a 85       	ldd	r19, Y+10	; 0x0a
    1b48:	f9 01       	movw	r30, r18
    1b4a:	47 81       	ldd	r20, Z+7	; 0x07
    1b4c:	50 85       	ldd	r21, Z+8	; 0x08
    1b4e:	29 81       	ldd	r18, Y+1	; 0x01
    1b50:	22 2f       	mov	r18, r18
    1b52:	30 e0       	ldi	r19, 0x00	; 0
    1b54:	24 0f       	add	r18, r20
    1b56:	35 1f       	adc	r19, r21
    1b58:	f9 01       	movw	r30, r18
    1b5a:	20 81       	ld	r18, Z
    1b5c:	fc 01       	movw	r30, r24
    1b5e:	20 83       	st	Z, r18
    1b60:	89 81       	ldd	r24, Y+1	; 0x01
    1b62:	8f 5f       	subi	r24, 0xFF	; 255
    1b64:	89 83       	std	Y+1, r24	; 0x01
    1b66:	89 85       	ldd	r24, Y+9	; 0x09
    1b68:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b6a:	fc 01       	movw	r30, r24
    1b6c:	96 81       	ldd	r25, Z+6	; 0x06
    1b6e:	89 81       	ldd	r24, Y+1	; 0x01
    1b70:	89 17       	cp	r24, r25
    1b72:	30 f3       	brcs	.-52     	; 0x1b40 <__stack+0xa41>
          u32_temp=~0; Can_set_ext_msk(u32_temp);
    1b74:	8f ef       	ldi	r24, 0xFF	; 255
    1b76:	9f ef       	ldi	r25, 0xFF	; 255
    1b78:	dc 01       	movw	r26, r24
    1b7a:	8d 83       	std	Y+5, r24	; 0x05
    1b7c:	9e 83       	std	Y+6, r25	; 0x06
    1b7e:	af 83       	std	Y+7, r26	; 0x07
    1b80:	b8 87       	std	Y+8, r27	; 0x08
    1b82:	27 ef       	ldi	r18, 0xF7	; 247
    1b84:	30 e0       	ldi	r19, 0x00	; 0
    1b86:	ce 01       	movw	r24, r28
    1b88:	05 96       	adiw	r24, 0x05	; 5
    1b8a:	03 96       	adiw	r24, 0x03	; 3
    1b8c:	fc 01       	movw	r30, r24
    1b8e:	80 81       	ld	r24, Z
    1b90:	48 2f       	mov	r20, r24
    1b92:	44 0f       	add	r20, r20
    1b94:	44 0f       	add	r20, r20
    1b96:	44 0f       	add	r20, r20
    1b98:	ce 01       	movw	r24, r28
    1b9a:	05 96       	adiw	r24, 0x05	; 5
    1b9c:	02 96       	adiw	r24, 0x02	; 2
    1b9e:	fc 01       	movw	r30, r24
    1ba0:	80 81       	ld	r24, Z
    1ba2:	82 95       	swap	r24
    1ba4:	86 95       	lsr	r24
    1ba6:	87 70       	andi	r24, 0x07	; 7
    1ba8:	84 0f       	add	r24, r20
    1baa:	f9 01       	movw	r30, r18
    1bac:	80 83       	st	Z, r24
    1bae:	26 ef       	ldi	r18, 0xF6	; 246
    1bb0:	30 e0       	ldi	r19, 0x00	; 0
    1bb2:	ce 01       	movw	r24, r28
    1bb4:	05 96       	adiw	r24, 0x05	; 5
    1bb6:	02 96       	adiw	r24, 0x02	; 2
    1bb8:	fc 01       	movw	r30, r24
    1bba:	80 81       	ld	r24, Z
    1bbc:	48 2f       	mov	r20, r24
    1bbe:	44 0f       	add	r20, r20
    1bc0:	44 0f       	add	r20, r20
    1bc2:	44 0f       	add	r20, r20
    1bc4:	ce 01       	movw	r24, r28
    1bc6:	05 96       	adiw	r24, 0x05	; 5
    1bc8:	01 96       	adiw	r24, 0x01	; 1
    1bca:	fc 01       	movw	r30, r24
    1bcc:	80 81       	ld	r24, Z
    1bce:	82 95       	swap	r24
    1bd0:	86 95       	lsr	r24
    1bd2:	87 70       	andi	r24, 0x07	; 7
    1bd4:	84 0f       	add	r24, r20
    1bd6:	f9 01       	movw	r30, r18
    1bd8:	80 83       	st	Z, r24
    1bda:	25 ef       	ldi	r18, 0xF5	; 245
    1bdc:	30 e0       	ldi	r19, 0x00	; 0
    1bde:	ce 01       	movw	r24, r28
    1be0:	05 96       	adiw	r24, 0x05	; 5
    1be2:	01 96       	adiw	r24, 0x01	; 1
    1be4:	fc 01       	movw	r30, r24
    1be6:	80 81       	ld	r24, Z
    1be8:	48 2f       	mov	r20, r24
    1bea:	44 0f       	add	r20, r20
    1bec:	44 0f       	add	r20, r20
    1bee:	44 0f       	add	r20, r20
    1bf0:	ce 01       	movw	r24, r28
    1bf2:	05 96       	adiw	r24, 0x05	; 5
    1bf4:	fc 01       	movw	r30, r24
    1bf6:	80 81       	ld	r24, Z
    1bf8:	82 95       	swap	r24
    1bfa:	86 95       	lsr	r24
    1bfc:	87 70       	andi	r24, 0x07	; 7
    1bfe:	84 0f       	add	r24, r20
    1c00:	f9 01       	movw	r30, r18
    1c02:	80 83       	st	Z, r24
    1c04:	84 ef       	ldi	r24, 0xF4	; 244
    1c06:	90 e0       	ldi	r25, 0x00	; 0
    1c08:	9e 01       	movw	r18, r28
    1c0a:	2b 5f       	subi	r18, 0xFB	; 251
    1c0c:	3f 4f       	sbci	r19, 0xFF	; 255
    1c0e:	f9 01       	movw	r30, r18
    1c10:	20 81       	ld	r18, Z
    1c12:	22 0f       	add	r18, r18
    1c14:	22 0f       	add	r18, r18
    1c16:	22 0f       	add	r18, r18
    1c18:	fc 01       	movw	r30, r24
    1c1a:	20 83       	st	Z, r18
          Can_set_dlc(cmd->dlc);
    1c1c:	8f ee       	ldi	r24, 0xEF	; 239
    1c1e:	90 e0       	ldi	r25, 0x00	; 0
    1c20:	2f ee       	ldi	r18, 0xEF	; 239
    1c22:	30 e0       	ldi	r19, 0x00	; 0
    1c24:	f9 01       	movw	r30, r18
    1c26:	40 81       	ld	r20, Z
    1c28:	29 85       	ldd	r18, Y+9	; 0x09
    1c2a:	3a 85       	ldd	r19, Y+10	; 0x0a
    1c2c:	f9 01       	movw	r30, r18
    1c2e:	26 81       	ldd	r18, Z+6	; 0x06
    1c30:	24 2b       	or	r18, r20
    1c32:	fc 01       	movw	r30, r24
    1c34:	20 83       	st	Z, r18
          cmd->ctrl.rtr=1; Can_set_rtrmsk(); Can_set_rtr();
    1c36:	89 85       	ldd	r24, Y+9	; 0x09
    1c38:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c3a:	21 e0       	ldi	r18, 0x01	; 1
    1c3c:	fc 01       	movw	r30, r24
    1c3e:	22 87       	std	Z+10, r18	; 0x0a
    1c40:	84 ef       	ldi	r24, 0xF4	; 244
    1c42:	90 e0       	ldi	r25, 0x00	; 0
    1c44:	24 ef       	ldi	r18, 0xF4	; 244
    1c46:	30 e0       	ldi	r19, 0x00	; 0
    1c48:	f9 01       	movw	r30, r18
    1c4a:	20 81       	ld	r18, Z
    1c4c:	24 60       	ori	r18, 0x04	; 4
    1c4e:	fc 01       	movw	r30, r24
    1c50:	20 83       	st	Z, r18
    1c52:	80 ef       	ldi	r24, 0xF0	; 240
    1c54:	90 e0       	ldi	r25, 0x00	; 0
    1c56:	20 ef       	ldi	r18, 0xF0	; 240
    1c58:	30 e0       	ldi	r19, 0x00	; 0
    1c5a:	f9 01       	movw	r30, r18
    1c5c:	20 81       	ld	r18, Z
    1c5e:	24 60       	ori	r18, 0x04	; 4
    1c60:	fc 01       	movw	r30, r24
    1c62:	20 83       	st	Z, r18
          Can_set_rplv();
    1c64:	8f ee       	ldi	r24, 0xEF	; 239
    1c66:	90 e0       	ldi	r25, 0x00	; 0
    1c68:	2f ee       	ldi	r18, 0xEF	; 239
    1c6a:	30 e0       	ldi	r19, 0x00	; 0
    1c6c:	f9 01       	movw	r30, r18
    1c6e:	20 81       	ld	r18, Z
    1c70:	20 62       	ori	r18, 0x20	; 32
    1c72:	fc 01       	movw	r30, r24
    1c74:	20 83       	st	Z, r18
          Can_set_idemsk();
    1c76:	84 ef       	ldi	r24, 0xF4	; 244
    1c78:	90 e0       	ldi	r25, 0x00	; 0
    1c7a:	24 ef       	ldi	r18, 0xF4	; 244
    1c7c:	30 e0       	ldi	r19, 0x00	; 0
    1c7e:	f9 01       	movw	r30, r18
    1c80:	20 81       	ld	r18, Z
    1c82:	21 60       	ori	r18, 0x01	; 1
    1c84:	fc 01       	movw	r30, r24
    1c86:	20 83       	st	Z, r18
          Can_config_rx();       
    1c88:	8f ee       	ldi	r24, 0xEF	; 239
    1c8a:	90 e0       	ldi	r25, 0x00	; 0
    1c8c:	2f ee       	ldi	r18, 0xEF	; 239
    1c8e:	30 e0       	ldi	r19, 0x00	; 0
    1c90:	f9 01       	movw	r30, r18
    1c92:	20 81       	ld	r18, Z
    1c94:	2f 73       	andi	r18, 0x3F	; 63
    1c96:	fc 01       	movw	r30, r24
    1c98:	20 83       	st	Z, r18
    1c9a:	8f ee       	ldi	r24, 0xEF	; 239
    1c9c:	90 e0       	ldi	r25, 0x00	; 0
    1c9e:	2f ee       	ldi	r18, 0xEF	; 239
    1ca0:	30 e0       	ldi	r19, 0x00	; 0
    1ca2:	f9 01       	movw	r30, r18
    1ca4:	20 81       	ld	r18, Z
    1ca6:	20 68       	ori	r18, 0x80	; 128
    1ca8:	fc 01       	movw	r30, r24
    1caa:	20 83       	st	Z, r18
          break;
    1cac:	05 c0       	rjmp	.+10     	; 0x1cb8 <__stack+0xbb9>
        //------------      
        default:
          // case CMD_NONE or not implemented command
          cmd->status = STATUS_CLEARED; 
    1cae:	89 85       	ldd	r24, Y+9	; 0x09
    1cb0:	9a 85       	ldd	r25, Y+10	; 0x0a
    1cb2:	fc 01       	movw	r30, r24
    1cb4:	11 86       	std	Z+9, r1	; 0x09
          break;
    1cb6:	00 00       	nop
    1cb8:	07 c0       	rjmp	.+14     	; 0x1cc8 <__stack+0xbc9>
        //------------      
      } // switch (cmd ...
    } // if (mob_handle ...
    else
    {
      cmd->status = MOB_NOT_REACHED;
    1cba:	89 85       	ldd	r24, Y+9	; 0x09
    1cbc:	9a 85       	ldd	r25, Y+10	; 0x0a
    1cbe:	2f e1       	ldi	r18, 0x1F	; 31
    1cc0:	fc 01       	movw	r30, r24
    1cc2:	21 87       	std	Z+9, r18	; 0x09
      return CAN_CMD_REFUSED;
    1cc4:	8f ef       	ldi	r24, 0xFF	; 255
    1cc6:	01 c0       	rjmp	.+2      	; 0x1cca <__stack+0xbcb>
    }
  } // else of no CMD_ABORT
  return CAN_CMD_ACCEPTED;
    1cc8:	80 e0       	ldi	r24, 0x00	; 0
}
    1cca:	2a 96       	adiw	r28, 0x0a	; 10
    1ccc:	0f b6       	in	r0, 0x3f	; 63
    1cce:	f8 94       	cli
    1cd0:	de bf       	out	0x3e, r29	; 62
    1cd2:	0f be       	out	0x3f, r0	; 63
    1cd4:	cd bf       	out	0x3d, r28	; 61
    1cd6:	df 91       	pop	r29
    1cd8:	cf 91       	pop	r28
    1cda:	08 95       	ret

00001cdc <can_get_status>:
//!         CAN_STATUS_ERROR         - Error in configuration or in the
//!                                    CAN communication
//!
//------------------------------------------------------------------------------
uint8_t can_get_status (st_cmd_t* cmd)
{
    1cdc:	cf 93       	push	r28
    1cde:	df 93       	push	r29
    1ce0:	00 d0       	rcall	.+0      	; 0x1ce2 <can_get_status+0x6>
    1ce2:	00 d0       	rcall	.+0      	; 0x1ce4 <can_get_status+0x8>
    1ce4:	cd b7       	in	r28, 0x3d	; 61
    1ce6:	de b7       	in	r29, 0x3e	; 62
    1ce8:	9c 83       	std	Y+4, r25	; 0x04
    1cea:	8b 83       	std	Y+3, r24	; 0x03
    uint8_t a_status, rtn_val;
     
    a_status = cmd->status;
    1cec:	8b 81       	ldd	r24, Y+3	; 0x03
    1cee:	9c 81       	ldd	r25, Y+4	; 0x04
    1cf0:	fc 01       	movw	r30, r24
    1cf2:	81 85       	ldd	r24, Z+9	; 0x09
    1cf4:	8a 83       	std	Y+2, r24	; 0x02
    if ((a_status==STATUS_CLEARED)||(a_status==MOB_NOT_REACHED)||(a_status==MOB_DISABLE))
    1cf6:	8a 81       	ldd	r24, Y+2	; 0x02
    1cf8:	88 23       	and	r24, r24
    1cfa:	31 f0       	breq	.+12     	; 0x1d08 <can_get_status+0x2c>
    1cfc:	8a 81       	ldd	r24, Y+2	; 0x02
    1cfe:	8f 31       	cpi	r24, 0x1F	; 31
    1d00:	19 f0       	breq	.+6      	; 0x1d08 <can_get_status+0x2c>
    1d02:	8a 81       	ldd	r24, Y+2	; 0x02
    1d04:	8f 3f       	cpi	r24, 0xFF	; 255
    1d06:	11 f4       	brne	.+4      	; 0x1d0c <can_get_status+0x30>
    {
        return CAN_STATUS_ERROR;
    1d08:	82 e0       	ldi	r24, 0x02	; 2
    1d0a:	11 c1       	rjmp	.+546    	; 0x1f2e <can_get_status+0x252>
    }

    Can_set_mob(cmd->handle);
    1d0c:	8d ee       	ldi	r24, 0xED	; 237
    1d0e:	90 e0       	ldi	r25, 0x00	; 0
    1d10:	2b 81       	ldd	r18, Y+3	; 0x03
    1d12:	3c 81       	ldd	r19, Y+4	; 0x04
    1d14:	f9 01       	movw	r30, r18
    1d16:	20 81       	ld	r18, Z
    1d18:	22 95       	swap	r18
    1d1a:	20 7f       	andi	r18, 0xF0	; 240
    1d1c:	fc 01       	movw	r30, r24
    1d1e:	20 83       	st	Z, r18
    a_status = can_get_mob_status();
    1d20:	0e 94 cb 00 	call	0x196	; 0x196 <can_get_mob_status>
    1d24:	8a 83       	std	Y+2, r24	; 0x02
    
    switch (a_status)
    1d26:	8a 81       	ldd	r24, Y+2	; 0x02
    1d28:	88 2f       	mov	r24, r24
    1d2a:	90 e0       	ldi	r25, 0x00	; 0
    1d2c:	80 32       	cpi	r24, 0x20	; 32
    1d2e:	91 05       	cpc	r25, r1
    1d30:	89 f0       	breq	.+34     	; 0x1d54 <can_get_status+0x78>
    1d32:	81 32       	cpi	r24, 0x21	; 33
    1d34:	91 05       	cpc	r25, r1
    1d36:	1c f4       	brge	.+6      	; 0x1d3e <can_get_status+0x62>
    1d38:	89 2b       	or	r24, r25
    1d3a:	49 f0       	breq	.+18     	; 0x1d4e <can_get_status+0x72>
    1d3c:	e2 c0       	rjmp	.+452    	; 0x1f02 <can_get_status+0x226>
    1d3e:	80 34       	cpi	r24, 0x40	; 64
    1d40:	91 05       	cpc	r25, r1
    1d42:	09 f4       	brne	.+2      	; 0x1d46 <can_get_status+0x6a>
    1d44:	ca c0       	rjmp	.+404    	; 0x1eda <can_get_status+0x1fe>
    1d46:	80 3a       	cpi	r24, 0xA0	; 160
    1d48:	91 05       	cpc	r25, r1
    1d4a:	21 f0       	breq	.+8      	; 0x1d54 <can_get_status+0x78>
    1d4c:	da c0       	rjmp	.+436    	; 0x1f02 <can_get_status+0x226>
    {
        case MOB_NOT_COMPLETED:
            // cmd->status not updated
            rtn_val = CAN_STATUS_NOT_COMPLETED;
    1d4e:	81 e0       	ldi	r24, 0x01	; 1
    1d50:	89 83       	std	Y+1, r24	; 0x01
            break;
    1d52:	ec c0       	rjmp	.+472    	; 0x1f2c <can_get_status+0x250>
        //---------------      
        case MOB_RX_COMPLETED:     
        case MOB_RX_COMPLETED_DLCW:
            cmd->dlc = Can_get_dlc();
    1d54:	8f ee       	ldi	r24, 0xEF	; 239
    1d56:	90 e0       	ldi	r25, 0x00	; 0
    1d58:	fc 01       	movw	r30, r24
    1d5a:	80 81       	ld	r24, Z
    1d5c:	28 2f       	mov	r18, r24
    1d5e:	2f 70       	andi	r18, 0x0F	; 15
    1d60:	8b 81       	ldd	r24, Y+3	; 0x03
    1d62:	9c 81       	ldd	r25, Y+4	; 0x04
    1d64:	fc 01       	movw	r30, r24
    1d66:	26 83       	std	Z+6, r18	; 0x06
            can_get_data(cmd->pt_data);
    1d68:	8b 81       	ldd	r24, Y+3	; 0x03
    1d6a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d6c:	fc 01       	movw	r30, r24
    1d6e:	87 81       	ldd	r24, Z+7	; 0x07
    1d70:	90 85       	ldd	r25, Z+8	; 0x08
    1d72:	0e 94 fd 00 	call	0x1fa	; 0x1fa <can_get_data>
            cmd->ctrl.rtr = Can_get_rtr();
    1d76:	80 ef       	ldi	r24, 0xF0	; 240
    1d78:	90 e0       	ldi	r25, 0x00	; 0
    1d7a:	fc 01       	movw	r30, r24
    1d7c:	80 81       	ld	r24, Z
    1d7e:	88 2f       	mov	r24, r24
    1d80:	90 e0       	ldi	r25, 0x00	; 0
    1d82:	84 70       	andi	r24, 0x04	; 4
    1d84:	99 27       	eor	r25, r25
    1d86:	95 95       	asr	r25
    1d88:	87 95       	ror	r24
    1d8a:	95 95       	asr	r25
    1d8c:	87 95       	ror	r24
    1d8e:	28 2f       	mov	r18, r24
    1d90:	8b 81       	ldd	r24, Y+3	; 0x03
    1d92:	9c 81       	ldd	r25, Y+4	; 0x04
    1d94:	fc 01       	movw	r30, r24
    1d96:	22 87       	std	Z+10, r18	; 0x0a
            if (Can_get_ide()) // if extended frame
    1d98:	8f ee       	ldi	r24, 0xEF	; 239
    1d9a:	90 e0       	ldi	r25, 0x00	; 0
    1d9c:	fc 01       	movw	r30, r24
    1d9e:	80 81       	ld	r24, Z
    1da0:	88 2f       	mov	r24, r24
    1da2:	90 e0       	ldi	r25, 0x00	; 0
    1da4:	80 71       	andi	r24, 0x10	; 16
    1da6:	99 27       	eor	r25, r25
    1da8:	95 95       	asr	r25
    1daa:	87 95       	ror	r24
    1dac:	95 95       	asr	r25
    1dae:	87 95       	ror	r24
    1db0:	95 95       	asr	r25
    1db2:	87 95       	ror	r24
    1db4:	95 95       	asr	r25
    1db6:	87 95       	ror	r24
    1db8:	89 2b       	or	r24, r25
    1dba:	09 f4       	brne	.+2      	; 0x1dbe <can_get_status+0xe2>
    1dbc:	54 c0       	rjmp	.+168    	; 0x1e66 <can_get_status+0x18a>
            {
                cmd->ctrl.ide = 1; // extended frame
    1dbe:	8b 81       	ldd	r24, Y+3	; 0x03
    1dc0:	9c 81       	ldd	r25, Y+4	; 0x04
    1dc2:	21 e0       	ldi	r18, 0x01	; 1
    1dc4:	fc 01       	movw	r30, r24
    1dc6:	23 87       	std	Z+11, r18	; 0x0b
                Can_get_ext_id(cmd->id.ext);
    1dc8:	8b 81       	ldd	r24, Y+3	; 0x03
    1dca:	9c 81       	ldd	r25, Y+4	; 0x04
    1dcc:	02 96       	adiw	r24, 0x02	; 2
    1dce:	03 96       	adiw	r24, 0x03	; 3
    1dd0:	23 ef       	ldi	r18, 0xF3	; 243
    1dd2:	30 e0       	ldi	r19, 0x00	; 0
    1dd4:	f9 01       	movw	r30, r18
    1dd6:	20 81       	ld	r18, Z
    1dd8:	26 95       	lsr	r18
    1dda:	26 95       	lsr	r18
    1ddc:	26 95       	lsr	r18
    1dde:	fc 01       	movw	r30, r24
    1de0:	20 83       	st	Z, r18
    1de2:	8b 81       	ldd	r24, Y+3	; 0x03
    1de4:	9c 81       	ldd	r25, Y+4	; 0x04
    1de6:	02 96       	adiw	r24, 0x02	; 2
    1de8:	02 96       	adiw	r24, 0x02	; 2
    1dea:	22 ef       	ldi	r18, 0xF2	; 242
    1dec:	30 e0       	ldi	r19, 0x00	; 0
    1dee:	f9 01       	movw	r30, r18
    1df0:	20 81       	ld	r18, Z
    1df2:	42 2f       	mov	r20, r18
    1df4:	46 95       	lsr	r20
    1df6:	46 95       	lsr	r20
    1df8:	46 95       	lsr	r20
    1dfa:	23 ef       	ldi	r18, 0xF3	; 243
    1dfc:	30 e0       	ldi	r19, 0x00	; 0
    1dfe:	f9 01       	movw	r30, r18
    1e00:	20 81       	ld	r18, Z
    1e02:	22 95       	swap	r18
    1e04:	22 0f       	add	r18, r18
    1e06:	20 7e       	andi	r18, 0xE0	; 224
    1e08:	24 0f       	add	r18, r20
    1e0a:	fc 01       	movw	r30, r24
    1e0c:	20 83       	st	Z, r18
    1e0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e10:	9c 81       	ldd	r25, Y+4	; 0x04
    1e12:	02 96       	adiw	r24, 0x02	; 2
    1e14:	01 96       	adiw	r24, 0x01	; 1
    1e16:	21 ef       	ldi	r18, 0xF1	; 241
    1e18:	30 e0       	ldi	r19, 0x00	; 0
    1e1a:	f9 01       	movw	r30, r18
    1e1c:	20 81       	ld	r18, Z
    1e1e:	42 2f       	mov	r20, r18
    1e20:	46 95       	lsr	r20
    1e22:	46 95       	lsr	r20
    1e24:	46 95       	lsr	r20
    1e26:	22 ef       	ldi	r18, 0xF2	; 242
    1e28:	30 e0       	ldi	r19, 0x00	; 0
    1e2a:	f9 01       	movw	r30, r18
    1e2c:	20 81       	ld	r18, Z
    1e2e:	22 95       	swap	r18
    1e30:	22 0f       	add	r18, r18
    1e32:	20 7e       	andi	r18, 0xE0	; 224
    1e34:	24 0f       	add	r18, r20
    1e36:	fc 01       	movw	r30, r24
    1e38:	20 83       	st	Z, r18
    1e3a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e3c:	9c 81       	ldd	r25, Y+4	; 0x04
    1e3e:	02 96       	adiw	r24, 0x02	; 2
    1e40:	20 ef       	ldi	r18, 0xF0	; 240
    1e42:	30 e0       	ldi	r19, 0x00	; 0
    1e44:	f9 01       	movw	r30, r18
    1e46:	20 81       	ld	r18, Z
    1e48:	42 2f       	mov	r20, r18
    1e4a:	46 95       	lsr	r20
    1e4c:	46 95       	lsr	r20
    1e4e:	46 95       	lsr	r20
    1e50:	21 ef       	ldi	r18, 0xF1	; 241
    1e52:	30 e0       	ldi	r19, 0x00	; 0
    1e54:	f9 01       	movw	r30, r18
    1e56:	20 81       	ld	r18, Z
    1e58:	22 95       	swap	r18
    1e5a:	22 0f       	add	r18, r18
    1e5c:	20 7e       	andi	r18, 0xE0	; 224
    1e5e:	24 0f       	add	r18, r20
    1e60:	fc 01       	movw	r30, r24
    1e62:	20 83       	st	Z, r18
    1e64:	26 c0       	rjmp	.+76     	; 0x1eb2 <can_get_status+0x1d6>
            }
            else // else standard frame
                {
                    cmd->ctrl.ide = 0;
    1e66:	8b 81       	ldd	r24, Y+3	; 0x03
    1e68:	9c 81       	ldd	r25, Y+4	; 0x04
    1e6a:	fc 01       	movw	r30, r24
    1e6c:	13 86       	std	Z+11, r1	; 0x0b
                    Can_get_std_id(cmd->id.std);
    1e6e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e70:	9c 81       	ldd	r25, Y+4	; 0x04
    1e72:	02 96       	adiw	r24, 0x02	; 2
    1e74:	01 96       	adiw	r24, 0x01	; 1
    1e76:	23 ef       	ldi	r18, 0xF3	; 243
    1e78:	30 e0       	ldi	r19, 0x00	; 0
    1e7a:	f9 01       	movw	r30, r18
    1e7c:	20 81       	ld	r18, Z
    1e7e:	22 95       	swap	r18
    1e80:	26 95       	lsr	r18
    1e82:	27 70       	andi	r18, 0x07	; 7
    1e84:	fc 01       	movw	r30, r24
    1e86:	20 83       	st	Z, r18
    1e88:	8b 81       	ldd	r24, Y+3	; 0x03
    1e8a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e8c:	02 96       	adiw	r24, 0x02	; 2
    1e8e:	22 ef       	ldi	r18, 0xF2	; 242
    1e90:	30 e0       	ldi	r19, 0x00	; 0
    1e92:	f9 01       	movw	r30, r18
    1e94:	20 81       	ld	r18, Z
    1e96:	42 2f       	mov	r20, r18
    1e98:	42 95       	swap	r20
    1e9a:	46 95       	lsr	r20
    1e9c:	47 70       	andi	r20, 0x07	; 7
    1e9e:	23 ef       	ldi	r18, 0xF3	; 243
    1ea0:	30 e0       	ldi	r19, 0x00	; 0
    1ea2:	f9 01       	movw	r30, r18
    1ea4:	20 81       	ld	r18, Z
    1ea6:	22 0f       	add	r18, r18
    1ea8:	22 0f       	add	r18, r18
    1eaa:	22 0f       	add	r18, r18
    1eac:	24 0f       	add	r18, r20
    1eae:	fc 01       	movw	r30, r24
    1eb0:	20 83       	st	Z, r18
                }
            // Status field of descriptor: 0x20 if Rx completed
            // Status field of descriptor: 0xA0 if Rx completed with DLCWarning    
            cmd->status = a_status;
    1eb2:	8b 81       	ldd	r24, Y+3	; 0x03
    1eb4:	9c 81       	ldd	r25, Y+4	; 0x04
    1eb6:	2a 81       	ldd	r18, Y+2	; 0x02
    1eb8:	fc 01       	movw	r30, r24
    1eba:	21 87       	std	Z+9, r18	; 0x09
            Can_mob_abort();        // Freed the MOB
    1ebc:	8f ee       	ldi	r24, 0xEF	; 239
    1ebe:	90 e0       	ldi	r25, 0x00	; 0
    1ec0:	2f ee       	ldi	r18, 0xEF	; 239
    1ec2:	30 e0       	ldi	r19, 0x00	; 0
    1ec4:	f9 01       	movw	r30, r18
    1ec6:	20 81       	ld	r18, Z
    1ec8:	2f 73       	andi	r18, 0x3F	; 63
    1eca:	fc 01       	movw	r30, r24
    1ecc:	20 83       	st	Z, r18
            Can_clear_status_mob(); //   and reset MOb status
    1ece:	8e ee       	ldi	r24, 0xEE	; 238
    1ed0:	90 e0       	ldi	r25, 0x00	; 0
    1ed2:	fc 01       	movw	r30, r24
    1ed4:	10 82       	st	Z, r1
            rtn_val = CAN_STATUS_COMPLETED;
    1ed6:	19 82       	std	Y+1, r1	; 0x01
            break;
    1ed8:	29 c0       	rjmp	.+82     	; 0x1f2c <can_get_status+0x250>
        //---------------      
        case MOB_TX_COMPLETED:     
            // Status field of descriptor: 0x40 if Tx completed
            cmd->status = a_status;
    1eda:	8b 81       	ldd	r24, Y+3	; 0x03
    1edc:	9c 81       	ldd	r25, Y+4	; 0x04
    1ede:	2a 81       	ldd	r18, Y+2	; 0x02
    1ee0:	fc 01       	movw	r30, r24
    1ee2:	21 87       	std	Z+9, r18	; 0x09
            Can_mob_abort();        // Freed the MOB
    1ee4:	8f ee       	ldi	r24, 0xEF	; 239
    1ee6:	90 e0       	ldi	r25, 0x00	; 0
    1ee8:	2f ee       	ldi	r18, 0xEF	; 239
    1eea:	30 e0       	ldi	r19, 0x00	; 0
    1eec:	f9 01       	movw	r30, r18
    1eee:	20 81       	ld	r18, Z
    1ef0:	2f 73       	andi	r18, 0x3F	; 63
    1ef2:	fc 01       	movw	r30, r24
    1ef4:	20 83       	st	Z, r18
            Can_clear_status_mob(); //   and reset MOb status
    1ef6:	8e ee       	ldi	r24, 0xEE	; 238
    1ef8:	90 e0       	ldi	r25, 0x00	; 0
    1efa:	fc 01       	movw	r30, r24
    1efc:	10 82       	st	Z, r1
            rtn_val = CAN_STATUS_COMPLETED;
    1efe:	19 82       	std	Y+1, r1	; 0x01
            break;
    1f00:	15 c0       	rjmp	.+42     	; 0x1f2c <can_get_status+0x250>
        //---------------      
        default:
            // Status field of descriptor: (bin)000b.scfa if MOb error
            cmd->status = a_status;
    1f02:	8b 81       	ldd	r24, Y+3	; 0x03
    1f04:	9c 81       	ldd	r25, Y+4	; 0x04
    1f06:	2a 81       	ldd	r18, Y+2	; 0x02
    1f08:	fc 01       	movw	r30, r24
    1f0a:	21 87       	std	Z+9, r18	; 0x09
            Can_mob_abort();        // Freed the MOB
    1f0c:	8f ee       	ldi	r24, 0xEF	; 239
    1f0e:	90 e0       	ldi	r25, 0x00	; 0
    1f10:	2f ee       	ldi	r18, 0xEF	; 239
    1f12:	30 e0       	ldi	r19, 0x00	; 0
    1f14:	f9 01       	movw	r30, r18
    1f16:	20 81       	ld	r18, Z
    1f18:	2f 73       	andi	r18, 0x3F	; 63
    1f1a:	fc 01       	movw	r30, r24
    1f1c:	20 83       	st	Z, r18
            Can_clear_status_mob(); //   and reset MOb status
    1f1e:	8e ee       	ldi	r24, 0xEE	; 238
    1f20:	90 e0       	ldi	r25, 0x00	; 0
    1f22:	fc 01       	movw	r30, r24
    1f24:	10 82       	st	Z, r1
            rtn_val = CAN_STATUS_ERROR;
    1f26:	82 e0       	ldi	r24, 0x02	; 2
    1f28:	89 83       	std	Y+1, r24	; 0x01
            break;
    1f2a:	00 00       	nop
             
    } // switch (a_status...
 
    return (rtn_val);
    1f2c:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f2e:	0f 90       	pop	r0
    1f30:	0f 90       	pop	r0
    1f32:	0f 90       	pop	r0
    1f34:	0f 90       	pop	r0
    1f36:	df 91       	pop	r29
    1f38:	cf 91       	pop	r28
    1f3a:	08 95       	ret

00001f3c <can_tx>:
 *		buf_size, the size of the buffer
 * 
 * Returns:
 *		void	
 */
void can_tx(uint16_t id, uint8_t *buffer, uint8_t buf_size) {
    1f3c:	cf 93       	push	r28
    1f3e:	df 93       	push	r29
    1f40:	cd b7       	in	r28, 0x3d	; 61
    1f42:	de b7       	in	r29, 0x3e	; 62
    1f44:	61 97       	sbiw	r28, 0x11	; 17
    1f46:	0f b6       	in	r0, 0x3f	; 63
    1f48:	f8 94       	cli
    1f4a:	de bf       	out	0x3e, r29	; 62
    1f4c:	0f be       	out	0x3f, r0	; 63
    1f4e:	cd bf       	out	0x3d, r28	; 61
    1f50:	9e 87       	std	Y+14, r25	; 0x0e
    1f52:	8d 87       	std	Y+13, r24	; 0x0d
    1f54:	78 8b       	std	Y+16, r23	; 0x10
    1f56:	6f 87       	std	Y+15, r22	; 0x0f
    1f58:	49 8b       	std	Y+17, r20	; 0x11
	
	// Message command object
	st_cmd_t can_msg;
	
	// Configure TX mailbox
	can_msg.pt_data = buffer;	// point message object to the data buffer
    1f5a:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f5c:	98 89       	ldd	r25, Y+16	; 0x10
    1f5e:	99 87       	std	Y+9, r25	; 0x09
    1f60:	88 87       	std	Y+8, r24	; 0x08
	can_msg.ctrl.ide = 0;		// CAN 2.0A
    1f62:	1c 86       	std	Y+12, r1	; 0x0c
	can_msg.dlc = buf_size;		// Number of data bytes (8 max) requested from remote node
    1f64:	89 89       	ldd	r24, Y+17	; 0x11
    1f66:	8f 83       	std	Y+7, r24	; 0x07
	can_msg.id.std = id;		// Message ID
    1f68:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f6a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f6c:	9c 83       	std	Y+4, r25	; 0x04
    1f6e:	8b 83       	std	Y+3, r24	; 0x03
	can_msg.cmd = CMD_TX_DATA;	// Transmit data command object
    1f70:	82 e0       	ldi	r24, 0x02	; 2
    1f72:	8a 83       	std	Y+2, r24	; 0x02

	// Wait for MOb to configure (Must re-configure MOb for every transaction) and send request
	while(can_cmd(&can_msg) != CAN_CMD_ACCEPTED);
    1f74:	00 00       	nop
    1f76:	ce 01       	movw	r24, r28
    1f78:	01 96       	adiw	r24, 0x01	; 1
    1f7a:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <can_cmd>
    1f7e:	88 23       	and	r24, r24
    1f80:	d1 f7       	brne	.-12     	; 0x1f76 <can_tx+0x3a>
	
	// Wait for Tx to complete
	while(can_get_status(&can_msg) == CAN_STATUS_NOT_COMPLETED);
    1f82:	00 00       	nop
    1f84:	ce 01       	movw	r24, r28
    1f86:	01 96       	adiw	r24, 0x01	; 1
    1f88:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <can_get_status>
    1f8c:	81 30       	cpi	r24, 0x01	; 1
    1f8e:	d1 f3       	breq	.-12     	; 0x1f84 <can_tx+0x48>
}
    1f90:	61 96       	adiw	r28, 0x11	; 17
    1f92:	0f b6       	in	r0, 0x3f	; 63
    1f94:	f8 94       	cli
    1f96:	de bf       	out	0x3e, r29	; 62
    1f98:	0f be       	out	0x3f, r0	; 63
    1f9a:	cd bf       	out	0x3d, r28	; 61
    1f9c:	df 91       	pop	r29
    1f9e:	cf 91       	pop	r28
    1fa0:	08 95       	ret

00001fa2 <can_rx_sync>:
 *		buf_size, the size of the buffer
 *
 * Returns:
 *		the received array
 */
void can_rx_sync(uint16_t ID, uint8_t *buffer, uint8_t buf_size) {
    1fa2:	cf 93       	push	r28
    1fa4:	df 93       	push	r29
    1fa6:	cd b7       	in	r28, 0x3d	; 61
    1fa8:	de b7       	in	r29, 0x3e	; 62
    1faa:	61 97       	sbiw	r28, 0x11	; 17
    1fac:	0f b6       	in	r0, 0x3f	; 63
    1fae:	f8 94       	cli
    1fb0:	de bf       	out	0x3e, r29	; 62
    1fb2:	0f be       	out	0x3f, r0	; 63
    1fb4:	cd bf       	out	0x3d, r28	; 61
    1fb6:	9e 87       	std	Y+14, r25	; 0x0e
    1fb8:	8d 87       	std	Y+13, r24	; 0x0d
    1fba:	78 8b       	std	Y+16, r23	; 0x10
    1fbc:	6f 87       	std	Y+15, r22	; 0x0f
    1fbe:	49 8b       	std	Y+17, r20	; 0x11
	// Message command object
	st_cmd_t can_msg;
	
	// Configure TX mailbox
	can_msg.pt_data = buffer;			// point message object to the data buffer
    1fc0:	8f 85       	ldd	r24, Y+15	; 0x0f
    1fc2:	98 89       	ldd	r25, Y+16	; 0x10
    1fc4:	99 87       	std	Y+9, r25	; 0x09
    1fc6:	88 87       	std	Y+8, r24	; 0x08
	can_msg.ctrl.ide = 0;				// CAN 2.0A
    1fc8:	1c 86       	std	Y+12, r1	; 0x0c
	can_msg.dlc = buf_size;				// Number of data bytes (8 max) requested from remote node
    1fca:	89 89       	ldd	r24, Y+17	; 0x11
    1fcc:	8f 83       	std	Y+7, r24	; 0x07
	can_msg.id.std = ID;				// Message ID
    1fce:	8d 85       	ldd	r24, Y+13	; 0x0d
    1fd0:	9e 85       	ldd	r25, Y+14	; 0x0e
    1fd2:	9c 83       	std	Y+4, r25	; 0x04
    1fd4:	8b 83       	std	Y+3, r24	; 0x03
	can_msg.cmd = CMD_RX_DATA_MASKED;	// Receive data command object
    1fd6:	88 e0       	ldi	r24, 0x08	; 8
    1fd8:	8a 83       	std	Y+2, r24	; 0x02

	// Wait for MOb to configure (Must re-configure MOb for every transaction) and send request
	while(can_cmd(&can_msg) != CAN_CMD_ACCEPTED);
    1fda:	00 00       	nop
    1fdc:	ce 01       	movw	r24, r28
    1fde:	01 96       	adiw	r24, 0x01	; 1
    1fe0:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <can_cmd>
    1fe4:	88 23       	and	r24, r24
    1fe6:	d1 f7       	brne	.-12     	; 0x1fdc <can_rx_sync+0x3a>
	// Wait for Tx to complete
	while(can_get_status(&can_msg) == CAN_STATUS_NOT_COMPLETED);
    1fe8:	00 00       	nop
    1fea:	ce 01       	movw	r24, r28
    1fec:	01 96       	adiw	r24, 0x01	; 1
    1fee:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <can_get_status>
    1ff2:	81 30       	cpi	r24, 0x01	; 1
    1ff4:	d1 f3       	breq	.-12     	; 0x1fea <can_rx_sync+0x48>
}
    1ff6:	61 96       	adiw	r28, 0x11	; 17
    1ff8:	0f b6       	in	r0, 0x3f	; 63
    1ffa:	f8 94       	cli
    1ffc:	de bf       	out	0x3e, r29	; 62
    1ffe:	0f be       	out	0x3f, r0	; 63
    2000:	cd bf       	out	0x3d, r28	; 61
    2002:	df 91       	pop	r29
    2004:	cf 91       	pop	r28
    2006:	08 95       	ret

00002008 <main>:

#define mainMCU_STATUS_TASK_PRIORITY	1
#define mainHEARTBEAT_TASK_PRIORITY		2

int main(void)
{	
    2008:	af 92       	push	r10
    200a:	bf 92       	push	r11
    200c:	cf 92       	push	r12
    200e:	df 92       	push	r13
    2010:	ef 92       	push	r14
    2012:	ff 92       	push	r15
    2014:	0f 93       	push	r16
    2016:	cf 93       	push	r28
    2018:	df 93       	push	r29
    201a:	cd b7       	in	r28, 0x3d	; 61
    201c:	de b7       	in	r29, 0x3e	; 62
	// Initialize CAN with fixed baud rate, as defined in can_config.h
	can_init(1);
    201e:	81 e0       	ldi	r24, 0x01	; 1
    2020:	0e 94 bb 03 	call	0x776	; 0x776 <can_init>
	
	// Create the MCU status task, to blink the LED
	// Rate: 4Hz
    xTaskCreate(vMCUStatusTask, "STATUS", configMINIMAL_STACK_SIZE, 
    2024:	a1 2c       	mov	r10, r1
    2026:	b1 2c       	mov	r11, r1
    2028:	c1 2c       	mov	r12, r1
    202a:	d1 2c       	mov	r13, r1
    202c:	e1 2c       	mov	r14, r1
    202e:	f1 2c       	mov	r15, r1
    2030:	01 e0       	ldi	r16, 0x01	; 1
    2032:	20 e0       	ldi	r18, 0x00	; 0
    2034:	30 e0       	ldi	r19, 0x00	; 0
    2036:	44 e6       	ldi	r20, 0x64	; 100
    2038:	50 e0       	ldi	r21, 0x00	; 0
    203a:	60 e0       	ldi	r22, 0x00	; 0
    203c:	71 e0       	ldi	r23, 0x01	; 1
    203e:	86 e7       	ldi	r24, 0x76	; 118
    2040:	97 e2       	ldi	r25, 0x27	; 39
    2042:	0e 94 4c 1b 	call	0x3698	; 0x3698 <xTaskGenericCreate>
		NULL, mainMCU_STATUS_TASK_PRIORITY, NULL);
		
	// Create the heartbeat task, to transmit over CAN
	// Rate: 10Hz
	xTaskCreate(vHeartbeatTask, "HEART", configMINIMAL_STACK_SIZE,
    2046:	a1 2c       	mov	r10, r1
    2048:	b1 2c       	mov	r11, r1
    204a:	c1 2c       	mov	r12, r1
    204c:	d1 2c       	mov	r13, r1
    204e:	e1 2c       	mov	r14, r1
    2050:	f1 2c       	mov	r15, r1
    2052:	02 e0       	ldi	r16, 0x02	; 2
    2054:	20 e0       	ldi	r18, 0x00	; 0
    2056:	30 e0       	ldi	r19, 0x00	; 0
    2058:	44 e6       	ldi	r20, 0x64	; 100
    205a:	50 e0       	ldi	r21, 0x00	; 0
    205c:	67 e0       	ldi	r22, 0x07	; 7
    205e:	71 e0       	ldi	r23, 0x01	; 1
    2060:	84 e9       	ldi	r24, 0x94	; 148
    2062:	97 e2       	ldi	r25, 0x27	; 39
    2064:	0e 94 4c 1b 	call	0x3698	; 0x3698 <xTaskGenericCreate>
		NULL, mainHEARTBEAT_TASK_PRIORITY, NULL);
	
	// Start the scheduler
	vTaskStartScheduler();
    2068:	0e 94 3b 1d 	call	0x3a76	; 0x3a76 <vTaskStartScheduler>
	
	// Return, the scheduler handles the rest
	return 0;
    206c:	80 e0       	ldi	r24, 0x00	; 0
    206e:	90 e0       	ldi	r25, 0x00	; 0
}
    2070:	df 91       	pop	r29
    2072:	cf 91       	pop	r28
    2074:	0f 91       	pop	r16
    2076:	ff 90       	pop	r15
    2078:	ef 90       	pop	r14
    207a:	df 90       	pop	r13
    207c:	cf 90       	pop	r12
    207e:	bf 90       	pop	r11
    2080:	af 90       	pop	r10
    2082:	08 95       	ret

00002084 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2084:	cf 93       	push	r28
    2086:	df 93       	push	r29
    2088:	00 d0       	rcall	.+0      	; 0x208a <vListInitialise+0x6>
    208a:	cd b7       	in	r28, 0x3d	; 61
    208c:	de b7       	in	r29, 0x3e	; 62
    208e:	9a 83       	std	Y+2, r25	; 0x02
    2090:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2092:	89 81       	ldd	r24, Y+1	; 0x01
    2094:	9a 81       	ldd	r25, Y+2	; 0x02
    2096:	9c 01       	movw	r18, r24
    2098:	2d 5f       	subi	r18, 0xFD	; 253
    209a:	3f 4f       	sbci	r19, 0xFF	; 255
    209c:	89 81       	ldd	r24, Y+1	; 0x01
    209e:	9a 81       	ldd	r25, Y+2	; 0x02
    20a0:	fc 01       	movw	r30, r24
    20a2:	32 83       	std	Z+2, r19	; 0x02
    20a4:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    20a6:	89 81       	ldd	r24, Y+1	; 0x01
    20a8:	9a 81       	ldd	r25, Y+2	; 0x02
    20aa:	2f ef       	ldi	r18, 0xFF	; 255
    20ac:	3f ef       	ldi	r19, 0xFF	; 255
    20ae:	fc 01       	movw	r30, r24
    20b0:	34 83       	std	Z+4, r19	; 0x04
    20b2:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    20b4:	89 81       	ldd	r24, Y+1	; 0x01
    20b6:	9a 81       	ldd	r25, Y+2	; 0x02
    20b8:	9c 01       	movw	r18, r24
    20ba:	2d 5f       	subi	r18, 0xFD	; 253
    20bc:	3f 4f       	sbci	r19, 0xFF	; 255
    20be:	89 81       	ldd	r24, Y+1	; 0x01
    20c0:	9a 81       	ldd	r25, Y+2	; 0x02
    20c2:	fc 01       	movw	r30, r24
    20c4:	36 83       	std	Z+6, r19	; 0x06
    20c6:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    20c8:	89 81       	ldd	r24, Y+1	; 0x01
    20ca:	9a 81       	ldd	r25, Y+2	; 0x02
    20cc:	9c 01       	movw	r18, r24
    20ce:	2d 5f       	subi	r18, 0xFD	; 253
    20d0:	3f 4f       	sbci	r19, 0xFF	; 255
    20d2:	89 81       	ldd	r24, Y+1	; 0x01
    20d4:	9a 81       	ldd	r25, Y+2	; 0x02
    20d6:	fc 01       	movw	r30, r24
    20d8:	30 87       	std	Z+8, r19	; 0x08
    20da:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    20dc:	89 81       	ldd	r24, Y+1	; 0x01
    20de:	9a 81       	ldd	r25, Y+2	; 0x02
    20e0:	fc 01       	movw	r30, r24
    20e2:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    20e4:	0f 90       	pop	r0
    20e6:	0f 90       	pop	r0
    20e8:	df 91       	pop	r29
    20ea:	cf 91       	pop	r28
    20ec:	08 95       	ret

000020ee <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    20ee:	cf 93       	push	r28
    20f0:	df 93       	push	r29
    20f2:	00 d0       	rcall	.+0      	; 0x20f4 <vListInitialiseItem+0x6>
    20f4:	cd b7       	in	r28, 0x3d	; 61
    20f6:	de b7       	in	r29, 0x3e	; 62
    20f8:	9a 83       	std	Y+2, r25	; 0x02
    20fa:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    20fc:	89 81       	ldd	r24, Y+1	; 0x01
    20fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2100:	fc 01       	movw	r30, r24
    2102:	11 86       	std	Z+9, r1	; 0x09
    2104:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    2106:	0f 90       	pop	r0
    2108:	0f 90       	pop	r0
    210a:	df 91       	pop	r29
    210c:	cf 91       	pop	r28
    210e:	08 95       	ret

00002110 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2110:	cf 93       	push	r28
    2112:	df 93       	push	r29
    2114:	00 d0       	rcall	.+0      	; 0x2116 <vListInsertEnd+0x6>
    2116:	00 d0       	rcall	.+0      	; 0x2118 <vListInsertEnd+0x8>
    2118:	00 d0       	rcall	.+0      	; 0x211a <vListInsertEnd+0xa>
    211a:	cd b7       	in	r28, 0x3d	; 61
    211c:	de b7       	in	r29, 0x3e	; 62
    211e:	9c 83       	std	Y+4, r25	; 0x04
    2120:	8b 83       	std	Y+3, r24	; 0x03
    2122:	7e 83       	std	Y+6, r23	; 0x06
    2124:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    2126:	8b 81       	ldd	r24, Y+3	; 0x03
    2128:	9c 81       	ldd	r25, Y+4	; 0x04
    212a:	fc 01       	movw	r30, r24
    212c:	81 81       	ldd	r24, Z+1	; 0x01
    212e:	92 81       	ldd	r25, Z+2	; 0x02
    2130:	9a 83       	std	Y+2, r25	; 0x02
    2132:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    2134:	8d 81       	ldd	r24, Y+5	; 0x05
    2136:	9e 81       	ldd	r25, Y+6	; 0x06
    2138:	29 81       	ldd	r18, Y+1	; 0x01
    213a:	3a 81       	ldd	r19, Y+2	; 0x02
    213c:	fc 01       	movw	r30, r24
    213e:	33 83       	std	Z+3, r19	; 0x03
    2140:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2142:	89 81       	ldd	r24, Y+1	; 0x01
    2144:	9a 81       	ldd	r25, Y+2	; 0x02
    2146:	fc 01       	movw	r30, r24
    2148:	24 81       	ldd	r18, Z+4	; 0x04
    214a:	35 81       	ldd	r19, Z+5	; 0x05
    214c:	8d 81       	ldd	r24, Y+5	; 0x05
    214e:	9e 81       	ldd	r25, Y+6	; 0x06
    2150:	fc 01       	movw	r30, r24
    2152:	35 83       	std	Z+5, r19	; 0x05
    2154:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2156:	89 81       	ldd	r24, Y+1	; 0x01
    2158:	9a 81       	ldd	r25, Y+2	; 0x02
    215a:	fc 01       	movw	r30, r24
    215c:	84 81       	ldd	r24, Z+4	; 0x04
    215e:	95 81       	ldd	r25, Z+5	; 0x05
    2160:	2d 81       	ldd	r18, Y+5	; 0x05
    2162:	3e 81       	ldd	r19, Y+6	; 0x06
    2164:	fc 01       	movw	r30, r24
    2166:	33 83       	std	Z+3, r19	; 0x03
    2168:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    216a:	89 81       	ldd	r24, Y+1	; 0x01
    216c:	9a 81       	ldd	r25, Y+2	; 0x02
    216e:	2d 81       	ldd	r18, Y+5	; 0x05
    2170:	3e 81       	ldd	r19, Y+6	; 0x06
    2172:	fc 01       	movw	r30, r24
    2174:	35 83       	std	Z+5, r19	; 0x05
    2176:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2178:	8d 81       	ldd	r24, Y+5	; 0x05
    217a:	9e 81       	ldd	r25, Y+6	; 0x06
    217c:	2b 81       	ldd	r18, Y+3	; 0x03
    217e:	3c 81       	ldd	r19, Y+4	; 0x04
    2180:	fc 01       	movw	r30, r24
    2182:	31 87       	std	Z+9, r19	; 0x09
    2184:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2186:	8b 81       	ldd	r24, Y+3	; 0x03
    2188:	9c 81       	ldd	r25, Y+4	; 0x04
    218a:	fc 01       	movw	r30, r24
    218c:	80 81       	ld	r24, Z
    218e:	21 e0       	ldi	r18, 0x01	; 1
    2190:	28 0f       	add	r18, r24
    2192:	8b 81       	ldd	r24, Y+3	; 0x03
    2194:	9c 81       	ldd	r25, Y+4	; 0x04
    2196:	fc 01       	movw	r30, r24
    2198:	20 83       	st	Z, r18
}
    219a:	26 96       	adiw	r28, 0x06	; 6
    219c:	0f b6       	in	r0, 0x3f	; 63
    219e:	f8 94       	cli
    21a0:	de bf       	out	0x3e, r29	; 62
    21a2:	0f be       	out	0x3f, r0	; 63
    21a4:	cd bf       	out	0x3d, r28	; 61
    21a6:	df 91       	pop	r29
    21a8:	cf 91       	pop	r28
    21aa:	08 95       	ret

000021ac <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    21ac:	cf 93       	push	r28
    21ae:	df 93       	push	r29
    21b0:	cd b7       	in	r28, 0x3d	; 61
    21b2:	de b7       	in	r29, 0x3e	; 62
    21b4:	28 97       	sbiw	r28, 0x08	; 8
    21b6:	0f b6       	in	r0, 0x3f	; 63
    21b8:	f8 94       	cli
    21ba:	de bf       	out	0x3e, r29	; 62
    21bc:	0f be       	out	0x3f, r0	; 63
    21be:	cd bf       	out	0x3d, r28	; 61
    21c0:	9e 83       	std	Y+6, r25	; 0x06
    21c2:	8d 83       	std	Y+5, r24	; 0x05
    21c4:	78 87       	std	Y+8, r23	; 0x08
    21c6:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    21c8:	8f 81       	ldd	r24, Y+7	; 0x07
    21ca:	98 85       	ldd	r25, Y+8	; 0x08
    21cc:	fc 01       	movw	r30, r24
    21ce:	80 81       	ld	r24, Z
    21d0:	91 81       	ldd	r25, Z+1	; 0x01
    21d2:	9c 83       	std	Y+4, r25	; 0x04
    21d4:	8b 83       	std	Y+3, r24	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    21d6:	8b 81       	ldd	r24, Y+3	; 0x03
    21d8:	9c 81       	ldd	r25, Y+4	; 0x04
    21da:	01 96       	adiw	r24, 0x01	; 1
    21dc:	41 f4       	brne	.+16     	; 0x21ee <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    21de:	8d 81       	ldd	r24, Y+5	; 0x05
    21e0:	9e 81       	ldd	r25, Y+6	; 0x06
    21e2:	fc 01       	movw	r30, r24
    21e4:	87 81       	ldd	r24, Z+7	; 0x07
    21e6:	90 85       	ldd	r25, Z+8	; 0x08
    21e8:	9a 83       	std	Y+2, r25	; 0x02
    21ea:	89 83       	std	Y+1, r24	; 0x01
    21ec:	1a c0       	rjmp	.+52     	; 0x2222 <vListInsert+0x76>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    21ee:	8d 81       	ldd	r24, Y+5	; 0x05
    21f0:	9e 81       	ldd	r25, Y+6	; 0x06
    21f2:	03 96       	adiw	r24, 0x03	; 3
    21f4:	9a 83       	std	Y+2, r25	; 0x02
    21f6:	89 83       	std	Y+1, r24	; 0x01
    21f8:	07 c0       	rjmp	.+14     	; 0x2208 <vListInsert+0x5c>
    21fa:	89 81       	ldd	r24, Y+1	; 0x01
    21fc:	9a 81       	ldd	r25, Y+2	; 0x02
    21fe:	fc 01       	movw	r30, r24
    2200:	82 81       	ldd	r24, Z+2	; 0x02
    2202:	93 81       	ldd	r25, Z+3	; 0x03
    2204:	9a 83       	std	Y+2, r25	; 0x02
    2206:	89 83       	std	Y+1, r24	; 0x01
    2208:	89 81       	ldd	r24, Y+1	; 0x01
    220a:	9a 81       	ldd	r25, Y+2	; 0x02
    220c:	fc 01       	movw	r30, r24
    220e:	82 81       	ldd	r24, Z+2	; 0x02
    2210:	93 81       	ldd	r25, Z+3	; 0x03
    2212:	fc 01       	movw	r30, r24
    2214:	20 81       	ld	r18, Z
    2216:	31 81       	ldd	r19, Z+1	; 0x01
    2218:	8b 81       	ldd	r24, Y+3	; 0x03
    221a:	9c 81       	ldd	r25, Y+4	; 0x04
    221c:	82 17       	cp	r24, r18
    221e:	93 07       	cpc	r25, r19
    2220:	60 f7       	brcc	.-40     	; 0x21fa <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2222:	89 81       	ldd	r24, Y+1	; 0x01
    2224:	9a 81       	ldd	r25, Y+2	; 0x02
    2226:	fc 01       	movw	r30, r24
    2228:	22 81       	ldd	r18, Z+2	; 0x02
    222a:	33 81       	ldd	r19, Z+3	; 0x03
    222c:	8f 81       	ldd	r24, Y+7	; 0x07
    222e:	98 85       	ldd	r25, Y+8	; 0x08
    2230:	fc 01       	movw	r30, r24
    2232:	33 83       	std	Z+3, r19	; 0x03
    2234:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2236:	8f 81       	ldd	r24, Y+7	; 0x07
    2238:	98 85       	ldd	r25, Y+8	; 0x08
    223a:	fc 01       	movw	r30, r24
    223c:	82 81       	ldd	r24, Z+2	; 0x02
    223e:	93 81       	ldd	r25, Z+3	; 0x03
    2240:	2f 81       	ldd	r18, Y+7	; 0x07
    2242:	38 85       	ldd	r19, Y+8	; 0x08
    2244:	fc 01       	movw	r30, r24
    2246:	35 83       	std	Z+5, r19	; 0x05
    2248:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    224a:	8f 81       	ldd	r24, Y+7	; 0x07
    224c:	98 85       	ldd	r25, Y+8	; 0x08
    224e:	29 81       	ldd	r18, Y+1	; 0x01
    2250:	3a 81       	ldd	r19, Y+2	; 0x02
    2252:	fc 01       	movw	r30, r24
    2254:	35 83       	std	Z+5, r19	; 0x05
    2256:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
    2258:	89 81       	ldd	r24, Y+1	; 0x01
    225a:	9a 81       	ldd	r25, Y+2	; 0x02
    225c:	2f 81       	ldd	r18, Y+7	; 0x07
    225e:	38 85       	ldd	r19, Y+8	; 0x08
    2260:	fc 01       	movw	r30, r24
    2262:	33 83       	std	Z+3, r19	; 0x03
    2264:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2266:	8f 81       	ldd	r24, Y+7	; 0x07
    2268:	98 85       	ldd	r25, Y+8	; 0x08
    226a:	2d 81       	ldd	r18, Y+5	; 0x05
    226c:	3e 81       	ldd	r19, Y+6	; 0x06
    226e:	fc 01       	movw	r30, r24
    2270:	31 87       	std	Z+9, r19	; 0x09
    2272:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2274:	8d 81       	ldd	r24, Y+5	; 0x05
    2276:	9e 81       	ldd	r25, Y+6	; 0x06
    2278:	fc 01       	movw	r30, r24
    227a:	80 81       	ld	r24, Z
    227c:	21 e0       	ldi	r18, 0x01	; 1
    227e:	28 0f       	add	r18, r24
    2280:	8d 81       	ldd	r24, Y+5	; 0x05
    2282:	9e 81       	ldd	r25, Y+6	; 0x06
    2284:	fc 01       	movw	r30, r24
    2286:	20 83       	st	Z, r18
}
    2288:	28 96       	adiw	r28, 0x08	; 8
    228a:	0f b6       	in	r0, 0x3f	; 63
    228c:	f8 94       	cli
    228e:	de bf       	out	0x3e, r29	; 62
    2290:	0f be       	out	0x3f, r0	; 63
    2292:	cd bf       	out	0x3d, r28	; 61
    2294:	df 91       	pop	r29
    2296:	cf 91       	pop	r28
    2298:	08 95       	ret

0000229a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    229a:	cf 93       	push	r28
    229c:	df 93       	push	r29
    229e:	00 d0       	rcall	.+0      	; 0x22a0 <uxListRemove+0x6>
    22a0:	00 d0       	rcall	.+0      	; 0x22a2 <uxListRemove+0x8>
    22a2:	cd b7       	in	r28, 0x3d	; 61
    22a4:	de b7       	in	r29, 0x3e	; 62
    22a6:	9c 83       	std	Y+4, r25	; 0x04
    22a8:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    22aa:	8b 81       	ldd	r24, Y+3	; 0x03
    22ac:	9c 81       	ldd	r25, Y+4	; 0x04
    22ae:	fc 01       	movw	r30, r24
    22b0:	80 85       	ldd	r24, Z+8	; 0x08
    22b2:	91 85       	ldd	r25, Z+9	; 0x09
    22b4:	9a 83       	std	Y+2, r25	; 0x02
    22b6:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    22b8:	8b 81       	ldd	r24, Y+3	; 0x03
    22ba:	9c 81       	ldd	r25, Y+4	; 0x04
    22bc:	fc 01       	movw	r30, r24
    22be:	82 81       	ldd	r24, Z+2	; 0x02
    22c0:	93 81       	ldd	r25, Z+3	; 0x03
    22c2:	2b 81       	ldd	r18, Y+3	; 0x03
    22c4:	3c 81       	ldd	r19, Y+4	; 0x04
    22c6:	f9 01       	movw	r30, r18
    22c8:	24 81       	ldd	r18, Z+4	; 0x04
    22ca:	35 81       	ldd	r19, Z+5	; 0x05
    22cc:	fc 01       	movw	r30, r24
    22ce:	35 83       	std	Z+5, r19	; 0x05
    22d0:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    22d2:	8b 81       	ldd	r24, Y+3	; 0x03
    22d4:	9c 81       	ldd	r25, Y+4	; 0x04
    22d6:	fc 01       	movw	r30, r24
    22d8:	84 81       	ldd	r24, Z+4	; 0x04
    22da:	95 81       	ldd	r25, Z+5	; 0x05
    22dc:	2b 81       	ldd	r18, Y+3	; 0x03
    22de:	3c 81       	ldd	r19, Y+4	; 0x04
    22e0:	f9 01       	movw	r30, r18
    22e2:	22 81       	ldd	r18, Z+2	; 0x02
    22e4:	33 81       	ldd	r19, Z+3	; 0x03
    22e6:	fc 01       	movw	r30, r24
    22e8:	33 83       	std	Z+3, r19	; 0x03
    22ea:	22 83       	std	Z+2, r18	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    22ec:	89 81       	ldd	r24, Y+1	; 0x01
    22ee:	9a 81       	ldd	r25, Y+2	; 0x02
    22f0:	fc 01       	movw	r30, r24
    22f2:	21 81       	ldd	r18, Z+1	; 0x01
    22f4:	32 81       	ldd	r19, Z+2	; 0x02
    22f6:	8b 81       	ldd	r24, Y+3	; 0x03
    22f8:	9c 81       	ldd	r25, Y+4	; 0x04
    22fa:	28 17       	cp	r18, r24
    22fc:	39 07       	cpc	r19, r25
    22fe:	51 f4       	brne	.+20     	; 0x2314 <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2300:	8b 81       	ldd	r24, Y+3	; 0x03
    2302:	9c 81       	ldd	r25, Y+4	; 0x04
    2304:	fc 01       	movw	r30, r24
    2306:	24 81       	ldd	r18, Z+4	; 0x04
    2308:	35 81       	ldd	r19, Z+5	; 0x05
    230a:	89 81       	ldd	r24, Y+1	; 0x01
    230c:	9a 81       	ldd	r25, Y+2	; 0x02
    230e:	fc 01       	movw	r30, r24
    2310:	32 83       	std	Z+2, r19	; 0x02
    2312:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    2314:	8b 81       	ldd	r24, Y+3	; 0x03
    2316:	9c 81       	ldd	r25, Y+4	; 0x04
    2318:	fc 01       	movw	r30, r24
    231a:	11 86       	std	Z+9, r1	; 0x09
    231c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    231e:	89 81       	ldd	r24, Y+1	; 0x01
    2320:	9a 81       	ldd	r25, Y+2	; 0x02
    2322:	fc 01       	movw	r30, r24
    2324:	80 81       	ld	r24, Z
    2326:	2f ef       	ldi	r18, 0xFF	; 255
    2328:	28 0f       	add	r18, r24
    232a:	89 81       	ldd	r24, Y+1	; 0x01
    232c:	9a 81       	ldd	r25, Y+2	; 0x02
    232e:	fc 01       	movw	r30, r24
    2330:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    2332:	89 81       	ldd	r24, Y+1	; 0x01
    2334:	9a 81       	ldd	r25, Y+2	; 0x02
    2336:	fc 01       	movw	r30, r24
    2338:	80 81       	ld	r24, Z
}
    233a:	0f 90       	pop	r0
    233c:	0f 90       	pop	r0
    233e:	0f 90       	pop	r0
    2340:	0f 90       	pop	r0
    2342:	df 91       	pop	r29
    2344:	cf 91       	pop	r28
    2346:	08 95       	ret

00002348 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2348:	cf 93       	push	r28
    234a:	df 93       	push	r29
    234c:	cd b7       	in	r28, 0x3d	; 61
    234e:	de b7       	in	r29, 0x3e	; 62
    2350:	28 97       	sbiw	r28, 0x08	; 8
    2352:	0f b6       	in	r0, 0x3f	; 63
    2354:	f8 94       	cli
    2356:	de bf       	out	0x3e, r29	; 62
    2358:	0f be       	out	0x3f, r0	; 63
    235a:	cd bf       	out	0x3d, r28	; 61
    235c:	9c 83       	std	Y+4, r25	; 0x04
    235e:	8b 83       	std	Y+3, r24	; 0x03
    2360:	7e 83       	std	Y+6, r23	; 0x06
    2362:	6d 83       	std	Y+5, r22	; 0x05
    2364:	58 87       	std	Y+8, r21	; 0x08
    2366:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2368:	8b 81       	ldd	r24, Y+3	; 0x03
    236a:	9c 81       	ldd	r25, Y+4	; 0x04
    236c:	21 e1       	ldi	r18, 0x11	; 17
    236e:	fc 01       	movw	r30, r24
    2370:	20 83       	st	Z, r18
	pxTopOfStack--;
    2372:	8b 81       	ldd	r24, Y+3	; 0x03
    2374:	9c 81       	ldd	r25, Y+4	; 0x04
    2376:	01 97       	sbiw	r24, 0x01	; 1
    2378:	9c 83       	std	Y+4, r25	; 0x04
    237a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    237c:	8b 81       	ldd	r24, Y+3	; 0x03
    237e:	9c 81       	ldd	r25, Y+4	; 0x04
    2380:	22 e2       	ldi	r18, 0x22	; 34
    2382:	fc 01       	movw	r30, r24
    2384:	20 83       	st	Z, r18
	pxTopOfStack--;
    2386:	8b 81       	ldd	r24, Y+3	; 0x03
    2388:	9c 81       	ldd	r25, Y+4	; 0x04
    238a:	01 97       	sbiw	r24, 0x01	; 1
    238c:	9c 83       	std	Y+4, r25	; 0x04
    238e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2390:	8b 81       	ldd	r24, Y+3	; 0x03
    2392:	9c 81       	ldd	r25, Y+4	; 0x04
    2394:	23 e3       	ldi	r18, 0x33	; 51
    2396:	fc 01       	movw	r30, r24
    2398:	20 83       	st	Z, r18
	pxTopOfStack--;
    239a:	8b 81       	ldd	r24, Y+3	; 0x03
    239c:	9c 81       	ldd	r25, Y+4	; 0x04
    239e:	01 97       	sbiw	r24, 0x01	; 1
    23a0:	9c 83       	std	Y+4, r25	; 0x04
    23a2:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    23a4:	8d 81       	ldd	r24, Y+5	; 0x05
    23a6:	9e 81       	ldd	r25, Y+6	; 0x06
    23a8:	9a 83       	std	Y+2, r25	; 0x02
    23aa:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    23ac:	29 81       	ldd	r18, Y+1	; 0x01
    23ae:	8b 81       	ldd	r24, Y+3	; 0x03
    23b0:	9c 81       	ldd	r25, Y+4	; 0x04
    23b2:	fc 01       	movw	r30, r24
    23b4:	20 83       	st	Z, r18
	pxTopOfStack--;
    23b6:	8b 81       	ldd	r24, Y+3	; 0x03
    23b8:	9c 81       	ldd	r25, Y+4	; 0x04
    23ba:	01 97       	sbiw	r24, 0x01	; 1
    23bc:	9c 83       	std	Y+4, r25	; 0x04
    23be:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    23c0:	89 81       	ldd	r24, Y+1	; 0x01
    23c2:	9a 81       	ldd	r25, Y+2	; 0x02
    23c4:	89 2f       	mov	r24, r25
    23c6:	99 27       	eor	r25, r25
    23c8:	9a 83       	std	Y+2, r25	; 0x02
    23ca:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    23cc:	29 81       	ldd	r18, Y+1	; 0x01
    23ce:	8b 81       	ldd	r24, Y+3	; 0x03
    23d0:	9c 81       	ldd	r25, Y+4	; 0x04
    23d2:	fc 01       	movw	r30, r24
    23d4:	20 83       	st	Z, r18
	pxTopOfStack--;
    23d6:	8b 81       	ldd	r24, Y+3	; 0x03
    23d8:	9c 81       	ldd	r25, Y+4	; 0x04
    23da:	01 97       	sbiw	r24, 0x01	; 1
    23dc:	9c 83       	std	Y+4, r25	; 0x04
    23de:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    23e0:	8b 81       	ldd	r24, Y+3	; 0x03
    23e2:	9c 81       	ldd	r25, Y+4	; 0x04
    23e4:	fc 01       	movw	r30, r24
    23e6:	10 82       	st	Z, r1
	pxTopOfStack--;
    23e8:	8b 81       	ldd	r24, Y+3	; 0x03
    23ea:	9c 81       	ldd	r25, Y+4	; 0x04
    23ec:	01 97       	sbiw	r24, 0x01	; 1
    23ee:	9c 83       	std	Y+4, r25	; 0x04
    23f0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    23f2:	8b 81       	ldd	r24, Y+3	; 0x03
    23f4:	9c 81       	ldd	r25, Y+4	; 0x04
    23f6:	20 e8       	ldi	r18, 0x80	; 128
    23f8:	fc 01       	movw	r30, r24
    23fa:	20 83       	st	Z, r18
	pxTopOfStack--;
    23fc:	8b 81       	ldd	r24, Y+3	; 0x03
    23fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2400:	01 97       	sbiw	r24, 0x01	; 1
    2402:	9c 83       	std	Y+4, r25	; 0x04
    2404:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2406:	8b 81       	ldd	r24, Y+3	; 0x03
    2408:	9c 81       	ldd	r25, Y+4	; 0x04
    240a:	fc 01       	movw	r30, r24
    240c:	10 82       	st	Z, r1
	pxTopOfStack--;
    240e:	8b 81       	ldd	r24, Y+3	; 0x03
    2410:	9c 81       	ldd	r25, Y+4	; 0x04
    2412:	01 97       	sbiw	r24, 0x01	; 1
    2414:	9c 83       	std	Y+4, r25	; 0x04
    2416:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2418:	8b 81       	ldd	r24, Y+3	; 0x03
    241a:	9c 81       	ldd	r25, Y+4	; 0x04
    241c:	22 e0       	ldi	r18, 0x02	; 2
    241e:	fc 01       	movw	r30, r24
    2420:	20 83       	st	Z, r18
	pxTopOfStack--;
    2422:	8b 81       	ldd	r24, Y+3	; 0x03
    2424:	9c 81       	ldd	r25, Y+4	; 0x04
    2426:	01 97       	sbiw	r24, 0x01	; 1
    2428:	9c 83       	std	Y+4, r25	; 0x04
    242a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    242c:	8b 81       	ldd	r24, Y+3	; 0x03
    242e:	9c 81       	ldd	r25, Y+4	; 0x04
    2430:	23 e0       	ldi	r18, 0x03	; 3
    2432:	fc 01       	movw	r30, r24
    2434:	20 83       	st	Z, r18
	pxTopOfStack--;
    2436:	8b 81       	ldd	r24, Y+3	; 0x03
    2438:	9c 81       	ldd	r25, Y+4	; 0x04
    243a:	01 97       	sbiw	r24, 0x01	; 1
    243c:	9c 83       	std	Y+4, r25	; 0x04
    243e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2440:	8b 81       	ldd	r24, Y+3	; 0x03
    2442:	9c 81       	ldd	r25, Y+4	; 0x04
    2444:	24 e0       	ldi	r18, 0x04	; 4
    2446:	fc 01       	movw	r30, r24
    2448:	20 83       	st	Z, r18
	pxTopOfStack--;
    244a:	8b 81       	ldd	r24, Y+3	; 0x03
    244c:	9c 81       	ldd	r25, Y+4	; 0x04
    244e:	01 97       	sbiw	r24, 0x01	; 1
    2450:	9c 83       	std	Y+4, r25	; 0x04
    2452:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2454:	8b 81       	ldd	r24, Y+3	; 0x03
    2456:	9c 81       	ldd	r25, Y+4	; 0x04
    2458:	25 e0       	ldi	r18, 0x05	; 5
    245a:	fc 01       	movw	r30, r24
    245c:	20 83       	st	Z, r18
	pxTopOfStack--;
    245e:	8b 81       	ldd	r24, Y+3	; 0x03
    2460:	9c 81       	ldd	r25, Y+4	; 0x04
    2462:	01 97       	sbiw	r24, 0x01	; 1
    2464:	9c 83       	std	Y+4, r25	; 0x04
    2466:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2468:	8b 81       	ldd	r24, Y+3	; 0x03
    246a:	9c 81       	ldd	r25, Y+4	; 0x04
    246c:	26 e0       	ldi	r18, 0x06	; 6
    246e:	fc 01       	movw	r30, r24
    2470:	20 83       	st	Z, r18
	pxTopOfStack--;
    2472:	8b 81       	ldd	r24, Y+3	; 0x03
    2474:	9c 81       	ldd	r25, Y+4	; 0x04
    2476:	01 97       	sbiw	r24, 0x01	; 1
    2478:	9c 83       	std	Y+4, r25	; 0x04
    247a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    247c:	8b 81       	ldd	r24, Y+3	; 0x03
    247e:	9c 81       	ldd	r25, Y+4	; 0x04
    2480:	27 e0       	ldi	r18, 0x07	; 7
    2482:	fc 01       	movw	r30, r24
    2484:	20 83       	st	Z, r18
	pxTopOfStack--;
    2486:	8b 81       	ldd	r24, Y+3	; 0x03
    2488:	9c 81       	ldd	r25, Y+4	; 0x04
    248a:	01 97       	sbiw	r24, 0x01	; 1
    248c:	9c 83       	std	Y+4, r25	; 0x04
    248e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2490:	8b 81       	ldd	r24, Y+3	; 0x03
    2492:	9c 81       	ldd	r25, Y+4	; 0x04
    2494:	28 e0       	ldi	r18, 0x08	; 8
    2496:	fc 01       	movw	r30, r24
    2498:	20 83       	st	Z, r18
	pxTopOfStack--;
    249a:	8b 81       	ldd	r24, Y+3	; 0x03
    249c:	9c 81       	ldd	r25, Y+4	; 0x04
    249e:	01 97       	sbiw	r24, 0x01	; 1
    24a0:	9c 83       	std	Y+4, r25	; 0x04
    24a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    24a4:	8b 81       	ldd	r24, Y+3	; 0x03
    24a6:	9c 81       	ldd	r25, Y+4	; 0x04
    24a8:	29 e0       	ldi	r18, 0x09	; 9
    24aa:	fc 01       	movw	r30, r24
    24ac:	20 83       	st	Z, r18
	pxTopOfStack--;
    24ae:	8b 81       	ldd	r24, Y+3	; 0x03
    24b0:	9c 81       	ldd	r25, Y+4	; 0x04
    24b2:	01 97       	sbiw	r24, 0x01	; 1
    24b4:	9c 83       	std	Y+4, r25	; 0x04
    24b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    24b8:	8b 81       	ldd	r24, Y+3	; 0x03
    24ba:	9c 81       	ldd	r25, Y+4	; 0x04
    24bc:	20 e1       	ldi	r18, 0x10	; 16
    24be:	fc 01       	movw	r30, r24
    24c0:	20 83       	st	Z, r18
	pxTopOfStack--;
    24c2:	8b 81       	ldd	r24, Y+3	; 0x03
    24c4:	9c 81       	ldd	r25, Y+4	; 0x04
    24c6:	01 97       	sbiw	r24, 0x01	; 1
    24c8:	9c 83       	std	Y+4, r25	; 0x04
    24ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    24cc:	8b 81       	ldd	r24, Y+3	; 0x03
    24ce:	9c 81       	ldd	r25, Y+4	; 0x04
    24d0:	21 e1       	ldi	r18, 0x11	; 17
    24d2:	fc 01       	movw	r30, r24
    24d4:	20 83       	st	Z, r18
	pxTopOfStack--;
    24d6:	8b 81       	ldd	r24, Y+3	; 0x03
    24d8:	9c 81       	ldd	r25, Y+4	; 0x04
    24da:	01 97       	sbiw	r24, 0x01	; 1
    24dc:	9c 83       	std	Y+4, r25	; 0x04
    24de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    24e0:	8b 81       	ldd	r24, Y+3	; 0x03
    24e2:	9c 81       	ldd	r25, Y+4	; 0x04
    24e4:	22 e1       	ldi	r18, 0x12	; 18
    24e6:	fc 01       	movw	r30, r24
    24e8:	20 83       	st	Z, r18
	pxTopOfStack--;
    24ea:	8b 81       	ldd	r24, Y+3	; 0x03
    24ec:	9c 81       	ldd	r25, Y+4	; 0x04
    24ee:	01 97       	sbiw	r24, 0x01	; 1
    24f0:	9c 83       	std	Y+4, r25	; 0x04
    24f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    24f4:	8b 81       	ldd	r24, Y+3	; 0x03
    24f6:	9c 81       	ldd	r25, Y+4	; 0x04
    24f8:	23 e1       	ldi	r18, 0x13	; 19
    24fa:	fc 01       	movw	r30, r24
    24fc:	20 83       	st	Z, r18
	pxTopOfStack--;
    24fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2500:	9c 81       	ldd	r25, Y+4	; 0x04
    2502:	01 97       	sbiw	r24, 0x01	; 1
    2504:	9c 83       	std	Y+4, r25	; 0x04
    2506:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2508:	8b 81       	ldd	r24, Y+3	; 0x03
    250a:	9c 81       	ldd	r25, Y+4	; 0x04
    250c:	24 e1       	ldi	r18, 0x14	; 20
    250e:	fc 01       	movw	r30, r24
    2510:	20 83       	st	Z, r18
	pxTopOfStack--;
    2512:	8b 81       	ldd	r24, Y+3	; 0x03
    2514:	9c 81       	ldd	r25, Y+4	; 0x04
    2516:	01 97       	sbiw	r24, 0x01	; 1
    2518:	9c 83       	std	Y+4, r25	; 0x04
    251a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    251c:	8b 81       	ldd	r24, Y+3	; 0x03
    251e:	9c 81       	ldd	r25, Y+4	; 0x04
    2520:	25 e1       	ldi	r18, 0x15	; 21
    2522:	fc 01       	movw	r30, r24
    2524:	20 83       	st	Z, r18
	pxTopOfStack--;
    2526:	8b 81       	ldd	r24, Y+3	; 0x03
    2528:	9c 81       	ldd	r25, Y+4	; 0x04
    252a:	01 97       	sbiw	r24, 0x01	; 1
    252c:	9c 83       	std	Y+4, r25	; 0x04
    252e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2530:	8b 81       	ldd	r24, Y+3	; 0x03
    2532:	9c 81       	ldd	r25, Y+4	; 0x04
    2534:	26 e1       	ldi	r18, 0x16	; 22
    2536:	fc 01       	movw	r30, r24
    2538:	20 83       	st	Z, r18
	pxTopOfStack--;
    253a:	8b 81       	ldd	r24, Y+3	; 0x03
    253c:	9c 81       	ldd	r25, Y+4	; 0x04
    253e:	01 97       	sbiw	r24, 0x01	; 1
    2540:	9c 83       	std	Y+4, r25	; 0x04
    2542:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2544:	8b 81       	ldd	r24, Y+3	; 0x03
    2546:	9c 81       	ldd	r25, Y+4	; 0x04
    2548:	27 e1       	ldi	r18, 0x17	; 23
    254a:	fc 01       	movw	r30, r24
    254c:	20 83       	st	Z, r18
	pxTopOfStack--;
    254e:	8b 81       	ldd	r24, Y+3	; 0x03
    2550:	9c 81       	ldd	r25, Y+4	; 0x04
    2552:	01 97       	sbiw	r24, 0x01	; 1
    2554:	9c 83       	std	Y+4, r25	; 0x04
    2556:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2558:	8b 81       	ldd	r24, Y+3	; 0x03
    255a:	9c 81       	ldd	r25, Y+4	; 0x04
    255c:	28 e1       	ldi	r18, 0x18	; 24
    255e:	fc 01       	movw	r30, r24
    2560:	20 83       	st	Z, r18
	pxTopOfStack--;
    2562:	8b 81       	ldd	r24, Y+3	; 0x03
    2564:	9c 81       	ldd	r25, Y+4	; 0x04
    2566:	01 97       	sbiw	r24, 0x01	; 1
    2568:	9c 83       	std	Y+4, r25	; 0x04
    256a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    256c:	8b 81       	ldd	r24, Y+3	; 0x03
    256e:	9c 81       	ldd	r25, Y+4	; 0x04
    2570:	29 e1       	ldi	r18, 0x19	; 25
    2572:	fc 01       	movw	r30, r24
    2574:	20 83       	st	Z, r18
	pxTopOfStack--;
    2576:	8b 81       	ldd	r24, Y+3	; 0x03
    2578:	9c 81       	ldd	r25, Y+4	; 0x04
    257a:	01 97       	sbiw	r24, 0x01	; 1
    257c:	9c 83       	std	Y+4, r25	; 0x04
    257e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2580:	8b 81       	ldd	r24, Y+3	; 0x03
    2582:	9c 81       	ldd	r25, Y+4	; 0x04
    2584:	20 e2       	ldi	r18, 0x20	; 32
    2586:	fc 01       	movw	r30, r24
    2588:	20 83       	st	Z, r18
	pxTopOfStack--;
    258a:	8b 81       	ldd	r24, Y+3	; 0x03
    258c:	9c 81       	ldd	r25, Y+4	; 0x04
    258e:	01 97       	sbiw	r24, 0x01	; 1
    2590:	9c 83       	std	Y+4, r25	; 0x04
    2592:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2594:	8b 81       	ldd	r24, Y+3	; 0x03
    2596:	9c 81       	ldd	r25, Y+4	; 0x04
    2598:	21 e2       	ldi	r18, 0x21	; 33
    259a:	fc 01       	movw	r30, r24
    259c:	20 83       	st	Z, r18
	pxTopOfStack--;
    259e:	8b 81       	ldd	r24, Y+3	; 0x03
    25a0:	9c 81       	ldd	r25, Y+4	; 0x04
    25a2:	01 97       	sbiw	r24, 0x01	; 1
    25a4:	9c 83       	std	Y+4, r25	; 0x04
    25a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    25a8:	8b 81       	ldd	r24, Y+3	; 0x03
    25aa:	9c 81       	ldd	r25, Y+4	; 0x04
    25ac:	22 e2       	ldi	r18, 0x22	; 34
    25ae:	fc 01       	movw	r30, r24
    25b0:	20 83       	st	Z, r18
	pxTopOfStack--;
    25b2:	8b 81       	ldd	r24, Y+3	; 0x03
    25b4:	9c 81       	ldd	r25, Y+4	; 0x04
    25b6:	01 97       	sbiw	r24, 0x01	; 1
    25b8:	9c 83       	std	Y+4, r25	; 0x04
    25ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    25bc:	8b 81       	ldd	r24, Y+3	; 0x03
    25be:	9c 81       	ldd	r25, Y+4	; 0x04
    25c0:	23 e2       	ldi	r18, 0x23	; 35
    25c2:	fc 01       	movw	r30, r24
    25c4:	20 83       	st	Z, r18
	pxTopOfStack--;
    25c6:	8b 81       	ldd	r24, Y+3	; 0x03
    25c8:	9c 81       	ldd	r25, Y+4	; 0x04
    25ca:	01 97       	sbiw	r24, 0x01	; 1
    25cc:	9c 83       	std	Y+4, r25	; 0x04
    25ce:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    25d0:	8f 81       	ldd	r24, Y+7	; 0x07
    25d2:	98 85       	ldd	r25, Y+8	; 0x08
    25d4:	9a 83       	std	Y+2, r25	; 0x02
    25d6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    25d8:	29 81       	ldd	r18, Y+1	; 0x01
    25da:	8b 81       	ldd	r24, Y+3	; 0x03
    25dc:	9c 81       	ldd	r25, Y+4	; 0x04
    25de:	fc 01       	movw	r30, r24
    25e0:	20 83       	st	Z, r18
	pxTopOfStack--;
    25e2:	8b 81       	ldd	r24, Y+3	; 0x03
    25e4:	9c 81       	ldd	r25, Y+4	; 0x04
    25e6:	01 97       	sbiw	r24, 0x01	; 1
    25e8:	9c 83       	std	Y+4, r25	; 0x04
    25ea:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    25ec:	89 81       	ldd	r24, Y+1	; 0x01
    25ee:	9a 81       	ldd	r25, Y+2	; 0x02
    25f0:	89 2f       	mov	r24, r25
    25f2:	99 27       	eor	r25, r25
    25f4:	9a 83       	std	Y+2, r25	; 0x02
    25f6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    25f8:	29 81       	ldd	r18, Y+1	; 0x01
    25fa:	8b 81       	ldd	r24, Y+3	; 0x03
    25fc:	9c 81       	ldd	r25, Y+4	; 0x04
    25fe:	fc 01       	movw	r30, r24
    2600:	20 83       	st	Z, r18
	pxTopOfStack--;
    2602:	8b 81       	ldd	r24, Y+3	; 0x03
    2604:	9c 81       	ldd	r25, Y+4	; 0x04
    2606:	01 97       	sbiw	r24, 0x01	; 1
    2608:	9c 83       	std	Y+4, r25	; 0x04
    260a:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    260c:	8b 81       	ldd	r24, Y+3	; 0x03
    260e:	9c 81       	ldd	r25, Y+4	; 0x04
    2610:	26 e2       	ldi	r18, 0x26	; 38
    2612:	fc 01       	movw	r30, r24
    2614:	20 83       	st	Z, r18
	pxTopOfStack--;
    2616:	8b 81       	ldd	r24, Y+3	; 0x03
    2618:	9c 81       	ldd	r25, Y+4	; 0x04
    261a:	01 97       	sbiw	r24, 0x01	; 1
    261c:	9c 83       	std	Y+4, r25	; 0x04
    261e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2620:	8b 81       	ldd	r24, Y+3	; 0x03
    2622:	9c 81       	ldd	r25, Y+4	; 0x04
    2624:	27 e2       	ldi	r18, 0x27	; 39
    2626:	fc 01       	movw	r30, r24
    2628:	20 83       	st	Z, r18
	pxTopOfStack--;
    262a:	8b 81       	ldd	r24, Y+3	; 0x03
    262c:	9c 81       	ldd	r25, Y+4	; 0x04
    262e:	01 97       	sbiw	r24, 0x01	; 1
    2630:	9c 83       	std	Y+4, r25	; 0x04
    2632:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2634:	8b 81       	ldd	r24, Y+3	; 0x03
    2636:	9c 81       	ldd	r25, Y+4	; 0x04
    2638:	28 e2       	ldi	r18, 0x28	; 40
    263a:	fc 01       	movw	r30, r24
    263c:	20 83       	st	Z, r18
	pxTopOfStack--;
    263e:	8b 81       	ldd	r24, Y+3	; 0x03
    2640:	9c 81       	ldd	r25, Y+4	; 0x04
    2642:	01 97       	sbiw	r24, 0x01	; 1
    2644:	9c 83       	std	Y+4, r25	; 0x04
    2646:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2648:	8b 81       	ldd	r24, Y+3	; 0x03
    264a:	9c 81       	ldd	r25, Y+4	; 0x04
    264c:	29 e2       	ldi	r18, 0x29	; 41
    264e:	fc 01       	movw	r30, r24
    2650:	20 83       	st	Z, r18
	pxTopOfStack--;
    2652:	8b 81       	ldd	r24, Y+3	; 0x03
    2654:	9c 81       	ldd	r25, Y+4	; 0x04
    2656:	01 97       	sbiw	r24, 0x01	; 1
    2658:	9c 83       	std	Y+4, r25	; 0x04
    265a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    265c:	8b 81       	ldd	r24, Y+3	; 0x03
    265e:	9c 81       	ldd	r25, Y+4	; 0x04
    2660:	20 e3       	ldi	r18, 0x30	; 48
    2662:	fc 01       	movw	r30, r24
    2664:	20 83       	st	Z, r18
	pxTopOfStack--;
    2666:	8b 81       	ldd	r24, Y+3	; 0x03
    2668:	9c 81       	ldd	r25, Y+4	; 0x04
    266a:	01 97       	sbiw	r24, 0x01	; 1
    266c:	9c 83       	std	Y+4, r25	; 0x04
    266e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2670:	8b 81       	ldd	r24, Y+3	; 0x03
    2672:	9c 81       	ldd	r25, Y+4	; 0x04
    2674:	21 e3       	ldi	r18, 0x31	; 49
    2676:	fc 01       	movw	r30, r24
    2678:	20 83       	st	Z, r18
	pxTopOfStack--;
    267a:	8b 81       	ldd	r24, Y+3	; 0x03
    267c:	9c 81       	ldd	r25, Y+4	; 0x04
    267e:	01 97       	sbiw	r24, 0x01	; 1
    2680:	9c 83       	std	Y+4, r25	; 0x04
    2682:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2684:	8b 81       	ldd	r24, Y+3	; 0x03
    2686:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2688:	28 96       	adiw	r28, 0x08	; 8
    268a:	0f b6       	in	r0, 0x3f	; 63
    268c:	f8 94       	cli
    268e:	de bf       	out	0x3e, r29	; 62
    2690:	0f be       	out	0x3f, r0	; 63
    2692:	cd bf       	out	0x3d, r28	; 61
    2694:	df 91       	pop	r29
    2696:	cf 91       	pop	r28
    2698:	08 95       	ret

0000269a <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    269a:	cf 93       	push	r28
    269c:	df 93       	push	r29
    269e:	cd b7       	in	r28, 0x3d	; 61
    26a0:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    26a2:	0e 94 3f 14 	call	0x287e	; 0x287e <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    26a6:	a0 91 fe 04 	lds	r26, 0x04FE
    26aa:	b0 91 ff 04 	lds	r27, 0x04FF
    26ae:	cd 91       	ld	r28, X+
    26b0:	cd bf       	out	0x3d, r28	; 61
    26b2:	dd 91       	ld	r29, X+
    26b4:	de bf       	out	0x3e, r29	; 62
    26b6:	ff 91       	pop	r31
    26b8:	ef 91       	pop	r30
    26ba:	df 91       	pop	r29
    26bc:	cf 91       	pop	r28
    26be:	bf 91       	pop	r27
    26c0:	af 91       	pop	r26
    26c2:	9f 91       	pop	r25
    26c4:	8f 91       	pop	r24
    26c6:	7f 91       	pop	r23
    26c8:	6f 91       	pop	r22
    26ca:	5f 91       	pop	r21
    26cc:	4f 91       	pop	r20
    26ce:	3f 91       	pop	r19
    26d0:	2f 91       	pop	r18
    26d2:	1f 91       	pop	r17
    26d4:	0f 91       	pop	r16
    26d6:	ff 90       	pop	r15
    26d8:	ef 90       	pop	r14
    26da:	df 90       	pop	r13
    26dc:	cf 90       	pop	r12
    26de:	bf 90       	pop	r11
    26e0:	af 90       	pop	r10
    26e2:	9f 90       	pop	r9
    26e4:	8f 90       	pop	r8
    26e6:	7f 90       	pop	r7
    26e8:	6f 90       	pop	r6
    26ea:	5f 90       	pop	r5
    26ec:	4f 90       	pop	r4
    26ee:	3f 90       	pop	r3
    26f0:	2f 90       	pop	r2
    26f2:	1f 90       	pop	r1
    26f4:	0f 90       	pop	r0
    26f6:	0f be       	out	0x3f, r0	; 63
    26f8:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    26fa:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    26fc:	81 e0       	ldi	r24, 0x01	; 1
}
    26fe:	df 91       	pop	r29
    2700:	cf 91       	pop	r28
    2702:	08 95       	ret

00002704 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2704:	cf 93       	push	r28
    2706:	df 93       	push	r29
    2708:	cd b7       	in	r28, 0x3d	; 61
    270a:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    270c:	df 91       	pop	r29
    270e:	cf 91       	pop	r28
    2710:	08 95       	ret

00002712 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2712:	0f 92       	push	r0
    2714:	0f b6       	in	r0, 0x3f	; 63
    2716:	f8 94       	cli
    2718:	0f 92       	push	r0
    271a:	1f 92       	push	r1
    271c:	11 24       	eor	r1, r1
    271e:	2f 92       	push	r2
    2720:	3f 92       	push	r3
    2722:	4f 92       	push	r4
    2724:	5f 92       	push	r5
    2726:	6f 92       	push	r6
    2728:	7f 92       	push	r7
    272a:	8f 92       	push	r8
    272c:	9f 92       	push	r9
    272e:	af 92       	push	r10
    2730:	bf 92       	push	r11
    2732:	cf 92       	push	r12
    2734:	df 92       	push	r13
    2736:	ef 92       	push	r14
    2738:	ff 92       	push	r15
    273a:	0f 93       	push	r16
    273c:	1f 93       	push	r17
    273e:	2f 93       	push	r18
    2740:	3f 93       	push	r19
    2742:	4f 93       	push	r20
    2744:	5f 93       	push	r21
    2746:	6f 93       	push	r22
    2748:	7f 93       	push	r23
    274a:	8f 93       	push	r24
    274c:	9f 93       	push	r25
    274e:	af 93       	push	r26
    2750:	bf 93       	push	r27
    2752:	cf 93       	push	r28
    2754:	df 93       	push	r29
    2756:	ef 93       	push	r30
    2758:	ff 93       	push	r31
    275a:	a0 91 fe 04 	lds	r26, 0x04FE
    275e:	b0 91 ff 04 	lds	r27, 0x04FF
    2762:	0d b6       	in	r0, 0x3d	; 61
    2764:	0d 92       	st	X+, r0
    2766:	0e b6       	in	r0, 0x3e	; 62
    2768:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    276a:	0e 94 40 1f 	call	0x3e80	; 0x3e80 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    276e:	a0 91 fe 04 	lds	r26, 0x04FE
    2772:	b0 91 ff 04 	lds	r27, 0x04FF
    2776:	cd 91       	ld	r28, X+
    2778:	cd bf       	out	0x3d, r28	; 61
    277a:	dd 91       	ld	r29, X+
    277c:	de bf       	out	0x3e, r29	; 62
    277e:	ff 91       	pop	r31
    2780:	ef 91       	pop	r30
    2782:	df 91       	pop	r29
    2784:	cf 91       	pop	r28
    2786:	bf 91       	pop	r27
    2788:	af 91       	pop	r26
    278a:	9f 91       	pop	r25
    278c:	8f 91       	pop	r24
    278e:	7f 91       	pop	r23
    2790:	6f 91       	pop	r22
    2792:	5f 91       	pop	r21
    2794:	4f 91       	pop	r20
    2796:	3f 91       	pop	r19
    2798:	2f 91       	pop	r18
    279a:	1f 91       	pop	r17
    279c:	0f 91       	pop	r16
    279e:	ff 90       	pop	r15
    27a0:	ef 90       	pop	r14
    27a2:	df 90       	pop	r13
    27a4:	cf 90       	pop	r12
    27a6:	bf 90       	pop	r11
    27a8:	af 90       	pop	r10
    27aa:	9f 90       	pop	r9
    27ac:	8f 90       	pop	r8
    27ae:	7f 90       	pop	r7
    27b0:	6f 90       	pop	r6
    27b2:	5f 90       	pop	r5
    27b4:	4f 90       	pop	r4
    27b6:	3f 90       	pop	r3
    27b8:	2f 90       	pop	r2
    27ba:	1f 90       	pop	r1
    27bc:	0f 90       	pop	r0
    27be:	0f be       	out	0x3f, r0	; 63
    27c0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    27c2:	08 95       	ret

000027c4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    27c4:	0f 92       	push	r0
    27c6:	0f b6       	in	r0, 0x3f	; 63
    27c8:	f8 94       	cli
    27ca:	0f 92       	push	r0
    27cc:	1f 92       	push	r1
    27ce:	11 24       	eor	r1, r1
    27d0:	2f 92       	push	r2
    27d2:	3f 92       	push	r3
    27d4:	4f 92       	push	r4
    27d6:	5f 92       	push	r5
    27d8:	6f 92       	push	r6
    27da:	7f 92       	push	r7
    27dc:	8f 92       	push	r8
    27de:	9f 92       	push	r9
    27e0:	af 92       	push	r10
    27e2:	bf 92       	push	r11
    27e4:	cf 92       	push	r12
    27e6:	df 92       	push	r13
    27e8:	ef 92       	push	r14
    27ea:	ff 92       	push	r15
    27ec:	0f 93       	push	r16
    27ee:	1f 93       	push	r17
    27f0:	2f 93       	push	r18
    27f2:	3f 93       	push	r19
    27f4:	4f 93       	push	r20
    27f6:	5f 93       	push	r21
    27f8:	6f 93       	push	r22
    27fa:	7f 93       	push	r23
    27fc:	8f 93       	push	r24
    27fe:	9f 93       	push	r25
    2800:	af 93       	push	r26
    2802:	bf 93       	push	r27
    2804:	cf 93       	push	r28
    2806:	df 93       	push	r29
    2808:	ef 93       	push	r30
    280a:	ff 93       	push	r31
    280c:	a0 91 fe 04 	lds	r26, 0x04FE
    2810:	b0 91 ff 04 	lds	r27, 0x04FF
    2814:	0d b6       	in	r0, 0x3d	; 61
    2816:	0d 92       	st	X+, r0
    2818:	0e b6       	in	r0, 0x3e	; 62
    281a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    281c:	0e 94 52 1e 	call	0x3ca4	; 0x3ca4 <xTaskIncrementTick>
    2820:	88 23       	and	r24, r24
    2822:	11 f0       	breq	.+4      	; 0x2828 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2824:	0e 94 40 1f 	call	0x3e80	; 0x3e80 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2828:	a0 91 fe 04 	lds	r26, 0x04FE
    282c:	b0 91 ff 04 	lds	r27, 0x04FF
    2830:	cd 91       	ld	r28, X+
    2832:	cd bf       	out	0x3d, r28	; 61
    2834:	dd 91       	ld	r29, X+
    2836:	de bf       	out	0x3e, r29	; 62
    2838:	ff 91       	pop	r31
    283a:	ef 91       	pop	r30
    283c:	df 91       	pop	r29
    283e:	cf 91       	pop	r28
    2840:	bf 91       	pop	r27
    2842:	af 91       	pop	r26
    2844:	9f 91       	pop	r25
    2846:	8f 91       	pop	r24
    2848:	7f 91       	pop	r23
    284a:	6f 91       	pop	r22
    284c:	5f 91       	pop	r21
    284e:	4f 91       	pop	r20
    2850:	3f 91       	pop	r19
    2852:	2f 91       	pop	r18
    2854:	1f 91       	pop	r17
    2856:	0f 91       	pop	r16
    2858:	ff 90       	pop	r15
    285a:	ef 90       	pop	r14
    285c:	df 90       	pop	r13
    285e:	cf 90       	pop	r12
    2860:	bf 90       	pop	r11
    2862:	af 90       	pop	r10
    2864:	9f 90       	pop	r9
    2866:	8f 90       	pop	r8
    2868:	7f 90       	pop	r7
    286a:	6f 90       	pop	r6
    286c:	5f 90       	pop	r5
    286e:	4f 90       	pop	r4
    2870:	3f 90       	pop	r3
    2872:	2f 90       	pop	r2
    2874:	1f 90       	pop	r1
    2876:	0f 90       	pop	r0
    2878:	0f be       	out	0x3f, r0	; 63
    287a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    287c:	08 95       	ret

0000287e <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    287e:	cf 93       	push	r28
    2880:	df 93       	push	r29
    2882:	00 d0       	rcall	.+0      	; 0x2884 <prvSetupTimerInterrupt+0x6>
    2884:	00 d0       	rcall	.+0      	; 0x2886 <prvSetupTimerInterrupt+0x8>
    2886:	00 d0       	rcall	.+0      	; 0x2888 <prvSetupTimerInterrupt+0xa>
    2888:	cd b7       	in	r28, 0x3d	; 61
    288a:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    288c:	80 e8       	ldi	r24, 0x80	; 128
    288e:	9e e3       	ldi	r25, 0x3E	; 62
    2890:	a0 e0       	ldi	r26, 0x00	; 0
    2892:	b0 e0       	ldi	r27, 0x00	; 0
    2894:	89 83       	std	Y+1, r24	; 0x01
    2896:	9a 83       	std	Y+2, r25	; 0x02
    2898:	ab 83       	std	Y+3, r26	; 0x03
    289a:	bc 83       	std	Y+4, r27	; 0x04

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    289c:	89 81       	ldd	r24, Y+1	; 0x01
    289e:	9a 81       	ldd	r25, Y+2	; 0x02
    28a0:	ab 81       	ldd	r26, Y+3	; 0x03
    28a2:	bc 81       	ldd	r27, Y+4	; 0x04
    28a4:	68 94       	set
    28a6:	15 f8       	bld	r1, 5
    28a8:	b6 95       	lsr	r27
    28aa:	a7 95       	ror	r26
    28ac:	97 95       	ror	r25
    28ae:	87 95       	ror	r24
    28b0:	16 94       	lsr	r1
    28b2:	d1 f7       	brne	.-12     	; 0x28a8 <prvSetupTimerInterrupt+0x2a>
    28b4:	89 83       	std	Y+1, r24	; 0x01
    28b6:	9a 83       	std	Y+2, r25	; 0x02
    28b8:	ab 83       	std	Y+3, r26	; 0x03
    28ba:	bc 83       	std	Y+4, r27	; 0x04

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    28bc:	89 81       	ldd	r24, Y+1	; 0x01
    28be:	9a 81       	ldd	r25, Y+2	; 0x02
    28c0:	ab 81       	ldd	r26, Y+3	; 0x03
    28c2:	bc 81       	ldd	r27, Y+4	; 0x04
    28c4:	01 97       	sbiw	r24, 0x01	; 1
    28c6:	a1 09       	sbc	r26, r1
    28c8:	b1 09       	sbc	r27, r1
    28ca:	89 83       	std	Y+1, r24	; 0x01
    28cc:	9a 83       	std	Y+2, r25	; 0x02
    28ce:	ab 83       	std	Y+3, r26	; 0x03
    28d0:	bc 83       	std	Y+4, r27	; 0x04

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    28d2:	89 81       	ldd	r24, Y+1	; 0x01
    28d4:	8d 83       	std	Y+5, r24	; 0x05
	ulCompareMatch >>= 8;
    28d6:	89 81       	ldd	r24, Y+1	; 0x01
    28d8:	9a 81       	ldd	r25, Y+2	; 0x02
    28da:	ab 81       	ldd	r26, Y+3	; 0x03
    28dc:	bc 81       	ldd	r27, Y+4	; 0x04
    28de:	89 2f       	mov	r24, r25
    28e0:	9a 2f       	mov	r25, r26
    28e2:	ab 2f       	mov	r26, r27
    28e4:	bb 27       	eor	r27, r27
    28e6:	89 83       	std	Y+1, r24	; 0x01
    28e8:	9a 83       	std	Y+2, r25	; 0x02
    28ea:	ab 83       	std	Y+3, r26	; 0x03
    28ec:	bc 83       	std	Y+4, r27	; 0x04
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    28ee:	89 81       	ldd	r24, Y+1	; 0x01
    28f0:	8e 83       	std	Y+6, r24	; 0x06
	OCR1AH = ucHighByte;
    28f2:	89 e8       	ldi	r24, 0x89	; 137
    28f4:	90 e0       	ldi	r25, 0x00	; 0
    28f6:	2e 81       	ldd	r18, Y+6	; 0x06
    28f8:	fc 01       	movw	r30, r24
    28fa:	20 83       	st	Z, r18
	OCR1AL = ucLowByte;
    28fc:	88 e8       	ldi	r24, 0x88	; 136
    28fe:	90 e0       	ldi	r25, 0x00	; 0
    2900:	2d 81       	ldd	r18, Y+5	; 0x05
    2902:	fc 01       	movw	r30, r24
    2904:	20 83       	st	Z, r18

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2906:	8b e0       	ldi	r24, 0x0B	; 11
    2908:	8d 83       	std	Y+5, r24	; 0x05
	TCCR1B = ucLowByte;
    290a:	81 e8       	ldi	r24, 0x81	; 129
    290c:	90 e0       	ldi	r25, 0x00	; 0
    290e:	2d 81       	ldd	r18, Y+5	; 0x05
    2910:	fc 01       	movw	r30, r24
    2912:	20 83       	st	Z, r18

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    2914:	8f e6       	ldi	r24, 0x6F	; 111
    2916:	90 e0       	ldi	r25, 0x00	; 0
    2918:	fc 01       	movw	r30, r24
    291a:	80 81       	ld	r24, Z
    291c:	8d 83       	std	Y+5, r24	; 0x05
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    291e:	8d 81       	ldd	r24, Y+5	; 0x05
    2920:	82 60       	ori	r24, 0x02	; 2
    2922:	8d 83       	std	Y+5, r24	; 0x05
	TIMSK1 = ucLowByte;
    2924:	8f e6       	ldi	r24, 0x6F	; 111
    2926:	90 e0       	ldi	r25, 0x00	; 0
    2928:	2d 81       	ldd	r18, Y+5	; 0x05
    292a:	fc 01       	movw	r30, r24
    292c:	20 83       	st	Z, r18
	
	TCNT1 = 0;
    292e:	84 e8       	ldi	r24, 0x84	; 132
    2930:	90 e0       	ldi	r25, 0x00	; 0
    2932:	fc 01       	movw	r30, r24
    2934:	11 82       	std	Z+1, r1	; 0x01
    2936:	10 82       	st	Z, r1
}
    2938:	26 96       	adiw	r28, 0x06	; 6
    293a:	0f b6       	in	r0, 0x3f	; 63
    293c:	f8 94       	cli
    293e:	de bf       	out	0x3e, r29	; 62
    2940:	0f be       	out	0x3f, r0	; 63
    2942:	cd bf       	out	0x3d, r28	; 61
    2944:	df 91       	pop	r29
    2946:	cf 91       	pop	r28
    2948:	08 95       	ret

0000294a <__vector_12>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	ISR(TIMER1_COMPA_vect, ISR_NAKED)
	{
		vPortYieldFromTick();
    294a:	0e 94 e2 13 	call	0x27c4	; 0x27c4 <vPortYieldFromTick>
		asm volatile ( "reti" );
    294e:	18 95       	reti

00002950 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2950:	cf 93       	push	r28
    2952:	df 93       	push	r29
    2954:	00 d0       	rcall	.+0      	; 0x2956 <pvPortMalloc+0x6>
    2956:	00 d0       	rcall	.+0      	; 0x2958 <pvPortMalloc+0x8>
    2958:	cd b7       	in	r28, 0x3d	; 61
    295a:	de b7       	in	r29, 0x3e	; 62
    295c:	9c 83       	std	Y+4, r25	; 0x04
    295e:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    2960:	1a 82       	std	Y+2, r1	; 0x02
    2962:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2964:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    2968:	80 91 fc 04 	lds	r24, 0x04FC
    296c:	90 91 fd 04 	lds	r25, 0x04FD
    2970:	89 2b       	or	r24, r25
    2972:	31 f4       	brne	.+12     	; 0x2980 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2974:	83 e1       	ldi	r24, 0x13	; 19
    2976:	91 e0       	ldi	r25, 0x01	; 1
    2978:	90 93 fd 04 	sts	0x04FD, r25
    297c:	80 93 fc 04 	sts	0x04FC, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2980:	20 91 fa 04 	lds	r18, 0x04FA
    2984:	30 91 fb 04 	lds	r19, 0x04FB
    2988:	8b 81       	ldd	r24, Y+3	; 0x03
    298a:	9c 81       	ldd	r25, Y+4	; 0x04
    298c:	82 0f       	add	r24, r18
    298e:	93 1f       	adc	r25, r19
    2990:	87 3e       	cpi	r24, 0xE7	; 231
    2992:	93 40       	sbci	r25, 0x03	; 3
    2994:	38 f5       	brcc	.+78     	; 0x29e4 <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    2996:	20 91 fa 04 	lds	r18, 0x04FA
    299a:	30 91 fb 04 	lds	r19, 0x04FB
    299e:	8b 81       	ldd	r24, Y+3	; 0x03
    29a0:	9c 81       	ldd	r25, Y+4	; 0x04
    29a2:	28 0f       	add	r18, r24
    29a4:	39 1f       	adc	r19, r25
    29a6:	80 91 fa 04 	lds	r24, 0x04FA
    29aa:	90 91 fb 04 	lds	r25, 0x04FB
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    29ae:	82 17       	cp	r24, r18
    29b0:	93 07       	cpc	r25, r19
    29b2:	c0 f4       	brcc	.+48     	; 0x29e4 <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    29b4:	20 91 fc 04 	lds	r18, 0x04FC
    29b8:	30 91 fd 04 	lds	r19, 0x04FD
    29bc:	80 91 fa 04 	lds	r24, 0x04FA
    29c0:	90 91 fb 04 	lds	r25, 0x04FB
    29c4:	82 0f       	add	r24, r18
    29c6:	93 1f       	adc	r25, r19
    29c8:	9a 83       	std	Y+2, r25	; 0x02
    29ca:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    29cc:	20 91 fa 04 	lds	r18, 0x04FA
    29d0:	30 91 fb 04 	lds	r19, 0x04FB
    29d4:	8b 81       	ldd	r24, Y+3	; 0x03
    29d6:	9c 81       	ldd	r25, Y+4	; 0x04
    29d8:	82 0f       	add	r24, r18
    29da:	93 1f       	adc	r25, r19
    29dc:	90 93 fb 04 	sts	0x04FB, r25
    29e0:	80 93 fa 04 	sts	0x04FA, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    29e4:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    29e8:	89 81       	ldd	r24, Y+1	; 0x01
    29ea:	9a 81       	ldd	r25, Y+2	; 0x02
}
    29ec:	0f 90       	pop	r0
    29ee:	0f 90       	pop	r0
    29f0:	0f 90       	pop	r0
    29f2:	0f 90       	pop	r0
    29f4:	df 91       	pop	r29
    29f6:	cf 91       	pop	r28
    29f8:	08 95       	ret

000029fa <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    29fa:	cf 93       	push	r28
    29fc:	df 93       	push	r29
    29fe:	00 d0       	rcall	.+0      	; 0x2a00 <vPortFree+0x6>
    2a00:	cd b7       	in	r28, 0x3d	; 61
    2a02:	de b7       	in	r29, 0x3e	; 62
    2a04:	9a 83       	std	Y+2, r25	; 0x02
    2a06:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    2a08:	0f 90       	pop	r0
    2a0a:	0f 90       	pop	r0
    2a0c:	df 91       	pop	r29
    2a0e:	cf 91       	pop	r28
    2a10:	08 95       	ret

00002a12 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2a12:	cf 93       	push	r28
    2a14:	df 93       	push	r29
    2a16:	cd b7       	in	r28, 0x3d	; 61
    2a18:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2a1a:	10 92 fb 04 	sts	0x04FB, r1
    2a1e:	10 92 fa 04 	sts	0x04FA, r1
}
    2a22:	df 91       	pop	r29
    2a24:	cf 91       	pop	r28
    2a26:	08 95       	ret

00002a28 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2a28:	cf 93       	push	r28
    2a2a:	df 93       	push	r29
    2a2c:	cd b7       	in	r28, 0x3d	; 61
    2a2e:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    2a30:	80 91 fa 04 	lds	r24, 0x04FA
    2a34:	90 91 fb 04 	lds	r25, 0x04FB
    2a38:	27 ee       	ldi	r18, 0xE7	; 231
    2a3a:	33 e0       	ldi	r19, 0x03	; 3
    2a3c:	a9 01       	movw	r20, r18
    2a3e:	48 1b       	sub	r20, r24
    2a40:	59 0b       	sbc	r21, r25
    2a42:	ca 01       	movw	r24, r20
}
    2a44:	df 91       	pop	r29
    2a46:	cf 91       	pop	r28
    2a48:	08 95       	ret

00002a4a <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    2a4a:	cf 93       	push	r28
    2a4c:	df 93       	push	r29
    2a4e:	00 d0       	rcall	.+0      	; 0x2a50 <xQueueGenericReset+0x6>
    2a50:	00 d0       	rcall	.+0      	; 0x2a52 <xQueueGenericReset+0x8>
    2a52:	1f 92       	push	r1
    2a54:	cd b7       	in	r28, 0x3d	; 61
    2a56:	de b7       	in	r29, 0x3e	; 62
    2a58:	9c 83       	std	Y+4, r25	; 0x04
    2a5a:	8b 83       	std	Y+3, r24	; 0x03
    2a5c:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2a5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a60:	9c 81       	ldd	r25, Y+4	; 0x04
    2a62:	9a 83       	std	Y+2, r25	; 0x02
    2a64:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2a66:	0f b6       	in	r0, 0x3f	; 63
    2a68:	f8 94       	cli
    2a6a:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    2a6c:	89 81       	ldd	r24, Y+1	; 0x01
    2a6e:	9a 81       	ldd	r25, Y+2	; 0x02
    2a70:	fc 01       	movw	r30, r24
    2a72:	80 81       	ld	r24, Z
    2a74:	91 81       	ldd	r25, Z+1	; 0x01
    2a76:	29 81       	ldd	r18, Y+1	; 0x01
    2a78:	3a 81       	ldd	r19, Y+2	; 0x02
    2a7a:	f9 01       	movw	r30, r18
    2a7c:	23 8d       	ldd	r18, Z+27	; 0x1b
    2a7e:	42 2f       	mov	r20, r18
    2a80:	50 e0       	ldi	r21, 0x00	; 0
    2a82:	29 81       	ldd	r18, Y+1	; 0x01
    2a84:	3a 81       	ldd	r19, Y+2	; 0x02
    2a86:	f9 01       	movw	r30, r18
    2a88:	24 8d       	ldd	r18, Z+28	; 0x1c
    2a8a:	22 2f       	mov	r18, r18
    2a8c:	30 e0       	ldi	r19, 0x00	; 0
    2a8e:	42 9f       	mul	r20, r18
    2a90:	b0 01       	movw	r22, r0
    2a92:	43 9f       	mul	r20, r19
    2a94:	70 0d       	add	r23, r0
    2a96:	52 9f       	mul	r21, r18
    2a98:	70 0d       	add	r23, r0
    2a9a:	11 24       	eor	r1, r1
    2a9c:	9b 01       	movw	r18, r22
    2a9e:	28 0f       	add	r18, r24
    2aa0:	39 1f       	adc	r19, r25
    2aa2:	89 81       	ldd	r24, Y+1	; 0x01
    2aa4:	9a 81       	ldd	r25, Y+2	; 0x02
    2aa6:	fc 01       	movw	r30, r24
    2aa8:	33 83       	std	Z+3, r19	; 0x03
    2aaa:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2aac:	89 81       	ldd	r24, Y+1	; 0x01
    2aae:	9a 81       	ldd	r25, Y+2	; 0x02
    2ab0:	fc 01       	movw	r30, r24
    2ab2:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    2ab4:	89 81       	ldd	r24, Y+1	; 0x01
    2ab6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ab8:	fc 01       	movw	r30, r24
    2aba:	20 81       	ld	r18, Z
    2abc:	31 81       	ldd	r19, Z+1	; 0x01
    2abe:	89 81       	ldd	r24, Y+1	; 0x01
    2ac0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ac2:	fc 01       	movw	r30, r24
    2ac4:	35 83       	std	Z+5, r19	; 0x05
    2ac6:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    2ac8:	89 81       	ldd	r24, Y+1	; 0x01
    2aca:	9a 81       	ldd	r25, Y+2	; 0x02
    2acc:	fc 01       	movw	r30, r24
    2ace:	80 81       	ld	r24, Z
    2ad0:	91 81       	ldd	r25, Z+1	; 0x01
    2ad2:	29 81       	ldd	r18, Y+1	; 0x01
    2ad4:	3a 81       	ldd	r19, Y+2	; 0x02
    2ad6:	f9 01       	movw	r30, r18
    2ad8:	23 8d       	ldd	r18, Z+27	; 0x1b
    2ada:	22 2f       	mov	r18, r18
    2adc:	30 e0       	ldi	r19, 0x00	; 0
    2ade:	a9 01       	movw	r20, r18
    2ae0:	41 50       	subi	r20, 0x01	; 1
    2ae2:	51 09       	sbc	r21, r1
    2ae4:	29 81       	ldd	r18, Y+1	; 0x01
    2ae6:	3a 81       	ldd	r19, Y+2	; 0x02
    2ae8:	f9 01       	movw	r30, r18
    2aea:	24 8d       	ldd	r18, Z+28	; 0x1c
    2aec:	22 2f       	mov	r18, r18
    2aee:	30 e0       	ldi	r19, 0x00	; 0
    2af0:	42 9f       	mul	r20, r18
    2af2:	b0 01       	movw	r22, r0
    2af4:	43 9f       	mul	r20, r19
    2af6:	70 0d       	add	r23, r0
    2af8:	52 9f       	mul	r21, r18
    2afa:	70 0d       	add	r23, r0
    2afc:	11 24       	eor	r1, r1
    2afe:	9b 01       	movw	r18, r22
    2b00:	28 0f       	add	r18, r24
    2b02:	39 1f       	adc	r19, r25
    2b04:	89 81       	ldd	r24, Y+1	; 0x01
    2b06:	9a 81       	ldd	r25, Y+2	; 0x02
    2b08:	fc 01       	movw	r30, r24
    2b0a:	37 83       	std	Z+7, r19	; 0x07
    2b0c:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    2b0e:	89 81       	ldd	r24, Y+1	; 0x01
    2b10:	9a 81       	ldd	r25, Y+2	; 0x02
    2b12:	2f ef       	ldi	r18, 0xFF	; 255
    2b14:	fc 01       	movw	r30, r24
    2b16:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    2b18:	89 81       	ldd	r24, Y+1	; 0x01
    2b1a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b1c:	2f ef       	ldi	r18, 0xFF	; 255
    2b1e:	fc 01       	movw	r30, r24
    2b20:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    2b22:	8d 81       	ldd	r24, Y+5	; 0x05
    2b24:	88 23       	and	r24, r24
    2b26:	81 f4       	brne	.+32     	; 0x2b48 <xQueueGenericReset+0xfe>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2b28:	89 81       	ldd	r24, Y+1	; 0x01
    2b2a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b2c:	fc 01       	movw	r30, r24
    2b2e:	80 85       	ldd	r24, Z+8	; 0x08
    2b30:	88 23       	and	r24, r24
    2b32:	a1 f0       	breq	.+40     	; 0x2b5c <xQueueGenericReset+0x112>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2b34:	89 81       	ldd	r24, Y+1	; 0x01
    2b36:	9a 81       	ldd	r25, Y+2	; 0x02
    2b38:	08 96       	adiw	r24, 0x08	; 8
    2b3a:	0e 94 28 20 	call	0x4050	; 0x4050 <xTaskRemoveFromEventList>
    2b3e:	81 30       	cpi	r24, 0x01	; 1
    2b40:	69 f4       	brne	.+26     	; 0x2b5c <xQueueGenericReset+0x112>
				{
					queueYIELD_IF_USING_PREEMPTION();
    2b42:	0e 94 89 13 	call	0x2712	; 0x2712 <vPortYield>
    2b46:	0a c0       	rjmp	.+20     	; 0x2b5c <xQueueGenericReset+0x112>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2b48:	89 81       	ldd	r24, Y+1	; 0x01
    2b4a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b4c:	08 96       	adiw	r24, 0x08	; 8
    2b4e:	0e 94 42 10 	call	0x2084	; 0x2084 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    2b52:	89 81       	ldd	r24, Y+1	; 0x01
    2b54:	9a 81       	ldd	r25, Y+2	; 0x02
    2b56:	41 96       	adiw	r24, 0x11	; 17
    2b58:	0e 94 42 10 	call	0x2084	; 0x2084 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    2b5c:	0f 90       	pop	r0
    2b5e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    2b60:	81 e0       	ldi	r24, 0x01	; 1
}
    2b62:	0f 90       	pop	r0
    2b64:	0f 90       	pop	r0
    2b66:	0f 90       	pop	r0
    2b68:	0f 90       	pop	r0
    2b6a:	0f 90       	pop	r0
    2b6c:	df 91       	pop	r29
    2b6e:	cf 91       	pop	r28
    2b70:	08 95       	ret

00002b72 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    2b72:	cf 93       	push	r28
    2b74:	df 93       	push	r29
    2b76:	cd b7       	in	r28, 0x3d	; 61
    2b78:	de b7       	in	r29, 0x3e	; 62
    2b7a:	29 97       	sbiw	r28, 0x09	; 9
    2b7c:	0f b6       	in	r0, 0x3f	; 63
    2b7e:	f8 94       	cli
    2b80:	de bf       	out	0x3e, r29	; 62
    2b82:	0f be       	out	0x3f, r0	; 63
    2b84:	cd bf       	out	0x3d, r28	; 61
    2b86:	8f 83       	std	Y+7, r24	; 0x07
    2b88:	68 87       	std	Y+8, r22	; 0x08
    2b8a:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    2b8c:	1c 82       	std	Y+4, r1	; 0x04
    2b8e:	1b 82       	std	Y+3, r1	; 0x03
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
    2b90:	88 85       	ldd	r24, Y+8	; 0x08
    2b92:	88 23       	and	r24, r24
    2b94:	19 f4       	brne	.+6      	; 0x2b9c <xQueueGenericCreate+0x2a>
	{
		/* There is not going to be a queue storage area. */
		xQueueSizeInBytes = ( size_t ) 0;
    2b96:	1a 82       	std	Y+2, r1	; 0x02
    2b98:	19 82       	std	Y+1, r1	; 0x01
    2b9a:	11 c0       	rjmp	.+34     	; 0x2bbe <xQueueGenericCreate+0x4c>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2b9c:	8f 81       	ldd	r24, Y+7	; 0x07
    2b9e:	28 2f       	mov	r18, r24
    2ba0:	30 e0       	ldi	r19, 0x00	; 0
    2ba2:	88 85       	ldd	r24, Y+8	; 0x08
    2ba4:	88 2f       	mov	r24, r24
    2ba6:	90 e0       	ldi	r25, 0x00	; 0
    2ba8:	28 9f       	mul	r18, r24
    2baa:	a0 01       	movw	r20, r0
    2bac:	29 9f       	mul	r18, r25
    2bae:	50 0d       	add	r21, r0
    2bb0:	38 9f       	mul	r19, r24
    2bb2:	50 0d       	add	r21, r0
    2bb4:	11 24       	eor	r1, r1
    2bb6:	ca 01       	movw	r24, r20
    2bb8:	01 96       	adiw	r24, 0x01	; 1
    2bba:	9a 83       	std	Y+2, r25	; 0x02
    2bbc:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    2bbe:	89 81       	ldd	r24, Y+1	; 0x01
    2bc0:	9a 81       	ldd	r25, Y+2	; 0x02
    2bc2:	4f 96       	adiw	r24, 0x1f	; 31
    2bc4:	0e 94 a8 14 	call	0x2950	; 0x2950 <pvPortMalloc>
    2bc8:	9e 83       	std	Y+6, r25	; 0x06
    2bca:	8d 83       	std	Y+5, r24	; 0x05

	if( pxNewQueue != NULL )
    2bcc:	8d 81       	ldd	r24, Y+5	; 0x05
    2bce:	9e 81       	ldd	r25, Y+6	; 0x06
    2bd0:	89 2b       	or	r24, r25
    2bd2:	41 f1       	breq	.+80     	; 0x2c24 <xQueueGenericCreate+0xb2>
	{
		if( uxItemSize == ( UBaseType_t ) 0 )
    2bd4:	88 85       	ldd	r24, Y+8	; 0x08
    2bd6:	88 23       	and	r24, r24
    2bd8:	41 f4       	brne	.+16     	; 0x2bea <xQueueGenericCreate+0x78>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    2bda:	8d 81       	ldd	r24, Y+5	; 0x05
    2bdc:	9e 81       	ldd	r25, Y+6	; 0x06
    2bde:	2d 81       	ldd	r18, Y+5	; 0x05
    2be0:	3e 81       	ldd	r19, Y+6	; 0x06
    2be2:	fc 01       	movw	r30, r24
    2be4:	31 83       	std	Z+1, r19	; 0x01
    2be6:	20 83       	st	Z, r18
    2be8:	0a c0       	rjmp	.+20     	; 0x2bfe <xQueueGenericCreate+0x8c>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
    2bea:	8d 81       	ldd	r24, Y+5	; 0x05
    2bec:	9e 81       	ldd	r25, Y+6	; 0x06
    2bee:	9c 01       	movw	r18, r24
    2bf0:	21 5e       	subi	r18, 0xE1	; 225
    2bf2:	3f 4f       	sbci	r19, 0xFF	; 255
    2bf4:	8d 81       	ldd	r24, Y+5	; 0x05
    2bf6:	9e 81       	ldd	r25, Y+6	; 0x06
    2bf8:	fc 01       	movw	r30, r24
    2bfa:	31 83       	std	Z+1, r19	; 0x01
    2bfc:	20 83       	st	Z, r18
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
    2bfe:	8d 81       	ldd	r24, Y+5	; 0x05
    2c00:	9e 81       	ldd	r25, Y+6	; 0x06
    2c02:	2f 81       	ldd	r18, Y+7	; 0x07
    2c04:	fc 01       	movw	r30, r24
    2c06:	23 8f       	std	Z+27, r18	; 0x1b
		pxNewQueue->uxItemSize = uxItemSize;
    2c08:	8d 81       	ldd	r24, Y+5	; 0x05
    2c0a:	9e 81       	ldd	r25, Y+6	; 0x06
    2c0c:	28 85       	ldd	r18, Y+8	; 0x08
    2c0e:	fc 01       	movw	r30, r24
    2c10:	24 8f       	std	Z+28, r18	; 0x1c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2c12:	8d 81       	ldd	r24, Y+5	; 0x05
    2c14:	9e 81       	ldd	r25, Y+6	; 0x06
    2c16:	61 e0       	ldi	r22, 0x01	; 1
    2c18:	0e 94 25 15 	call	0x2a4a	; 0x2a4a <xQueueGenericReset>
			pxNewQueue->pxQueueSetContainer = NULL;
		}
		#endif /* configUSE_QUEUE_SETS */

		traceQUEUE_CREATE( pxNewQueue );
		xReturn = pxNewQueue;
    2c1c:	8d 81       	ldd	r24, Y+5	; 0x05
    2c1e:	9e 81       	ldd	r25, Y+6	; 0x06
    2c20:	9c 83       	std	Y+4, r25	; 0x04
    2c22:	8b 83       	std	Y+3, r24	; 0x03
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    2c24:	8b 81       	ldd	r24, Y+3	; 0x03
    2c26:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2c28:	29 96       	adiw	r28, 0x09	; 9
    2c2a:	0f b6       	in	r0, 0x3f	; 63
    2c2c:	f8 94       	cli
    2c2e:	de bf       	out	0x3e, r29	; 62
    2c30:	0f be       	out	0x3f, r0	; 63
    2c32:	cd bf       	out	0x3d, r28	; 61
    2c34:	df 91       	pop	r29
    2c36:	cf 91       	pop	r28
    2c38:	08 95       	ret

00002c3a <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    2c3a:	cf 93       	push	r28
    2c3c:	df 93       	push	r29
    2c3e:	cd b7       	in	r28, 0x3d	; 61
    2c40:	de b7       	in	r29, 0x3e	; 62
    2c42:	2e 97       	sbiw	r28, 0x0e	; 14
    2c44:	0f b6       	in	r0, 0x3f	; 63
    2c46:	f8 94       	cli
    2c48:	de bf       	out	0x3e, r29	; 62
    2c4a:	0f be       	out	0x3f, r0	; 63
    2c4c:	cd bf       	out	0x3d, r28	; 61
    2c4e:	99 87       	std	Y+9, r25	; 0x09
    2c50:	88 87       	std	Y+8, r24	; 0x08
    2c52:	7b 87       	std	Y+11, r23	; 0x0b
    2c54:	6a 87       	std	Y+10, r22	; 0x0a
    2c56:	5d 87       	std	Y+13, r21	; 0x0d
    2c58:	4c 87       	std	Y+12, r20	; 0x0c
    2c5a:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2c5c:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2c5e:	88 85       	ldd	r24, Y+8	; 0x08
    2c60:	99 85       	ldd	r25, Y+9	; 0x09
    2c62:	9b 83       	std	Y+3, r25	; 0x03
    2c64:	8a 83       	std	Y+2, r24	; 0x02
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2c66:	0f b6       	in	r0, 0x3f	; 63
    2c68:	f8 94       	cli
    2c6a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2c6c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c6e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c70:	fc 01       	movw	r30, r24
    2c72:	22 8d       	ldd	r18, Z+26	; 0x1a
    2c74:	8a 81       	ldd	r24, Y+2	; 0x02
    2c76:	9b 81       	ldd	r25, Y+3	; 0x03
    2c78:	fc 01       	movw	r30, r24
    2c7a:	83 8d       	ldd	r24, Z+27	; 0x1b
    2c7c:	28 17       	cp	r18, r24
    2c7e:	18 f0       	brcs	.+6      	; 0x2c86 <xQueueGenericSend+0x4c>
    2c80:	8e 85       	ldd	r24, Y+14	; 0x0e
    2c82:	82 30       	cpi	r24, 0x02	; 2
    2c84:	11 f5       	brne	.+68     	; 0x2cca <xQueueGenericSend+0x90>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2c86:	2a 85       	ldd	r18, Y+10	; 0x0a
    2c88:	3b 85       	ldd	r19, Y+11	; 0x0b
    2c8a:	8a 81       	ldd	r24, Y+2	; 0x02
    2c8c:	9b 81       	ldd	r25, Y+3	; 0x03
    2c8e:	4e 85       	ldd	r20, Y+14	; 0x0e
    2c90:	b9 01       	movw	r22, r18
    2c92:	0e 94 62 19 	call	0x32c4	; 0x32c4 <prvCopyDataToQueue>
    2c96:	8c 83       	std	Y+4, r24	; 0x04
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2c98:	8a 81       	ldd	r24, Y+2	; 0x02
    2c9a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c9c:	fc 01       	movw	r30, r24
    2c9e:	81 89       	ldd	r24, Z+17	; 0x11
    2ca0:	88 23       	and	r24, r24
    2ca2:	51 f0       	breq	.+20     	; 0x2cb8 <xQueueGenericSend+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2ca4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ca6:	9b 81       	ldd	r25, Y+3	; 0x03
    2ca8:	41 96       	adiw	r24, 0x11	; 17
    2caa:	0e 94 28 20 	call	0x4050	; 0x4050 <xTaskRemoveFromEventList>
    2cae:	81 30       	cpi	r24, 0x01	; 1
    2cb0:	41 f4       	brne	.+16     	; 0x2cc2 <xQueueGenericSend+0x88>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2cb2:	0e 94 89 13 	call	0x2712	; 0x2712 <vPortYield>
    2cb6:	05 c0       	rjmp	.+10     	; 0x2cc2 <xQueueGenericSend+0x88>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    2cb8:	8c 81       	ldd	r24, Y+4	; 0x04
    2cba:	88 23       	and	r24, r24
    2cbc:	11 f0       	breq	.+4      	; 0x2cc2 <xQueueGenericSend+0x88>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2cbe:	0e 94 89 13 	call	0x2712	; 0x2712 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2cc2:	0f 90       	pop	r0
    2cc4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2cc6:	81 e0       	ldi	r24, 0x01	; 1
    2cc8:	61 c0       	rjmp	.+194    	; 0x2d8c <xQueueGenericSend+0x152>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2cca:	8c 85       	ldd	r24, Y+12	; 0x0c
    2ccc:	9d 85       	ldd	r25, Y+13	; 0x0d
    2cce:	89 2b       	or	r24, r25
    2cd0:	21 f4       	brne	.+8      	; 0x2cda <xQueueGenericSend+0xa0>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2cd2:	0f 90       	pop	r0
    2cd4:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2cd6:	80 e0       	ldi	r24, 0x00	; 0
    2cd8:	59 c0       	rjmp	.+178    	; 0x2d8c <xQueueGenericSend+0x152>
				}
				else if( xEntryTimeSet == pdFALSE )
    2cda:	89 81       	ldd	r24, Y+1	; 0x01
    2cdc:	88 23       	and	r24, r24
    2cde:	31 f4       	brne	.+12     	; 0x2cec <xQueueGenericSend+0xb2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2ce0:	ce 01       	movw	r24, r28
    2ce2:	05 96       	adiw	r24, 0x05	; 5
    2ce4:	0e 94 00 21 	call	0x4200	; 0x4200 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2ce8:	81 e0       	ldi	r24, 0x01	; 1
    2cea:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2cec:	0f 90       	pop	r0
    2cee:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2cf0:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2cf4:	0f b6       	in	r0, 0x3f	; 63
    2cf6:	f8 94       	cli
    2cf8:	0f 92       	push	r0
    2cfa:	8a 81       	ldd	r24, Y+2	; 0x02
    2cfc:	9b 81       	ldd	r25, Y+3	; 0x03
    2cfe:	fc 01       	movw	r30, r24
    2d00:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d02:	8f 3f       	cpi	r24, 0xFF	; 255
    2d04:	21 f4       	brne	.+8      	; 0x2d0e <xQueueGenericSend+0xd4>
    2d06:	8a 81       	ldd	r24, Y+2	; 0x02
    2d08:	9b 81       	ldd	r25, Y+3	; 0x03
    2d0a:	fc 01       	movw	r30, r24
    2d0c:	15 8e       	std	Z+29, r1	; 0x1d
    2d0e:	8a 81       	ldd	r24, Y+2	; 0x02
    2d10:	9b 81       	ldd	r25, Y+3	; 0x03
    2d12:	fc 01       	movw	r30, r24
    2d14:	86 8d       	ldd	r24, Z+30	; 0x1e
    2d16:	8f 3f       	cpi	r24, 0xFF	; 255
    2d18:	21 f4       	brne	.+8      	; 0x2d22 <xQueueGenericSend+0xe8>
    2d1a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d1c:	9b 81       	ldd	r25, Y+3	; 0x03
    2d1e:	fc 01       	movw	r30, r24
    2d20:	16 8e       	std	Z+30, r1	; 0x1e
    2d22:	0f 90       	pop	r0
    2d24:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2d26:	9e 01       	movw	r18, r28
    2d28:	24 5f       	subi	r18, 0xF4	; 244
    2d2a:	3f 4f       	sbci	r19, 0xFF	; 255
    2d2c:	ce 01       	movw	r24, r28
    2d2e:	05 96       	adiw	r24, 0x05	; 5
    2d30:	b9 01       	movw	r22, r18
    2d32:	0e 94 1b 21 	call	0x4236	; 0x4236 <xTaskCheckForTimeOut>
    2d36:	88 23       	and	r24, r24
    2d38:	01 f5       	brne	.+64     	; 0x2d7a <xQueueGenericSend+0x140>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2d3a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d3c:	9b 81       	ldd	r25, Y+3	; 0x03
    2d3e:	0e 94 0d 1b 	call	0x361a	; 0x361a <prvIsQueueFull>
    2d42:	88 23       	and	r24, r24
    2d44:	99 f0       	breq	.+38     	; 0x2d6c <xQueueGenericSend+0x132>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2d46:	2c 85       	ldd	r18, Y+12	; 0x0c
    2d48:	3d 85       	ldd	r19, Y+13	; 0x0d
    2d4a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d4c:	9b 81       	ldd	r25, Y+3	; 0x03
    2d4e:	08 96       	adiw	r24, 0x08	; 8
    2d50:	b9 01       	movw	r22, r18
    2d52:	0e 94 af 1f 	call	0x3f5e	; 0x3f5e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2d56:	8a 81       	ldd	r24, Y+2	; 0x02
    2d58:	9b 81       	ldd	r25, Y+3	; 0x03
    2d5a:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2d5e:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
    2d62:	88 23       	and	r24, r24
    2d64:	91 f4       	brne	.+36     	; 0x2d8a <xQueueGenericSend+0x150>
				{
					portYIELD_WITHIN_API();
    2d66:	0e 94 89 13 	call	0x2712	; 0x2712 <vPortYield>
    2d6a:	0f c0       	rjmp	.+30     	; 0x2d8a <xQueueGenericSend+0x150>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2d6c:	8a 81       	ldd	r24, Y+2	; 0x02
    2d6e:	9b 81       	ldd	r25, Y+3	; 0x03
    2d70:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2d74:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
    2d78:	76 cf       	rjmp	.-276    	; 0x2c66 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2d7a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d7c:	9b 81       	ldd	r25, Y+3	; 0x03
    2d7e:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2d82:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2d86:	80 e0       	ldi	r24, 0x00	; 0
    2d88:	01 c0       	rjmp	.+2      	; 0x2d8c <xQueueGenericSend+0x152>
		}
	}
    2d8a:	6d cf       	rjmp	.-294    	; 0x2c66 <xQueueGenericSend+0x2c>
}
    2d8c:	2e 96       	adiw	r28, 0x0e	; 14
    2d8e:	0f b6       	in	r0, 0x3f	; 63
    2d90:	f8 94       	cli
    2d92:	de bf       	out	0x3e, r29	; 62
    2d94:	0f be       	out	0x3f, r0	; 63
    2d96:	cd bf       	out	0x3d, r28	; 61
    2d98:	df 91       	pop	r29
    2d9a:	cf 91       	pop	r28
    2d9c:	08 95       	ret

00002d9e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    2d9e:	cf 93       	push	r28
    2da0:	df 93       	push	r29
    2da2:	cd b7       	in	r28, 0x3d	; 61
    2da4:	de b7       	in	r29, 0x3e	; 62
    2da6:	2b 97       	sbiw	r28, 0x0b	; 11
    2da8:	0f b6       	in	r0, 0x3f	; 63
    2daa:	f8 94       	cli
    2dac:	de bf       	out	0x3e, r29	; 62
    2dae:	0f be       	out	0x3f, r0	; 63
    2db0:	cd bf       	out	0x3d, r28	; 61
    2db2:	9e 83       	std	Y+6, r25	; 0x06
    2db4:	8d 83       	std	Y+5, r24	; 0x05
    2db6:	78 87       	std	Y+8, r23	; 0x08
    2db8:	6f 83       	std	Y+7, r22	; 0x07
    2dba:	5a 87       	std	Y+10, r21	; 0x0a
    2dbc:	49 87       	std	Y+9, r20	; 0x09
    2dbe:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2dc0:	8d 81       	ldd	r24, Y+5	; 0x05
    2dc2:	9e 81       	ldd	r25, Y+6	; 0x06
    2dc4:	9b 83       	std	Y+3, r25	; 0x03
    2dc6:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2dc8:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2dca:	8a 81       	ldd	r24, Y+2	; 0x02
    2dcc:	9b 81       	ldd	r25, Y+3	; 0x03
    2dce:	fc 01       	movw	r30, r24
    2dd0:	22 8d       	ldd	r18, Z+26	; 0x1a
    2dd2:	8a 81       	ldd	r24, Y+2	; 0x02
    2dd4:	9b 81       	ldd	r25, Y+3	; 0x03
    2dd6:	fc 01       	movw	r30, r24
    2dd8:	83 8d       	ldd	r24, Z+27	; 0x1b
    2dda:	28 17       	cp	r18, r24
    2ddc:	18 f0       	brcs	.+6      	; 0x2de4 <xQueueGenericSendFromISR+0x46>
    2dde:	8b 85       	ldd	r24, Y+11	; 0x0b
    2de0:	82 30       	cpi	r24, 0x02	; 2
    2de2:	91 f5       	brne	.+100    	; 0x2e48 <xQueueGenericSendFromISR+0xaa>
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2de4:	2f 81       	ldd	r18, Y+7	; 0x07
    2de6:	38 85       	ldd	r19, Y+8	; 0x08
    2de8:	8a 81       	ldd	r24, Y+2	; 0x02
    2dea:	9b 81       	ldd	r25, Y+3	; 0x03
    2dec:	4b 85       	ldd	r20, Y+11	; 0x0b
    2dee:	b9 01       	movw	r22, r18
    2df0:	0e 94 62 19 	call	0x32c4	; 0x32c4 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2df4:	8a 81       	ldd	r24, Y+2	; 0x02
    2df6:	9b 81       	ldd	r25, Y+3	; 0x03
    2df8:	fc 01       	movw	r30, r24
    2dfa:	86 8d       	ldd	r24, Z+30	; 0x1e
    2dfc:	8f 3f       	cpi	r24, 0xFF	; 255
    2dfe:	b9 f4       	brne	.+46     	; 0x2e2e <xQueueGenericSendFromISR+0x90>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2e00:	8a 81       	ldd	r24, Y+2	; 0x02
    2e02:	9b 81       	ldd	r25, Y+3	; 0x03
    2e04:	fc 01       	movw	r30, r24
    2e06:	81 89       	ldd	r24, Z+17	; 0x11
    2e08:	88 23       	and	r24, r24
    2e0a:	d9 f0       	breq	.+54     	; 0x2e42 <xQueueGenericSendFromISR+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2e0c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e0e:	9b 81       	ldd	r25, Y+3	; 0x03
    2e10:	41 96       	adiw	r24, 0x11	; 17
    2e12:	0e 94 28 20 	call	0x4050	; 0x4050 <xTaskRemoveFromEventList>
    2e16:	88 23       	and	r24, r24
    2e18:	a1 f0       	breq	.+40     	; 0x2e42 <xQueueGenericSendFromISR+0xa4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2e1a:	89 85       	ldd	r24, Y+9	; 0x09
    2e1c:	9a 85       	ldd	r25, Y+10	; 0x0a
    2e1e:	89 2b       	or	r24, r25
    2e20:	81 f0       	breq	.+32     	; 0x2e42 <xQueueGenericSendFromISR+0xa4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2e22:	89 85       	ldd	r24, Y+9	; 0x09
    2e24:	9a 85       	ldd	r25, Y+10	; 0x0a
    2e26:	21 e0       	ldi	r18, 0x01	; 1
    2e28:	fc 01       	movw	r30, r24
    2e2a:	20 83       	st	Z, r18
    2e2c:	0a c0       	rjmp	.+20     	; 0x2e42 <xQueueGenericSendFromISR+0xa4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2e2e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e30:	9b 81       	ldd	r25, Y+3	; 0x03
    2e32:	fc 01       	movw	r30, r24
    2e34:	86 8d       	ldd	r24, Z+30	; 0x1e
    2e36:	8f 5f       	subi	r24, 0xFF	; 255
    2e38:	28 2f       	mov	r18, r24
    2e3a:	8a 81       	ldd	r24, Y+2	; 0x02
    2e3c:	9b 81       	ldd	r25, Y+3	; 0x03
    2e3e:	fc 01       	movw	r30, r24
    2e40:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    2e42:	81 e0       	ldi	r24, 0x01	; 1
    2e44:	89 83       	std	Y+1, r24	; 0x01
    2e46:	01 c0       	rjmp	.+2      	; 0x2e4a <xQueueGenericSendFromISR+0xac>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2e48:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2e4a:	89 81       	ldd	r24, Y+1	; 0x01
}
    2e4c:	2b 96       	adiw	r28, 0x0b	; 11
    2e4e:	0f b6       	in	r0, 0x3f	; 63
    2e50:	f8 94       	cli
    2e52:	de bf       	out	0x3e, r29	; 62
    2e54:	0f be       	out	0x3f, r0	; 63
    2e56:	cd bf       	out	0x3d, r28	; 61
    2e58:	df 91       	pop	r29
    2e5a:	cf 91       	pop	r28
    2e5c:	08 95       	ret

00002e5e <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2e5e:	cf 93       	push	r28
    2e60:	df 93       	push	r29
    2e62:	cd b7       	in	r28, 0x3d	; 61
    2e64:	de b7       	in	r29, 0x3e	; 62
    2e66:	28 97       	sbiw	r28, 0x08	; 8
    2e68:	0f b6       	in	r0, 0x3f	; 63
    2e6a:	f8 94       	cli
    2e6c:	de bf       	out	0x3e, r29	; 62
    2e6e:	0f be       	out	0x3f, r0	; 63
    2e70:	cd bf       	out	0x3d, r28	; 61
    2e72:	9e 83       	std	Y+6, r25	; 0x06
    2e74:	8d 83       	std	Y+5, r24	; 0x05
    2e76:	78 87       	std	Y+8, r23	; 0x08
    2e78:	6f 83       	std	Y+7, r22	; 0x07
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2e7a:	8d 81       	ldd	r24, Y+5	; 0x05
    2e7c:	9e 81       	ldd	r25, Y+6	; 0x06
    2e7e:	9b 83       	std	Y+3, r25	; 0x03
    2e80:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2e82:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2e84:	8a 81       	ldd	r24, Y+2	; 0x02
    2e86:	9b 81       	ldd	r25, Y+3	; 0x03
    2e88:	fc 01       	movw	r30, r24
    2e8a:	22 8d       	ldd	r18, Z+26	; 0x1a
    2e8c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e8e:	9b 81       	ldd	r25, Y+3	; 0x03
    2e90:	fc 01       	movw	r30, r24
    2e92:	83 8d       	ldd	r24, Z+27	; 0x1b
    2e94:	28 17       	cp	r18, r24
    2e96:	a0 f5       	brcc	.+104    	; 0x2f00 <xQueueGiveFromISR+0xa2>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    2e98:	8a 81       	ldd	r24, Y+2	; 0x02
    2e9a:	9b 81       	ldd	r25, Y+3	; 0x03
    2e9c:	fc 01       	movw	r30, r24
    2e9e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ea0:	21 e0       	ldi	r18, 0x01	; 1
    2ea2:	28 0f       	add	r18, r24
    2ea4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ea6:	9b 81       	ldd	r25, Y+3	; 0x03
    2ea8:	fc 01       	movw	r30, r24
    2eaa:	22 8f       	std	Z+26, r18	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2eac:	8a 81       	ldd	r24, Y+2	; 0x02
    2eae:	9b 81       	ldd	r25, Y+3	; 0x03
    2eb0:	fc 01       	movw	r30, r24
    2eb2:	86 8d       	ldd	r24, Z+30	; 0x1e
    2eb4:	8f 3f       	cpi	r24, 0xFF	; 255
    2eb6:	b9 f4       	brne	.+46     	; 0x2ee6 <xQueueGiveFromISR+0x88>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2eb8:	8a 81       	ldd	r24, Y+2	; 0x02
    2eba:	9b 81       	ldd	r25, Y+3	; 0x03
    2ebc:	fc 01       	movw	r30, r24
    2ebe:	81 89       	ldd	r24, Z+17	; 0x11
    2ec0:	88 23       	and	r24, r24
    2ec2:	d9 f0       	breq	.+54     	; 0x2efa <xQueueGiveFromISR+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2ec4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ec6:	9b 81       	ldd	r25, Y+3	; 0x03
    2ec8:	41 96       	adiw	r24, 0x11	; 17
    2eca:	0e 94 28 20 	call	0x4050	; 0x4050 <xTaskRemoveFromEventList>
    2ece:	88 23       	and	r24, r24
    2ed0:	a1 f0       	breq	.+40     	; 0x2efa <xQueueGiveFromISR+0x9c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2ed2:	8f 81       	ldd	r24, Y+7	; 0x07
    2ed4:	98 85       	ldd	r25, Y+8	; 0x08
    2ed6:	89 2b       	or	r24, r25
    2ed8:	81 f0       	breq	.+32     	; 0x2efa <xQueueGiveFromISR+0x9c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2eda:	8f 81       	ldd	r24, Y+7	; 0x07
    2edc:	98 85       	ldd	r25, Y+8	; 0x08
    2ede:	21 e0       	ldi	r18, 0x01	; 1
    2ee0:	fc 01       	movw	r30, r24
    2ee2:	20 83       	st	Z, r18
    2ee4:	0a c0       	rjmp	.+20     	; 0x2efa <xQueueGiveFromISR+0x9c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2ee6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ee8:	9b 81       	ldd	r25, Y+3	; 0x03
    2eea:	fc 01       	movw	r30, r24
    2eec:	86 8d       	ldd	r24, Z+30	; 0x1e
    2eee:	8f 5f       	subi	r24, 0xFF	; 255
    2ef0:	28 2f       	mov	r18, r24
    2ef2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ef4:	9b 81       	ldd	r25, Y+3	; 0x03
    2ef6:	fc 01       	movw	r30, r24
    2ef8:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    2efa:	81 e0       	ldi	r24, 0x01	; 1
    2efc:	89 83       	std	Y+1, r24	; 0x01
    2efe:	01 c0       	rjmp	.+2      	; 0x2f02 <xQueueGiveFromISR+0xa4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2f00:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2f02:	89 81       	ldd	r24, Y+1	; 0x01
}
    2f04:	28 96       	adiw	r28, 0x08	; 8
    2f06:	0f b6       	in	r0, 0x3f	; 63
    2f08:	f8 94       	cli
    2f0a:	de bf       	out	0x3e, r29	; 62
    2f0c:	0f be       	out	0x3f, r0	; 63
    2f0e:	cd bf       	out	0x3d, r28	; 61
    2f10:	df 91       	pop	r29
    2f12:	cf 91       	pop	r28
    2f14:	08 95       	ret

00002f16 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    2f16:	cf 93       	push	r28
    2f18:	df 93       	push	r29
    2f1a:	cd b7       	in	r28, 0x3d	; 61
    2f1c:	de b7       	in	r29, 0x3e	; 62
    2f1e:	2f 97       	sbiw	r28, 0x0f	; 15
    2f20:	0f b6       	in	r0, 0x3f	; 63
    2f22:	f8 94       	cli
    2f24:	de bf       	out	0x3e, r29	; 62
    2f26:	0f be       	out	0x3f, r0	; 63
    2f28:	cd bf       	out	0x3d, r28	; 61
    2f2a:	9a 87       	std	Y+10, r25	; 0x0a
    2f2c:	89 87       	std	Y+9, r24	; 0x09
    2f2e:	7c 87       	std	Y+12, r23	; 0x0c
    2f30:	6b 87       	std	Y+11, r22	; 0x0b
    2f32:	5e 87       	std	Y+14, r21	; 0x0e
    2f34:	4d 87       	std	Y+13, r20	; 0x0d
    2f36:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    2f38:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2f3a:	89 85       	ldd	r24, Y+9	; 0x09
    2f3c:	9a 85       	ldd	r25, Y+10	; 0x0a
    2f3e:	9b 83       	std	Y+3, r25	; 0x03
    2f40:	8a 83       	std	Y+2, r24	; 0x02
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2f42:	0f b6       	in	r0, 0x3f	; 63
    2f44:	f8 94       	cli
    2f46:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2f48:	8a 81       	ldd	r24, Y+2	; 0x02
    2f4a:	9b 81       	ldd	r25, Y+3	; 0x03
    2f4c:	fc 01       	movw	r30, r24
    2f4e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f50:	88 23       	and	r24, r24
    2f52:	09 f4       	brne	.+2      	; 0x2f56 <xQueueGenericReceive+0x40>
    2f54:	45 c0       	rjmp	.+138    	; 0x2fe0 <xQueueGenericReceive+0xca>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2f56:	8a 81       	ldd	r24, Y+2	; 0x02
    2f58:	9b 81       	ldd	r25, Y+3	; 0x03
    2f5a:	fc 01       	movw	r30, r24
    2f5c:	86 81       	ldd	r24, Z+6	; 0x06
    2f5e:	97 81       	ldd	r25, Z+7	; 0x07
    2f60:	9d 83       	std	Y+5, r25	; 0x05
    2f62:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2f64:	2b 85       	ldd	r18, Y+11	; 0x0b
    2f66:	3c 85       	ldd	r19, Y+12	; 0x0c
    2f68:	8a 81       	ldd	r24, Y+2	; 0x02
    2f6a:	9b 81       	ldd	r25, Y+3	; 0x03
    2f6c:	b9 01       	movw	r22, r18
    2f6e:	0e 94 22 1a 	call	0x3444	; 0x3444 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2f72:	8f 85       	ldd	r24, Y+15	; 0x0f
    2f74:	88 23       	and	r24, r24
    2f76:	d1 f4       	brne	.+52     	; 0x2fac <xQueueGenericReceive+0x96>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    2f78:	8a 81       	ldd	r24, Y+2	; 0x02
    2f7a:	9b 81       	ldd	r25, Y+3	; 0x03
    2f7c:	fc 01       	movw	r30, r24
    2f7e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f80:	2f ef       	ldi	r18, 0xFF	; 255
    2f82:	28 0f       	add	r18, r24
    2f84:	8a 81       	ldd	r24, Y+2	; 0x02
    2f86:	9b 81       	ldd	r25, Y+3	; 0x03
    2f88:	fc 01       	movw	r30, r24
    2f8a:	22 8f       	std	Z+26, r18	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2f8c:	8a 81       	ldd	r24, Y+2	; 0x02
    2f8e:	9b 81       	ldd	r25, Y+3	; 0x03
    2f90:	fc 01       	movw	r30, r24
    2f92:	80 85       	ldd	r24, Z+8	; 0x08
    2f94:	88 23       	and	r24, r24
    2f96:	01 f1       	breq	.+64     	; 0x2fd8 <xQueueGenericReceive+0xc2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2f98:	8a 81       	ldd	r24, Y+2	; 0x02
    2f9a:	9b 81       	ldd	r25, Y+3	; 0x03
    2f9c:	08 96       	adiw	r24, 0x08	; 8
    2f9e:	0e 94 28 20 	call	0x4050	; 0x4050 <xTaskRemoveFromEventList>
    2fa2:	81 30       	cpi	r24, 0x01	; 1
    2fa4:	c9 f4       	brne	.+50     	; 0x2fd8 <xQueueGenericReceive+0xc2>
						{
							queueYIELD_IF_USING_PREEMPTION();
    2fa6:	0e 94 89 13 	call	0x2712	; 0x2712 <vPortYield>
    2faa:	16 c0       	rjmp	.+44     	; 0x2fd8 <xQueueGenericReceive+0xc2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2fac:	8a 81       	ldd	r24, Y+2	; 0x02
    2fae:	9b 81       	ldd	r25, Y+3	; 0x03
    2fb0:	2c 81       	ldd	r18, Y+4	; 0x04
    2fb2:	3d 81       	ldd	r19, Y+5	; 0x05
    2fb4:	fc 01       	movw	r30, r24
    2fb6:	37 83       	std	Z+7, r19	; 0x07
    2fb8:	26 83       	std	Z+6, r18	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2fba:	8a 81       	ldd	r24, Y+2	; 0x02
    2fbc:	9b 81       	ldd	r25, Y+3	; 0x03
    2fbe:	fc 01       	movw	r30, r24
    2fc0:	81 89       	ldd	r24, Z+17	; 0x11
    2fc2:	88 23       	and	r24, r24
    2fc4:	49 f0       	breq	.+18     	; 0x2fd8 <xQueueGenericReceive+0xc2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2fc6:	8a 81       	ldd	r24, Y+2	; 0x02
    2fc8:	9b 81       	ldd	r25, Y+3	; 0x03
    2fca:	41 96       	adiw	r24, 0x11	; 17
    2fcc:	0e 94 28 20 	call	0x4050	; 0x4050 <xTaskRemoveFromEventList>
    2fd0:	88 23       	and	r24, r24
    2fd2:	11 f0       	breq	.+4      	; 0x2fd8 <xQueueGenericReceive+0xc2>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    2fd4:	0e 94 89 13 	call	0x2712	; 0x2712 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    2fd8:	0f 90       	pop	r0
    2fda:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2fdc:	81 e0       	ldi	r24, 0x01	; 1
    2fde:	61 c0       	rjmp	.+194    	; 0x30a2 <xQueueGenericReceive+0x18c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2fe0:	8d 85       	ldd	r24, Y+13	; 0x0d
    2fe2:	9e 85       	ldd	r25, Y+14	; 0x0e
    2fe4:	89 2b       	or	r24, r25
    2fe6:	21 f4       	brne	.+8      	; 0x2ff0 <xQueueGenericReceive+0xda>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2fe8:	0f 90       	pop	r0
    2fea:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2fec:	80 e0       	ldi	r24, 0x00	; 0
    2fee:	59 c0       	rjmp	.+178    	; 0x30a2 <xQueueGenericReceive+0x18c>
				}
				else if( xEntryTimeSet == pdFALSE )
    2ff0:	89 81       	ldd	r24, Y+1	; 0x01
    2ff2:	88 23       	and	r24, r24
    2ff4:	31 f4       	brne	.+12     	; 0x3002 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2ff6:	ce 01       	movw	r24, r28
    2ff8:	06 96       	adiw	r24, 0x06	; 6
    2ffa:	0e 94 00 21 	call	0x4200	; 0x4200 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2ffe:	81 e0       	ldi	r24, 0x01	; 1
    3000:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3002:	0f 90       	pop	r0
    3004:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3006:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    300a:	0f b6       	in	r0, 0x3f	; 63
    300c:	f8 94       	cli
    300e:	0f 92       	push	r0
    3010:	8a 81       	ldd	r24, Y+2	; 0x02
    3012:	9b 81       	ldd	r25, Y+3	; 0x03
    3014:	fc 01       	movw	r30, r24
    3016:	85 8d       	ldd	r24, Z+29	; 0x1d
    3018:	8f 3f       	cpi	r24, 0xFF	; 255
    301a:	21 f4       	brne	.+8      	; 0x3024 <xQueueGenericReceive+0x10e>
    301c:	8a 81       	ldd	r24, Y+2	; 0x02
    301e:	9b 81       	ldd	r25, Y+3	; 0x03
    3020:	fc 01       	movw	r30, r24
    3022:	15 8e       	std	Z+29, r1	; 0x1d
    3024:	8a 81       	ldd	r24, Y+2	; 0x02
    3026:	9b 81       	ldd	r25, Y+3	; 0x03
    3028:	fc 01       	movw	r30, r24
    302a:	86 8d       	ldd	r24, Z+30	; 0x1e
    302c:	8f 3f       	cpi	r24, 0xFF	; 255
    302e:	21 f4       	brne	.+8      	; 0x3038 <xQueueGenericReceive+0x122>
    3030:	8a 81       	ldd	r24, Y+2	; 0x02
    3032:	9b 81       	ldd	r25, Y+3	; 0x03
    3034:	fc 01       	movw	r30, r24
    3036:	16 8e       	std	Z+30, r1	; 0x1e
    3038:	0f 90       	pop	r0
    303a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    303c:	9e 01       	movw	r18, r28
    303e:	23 5f       	subi	r18, 0xF3	; 243
    3040:	3f 4f       	sbci	r19, 0xFF	; 255
    3042:	ce 01       	movw	r24, r28
    3044:	06 96       	adiw	r24, 0x06	; 6
    3046:	b9 01       	movw	r22, r18
    3048:	0e 94 1b 21 	call	0x4236	; 0x4236 <xTaskCheckForTimeOut>
    304c:	88 23       	and	r24, r24
    304e:	01 f5       	brne	.+64     	; 0x3090 <xQueueGenericReceive+0x17a>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3050:	8a 81       	ldd	r24, Y+2	; 0x02
    3052:	9b 81       	ldd	r25, Y+3	; 0x03
    3054:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <prvIsQueueEmpty>
    3058:	88 23       	and	r24, r24
    305a:	99 f0       	breq	.+38     	; 0x3082 <xQueueGenericReceive+0x16c>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    305c:	2d 85       	ldd	r18, Y+13	; 0x0d
    305e:	3e 85       	ldd	r19, Y+14	; 0x0e
    3060:	8a 81       	ldd	r24, Y+2	; 0x02
    3062:	9b 81       	ldd	r25, Y+3	; 0x03
    3064:	41 96       	adiw	r24, 0x11	; 17
    3066:	b9 01       	movw	r22, r18
    3068:	0e 94 af 1f 	call	0x3f5e	; 0x3f5e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    306c:	8a 81       	ldd	r24, Y+2	; 0x02
    306e:	9b 81       	ldd	r25, Y+3	; 0x03
    3070:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3074:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
    3078:	88 23       	and	r24, r24
    307a:	91 f4       	brne	.+36     	; 0x30a0 <xQueueGenericReceive+0x18a>
				{
					portYIELD_WITHIN_API();
    307c:	0e 94 89 13 	call	0x2712	; 0x2712 <vPortYield>
    3080:	0f c0       	rjmp	.+30     	; 0x30a0 <xQueueGenericReceive+0x18a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3082:	8a 81       	ldd	r24, Y+2	; 0x02
    3084:	9b 81       	ldd	r25, Y+3	; 0x03
    3086:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    308a:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
    308e:	59 cf       	rjmp	.-334    	; 0x2f42 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    3090:	8a 81       	ldd	r24, Y+2	; 0x02
    3092:	9b 81       	ldd	r25, Y+3	; 0x03
    3094:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3098:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    309c:	80 e0       	ldi	r24, 0x00	; 0
    309e:	01 c0       	rjmp	.+2      	; 0x30a2 <xQueueGenericReceive+0x18c>
		}
	}
    30a0:	50 cf       	rjmp	.-352    	; 0x2f42 <xQueueGenericReceive+0x2c>
}
    30a2:	2f 96       	adiw	r28, 0x0f	; 15
    30a4:	0f b6       	in	r0, 0x3f	; 63
    30a6:	f8 94       	cli
    30a8:	de bf       	out	0x3e, r29	; 62
    30aa:	0f be       	out	0x3f, r0	; 63
    30ac:	cd bf       	out	0x3d, r28	; 61
    30ae:	df 91       	pop	r29
    30b0:	cf 91       	pop	r28
    30b2:	08 95       	ret

000030b4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    30b4:	cf 93       	push	r28
    30b6:	df 93       	push	r29
    30b8:	cd b7       	in	r28, 0x3d	; 61
    30ba:	de b7       	in	r29, 0x3e	; 62
    30bc:	2a 97       	sbiw	r28, 0x0a	; 10
    30be:	0f b6       	in	r0, 0x3f	; 63
    30c0:	f8 94       	cli
    30c2:	de bf       	out	0x3e, r29	; 62
    30c4:	0f be       	out	0x3f, r0	; 63
    30c6:	cd bf       	out	0x3d, r28	; 61
    30c8:	9e 83       	std	Y+6, r25	; 0x06
    30ca:	8d 83       	std	Y+5, r24	; 0x05
    30cc:	78 87       	std	Y+8, r23	; 0x08
    30ce:	6f 83       	std	Y+7, r22	; 0x07
    30d0:	5a 87       	std	Y+10, r21	; 0x0a
    30d2:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    30d4:	8d 81       	ldd	r24, Y+5	; 0x05
    30d6:	9e 81       	ldd	r25, Y+6	; 0x06
    30d8:	9b 83       	std	Y+3, r25	; 0x03
    30da:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    30dc:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    30de:	8a 81       	ldd	r24, Y+2	; 0x02
    30e0:	9b 81       	ldd	r25, Y+3	; 0x03
    30e2:	fc 01       	movw	r30, r24
    30e4:	82 8d       	ldd	r24, Z+26	; 0x1a
    30e6:	88 23       	and	r24, r24
    30e8:	d9 f1       	breq	.+118    	; 0x3160 <xQueueReceiveFromISR+0xac>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    30ea:	2f 81       	ldd	r18, Y+7	; 0x07
    30ec:	38 85       	ldd	r19, Y+8	; 0x08
    30ee:	8a 81       	ldd	r24, Y+2	; 0x02
    30f0:	9b 81       	ldd	r25, Y+3	; 0x03
    30f2:	b9 01       	movw	r22, r18
    30f4:	0e 94 22 1a 	call	0x3444	; 0x3444 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    30f8:	8a 81       	ldd	r24, Y+2	; 0x02
    30fa:	9b 81       	ldd	r25, Y+3	; 0x03
    30fc:	fc 01       	movw	r30, r24
    30fe:	82 8d       	ldd	r24, Z+26	; 0x1a
    3100:	2f ef       	ldi	r18, 0xFF	; 255
    3102:	28 0f       	add	r18, r24
    3104:	8a 81       	ldd	r24, Y+2	; 0x02
    3106:	9b 81       	ldd	r25, Y+3	; 0x03
    3108:	fc 01       	movw	r30, r24
    310a:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    310c:	8a 81       	ldd	r24, Y+2	; 0x02
    310e:	9b 81       	ldd	r25, Y+3	; 0x03
    3110:	fc 01       	movw	r30, r24
    3112:	85 8d       	ldd	r24, Z+29	; 0x1d
    3114:	8f 3f       	cpi	r24, 0xFF	; 255
    3116:	b9 f4       	brne	.+46     	; 0x3146 <xQueueReceiveFromISR+0x92>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3118:	8a 81       	ldd	r24, Y+2	; 0x02
    311a:	9b 81       	ldd	r25, Y+3	; 0x03
    311c:	fc 01       	movw	r30, r24
    311e:	80 85       	ldd	r24, Z+8	; 0x08
    3120:	88 23       	and	r24, r24
    3122:	d9 f0       	breq	.+54     	; 0x315a <xQueueReceiveFromISR+0xa6>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3124:	8a 81       	ldd	r24, Y+2	; 0x02
    3126:	9b 81       	ldd	r25, Y+3	; 0x03
    3128:	08 96       	adiw	r24, 0x08	; 8
    312a:	0e 94 28 20 	call	0x4050	; 0x4050 <xTaskRemoveFromEventList>
    312e:	88 23       	and	r24, r24
    3130:	a1 f0       	breq	.+40     	; 0x315a <xQueueReceiveFromISR+0xa6>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    3132:	89 85       	ldd	r24, Y+9	; 0x09
    3134:	9a 85       	ldd	r25, Y+10	; 0x0a
    3136:	89 2b       	or	r24, r25
    3138:	81 f0       	breq	.+32     	; 0x315a <xQueueReceiveFromISR+0xa6>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    313a:	89 85       	ldd	r24, Y+9	; 0x09
    313c:	9a 85       	ldd	r25, Y+10	; 0x0a
    313e:	21 e0       	ldi	r18, 0x01	; 1
    3140:	fc 01       	movw	r30, r24
    3142:	20 83       	st	Z, r18
    3144:	0a c0       	rjmp	.+20     	; 0x315a <xQueueReceiveFromISR+0xa6>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    3146:	8a 81       	ldd	r24, Y+2	; 0x02
    3148:	9b 81       	ldd	r25, Y+3	; 0x03
    314a:	fc 01       	movw	r30, r24
    314c:	85 8d       	ldd	r24, Z+29	; 0x1d
    314e:	8f 5f       	subi	r24, 0xFF	; 255
    3150:	28 2f       	mov	r18, r24
    3152:	8a 81       	ldd	r24, Y+2	; 0x02
    3154:	9b 81       	ldd	r25, Y+3	; 0x03
    3156:	fc 01       	movw	r30, r24
    3158:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    315a:	81 e0       	ldi	r24, 0x01	; 1
    315c:	89 83       	std	Y+1, r24	; 0x01
    315e:	01 c0       	rjmp	.+2      	; 0x3162 <xQueueReceiveFromISR+0xae>
		}
		else
		{
			xReturn = pdFAIL;
    3160:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3162:	89 81       	ldd	r24, Y+1	; 0x01
}
    3164:	2a 96       	adiw	r28, 0x0a	; 10
    3166:	0f b6       	in	r0, 0x3f	; 63
    3168:	f8 94       	cli
    316a:	de bf       	out	0x3e, r29	; 62
    316c:	0f be       	out	0x3f, r0	; 63
    316e:	cd bf       	out	0x3d, r28	; 61
    3170:	df 91       	pop	r29
    3172:	cf 91       	pop	r28
    3174:	08 95       	ret

00003176 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    3176:	cf 93       	push	r28
    3178:	df 93       	push	r29
    317a:	cd b7       	in	r28, 0x3d	; 61
    317c:	de b7       	in	r29, 0x3e	; 62
    317e:	2a 97       	sbiw	r28, 0x0a	; 10
    3180:	0f b6       	in	r0, 0x3f	; 63
    3182:	f8 94       	cli
    3184:	de bf       	out	0x3e, r29	; 62
    3186:	0f be       	out	0x3f, r0	; 63
    3188:	cd bf       	out	0x3d, r28	; 61
    318a:	98 87       	std	Y+8, r25	; 0x08
    318c:	8f 83       	std	Y+7, r24	; 0x07
    318e:	7a 87       	std	Y+10, r23	; 0x0a
    3190:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3192:	8f 81       	ldd	r24, Y+7	; 0x07
    3194:	98 85       	ldd	r25, Y+8	; 0x08
    3196:	9b 83       	std	Y+3, r25	; 0x03
    3198:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    319a:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    319c:	8a 81       	ldd	r24, Y+2	; 0x02
    319e:	9b 81       	ldd	r25, Y+3	; 0x03
    31a0:	fc 01       	movw	r30, r24
    31a2:	82 8d       	ldd	r24, Z+26	; 0x1a
    31a4:	88 23       	and	r24, r24
    31a6:	c1 f0       	breq	.+48     	; 0x31d8 <xQueuePeekFromISR+0x62>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    31a8:	8a 81       	ldd	r24, Y+2	; 0x02
    31aa:	9b 81       	ldd	r25, Y+3	; 0x03
    31ac:	fc 01       	movw	r30, r24
    31ae:	86 81       	ldd	r24, Z+6	; 0x06
    31b0:	97 81       	ldd	r25, Z+7	; 0x07
    31b2:	9e 83       	std	Y+6, r25	; 0x06
    31b4:	8d 83       	std	Y+5, r24	; 0x05
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    31b6:	29 85       	ldd	r18, Y+9	; 0x09
    31b8:	3a 85       	ldd	r19, Y+10	; 0x0a
    31ba:	8a 81       	ldd	r24, Y+2	; 0x02
    31bc:	9b 81       	ldd	r25, Y+3	; 0x03
    31be:	b9 01       	movw	r22, r18
    31c0:	0e 94 22 1a 	call	0x3444	; 0x3444 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    31c4:	8a 81       	ldd	r24, Y+2	; 0x02
    31c6:	9b 81       	ldd	r25, Y+3	; 0x03
    31c8:	2d 81       	ldd	r18, Y+5	; 0x05
    31ca:	3e 81       	ldd	r19, Y+6	; 0x06
    31cc:	fc 01       	movw	r30, r24
    31ce:	37 83       	std	Z+7, r19	; 0x07
    31d0:	26 83       	std	Z+6, r18	; 0x06

			xReturn = pdPASS;
    31d2:	81 e0       	ldi	r24, 0x01	; 1
    31d4:	89 83       	std	Y+1, r24	; 0x01
    31d6:	01 c0       	rjmp	.+2      	; 0x31da <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
    31d8:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    31da:	89 81       	ldd	r24, Y+1	; 0x01
}
    31dc:	2a 96       	adiw	r28, 0x0a	; 10
    31de:	0f b6       	in	r0, 0x3f	; 63
    31e0:	f8 94       	cli
    31e2:	de bf       	out	0x3e, r29	; 62
    31e4:	0f be       	out	0x3f, r0	; 63
    31e6:	cd bf       	out	0x3d, r28	; 61
    31e8:	df 91       	pop	r29
    31ea:	cf 91       	pop	r28
    31ec:	08 95       	ret

000031ee <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    31ee:	cf 93       	push	r28
    31f0:	df 93       	push	r29
    31f2:	00 d0       	rcall	.+0      	; 0x31f4 <uxQueueMessagesWaiting+0x6>
    31f4:	1f 92       	push	r1
    31f6:	cd b7       	in	r28, 0x3d	; 61
    31f8:	de b7       	in	r29, 0x3e	; 62
    31fa:	9b 83       	std	Y+3, r25	; 0x03
    31fc:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    31fe:	0f b6       	in	r0, 0x3f	; 63
    3200:	f8 94       	cli
    3202:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3204:	8a 81       	ldd	r24, Y+2	; 0x02
    3206:	9b 81       	ldd	r25, Y+3	; 0x03
    3208:	fc 01       	movw	r30, r24
    320a:	82 8d       	ldd	r24, Z+26	; 0x1a
    320c:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    320e:	0f 90       	pop	r0
    3210:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3212:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3214:	0f 90       	pop	r0
    3216:	0f 90       	pop	r0
    3218:	0f 90       	pop	r0
    321a:	df 91       	pop	r29
    321c:	cf 91       	pop	r28
    321e:	08 95       	ret

00003220 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3220:	cf 93       	push	r28
    3222:	df 93       	push	r29
    3224:	00 d0       	rcall	.+0      	; 0x3226 <uxQueueSpacesAvailable+0x6>
    3226:	00 d0       	rcall	.+0      	; 0x3228 <uxQueueSpacesAvailable+0x8>
    3228:	1f 92       	push	r1
    322a:	cd b7       	in	r28, 0x3d	; 61
    322c:	de b7       	in	r29, 0x3e	; 62
    322e:	9d 83       	std	Y+5, r25	; 0x05
    3230:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    3232:	8c 81       	ldd	r24, Y+4	; 0x04
    3234:	9d 81       	ldd	r25, Y+5	; 0x05
    3236:	9a 83       	std	Y+2, r25	; 0x02
    3238:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    323a:	0f b6       	in	r0, 0x3f	; 63
    323c:	f8 94       	cli
    323e:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3240:	89 81       	ldd	r24, Y+1	; 0x01
    3242:	9a 81       	ldd	r25, Y+2	; 0x02
    3244:	fc 01       	movw	r30, r24
    3246:	23 8d       	ldd	r18, Z+27	; 0x1b
    3248:	89 81       	ldd	r24, Y+1	; 0x01
    324a:	9a 81       	ldd	r25, Y+2	; 0x02
    324c:	fc 01       	movw	r30, r24
    324e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3250:	f2 2f       	mov	r31, r18
    3252:	f8 1b       	sub	r31, r24
    3254:	8f 2f       	mov	r24, r31
    3256:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    3258:	0f 90       	pop	r0
    325a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    325c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    325e:	0f 90       	pop	r0
    3260:	0f 90       	pop	r0
    3262:	0f 90       	pop	r0
    3264:	0f 90       	pop	r0
    3266:	0f 90       	pop	r0
    3268:	df 91       	pop	r29
    326a:	cf 91       	pop	r28
    326c:	08 95       	ret

0000326e <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    326e:	cf 93       	push	r28
    3270:	df 93       	push	r29
    3272:	00 d0       	rcall	.+0      	; 0x3274 <uxQueueMessagesWaitingFromISR+0x6>
    3274:	1f 92       	push	r1
    3276:	cd b7       	in	r28, 0x3d	; 61
    3278:	de b7       	in	r29, 0x3e	; 62
    327a:	9b 83       	std	Y+3, r25	; 0x03
    327c:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    327e:	8a 81       	ldd	r24, Y+2	; 0x02
    3280:	9b 81       	ldd	r25, Y+3	; 0x03
    3282:	fc 01       	movw	r30, r24
    3284:	82 8d       	ldd	r24, Z+26	; 0x1a
    3286:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    3288:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    328a:	0f 90       	pop	r0
    328c:	0f 90       	pop	r0
    328e:	0f 90       	pop	r0
    3290:	df 91       	pop	r29
    3292:	cf 91       	pop	r28
    3294:	08 95       	ret

00003296 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3296:	cf 93       	push	r28
    3298:	df 93       	push	r29
    329a:	00 d0       	rcall	.+0      	; 0x329c <vQueueDelete+0x6>
    329c:	00 d0       	rcall	.+0      	; 0x329e <vQueueDelete+0x8>
    329e:	cd b7       	in	r28, 0x3d	; 61
    32a0:	de b7       	in	r29, 0x3e	; 62
    32a2:	9c 83       	std	Y+4, r25	; 0x04
    32a4:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    32a6:	8b 81       	ldd	r24, Y+3	; 0x03
    32a8:	9c 81       	ldd	r25, Y+4	; 0x04
    32aa:	9a 83       	std	Y+2, r25	; 0x02
    32ac:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue );
    32ae:	89 81       	ldd	r24, Y+1	; 0x01
    32b0:	9a 81       	ldd	r25, Y+2	; 0x02
    32b2:	0e 94 fd 14 	call	0x29fa	; 0x29fa <vPortFree>
}
    32b6:	0f 90       	pop	r0
    32b8:	0f 90       	pop	r0
    32ba:	0f 90       	pop	r0
    32bc:	0f 90       	pop	r0
    32be:	df 91       	pop	r29
    32c0:	cf 91       	pop	r28
    32c2:	08 95       	ret

000032c4 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    32c4:	cf 93       	push	r28
    32c6:	df 93       	push	r29
    32c8:	00 d0       	rcall	.+0      	; 0x32ca <prvCopyDataToQueue+0x6>
    32ca:	00 d0       	rcall	.+0      	; 0x32cc <prvCopyDataToQueue+0x8>
    32cc:	00 d0       	rcall	.+0      	; 0x32ce <prvCopyDataToQueue+0xa>
    32ce:	cd b7       	in	r28, 0x3d	; 61
    32d0:	de b7       	in	r29, 0x3e	; 62
    32d2:	9b 83       	std	Y+3, r25	; 0x03
    32d4:	8a 83       	std	Y+2, r24	; 0x02
    32d6:	7d 83       	std	Y+5, r23	; 0x05
    32d8:	6c 83       	std	Y+4, r22	; 0x04
    32da:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    32dc:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    32de:	8a 81       	ldd	r24, Y+2	; 0x02
    32e0:	9b 81       	ldd	r25, Y+3	; 0x03
    32e2:	fc 01       	movw	r30, r24
    32e4:	84 8d       	ldd	r24, Z+28	; 0x1c
    32e6:	88 23       	and	r24, r24
    32e8:	09 f4       	brne	.+2      	; 0x32ec <prvCopyDataToQueue+0x28>
    32ea:	98 c0       	rjmp	.+304    	; 0x341c <prvCopyDataToQueue+0x158>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    32ec:	8e 81       	ldd	r24, Y+6	; 0x06
    32ee:	88 23       	and	r24, r24
    32f0:	d9 f5       	brne	.+118    	; 0x3368 <prvCopyDataToQueue+0xa4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    32f2:	8a 81       	ldd	r24, Y+2	; 0x02
    32f4:	9b 81       	ldd	r25, Y+3	; 0x03
    32f6:	fc 01       	movw	r30, r24
    32f8:	84 8d       	ldd	r24, Z+28	; 0x1c
    32fa:	48 2f       	mov	r20, r24
    32fc:	50 e0       	ldi	r21, 0x00	; 0
    32fe:	8a 81       	ldd	r24, Y+2	; 0x02
    3300:	9b 81       	ldd	r25, Y+3	; 0x03
    3302:	fc 01       	movw	r30, r24
    3304:	84 81       	ldd	r24, Z+4	; 0x04
    3306:	95 81       	ldd	r25, Z+5	; 0x05
    3308:	2c 81       	ldd	r18, Y+4	; 0x04
    330a:	3d 81       	ldd	r19, Y+5	; 0x05
    330c:	b9 01       	movw	r22, r18
    330e:	0e 94 62 28 	call	0x50c4	; 0x50c4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    3312:	8a 81       	ldd	r24, Y+2	; 0x02
    3314:	9b 81       	ldd	r25, Y+3	; 0x03
    3316:	fc 01       	movw	r30, r24
    3318:	24 81       	ldd	r18, Z+4	; 0x04
    331a:	35 81       	ldd	r19, Z+5	; 0x05
    331c:	8a 81       	ldd	r24, Y+2	; 0x02
    331e:	9b 81       	ldd	r25, Y+3	; 0x03
    3320:	fc 01       	movw	r30, r24
    3322:	84 8d       	ldd	r24, Z+28	; 0x1c
    3324:	88 2f       	mov	r24, r24
    3326:	90 e0       	ldi	r25, 0x00	; 0
    3328:	28 0f       	add	r18, r24
    332a:	39 1f       	adc	r19, r25
    332c:	8a 81       	ldd	r24, Y+2	; 0x02
    332e:	9b 81       	ldd	r25, Y+3	; 0x03
    3330:	fc 01       	movw	r30, r24
    3332:	35 83       	std	Z+5, r19	; 0x05
    3334:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3336:	8a 81       	ldd	r24, Y+2	; 0x02
    3338:	9b 81       	ldd	r25, Y+3	; 0x03
    333a:	fc 01       	movw	r30, r24
    333c:	24 81       	ldd	r18, Z+4	; 0x04
    333e:	35 81       	ldd	r19, Z+5	; 0x05
    3340:	8a 81       	ldd	r24, Y+2	; 0x02
    3342:	9b 81       	ldd	r25, Y+3	; 0x03
    3344:	fc 01       	movw	r30, r24
    3346:	82 81       	ldd	r24, Z+2	; 0x02
    3348:	93 81       	ldd	r25, Z+3	; 0x03
    334a:	28 17       	cp	r18, r24
    334c:	39 07       	cpc	r19, r25
    334e:	08 f4       	brcc	.+2      	; 0x3352 <prvCopyDataToQueue+0x8e>
    3350:	65 c0       	rjmp	.+202    	; 0x341c <prvCopyDataToQueue+0x158>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3352:	8a 81       	ldd	r24, Y+2	; 0x02
    3354:	9b 81       	ldd	r25, Y+3	; 0x03
    3356:	fc 01       	movw	r30, r24
    3358:	20 81       	ld	r18, Z
    335a:	31 81       	ldd	r19, Z+1	; 0x01
    335c:	8a 81       	ldd	r24, Y+2	; 0x02
    335e:	9b 81       	ldd	r25, Y+3	; 0x03
    3360:	fc 01       	movw	r30, r24
    3362:	35 83       	std	Z+5, r19	; 0x05
    3364:	24 83       	std	Z+4, r18	; 0x04
    3366:	5a c0       	rjmp	.+180    	; 0x341c <prvCopyDataToQueue+0x158>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3368:	8a 81       	ldd	r24, Y+2	; 0x02
    336a:	9b 81       	ldd	r25, Y+3	; 0x03
    336c:	fc 01       	movw	r30, r24
    336e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3370:	48 2f       	mov	r20, r24
    3372:	50 e0       	ldi	r21, 0x00	; 0
    3374:	8a 81       	ldd	r24, Y+2	; 0x02
    3376:	9b 81       	ldd	r25, Y+3	; 0x03
    3378:	fc 01       	movw	r30, r24
    337a:	86 81       	ldd	r24, Z+6	; 0x06
    337c:	97 81       	ldd	r25, Z+7	; 0x07
    337e:	2c 81       	ldd	r18, Y+4	; 0x04
    3380:	3d 81       	ldd	r19, Y+5	; 0x05
    3382:	b9 01       	movw	r22, r18
    3384:	0e 94 62 28 	call	0x50c4	; 0x50c4 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    3388:	8a 81       	ldd	r24, Y+2	; 0x02
    338a:	9b 81       	ldd	r25, Y+3	; 0x03
    338c:	fc 01       	movw	r30, r24
    338e:	26 81       	ldd	r18, Z+6	; 0x06
    3390:	37 81       	ldd	r19, Z+7	; 0x07
    3392:	8a 81       	ldd	r24, Y+2	; 0x02
    3394:	9b 81       	ldd	r25, Y+3	; 0x03
    3396:	fc 01       	movw	r30, r24
    3398:	84 8d       	ldd	r24, Z+28	; 0x1c
    339a:	88 2f       	mov	r24, r24
    339c:	90 e0       	ldi	r25, 0x00	; 0
    339e:	91 95       	neg	r25
    33a0:	81 95       	neg	r24
    33a2:	91 09       	sbc	r25, r1
    33a4:	28 0f       	add	r18, r24
    33a6:	39 1f       	adc	r19, r25
    33a8:	8a 81       	ldd	r24, Y+2	; 0x02
    33aa:	9b 81       	ldd	r25, Y+3	; 0x03
    33ac:	fc 01       	movw	r30, r24
    33ae:	37 83       	std	Z+7, r19	; 0x07
    33b0:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    33b2:	8a 81       	ldd	r24, Y+2	; 0x02
    33b4:	9b 81       	ldd	r25, Y+3	; 0x03
    33b6:	fc 01       	movw	r30, r24
    33b8:	26 81       	ldd	r18, Z+6	; 0x06
    33ba:	37 81       	ldd	r19, Z+7	; 0x07
    33bc:	8a 81       	ldd	r24, Y+2	; 0x02
    33be:	9b 81       	ldd	r25, Y+3	; 0x03
    33c0:	fc 01       	movw	r30, r24
    33c2:	80 81       	ld	r24, Z
    33c4:	91 81       	ldd	r25, Z+1	; 0x01
    33c6:	28 17       	cp	r18, r24
    33c8:	39 07       	cpc	r19, r25
    33ca:	a8 f4       	brcc	.+42     	; 0x33f6 <prvCopyDataToQueue+0x132>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    33cc:	8a 81       	ldd	r24, Y+2	; 0x02
    33ce:	9b 81       	ldd	r25, Y+3	; 0x03
    33d0:	fc 01       	movw	r30, r24
    33d2:	22 81       	ldd	r18, Z+2	; 0x02
    33d4:	33 81       	ldd	r19, Z+3	; 0x03
    33d6:	8a 81       	ldd	r24, Y+2	; 0x02
    33d8:	9b 81       	ldd	r25, Y+3	; 0x03
    33da:	fc 01       	movw	r30, r24
    33dc:	84 8d       	ldd	r24, Z+28	; 0x1c
    33de:	88 2f       	mov	r24, r24
    33e0:	90 e0       	ldi	r25, 0x00	; 0
    33e2:	91 95       	neg	r25
    33e4:	81 95       	neg	r24
    33e6:	91 09       	sbc	r25, r1
    33e8:	28 0f       	add	r18, r24
    33ea:	39 1f       	adc	r19, r25
    33ec:	8a 81       	ldd	r24, Y+2	; 0x02
    33ee:	9b 81       	ldd	r25, Y+3	; 0x03
    33f0:	fc 01       	movw	r30, r24
    33f2:	37 83       	std	Z+7, r19	; 0x07
    33f4:	26 83       	std	Z+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    33f6:	8e 81       	ldd	r24, Y+6	; 0x06
    33f8:	82 30       	cpi	r24, 0x02	; 2
    33fa:	81 f4       	brne	.+32     	; 0x341c <prvCopyDataToQueue+0x158>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    33fc:	8a 81       	ldd	r24, Y+2	; 0x02
    33fe:	9b 81       	ldd	r25, Y+3	; 0x03
    3400:	fc 01       	movw	r30, r24
    3402:	82 8d       	ldd	r24, Z+26	; 0x1a
    3404:	88 23       	and	r24, r24
    3406:	51 f0       	breq	.+20     	; 0x341c <prvCopyDataToQueue+0x158>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    3408:	8a 81       	ldd	r24, Y+2	; 0x02
    340a:	9b 81       	ldd	r25, Y+3	; 0x03
    340c:	fc 01       	movw	r30, r24
    340e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3410:	2f ef       	ldi	r18, 0xFF	; 255
    3412:	28 0f       	add	r18, r24
    3414:	8a 81       	ldd	r24, Y+2	; 0x02
    3416:	9b 81       	ldd	r25, Y+3	; 0x03
    3418:	fc 01       	movw	r30, r24
    341a:	22 8f       	std	Z+26, r18	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    341c:	8a 81       	ldd	r24, Y+2	; 0x02
    341e:	9b 81       	ldd	r25, Y+3	; 0x03
    3420:	fc 01       	movw	r30, r24
    3422:	82 8d       	ldd	r24, Z+26	; 0x1a
    3424:	21 e0       	ldi	r18, 0x01	; 1
    3426:	28 0f       	add	r18, r24
    3428:	8a 81       	ldd	r24, Y+2	; 0x02
    342a:	9b 81       	ldd	r25, Y+3	; 0x03
    342c:	fc 01       	movw	r30, r24
    342e:	22 8f       	std	Z+26, r18	; 0x1a

	return xReturn;
    3430:	89 81       	ldd	r24, Y+1	; 0x01
}
    3432:	26 96       	adiw	r28, 0x06	; 6
    3434:	0f b6       	in	r0, 0x3f	; 63
    3436:	f8 94       	cli
    3438:	de bf       	out	0x3e, r29	; 62
    343a:	0f be       	out	0x3f, r0	; 63
    343c:	cd bf       	out	0x3d, r28	; 61
    343e:	df 91       	pop	r29
    3440:	cf 91       	pop	r28
    3442:	08 95       	ret

00003444 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    3444:	cf 93       	push	r28
    3446:	df 93       	push	r29
    3448:	00 d0       	rcall	.+0      	; 0x344a <prvCopyDataFromQueue+0x6>
    344a:	00 d0       	rcall	.+0      	; 0x344c <prvCopyDataFromQueue+0x8>
    344c:	cd b7       	in	r28, 0x3d	; 61
    344e:	de b7       	in	r29, 0x3e	; 62
    3450:	9a 83       	std	Y+2, r25	; 0x02
    3452:	89 83       	std	Y+1, r24	; 0x01
    3454:	7c 83       	std	Y+4, r23	; 0x04
    3456:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3458:	89 81       	ldd	r24, Y+1	; 0x01
    345a:	9a 81       	ldd	r25, Y+2	; 0x02
    345c:	fc 01       	movw	r30, r24
    345e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3460:	88 23       	and	r24, r24
    3462:	c9 f1       	breq	.+114    	; 0x34d6 <prvCopyDataFromQueue+0x92>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    3464:	89 81       	ldd	r24, Y+1	; 0x01
    3466:	9a 81       	ldd	r25, Y+2	; 0x02
    3468:	fc 01       	movw	r30, r24
    346a:	26 81       	ldd	r18, Z+6	; 0x06
    346c:	37 81       	ldd	r19, Z+7	; 0x07
    346e:	89 81       	ldd	r24, Y+1	; 0x01
    3470:	9a 81       	ldd	r25, Y+2	; 0x02
    3472:	fc 01       	movw	r30, r24
    3474:	84 8d       	ldd	r24, Z+28	; 0x1c
    3476:	88 2f       	mov	r24, r24
    3478:	90 e0       	ldi	r25, 0x00	; 0
    347a:	28 0f       	add	r18, r24
    347c:	39 1f       	adc	r19, r25
    347e:	89 81       	ldd	r24, Y+1	; 0x01
    3480:	9a 81       	ldd	r25, Y+2	; 0x02
    3482:	fc 01       	movw	r30, r24
    3484:	37 83       	std	Z+7, r19	; 0x07
    3486:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3488:	89 81       	ldd	r24, Y+1	; 0x01
    348a:	9a 81       	ldd	r25, Y+2	; 0x02
    348c:	fc 01       	movw	r30, r24
    348e:	26 81       	ldd	r18, Z+6	; 0x06
    3490:	37 81       	ldd	r19, Z+7	; 0x07
    3492:	89 81       	ldd	r24, Y+1	; 0x01
    3494:	9a 81       	ldd	r25, Y+2	; 0x02
    3496:	fc 01       	movw	r30, r24
    3498:	82 81       	ldd	r24, Z+2	; 0x02
    349a:	93 81       	ldd	r25, Z+3	; 0x03
    349c:	28 17       	cp	r18, r24
    349e:	39 07       	cpc	r19, r25
    34a0:	50 f0       	brcs	.+20     	; 0x34b6 <prvCopyDataFromQueue+0x72>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    34a2:	89 81       	ldd	r24, Y+1	; 0x01
    34a4:	9a 81       	ldd	r25, Y+2	; 0x02
    34a6:	fc 01       	movw	r30, r24
    34a8:	20 81       	ld	r18, Z
    34aa:	31 81       	ldd	r19, Z+1	; 0x01
    34ac:	89 81       	ldd	r24, Y+1	; 0x01
    34ae:	9a 81       	ldd	r25, Y+2	; 0x02
    34b0:	fc 01       	movw	r30, r24
    34b2:	37 83       	std	Z+7, r19	; 0x07
    34b4:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    34b6:	89 81       	ldd	r24, Y+1	; 0x01
    34b8:	9a 81       	ldd	r25, Y+2	; 0x02
    34ba:	fc 01       	movw	r30, r24
    34bc:	84 8d       	ldd	r24, Z+28	; 0x1c
    34be:	48 2f       	mov	r20, r24
    34c0:	50 e0       	ldi	r21, 0x00	; 0
    34c2:	89 81       	ldd	r24, Y+1	; 0x01
    34c4:	9a 81       	ldd	r25, Y+2	; 0x02
    34c6:	fc 01       	movw	r30, r24
    34c8:	26 81       	ldd	r18, Z+6	; 0x06
    34ca:	37 81       	ldd	r19, Z+7	; 0x07
    34cc:	8b 81       	ldd	r24, Y+3	; 0x03
    34ce:	9c 81       	ldd	r25, Y+4	; 0x04
    34d0:	b9 01       	movw	r22, r18
    34d2:	0e 94 62 28 	call	0x50c4	; 0x50c4 <memcpy>
	}
}
    34d6:	0f 90       	pop	r0
    34d8:	0f 90       	pop	r0
    34da:	0f 90       	pop	r0
    34dc:	0f 90       	pop	r0
    34de:	df 91       	pop	r29
    34e0:	cf 91       	pop	r28
    34e2:	08 95       	ret

000034e4 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    34e4:	cf 93       	push	r28
    34e6:	df 93       	push	r29
    34e8:	00 d0       	rcall	.+0      	; 0x34ea <prvUnlockQueue+0x6>
    34ea:	cd b7       	in	r28, 0x3d	; 61
    34ec:	de b7       	in	r29, 0x3e	; 62
    34ee:	9a 83       	std	Y+2, r25	; 0x02
    34f0:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    34f2:	0f b6       	in	r0, 0x3f	; 63
    34f4:	f8 94       	cli
    34f6:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    34f8:	1b c0       	rjmp	.+54     	; 0x3530 <prvUnlockQueue+0x4c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    34fa:	89 81       	ldd	r24, Y+1	; 0x01
    34fc:	9a 81       	ldd	r25, Y+2	; 0x02
    34fe:	fc 01       	movw	r30, r24
    3500:	81 89       	ldd	r24, Z+17	; 0x11
    3502:	88 23       	and	r24, r24
    3504:	51 f0       	breq	.+20     	; 0x351a <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3506:	89 81       	ldd	r24, Y+1	; 0x01
    3508:	9a 81       	ldd	r25, Y+2	; 0x02
    350a:	41 96       	adiw	r24, 0x11	; 17
    350c:	0e 94 28 20 	call	0x4050	; 0x4050 <xTaskRemoveFromEventList>
    3510:	88 23       	and	r24, r24
    3512:	21 f0       	breq	.+8      	; 0x351c <prvUnlockQueue+0x38>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    3514:	0e 94 83 21 	call	0x4306	; 0x4306 <vTaskMissedYield>
    3518:	01 c0       	rjmp	.+2      	; 0x351c <prvUnlockQueue+0x38>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
    351a:	10 c0       	rjmp	.+32     	; 0x353c <prvUnlockQueue+0x58>
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    351c:	89 81       	ldd	r24, Y+1	; 0x01
    351e:	9a 81       	ldd	r25, Y+2	; 0x02
    3520:	fc 01       	movw	r30, r24
    3522:	86 8d       	ldd	r24, Z+30	; 0x1e
    3524:	81 50       	subi	r24, 0x01	; 1
    3526:	28 2f       	mov	r18, r24
    3528:	89 81       	ldd	r24, Y+1	; 0x01
    352a:	9a 81       	ldd	r25, Y+2	; 0x02
    352c:	fc 01       	movw	r30, r24
    352e:	26 8f       	std	Z+30, r18	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3530:	89 81       	ldd	r24, Y+1	; 0x01
    3532:	9a 81       	ldd	r25, Y+2	; 0x02
    3534:	fc 01       	movw	r30, r24
    3536:	86 8d       	ldd	r24, Z+30	; 0x1e
    3538:	18 16       	cp	r1, r24
    353a:	fc f2       	brlt	.-66     	; 0x34fa <prvUnlockQueue+0x16>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    353c:	89 81       	ldd	r24, Y+1	; 0x01
    353e:	9a 81       	ldd	r25, Y+2	; 0x02
    3540:	2f ef       	ldi	r18, 0xFF	; 255
    3542:	fc 01       	movw	r30, r24
    3544:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    3546:	0f 90       	pop	r0
    3548:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    354a:	0f b6       	in	r0, 0x3f	; 63
    354c:	f8 94       	cli
    354e:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3550:	1b c0       	rjmp	.+54     	; 0x3588 <prvUnlockQueue+0xa4>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3552:	89 81       	ldd	r24, Y+1	; 0x01
    3554:	9a 81       	ldd	r25, Y+2	; 0x02
    3556:	fc 01       	movw	r30, r24
    3558:	80 85       	ldd	r24, Z+8	; 0x08
    355a:	88 23       	and	r24, r24
    355c:	a1 f0       	breq	.+40     	; 0x3586 <prvUnlockQueue+0xa2>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    355e:	89 81       	ldd	r24, Y+1	; 0x01
    3560:	9a 81       	ldd	r25, Y+2	; 0x02
    3562:	08 96       	adiw	r24, 0x08	; 8
    3564:	0e 94 28 20 	call	0x4050	; 0x4050 <xTaskRemoveFromEventList>
    3568:	88 23       	and	r24, r24
    356a:	11 f0       	breq	.+4      	; 0x3570 <prvUnlockQueue+0x8c>
				{
					vTaskMissedYield();
    356c:	0e 94 83 21 	call	0x4306	; 0x4306 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    3570:	89 81       	ldd	r24, Y+1	; 0x01
    3572:	9a 81       	ldd	r25, Y+2	; 0x02
    3574:	fc 01       	movw	r30, r24
    3576:	85 8d       	ldd	r24, Z+29	; 0x1d
    3578:	81 50       	subi	r24, 0x01	; 1
    357a:	28 2f       	mov	r18, r24
    357c:	89 81       	ldd	r24, Y+1	; 0x01
    357e:	9a 81       	ldd	r25, Y+2	; 0x02
    3580:	fc 01       	movw	r30, r24
    3582:	25 8f       	std	Z+29, r18	; 0x1d
    3584:	01 c0       	rjmp	.+2      	; 0x3588 <prvUnlockQueue+0xa4>
			}
			else
			{
				break;
    3586:	06 c0       	rjmp	.+12     	; 0x3594 <prvUnlockQueue+0xb0>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3588:	89 81       	ldd	r24, Y+1	; 0x01
    358a:	9a 81       	ldd	r25, Y+2	; 0x02
    358c:	fc 01       	movw	r30, r24
    358e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3590:	18 16       	cp	r1, r24
    3592:	fc f2       	brlt	.-66     	; 0x3552 <prvUnlockQueue+0x6e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    3594:	89 81       	ldd	r24, Y+1	; 0x01
    3596:	9a 81       	ldd	r25, Y+2	; 0x02
    3598:	2f ef       	ldi	r18, 0xFF	; 255
    359a:	fc 01       	movw	r30, r24
    359c:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    359e:	0f 90       	pop	r0
    35a0:	0f be       	out	0x3f, r0	; 63
}
    35a2:	0f 90       	pop	r0
    35a4:	0f 90       	pop	r0
    35a6:	df 91       	pop	r29
    35a8:	cf 91       	pop	r28
    35aa:	08 95       	ret

000035ac <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    35ac:	cf 93       	push	r28
    35ae:	df 93       	push	r29
    35b0:	00 d0       	rcall	.+0      	; 0x35b2 <prvIsQueueEmpty+0x6>
    35b2:	1f 92       	push	r1
    35b4:	cd b7       	in	r28, 0x3d	; 61
    35b6:	de b7       	in	r29, 0x3e	; 62
    35b8:	9b 83       	std	Y+3, r25	; 0x03
    35ba:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    35bc:	0f b6       	in	r0, 0x3f	; 63
    35be:	f8 94       	cli
    35c0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    35c2:	8a 81       	ldd	r24, Y+2	; 0x02
    35c4:	9b 81       	ldd	r25, Y+3	; 0x03
    35c6:	fc 01       	movw	r30, r24
    35c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    35ca:	88 23       	and	r24, r24
    35cc:	19 f4       	brne	.+6      	; 0x35d4 <prvIsQueueEmpty+0x28>
		{
			xReturn = pdTRUE;
    35ce:	81 e0       	ldi	r24, 0x01	; 1
    35d0:	89 83       	std	Y+1, r24	; 0x01
    35d2:	01 c0       	rjmp	.+2      	; 0x35d6 <prvIsQueueEmpty+0x2a>
		}
		else
		{
			xReturn = pdFALSE;
    35d4:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    35d6:	0f 90       	pop	r0
    35d8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    35da:	89 81       	ldd	r24, Y+1	; 0x01
}
    35dc:	0f 90       	pop	r0
    35de:	0f 90       	pop	r0
    35e0:	0f 90       	pop	r0
    35e2:	df 91       	pop	r29
    35e4:	cf 91       	pop	r28
    35e6:	08 95       	ret

000035e8 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    35e8:	cf 93       	push	r28
    35ea:	df 93       	push	r29
    35ec:	00 d0       	rcall	.+0      	; 0x35ee <xQueueIsQueueEmptyFromISR+0x6>
    35ee:	1f 92       	push	r1
    35f0:	cd b7       	in	r28, 0x3d	; 61
    35f2:	de b7       	in	r29, 0x3e	; 62
    35f4:	9b 83       	std	Y+3, r25	; 0x03
    35f6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    35f8:	8a 81       	ldd	r24, Y+2	; 0x02
    35fa:	9b 81       	ldd	r25, Y+3	; 0x03
    35fc:	fc 01       	movw	r30, r24
    35fe:	82 8d       	ldd	r24, Z+26	; 0x1a
    3600:	88 23       	and	r24, r24
    3602:	19 f4       	brne	.+6      	; 0x360a <xQueueIsQueueEmptyFromISR+0x22>
	{
		xReturn = pdTRUE;
    3604:	81 e0       	ldi	r24, 0x01	; 1
    3606:	89 83       	std	Y+1, r24	; 0x01
    3608:	01 c0       	rjmp	.+2      	; 0x360c <xQueueIsQueueEmptyFromISR+0x24>
	}
	else
	{
		xReturn = pdFALSE;
    360a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    360c:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    360e:	0f 90       	pop	r0
    3610:	0f 90       	pop	r0
    3612:	0f 90       	pop	r0
    3614:	df 91       	pop	r29
    3616:	cf 91       	pop	r28
    3618:	08 95       	ret

0000361a <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    361a:	cf 93       	push	r28
    361c:	df 93       	push	r29
    361e:	00 d0       	rcall	.+0      	; 0x3620 <prvIsQueueFull+0x6>
    3620:	1f 92       	push	r1
    3622:	cd b7       	in	r28, 0x3d	; 61
    3624:	de b7       	in	r29, 0x3e	; 62
    3626:	9b 83       	std	Y+3, r25	; 0x03
    3628:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    362a:	0f b6       	in	r0, 0x3f	; 63
    362c:	f8 94       	cli
    362e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3630:	8a 81       	ldd	r24, Y+2	; 0x02
    3632:	9b 81       	ldd	r25, Y+3	; 0x03
    3634:	fc 01       	movw	r30, r24
    3636:	22 8d       	ldd	r18, Z+26	; 0x1a
    3638:	8a 81       	ldd	r24, Y+2	; 0x02
    363a:	9b 81       	ldd	r25, Y+3	; 0x03
    363c:	fc 01       	movw	r30, r24
    363e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3640:	28 17       	cp	r18, r24
    3642:	19 f4       	brne	.+6      	; 0x364a <prvIsQueueFull+0x30>
		{
			xReturn = pdTRUE;
    3644:	81 e0       	ldi	r24, 0x01	; 1
    3646:	89 83       	std	Y+1, r24	; 0x01
    3648:	01 c0       	rjmp	.+2      	; 0x364c <prvIsQueueFull+0x32>
		}
		else
		{
			xReturn = pdFALSE;
    364a:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    364c:	0f 90       	pop	r0
    364e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3650:	89 81       	ldd	r24, Y+1	; 0x01
}
    3652:	0f 90       	pop	r0
    3654:	0f 90       	pop	r0
    3656:	0f 90       	pop	r0
    3658:	df 91       	pop	r29
    365a:	cf 91       	pop	r28
    365c:	08 95       	ret

0000365e <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    365e:	cf 93       	push	r28
    3660:	df 93       	push	r29
    3662:	00 d0       	rcall	.+0      	; 0x3664 <xQueueIsQueueFullFromISR+0x6>
    3664:	1f 92       	push	r1
    3666:	cd b7       	in	r28, 0x3d	; 61
    3668:	de b7       	in	r29, 0x3e	; 62
    366a:	9b 83       	std	Y+3, r25	; 0x03
    366c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    366e:	8a 81       	ldd	r24, Y+2	; 0x02
    3670:	9b 81       	ldd	r25, Y+3	; 0x03
    3672:	fc 01       	movw	r30, r24
    3674:	22 8d       	ldd	r18, Z+26	; 0x1a
    3676:	8a 81       	ldd	r24, Y+2	; 0x02
    3678:	9b 81       	ldd	r25, Y+3	; 0x03
    367a:	fc 01       	movw	r30, r24
    367c:	83 8d       	ldd	r24, Z+27	; 0x1b
    367e:	28 17       	cp	r18, r24
    3680:	19 f4       	brne	.+6      	; 0x3688 <xQueueIsQueueFullFromISR+0x2a>
	{
		xReturn = pdTRUE;
    3682:	81 e0       	ldi	r24, 0x01	; 1
    3684:	89 83       	std	Y+1, r24	; 0x01
    3686:	01 c0       	rjmp	.+2      	; 0x368a <xQueueIsQueueFullFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    3688:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    368a:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    368c:	0f 90       	pop	r0
    368e:	0f 90       	pop	r0
    3690:	0f 90       	pop	r0
    3692:	df 91       	pop	r29
    3694:	cf 91       	pop	r28
    3696:	08 95       	ret

00003698 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3698:	af 92       	push	r10
    369a:	bf 92       	push	r11
    369c:	cf 92       	push	r12
    369e:	df 92       	push	r13
    36a0:	ef 92       	push	r14
    36a2:	ff 92       	push	r15
    36a4:	0f 93       	push	r16
    36a6:	1f 93       	push	r17
    36a8:	cf 93       	push	r28
    36aa:	df 93       	push	r29
    36ac:	cd b7       	in	r28, 0x3d	; 61
    36ae:	de b7       	in	r29, 0x3e	; 62
    36b0:	64 97       	sbiw	r28, 0x14	; 20
    36b2:	0f b6       	in	r0, 0x3f	; 63
    36b4:	f8 94       	cli
    36b6:	de bf       	out	0x3e, r29	; 62
    36b8:	0f be       	out	0x3f, r0	; 63
    36ba:	cd bf       	out	0x3d, r28	; 61
    36bc:	9f 83       	std	Y+7, r25	; 0x07
    36be:	8e 83       	std	Y+6, r24	; 0x06
    36c0:	79 87       	std	Y+9, r23	; 0x09
    36c2:	68 87       	std	Y+8, r22	; 0x08
    36c4:	5b 87       	std	Y+11, r21	; 0x0b
    36c6:	4a 87       	std	Y+10, r20	; 0x0a
    36c8:	3d 87       	std	Y+13, r19	; 0x0d
    36ca:	2c 87       	std	Y+12, r18	; 0x0c
    36cc:	0e 87       	std	Y+14, r16	; 0x0e
    36ce:	f8 8a       	std	Y+16, r15	; 0x10
    36d0:	ef 86       	std	Y+15, r14	; 0x0f
    36d2:	da 8a       	std	Y+18, r13	; 0x12
    36d4:	c9 8a       	std	Y+17, r12	; 0x11
    36d6:	bc 8a       	std	Y+20, r11	; 0x14
    36d8:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    36da:	29 89       	ldd	r18, Y+17	; 0x11
    36dc:	3a 89       	ldd	r19, Y+18	; 0x12
    36de:	8a 85       	ldd	r24, Y+10	; 0x0a
    36e0:	9b 85       	ldd	r25, Y+11	; 0x0b
    36e2:	b9 01       	movw	r22, r18
    36e4:	0e 94 e8 22 	call	0x45d0	; 0x45d0 <prvAllocateTCBAndStack>
    36e8:	9b 83       	std	Y+3, r25	; 0x03
    36ea:	8a 83       	std	Y+2, r24	; 0x02

	if( pxNewTCB != NULL )
    36ec:	8a 81       	ldd	r24, Y+2	; 0x02
    36ee:	9b 81       	ldd	r25, Y+3	; 0x03
    36f0:	89 2b       	or	r24, r25
    36f2:	09 f4       	brne	.+2      	; 0x36f6 <xTaskGenericCreate+0x5e>
    36f4:	91 c0       	rjmp	.+290    	; 0x3818 <xTaskGenericCreate+0x180>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    36f6:	8a 81       	ldd	r24, Y+2	; 0x02
    36f8:	9b 81       	ldd	r25, Y+3	; 0x03
    36fa:	fc 01       	movw	r30, r24
    36fc:	27 89       	ldd	r18, Z+23	; 0x17
    36fe:	30 8d       	ldd	r19, Z+24	; 0x18
    3700:	8a 85       	ldd	r24, Y+10	; 0x0a
    3702:	9b 85       	ldd	r25, Y+11	; 0x0b
    3704:	01 97       	sbiw	r24, 0x01	; 1
    3706:	82 0f       	add	r24, r18
    3708:	93 1f       	adc	r25, r19
    370a:	9d 83       	std	Y+5, r25	; 0x05
    370c:	8c 83       	std	Y+4, r24	; 0x04
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    370e:	4a 85       	ldd	r20, Y+10	; 0x0a
    3710:	5b 85       	ldd	r21, Y+11	; 0x0b
    3712:	2b 89       	ldd	r18, Y+19	; 0x13
    3714:	3c 89       	ldd	r19, Y+20	; 0x14
    3716:	68 85       	ldd	r22, Y+8	; 0x08
    3718:	79 85       	ldd	r23, Y+9	; 0x09
    371a:	8a 81       	ldd	r24, Y+2	; 0x02
    371c:	9b 81       	ldd	r25, Y+3	; 0x03
    371e:	8a 01       	movw	r16, r20
    3720:	4e 85       	ldd	r20, Y+14	; 0x0e
    3722:	0e 94 9d 21 	call	0x433a	; 0x433a <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3726:	4c 85       	ldd	r20, Y+12	; 0x0c
    3728:	5d 85       	ldd	r21, Y+13	; 0x0d
    372a:	2e 81       	ldd	r18, Y+6	; 0x06
    372c:	3f 81       	ldd	r19, Y+7	; 0x07
    372e:	8c 81       	ldd	r24, Y+4	; 0x04
    3730:	9d 81       	ldd	r25, Y+5	; 0x05
    3732:	b9 01       	movw	r22, r18
    3734:	0e 94 a4 11 	call	0x2348	; 0x2348 <pxPortInitialiseStack>
    3738:	9c 01       	movw	r18, r24
    373a:	8a 81       	ldd	r24, Y+2	; 0x02
    373c:	9b 81       	ldd	r25, Y+3	; 0x03
    373e:	fc 01       	movw	r30, r24
    3740:	31 83       	std	Z+1, r19	; 0x01
    3742:	20 83       	st	Z, r18
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    3744:	8f 85       	ldd	r24, Y+15	; 0x0f
    3746:	98 89       	ldd	r25, Y+16	; 0x10
    3748:	89 2b       	or	r24, r25
    374a:	39 f0       	breq	.+14     	; 0x375a <xTaskGenericCreate+0xc2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    374c:	8f 85       	ldd	r24, Y+15	; 0x0f
    374e:	98 89       	ldd	r25, Y+16	; 0x10
    3750:	2a 81       	ldd	r18, Y+2	; 0x02
    3752:	3b 81       	ldd	r19, Y+3	; 0x03
    3754:	fc 01       	movw	r30, r24
    3756:	31 83       	std	Z+1, r19	; 0x01
    3758:	20 83       	st	Z, r18
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    375a:	0f b6       	in	r0, 0x3f	; 63
    375c:	f8 94       	cli
    375e:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    3760:	80 91 4d 05 	lds	r24, 0x054D
    3764:	8f 5f       	subi	r24, 0xFF	; 255
    3766:	80 93 4d 05 	sts	0x054D, r24
			if( pxCurrentTCB == NULL )
    376a:	80 91 fe 04 	lds	r24, 0x04FE
    376e:	90 91 ff 04 	lds	r25, 0x04FF
    3772:	89 2b       	or	r24, r25
    3774:	69 f4       	brne	.+26     	; 0x3790 <xTaskGenericCreate+0xf8>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    3776:	8a 81       	ldd	r24, Y+2	; 0x02
    3778:	9b 81       	ldd	r25, Y+3	; 0x03
    377a:	90 93 ff 04 	sts	0x04FF, r25
    377e:	80 93 fe 04 	sts	0x04FE, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3782:	80 91 4d 05 	lds	r24, 0x054D
    3786:	81 30       	cpi	r24, 0x01	; 1
    3788:	b1 f4       	brne	.+44     	; 0x37b6 <xTaskGenericCreate+0x11e>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    378a:	0e 94 21 22 	call	0x4442	; 0x4442 <prvInitialiseTaskLists>
    378e:	13 c0       	rjmp	.+38     	; 0x37b6 <xTaskGenericCreate+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    3790:	80 91 51 05 	lds	r24, 0x0551
    3794:	88 23       	and	r24, r24
    3796:	79 f4       	brne	.+30     	; 0x37b6 <xTaskGenericCreate+0x11e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    3798:	80 91 fe 04 	lds	r24, 0x04FE
    379c:	90 91 ff 04 	lds	r25, 0x04FF
    37a0:	fc 01       	movw	r30, r24
    37a2:	96 89       	ldd	r25, Z+22	; 0x16
    37a4:	8e 85       	ldd	r24, Y+14	; 0x0e
    37a6:	89 17       	cp	r24, r25
    37a8:	30 f0       	brcs	.+12     	; 0x37b6 <xTaskGenericCreate+0x11e>
					{
						pxCurrentTCB = pxNewTCB;
    37aa:	8a 81       	ldd	r24, Y+2	; 0x02
    37ac:	9b 81       	ldd	r25, Y+3	; 0x03
    37ae:	90 93 ff 04 	sts	0x04FF, r25
    37b2:	80 93 fe 04 	sts	0x04FE, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    37b6:	80 91 55 05 	lds	r24, 0x0555
    37ba:	8f 5f       	subi	r24, 0xFF	; 255
    37bc:	80 93 55 05 	sts	0x0555, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    37c0:	8a 81       	ldd	r24, Y+2	; 0x02
    37c2:	9b 81       	ldd	r25, Y+3	; 0x03
    37c4:	fc 01       	movw	r30, r24
    37c6:	96 89       	ldd	r25, Z+22	; 0x16
    37c8:	80 91 50 05 	lds	r24, 0x0550
    37cc:	89 17       	cp	r24, r25
    37ce:	30 f4       	brcc	.+12     	; 0x37dc <xTaskGenericCreate+0x144>
    37d0:	8a 81       	ldd	r24, Y+2	; 0x02
    37d2:	9b 81       	ldd	r25, Y+3	; 0x03
    37d4:	fc 01       	movw	r30, r24
    37d6:	86 89       	ldd	r24, Z+22	; 0x16
    37d8:	80 93 50 05 	sts	0x0550, r24
    37dc:	8a 81       	ldd	r24, Y+2	; 0x02
    37de:	9b 81       	ldd	r25, Y+3	; 0x03
    37e0:	ac 01       	movw	r20, r24
    37e2:	4e 5f       	subi	r20, 0xFE	; 254
    37e4:	5f 4f       	sbci	r21, 0xFF	; 255
    37e6:	8a 81       	ldd	r24, Y+2	; 0x02
    37e8:	9b 81       	ldd	r25, Y+3	; 0x03
    37ea:	fc 01       	movw	r30, r24
    37ec:	86 89       	ldd	r24, Z+22	; 0x16
    37ee:	28 2f       	mov	r18, r24
    37f0:	30 e0       	ldi	r19, 0x00	; 0
    37f2:	c9 01       	movw	r24, r18
    37f4:	88 0f       	add	r24, r24
    37f6:	99 1f       	adc	r25, r25
    37f8:	88 0f       	add	r24, r24
    37fa:	99 1f       	adc	r25, r25
    37fc:	88 0f       	add	r24, r24
    37fe:	99 1f       	adc	r25, r25
    3800:	82 0f       	add	r24, r18
    3802:	93 1f       	adc	r25, r19
    3804:	80 50       	subi	r24, 0x00	; 0
    3806:	9b 4f       	sbci	r25, 0xFB	; 251
    3808:	ba 01       	movw	r22, r20
    380a:	0e 94 88 10 	call	0x2110	; 0x2110 <vListInsertEnd>

			xReturn = pdPASS;
    380e:	81 e0       	ldi	r24, 0x01	; 1
    3810:	89 83       	std	Y+1, r24	; 0x01
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    3812:	0f 90       	pop	r0
    3814:	0f be       	out	0x3f, r0	; 63
    3816:	02 c0       	rjmp	.+4      	; 0x381c <xTaskGenericCreate+0x184>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3818:	8f ef       	ldi	r24, 0xFF	; 255
    381a:	89 83       	std	Y+1, r24	; 0x01
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    381c:	89 81       	ldd	r24, Y+1	; 0x01
    381e:	81 30       	cpi	r24, 0x01	; 1
    3820:	79 f4       	brne	.+30     	; 0x3840 <xTaskGenericCreate+0x1a8>
	{
		if( xSchedulerRunning != pdFALSE )
    3822:	80 91 51 05 	lds	r24, 0x0551
    3826:	88 23       	and	r24, r24
    3828:	59 f0       	breq	.+22     	; 0x3840 <xTaskGenericCreate+0x1a8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    382a:	80 91 fe 04 	lds	r24, 0x04FE
    382e:	90 91 ff 04 	lds	r25, 0x04FF
    3832:	fc 01       	movw	r30, r24
    3834:	96 89       	ldd	r25, Z+22	; 0x16
    3836:	8e 85       	ldd	r24, Y+14	; 0x0e
    3838:	98 17       	cp	r25, r24
    383a:	10 f4       	brcc	.+4      	; 0x3840 <xTaskGenericCreate+0x1a8>
			{
				taskYIELD_IF_USING_PREEMPTION();
    383c:	0e 94 89 13 	call	0x2712	; 0x2712 <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    3840:	89 81       	ldd	r24, Y+1	; 0x01
}
    3842:	64 96       	adiw	r28, 0x14	; 20
    3844:	0f b6       	in	r0, 0x3f	; 63
    3846:	f8 94       	cli
    3848:	de bf       	out	0x3e, r29	; 62
    384a:	0f be       	out	0x3f, r0	; 63
    384c:	cd bf       	out	0x3d, r28	; 61
    384e:	df 91       	pop	r29
    3850:	cf 91       	pop	r28
    3852:	1f 91       	pop	r17
    3854:	0f 91       	pop	r16
    3856:	ff 90       	pop	r15
    3858:	ef 90       	pop	r14
    385a:	df 90       	pop	r13
    385c:	cf 90       	pop	r12
    385e:	bf 90       	pop	r11
    3860:	af 90       	pop	r10
    3862:	08 95       	ret

00003864 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    3864:	cf 93       	push	r28
    3866:	df 93       	push	r29
    3868:	00 d0       	rcall	.+0      	; 0x386a <vTaskDelete+0x6>
    386a:	00 d0       	rcall	.+0      	; 0x386c <vTaskDelete+0x8>
    386c:	cd b7       	in	r28, 0x3d	; 61
    386e:	de b7       	in	r29, 0x3e	; 62
    3870:	9c 83       	std	Y+4, r25	; 0x04
    3872:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3874:	0f b6       	in	r0, 0x3f	; 63
    3876:	f8 94       	cli
    3878:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    387a:	8b 81       	ldd	r24, Y+3	; 0x03
    387c:	9c 81       	ldd	r25, Y+4	; 0x04
    387e:	89 2b       	or	r24, r25
    3880:	29 f4       	brne	.+10     	; 0x388c <vTaskDelete+0x28>
    3882:	80 91 fe 04 	lds	r24, 0x04FE
    3886:	90 91 ff 04 	lds	r25, 0x04FF
    388a:	02 c0       	rjmp	.+4      	; 0x3890 <vTaskDelete+0x2c>
    388c:	8b 81       	ldd	r24, Y+3	; 0x03
    388e:	9c 81       	ldd	r25, Y+4	; 0x04
    3890:	9a 83       	std	Y+2, r25	; 0x02
    3892:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3894:	89 81       	ldd	r24, Y+1	; 0x01
    3896:	9a 81       	ldd	r25, Y+2	; 0x02
    3898:	02 96       	adiw	r24, 0x02	; 2
    389a:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    389e:	89 81       	ldd	r24, Y+1	; 0x01
    38a0:	9a 81       	ldd	r25, Y+2	; 0x02
    38a2:	fc 01       	movw	r30, r24
    38a4:	84 89       	ldd	r24, Z+20	; 0x14
    38a6:	95 89       	ldd	r25, Z+21	; 0x15
    38a8:	89 2b       	or	r24, r25
    38aa:	29 f0       	breq	.+10     	; 0x38b6 <vTaskDelete+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    38ac:	89 81       	ldd	r24, Y+1	; 0x01
    38ae:	9a 81       	ldd	r25, Y+2	; 0x02
    38b0:	0c 96       	adiw	r24, 0x0c	; 12
    38b2:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    38b6:	89 81       	ldd	r24, Y+1	; 0x01
    38b8:	9a 81       	ldd	r25, Y+2	; 0x02
    38ba:	02 96       	adiw	r24, 0x02	; 2
    38bc:	bc 01       	movw	r22, r24
    38be:	83 e4       	ldi	r24, 0x43	; 67
    38c0:	95 e0       	ldi	r25, 0x05	; 5
    38c2:	0e 94 88 10 	call	0x2110	; 0x2110 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    38c6:	80 91 4c 05 	lds	r24, 0x054C
    38ca:	8f 5f       	subi	r24, 0xFF	; 255
    38cc:	80 93 4c 05 	sts	0x054C, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    38d0:	80 91 55 05 	lds	r24, 0x0555
    38d4:	8f 5f       	subi	r24, 0xFF	; 255
    38d6:	80 93 55 05 	sts	0x0555, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    38da:	0f 90       	pop	r0
    38dc:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    38de:	80 91 51 05 	lds	r24, 0x0551
    38e2:	88 23       	and	r24, r24
    38e4:	99 f0       	breq	.+38     	; 0x390c <vTaskDelete+0xa8>
		{
			if( pxTCB == pxCurrentTCB )
    38e6:	80 91 fe 04 	lds	r24, 0x04FE
    38ea:	90 91 ff 04 	lds	r25, 0x04FF
    38ee:	29 81       	ldd	r18, Y+1	; 0x01
    38f0:	3a 81       	ldd	r19, Y+2	; 0x02
    38f2:	28 17       	cp	r18, r24
    38f4:	39 07       	cpc	r19, r25
    38f6:	19 f4       	brne	.+6      	; 0x38fe <vTaskDelete+0x9a>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    38f8:	0e 94 89 13 	call	0x2712	; 0x2712 <vPortYield>
    38fc:	07 c0       	rjmp	.+14     	; 0x390c <vTaskDelete+0xa8>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    38fe:	0f b6       	in	r0, 0x3f	; 63
    3900:	f8 94       	cli
    3902:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    3904:	0e 94 42 23 	call	0x4684	; 0x4684 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    3908:	0f 90       	pop	r0
    390a:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    390c:	0f 90       	pop	r0
    390e:	0f 90       	pop	r0
    3910:	0f 90       	pop	r0
    3912:	0f 90       	pop	r0
    3914:	df 91       	pop	r29
    3916:	cf 91       	pop	r28
    3918:	08 95       	ret

0000391a <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    391a:	cf 93       	push	r28
    391c:	df 93       	push	r29
    391e:	cd b7       	in	r28, 0x3d	; 61
    3920:	de b7       	in	r29, 0x3e	; 62
    3922:	2a 97       	sbiw	r28, 0x0a	; 10
    3924:	0f b6       	in	r0, 0x3f	; 63
    3926:	f8 94       	cli
    3928:	de bf       	out	0x3e, r29	; 62
    392a:	0f be       	out	0x3f, r0	; 63
    392c:	cd bf       	out	0x3d, r28	; 61
    392e:	98 87       	std	Y+8, r25	; 0x08
    3930:	8f 83       	std	Y+7, r24	; 0x07
    3932:	7a 87       	std	Y+10, r23	; 0x0a
    3934:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    3936:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    3938:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    393c:	80 91 4e 05 	lds	r24, 0x054E
    3940:	90 91 4f 05 	lds	r25, 0x054F
    3944:	9b 83       	std	Y+3, r25	; 0x03
    3946:	8a 83       	std	Y+2, r24	; 0x02

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3948:	8f 81       	ldd	r24, Y+7	; 0x07
    394a:	98 85       	ldd	r25, Y+8	; 0x08
    394c:	fc 01       	movw	r30, r24
    394e:	20 81       	ld	r18, Z
    3950:	31 81       	ldd	r19, Z+1	; 0x01
    3952:	89 85       	ldd	r24, Y+9	; 0x09
    3954:	9a 85       	ldd	r25, Y+10	; 0x0a
    3956:	82 0f       	add	r24, r18
    3958:	93 1f       	adc	r25, r19
    395a:	9d 83       	std	Y+5, r25	; 0x05
    395c:	8c 83       	std	Y+4, r24	; 0x04

			if( xConstTickCount < *pxPreviousWakeTime )
    395e:	8f 81       	ldd	r24, Y+7	; 0x07
    3960:	98 85       	ldd	r25, Y+8	; 0x08
    3962:	fc 01       	movw	r30, r24
    3964:	20 81       	ld	r18, Z
    3966:	31 81       	ldd	r19, Z+1	; 0x01
    3968:	8a 81       	ldd	r24, Y+2	; 0x02
    396a:	9b 81       	ldd	r25, Y+3	; 0x03
    396c:	82 17       	cp	r24, r18
    396e:	93 07       	cpc	r25, r19
    3970:	a0 f4       	brcc	.+40     	; 0x399a <vTaskDelayUntil+0x80>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    3972:	8f 81       	ldd	r24, Y+7	; 0x07
    3974:	98 85       	ldd	r25, Y+8	; 0x08
    3976:	fc 01       	movw	r30, r24
    3978:	20 81       	ld	r18, Z
    397a:	31 81       	ldd	r19, Z+1	; 0x01
    397c:	8c 81       	ldd	r24, Y+4	; 0x04
    397e:	9d 81       	ldd	r25, Y+5	; 0x05
    3980:	82 17       	cp	r24, r18
    3982:	93 07       	cpc	r25, r19
    3984:	e8 f4       	brcc	.+58     	; 0x39c0 <vTaskDelayUntil+0xa6>
    3986:	2c 81       	ldd	r18, Y+4	; 0x04
    3988:	3d 81       	ldd	r19, Y+5	; 0x05
    398a:	8a 81       	ldd	r24, Y+2	; 0x02
    398c:	9b 81       	ldd	r25, Y+3	; 0x03
    398e:	82 17       	cp	r24, r18
    3990:	93 07       	cpc	r25, r19
    3992:	b0 f4       	brcc	.+44     	; 0x39c0 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    3994:	81 e0       	ldi	r24, 0x01	; 1
    3996:	89 83       	std	Y+1, r24	; 0x01
    3998:	13 c0       	rjmp	.+38     	; 0x39c0 <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    399a:	8f 81       	ldd	r24, Y+7	; 0x07
    399c:	98 85       	ldd	r25, Y+8	; 0x08
    399e:	fc 01       	movw	r30, r24
    39a0:	20 81       	ld	r18, Z
    39a2:	31 81       	ldd	r19, Z+1	; 0x01
    39a4:	8c 81       	ldd	r24, Y+4	; 0x04
    39a6:	9d 81       	ldd	r25, Y+5	; 0x05
    39a8:	82 17       	cp	r24, r18
    39aa:	93 07       	cpc	r25, r19
    39ac:	38 f0       	brcs	.+14     	; 0x39bc <vTaskDelayUntil+0xa2>
    39ae:	2c 81       	ldd	r18, Y+4	; 0x04
    39b0:	3d 81       	ldd	r19, Y+5	; 0x05
    39b2:	8a 81       	ldd	r24, Y+2	; 0x02
    39b4:	9b 81       	ldd	r25, Y+3	; 0x03
    39b6:	82 17       	cp	r24, r18
    39b8:	93 07       	cpc	r25, r19
    39ba:	10 f4       	brcc	.+4      	; 0x39c0 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    39bc:	81 e0       	ldi	r24, 0x01	; 1
    39be:	89 83       	std	Y+1, r24	; 0x01
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    39c0:	8f 81       	ldd	r24, Y+7	; 0x07
    39c2:	98 85       	ldd	r25, Y+8	; 0x08
    39c4:	2c 81       	ldd	r18, Y+4	; 0x04
    39c6:	3d 81       	ldd	r19, Y+5	; 0x05
    39c8:	fc 01       	movw	r30, r24
    39ca:	31 83       	std	Z+1, r19	; 0x01
    39cc:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
    39ce:	89 81       	ldd	r24, Y+1	; 0x01
    39d0:	88 23       	and	r24, r24
    39d2:	59 f0       	breq	.+22     	; 0x39ea <vTaskDelayUntil+0xd0>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    39d4:	80 91 fe 04 	lds	r24, 0x04FE
    39d8:	90 91 ff 04 	lds	r25, 0x04FF
    39dc:	02 96       	adiw	r24, 0x02	; 2
    39de:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    39e2:	8c 81       	ldd	r24, Y+4	; 0x04
    39e4:	9d 81       	ldd	r25, Y+5	; 0x05
    39e6:	0e 94 9e 22 	call	0x453c	; 0x453c <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    39ea:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
    39ee:	8e 83       	std	Y+6, r24	; 0x06

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    39f0:	8e 81       	ldd	r24, Y+6	; 0x06
    39f2:	88 23       	and	r24, r24
    39f4:	11 f4       	brne	.+4      	; 0x39fa <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
    39f6:	0e 94 89 13 	call	0x2712	; 0x2712 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    39fa:	2a 96       	adiw	r28, 0x0a	; 10
    39fc:	0f b6       	in	r0, 0x3f	; 63
    39fe:	f8 94       	cli
    3a00:	de bf       	out	0x3e, r29	; 62
    3a02:	0f be       	out	0x3f, r0	; 63
    3a04:	cd bf       	out	0x3d, r28	; 61
    3a06:	df 91       	pop	r29
    3a08:	cf 91       	pop	r28
    3a0a:	08 95       	ret

00003a0c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    3a0c:	cf 93       	push	r28
    3a0e:	df 93       	push	r29
    3a10:	00 d0       	rcall	.+0      	; 0x3a12 <vTaskDelay+0x6>
    3a12:	00 d0       	rcall	.+0      	; 0x3a14 <vTaskDelay+0x8>
    3a14:	1f 92       	push	r1
    3a16:	cd b7       	in	r28, 0x3d	; 61
    3a18:	de b7       	in	r29, 0x3e	; 62
    3a1a:	9d 83       	std	Y+5, r25	; 0x05
    3a1c:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    3a1e:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3a20:	8c 81       	ldd	r24, Y+4	; 0x04
    3a22:	9d 81       	ldd	r25, Y+5	; 0x05
    3a24:	89 2b       	or	r24, r25
    3a26:	d1 f0       	breq	.+52     	; 0x3a5c <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    3a28:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    3a2c:	20 91 4e 05 	lds	r18, 0x054E
    3a30:	30 91 4f 05 	lds	r19, 0x054F
    3a34:	8c 81       	ldd	r24, Y+4	; 0x04
    3a36:	9d 81       	ldd	r25, Y+5	; 0x05
    3a38:	82 0f       	add	r24, r18
    3a3a:	93 1f       	adc	r25, r19
    3a3c:	9b 83       	std	Y+3, r25	; 0x03
    3a3e:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3a40:	80 91 fe 04 	lds	r24, 0x04FE
    3a44:	90 91 ff 04 	lds	r25, 0x04FF
    3a48:	02 96       	adiw	r24, 0x02	; 2
    3a4a:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3a4e:	8a 81       	ldd	r24, Y+2	; 0x02
    3a50:	9b 81       	ldd	r25, Y+3	; 0x03
    3a52:	0e 94 9e 22 	call	0x453c	; 0x453c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3a56:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>
    3a5a:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3a5c:	89 81       	ldd	r24, Y+1	; 0x01
    3a5e:	88 23       	and	r24, r24
    3a60:	11 f4       	brne	.+4      	; 0x3a66 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    3a62:	0e 94 89 13 	call	0x2712	; 0x2712 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3a66:	0f 90       	pop	r0
    3a68:	0f 90       	pop	r0
    3a6a:	0f 90       	pop	r0
    3a6c:	0f 90       	pop	r0
    3a6e:	0f 90       	pop	r0
    3a70:	df 91       	pop	r29
    3a72:	cf 91       	pop	r28
    3a74:	08 95       	ret

00003a76 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3a76:	af 92       	push	r10
    3a78:	bf 92       	push	r11
    3a7a:	cf 92       	push	r12
    3a7c:	df 92       	push	r13
    3a7e:	ef 92       	push	r14
    3a80:	ff 92       	push	r15
    3a82:	0f 93       	push	r16
    3a84:	cf 93       	push	r28
    3a86:	df 93       	push	r29
    3a88:	1f 92       	push	r1
    3a8a:	cd b7       	in	r28, 0x3d	; 61
    3a8c:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    3a8e:	a1 2c       	mov	r10, r1
    3a90:	b1 2c       	mov	r11, r1
    3a92:	c1 2c       	mov	r12, r1
    3a94:	d1 2c       	mov	r13, r1
    3a96:	e1 2c       	mov	r14, r1
    3a98:	f1 2c       	mov	r15, r1
    3a9a:	00 e0       	ldi	r16, 0x00	; 0
    3a9c:	20 e0       	ldi	r18, 0x00	; 0
    3a9e:	30 e0       	ldi	r19, 0x00	; 0
    3aa0:	44 e6       	ldi	r20, 0x64	; 100
    3aa2:	50 e0       	ldi	r21, 0x00	; 0
    3aa4:	6d e0       	ldi	r22, 0x0D	; 13
    3aa6:	71 e0       	ldi	r23, 0x01	; 1
    3aa8:	8d e8       	ldi	r24, 0x8D	; 141
    3aaa:	91 e2       	ldi	r25, 0x21	; 33
    3aac:	0e 94 4c 1b 	call	0x3698	; 0x3698 <xTaskGenericCreate>
    3ab0:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    3ab2:	89 81       	ldd	r24, Y+1	; 0x01
    3ab4:	81 30       	cpi	r24, 0x01	; 1
    3ab6:	81 f4       	brne	.+32     	; 0x3ad8 <vTaskStartScheduler+0x62>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    3ab8:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    3aba:	8f ef       	ldi	r24, 0xFF	; 255
    3abc:	9f ef       	ldi	r25, 0xFF	; 255
    3abe:	90 93 57 05 	sts	0x0557, r25
    3ac2:	80 93 56 05 	sts	0x0556, r24
		xSchedulerRunning = pdTRUE;
    3ac6:	81 e0       	ldi	r24, 0x01	; 1
    3ac8:	80 93 51 05 	sts	0x0551, r24
		xTickCount = ( TickType_t ) 0U;
    3acc:	10 92 4f 05 	sts	0x054F, r1
    3ad0:	10 92 4e 05 	sts	0x054E, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    3ad4:	0e 94 4d 13 	call	0x269a	; 0x269a <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    3ad8:	0f 90       	pop	r0
    3ada:	df 91       	pop	r29
    3adc:	cf 91       	pop	r28
    3ade:	0f 91       	pop	r16
    3ae0:	ff 90       	pop	r15
    3ae2:	ef 90       	pop	r14
    3ae4:	df 90       	pop	r13
    3ae6:	cf 90       	pop	r12
    3ae8:	bf 90       	pop	r11
    3aea:	af 90       	pop	r10
    3aec:	08 95       	ret

00003aee <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3aee:	cf 93       	push	r28
    3af0:	df 93       	push	r29
    3af2:	cd b7       	in	r28, 0x3d	; 61
    3af4:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    3af6:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    3af8:	10 92 51 05 	sts	0x0551, r1
	vPortEndScheduler();
    3afc:	0e 94 82 13 	call	0x2704	; 0x2704 <vPortEndScheduler>
}
    3b00:	df 91       	pop	r29
    3b02:	cf 91       	pop	r28
    3b04:	08 95       	ret

00003b06 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3b06:	cf 93       	push	r28
    3b08:	df 93       	push	r29
    3b0a:	cd b7       	in	r28, 0x3d	; 61
    3b0c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    3b0e:	80 91 58 05 	lds	r24, 0x0558
    3b12:	8f 5f       	subi	r24, 0xFF	; 255
    3b14:	80 93 58 05 	sts	0x0558, r24
}
    3b18:	df 91       	pop	r29
    3b1a:	cf 91       	pop	r28
    3b1c:	08 95       	ret

00003b1e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3b1e:	cf 93       	push	r28
    3b20:	df 93       	push	r29
    3b22:	00 d0       	rcall	.+0      	; 0x3b24 <xTaskResumeAll+0x6>
    3b24:	1f 92       	push	r1
    3b26:	cd b7       	in	r28, 0x3d	; 61
    3b28:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    3b2a:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    3b2c:	0f b6       	in	r0, 0x3f	; 63
    3b2e:	f8 94       	cli
    3b30:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    3b32:	80 91 58 05 	lds	r24, 0x0558
    3b36:	81 50       	subi	r24, 0x01	; 1
    3b38:	80 93 58 05 	sts	0x0558, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3b3c:	80 91 58 05 	lds	r24, 0x0558
    3b40:	88 23       	and	r24, r24
    3b42:	09 f0       	breq	.+2      	; 0x3b46 <xTaskResumeAll+0x28>
    3b44:	71 c0       	rjmp	.+226    	; 0x3c28 <xTaskResumeAll+0x10a>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3b46:	80 91 4d 05 	lds	r24, 0x054D
    3b4a:	88 23       	and	r24, r24
    3b4c:	09 f4       	brne	.+2      	; 0x3b50 <xTaskResumeAll+0x32>
    3b4e:	6c c0       	rjmp	.+216    	; 0x3c28 <xTaskResumeAll+0x10a>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3b50:	49 c0       	rjmp	.+146    	; 0x3be4 <xTaskResumeAll+0xc6>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    3b52:	80 91 3f 05 	lds	r24, 0x053F
    3b56:	90 91 40 05 	lds	r25, 0x0540
    3b5a:	fc 01       	movw	r30, r24
    3b5c:	86 81       	ldd	r24, Z+6	; 0x06
    3b5e:	97 81       	ldd	r25, Z+7	; 0x07
    3b60:	9b 83       	std	Y+3, r25	; 0x03
    3b62:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3b64:	8a 81       	ldd	r24, Y+2	; 0x02
    3b66:	9b 81       	ldd	r25, Y+3	; 0x03
    3b68:	0c 96       	adiw	r24, 0x0c	; 12
    3b6a:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3b6e:	8a 81       	ldd	r24, Y+2	; 0x02
    3b70:	9b 81       	ldd	r25, Y+3	; 0x03
    3b72:	02 96       	adiw	r24, 0x02	; 2
    3b74:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3b78:	8a 81       	ldd	r24, Y+2	; 0x02
    3b7a:	9b 81       	ldd	r25, Y+3	; 0x03
    3b7c:	fc 01       	movw	r30, r24
    3b7e:	96 89       	ldd	r25, Z+22	; 0x16
    3b80:	80 91 50 05 	lds	r24, 0x0550
    3b84:	89 17       	cp	r24, r25
    3b86:	30 f4       	brcc	.+12     	; 0x3b94 <xTaskResumeAll+0x76>
    3b88:	8a 81       	ldd	r24, Y+2	; 0x02
    3b8a:	9b 81       	ldd	r25, Y+3	; 0x03
    3b8c:	fc 01       	movw	r30, r24
    3b8e:	86 89       	ldd	r24, Z+22	; 0x16
    3b90:	80 93 50 05 	sts	0x0550, r24
    3b94:	8a 81       	ldd	r24, Y+2	; 0x02
    3b96:	9b 81       	ldd	r25, Y+3	; 0x03
    3b98:	ac 01       	movw	r20, r24
    3b9a:	4e 5f       	subi	r20, 0xFE	; 254
    3b9c:	5f 4f       	sbci	r21, 0xFF	; 255
    3b9e:	8a 81       	ldd	r24, Y+2	; 0x02
    3ba0:	9b 81       	ldd	r25, Y+3	; 0x03
    3ba2:	fc 01       	movw	r30, r24
    3ba4:	86 89       	ldd	r24, Z+22	; 0x16
    3ba6:	28 2f       	mov	r18, r24
    3ba8:	30 e0       	ldi	r19, 0x00	; 0
    3baa:	c9 01       	movw	r24, r18
    3bac:	88 0f       	add	r24, r24
    3bae:	99 1f       	adc	r25, r25
    3bb0:	88 0f       	add	r24, r24
    3bb2:	99 1f       	adc	r25, r25
    3bb4:	88 0f       	add	r24, r24
    3bb6:	99 1f       	adc	r25, r25
    3bb8:	82 0f       	add	r24, r18
    3bba:	93 1f       	adc	r25, r19
    3bbc:	80 50       	subi	r24, 0x00	; 0
    3bbe:	9b 4f       	sbci	r25, 0xFB	; 251
    3bc0:	ba 01       	movw	r22, r20
    3bc2:	0e 94 88 10 	call	0x2110	; 0x2110 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3bc6:	8a 81       	ldd	r24, Y+2	; 0x02
    3bc8:	9b 81       	ldd	r25, Y+3	; 0x03
    3bca:	fc 01       	movw	r30, r24
    3bcc:	26 89       	ldd	r18, Z+22	; 0x16
    3bce:	80 91 fe 04 	lds	r24, 0x04FE
    3bd2:	90 91 ff 04 	lds	r25, 0x04FF
    3bd6:	fc 01       	movw	r30, r24
    3bd8:	86 89       	ldd	r24, Z+22	; 0x16
    3bda:	28 17       	cp	r18, r24
    3bdc:	18 f0       	brcs	.+6      	; 0x3be4 <xTaskResumeAll+0xc6>
					{
						xYieldPending = pdTRUE;
    3bde:	81 e0       	ldi	r24, 0x01	; 1
    3be0:	80 93 53 05 	sts	0x0553, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3be4:	80 91 3a 05 	lds	r24, 0x053A
    3be8:	88 23       	and	r24, r24
    3bea:	09 f0       	breq	.+2      	; 0x3bee <xTaskResumeAll+0xd0>
    3bec:	b2 cf       	rjmp	.-156    	; 0x3b52 <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    3bee:	80 91 52 05 	lds	r24, 0x0552
    3bf2:	88 23       	and	r24, r24
    3bf4:	89 f0       	breq	.+34     	; 0x3c18 <xTaskResumeAll+0xfa>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    3bf6:	0c c0       	rjmp	.+24     	; 0x3c10 <xTaskResumeAll+0xf2>
					{
						if( xTaskIncrementTick() != pdFALSE )
    3bf8:	0e 94 52 1e 	call	0x3ca4	; 0x3ca4 <xTaskIncrementTick>
    3bfc:	88 23       	and	r24, r24
    3bfe:	19 f0       	breq	.+6      	; 0x3c06 <xTaskResumeAll+0xe8>
						{
							xYieldPending = pdTRUE;
    3c00:	81 e0       	ldi	r24, 0x01	; 1
    3c02:	80 93 53 05 	sts	0x0553, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    3c06:	80 91 52 05 	lds	r24, 0x0552
    3c0a:	81 50       	subi	r24, 0x01	; 1
    3c0c:	80 93 52 05 	sts	0x0552, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    3c10:	80 91 52 05 	lds	r24, 0x0552
    3c14:	88 23       	and	r24, r24
    3c16:	81 f7       	brne	.-32     	; 0x3bf8 <xTaskResumeAll+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    3c18:	80 91 53 05 	lds	r24, 0x0553
    3c1c:	81 30       	cpi	r24, 0x01	; 1
    3c1e:	21 f4       	brne	.+8      	; 0x3c28 <xTaskResumeAll+0x10a>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    3c20:	81 e0       	ldi	r24, 0x01	; 1
    3c22:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    3c24:	0e 94 89 13 	call	0x2712	; 0x2712 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    3c28:	0f 90       	pop	r0
    3c2a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3c2c:	89 81       	ldd	r24, Y+1	; 0x01
}
    3c2e:	0f 90       	pop	r0
    3c30:	0f 90       	pop	r0
    3c32:	0f 90       	pop	r0
    3c34:	df 91       	pop	r29
    3c36:	cf 91       	pop	r28
    3c38:	08 95       	ret

00003c3a <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3c3a:	cf 93       	push	r28
    3c3c:	df 93       	push	r29
    3c3e:	00 d0       	rcall	.+0      	; 0x3c40 <xTaskGetTickCount+0x6>
    3c40:	cd b7       	in	r28, 0x3d	; 61
    3c42:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    3c44:	0f b6       	in	r0, 0x3f	; 63
    3c46:	f8 94       	cli
    3c48:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3c4a:	80 91 4e 05 	lds	r24, 0x054E
    3c4e:	90 91 4f 05 	lds	r25, 0x054F
    3c52:	9a 83       	std	Y+2, r25	; 0x02
    3c54:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    3c56:	0f 90       	pop	r0
    3c58:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3c5a:	89 81       	ldd	r24, Y+1	; 0x01
    3c5c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3c5e:	0f 90       	pop	r0
    3c60:	0f 90       	pop	r0
    3c62:	df 91       	pop	r29
    3c64:	cf 91       	pop	r28
    3c66:	08 95       	ret

00003c68 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3c68:	cf 93       	push	r28
    3c6a:	df 93       	push	r29
    3c6c:	00 d0       	rcall	.+0      	; 0x3c6e <xTaskGetTickCountFromISR+0x6>
    3c6e:	1f 92       	push	r1
    3c70:	cd b7       	in	r28, 0x3d	; 61
    3c72:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    3c74:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    3c76:	80 91 4e 05 	lds	r24, 0x054E
    3c7a:	90 91 4f 05 	lds	r25, 0x054F
    3c7e:	9b 83       	std	Y+3, r25	; 0x03
    3c80:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3c82:	8a 81       	ldd	r24, Y+2	; 0x02
    3c84:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3c86:	0f 90       	pop	r0
    3c88:	0f 90       	pop	r0
    3c8a:	0f 90       	pop	r0
    3c8c:	df 91       	pop	r29
    3c8e:	cf 91       	pop	r28
    3c90:	08 95       	ret

00003c92 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3c92:	cf 93       	push	r28
    3c94:	df 93       	push	r29
    3c96:	cd b7       	in	r28, 0x3d	; 61
    3c98:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    3c9a:	80 91 4d 05 	lds	r24, 0x054D
}
    3c9e:	df 91       	pop	r29
    3ca0:	cf 91       	pop	r28
    3ca2:	08 95       	ret

00003ca4 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3ca4:	cf 93       	push	r28
    3ca6:	df 93       	push	r29
    3ca8:	cd b7       	in	r28, 0x3d	; 61
    3caa:	de b7       	in	r29, 0x3e	; 62
    3cac:	29 97       	sbiw	r28, 0x09	; 9
    3cae:	0f b6       	in	r0, 0x3f	; 63
    3cb0:	f8 94       	cli
    3cb2:	de bf       	out	0x3e, r29	; 62
    3cb4:	0f be       	out	0x3f, r0	; 63
    3cb6:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    3cb8:	19 82       	std	Y+1, r1	; 0x01

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3cba:	80 91 58 05 	lds	r24, 0x0558
    3cbe:	88 23       	and	r24, r24
    3cc0:	09 f0       	breq	.+2      	; 0x3cc4 <xTaskIncrementTick+0x20>
    3cc2:	c9 c0       	rjmp	.+402    	; 0x3e56 <xTaskIncrementTick+0x1b2>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    3cc4:	80 91 4e 05 	lds	r24, 0x054E
    3cc8:	90 91 4f 05 	lds	r25, 0x054F
    3ccc:	01 96       	adiw	r24, 0x01	; 1
    3cce:	90 93 4f 05 	sts	0x054F, r25
    3cd2:	80 93 4e 05 	sts	0x054E, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    3cd6:	80 91 4e 05 	lds	r24, 0x054E
    3cda:	90 91 4f 05 	lds	r25, 0x054F
    3cde:	9b 83       	std	Y+3, r25	; 0x03
    3ce0:	8a 83       	std	Y+2, r24	; 0x02

			if( xConstTickCount == ( TickType_t ) 0U )
    3ce2:	8a 81       	ldd	r24, Y+2	; 0x02
    3ce4:	9b 81       	ldd	r25, Y+3	; 0x03
    3ce6:	89 2b       	or	r24, r25
    3ce8:	d9 f4       	brne	.+54     	; 0x3d20 <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    3cea:	80 91 36 05 	lds	r24, 0x0536
    3cee:	90 91 37 05 	lds	r25, 0x0537
    3cf2:	9d 83       	std	Y+5, r25	; 0x05
    3cf4:	8c 83       	std	Y+4, r24	; 0x04
    3cf6:	80 91 38 05 	lds	r24, 0x0538
    3cfa:	90 91 39 05 	lds	r25, 0x0539
    3cfe:	90 93 37 05 	sts	0x0537, r25
    3d02:	80 93 36 05 	sts	0x0536, r24
    3d06:	8c 81       	ldd	r24, Y+4	; 0x04
    3d08:	9d 81       	ldd	r25, Y+5	; 0x05
    3d0a:	90 93 39 05 	sts	0x0539, r25
    3d0e:	80 93 38 05 	sts	0x0538, r24
    3d12:	80 91 54 05 	lds	r24, 0x0554
    3d16:	8f 5f       	subi	r24, 0xFF	; 255
    3d18:	80 93 54 05 	sts	0x0554, r24
    3d1c:	0e 94 42 23 	call	0x4684	; 0x4684 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    3d20:	80 91 56 05 	lds	r24, 0x0556
    3d24:	90 91 57 05 	lds	r25, 0x0557
    3d28:	2a 81       	ldd	r18, Y+2	; 0x02
    3d2a:	3b 81       	ldd	r19, Y+3	; 0x03
    3d2c:	28 17       	cp	r18, r24
    3d2e:	39 07       	cpc	r19, r25
    3d30:	08 f4       	brcc	.+2      	; 0x3d34 <xTaskIncrementTick+0x90>
    3d32:	77 c0       	rjmp	.+238    	; 0x3e22 <xTaskIncrementTick+0x17e>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3d34:	80 91 36 05 	lds	r24, 0x0536
    3d38:	90 91 37 05 	lds	r25, 0x0537
    3d3c:	fc 01       	movw	r30, r24
    3d3e:	80 81       	ld	r24, Z
    3d40:	88 23       	and	r24, r24
    3d42:	39 f4       	brne	.+14     	; 0x3d52 <xTaskIncrementTick+0xae>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    3d44:	8f ef       	ldi	r24, 0xFF	; 255
    3d46:	9f ef       	ldi	r25, 0xFF	; 255
    3d48:	90 93 57 05 	sts	0x0557, r25
    3d4c:	80 93 56 05 	sts	0x0556, r24
						break;
    3d50:	68 c0       	rjmp	.+208    	; 0x3e22 <xTaskIncrementTick+0x17e>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    3d52:	80 91 36 05 	lds	r24, 0x0536
    3d56:	90 91 37 05 	lds	r25, 0x0537
    3d5a:	fc 01       	movw	r30, r24
    3d5c:	85 81       	ldd	r24, Z+5	; 0x05
    3d5e:	96 81       	ldd	r25, Z+6	; 0x06
    3d60:	fc 01       	movw	r30, r24
    3d62:	86 81       	ldd	r24, Z+6	; 0x06
    3d64:	97 81       	ldd	r25, Z+7	; 0x07
    3d66:	9f 83       	std	Y+7, r25	; 0x07
    3d68:	8e 83       	std	Y+6, r24	; 0x06
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    3d6a:	8e 81       	ldd	r24, Y+6	; 0x06
    3d6c:	9f 81       	ldd	r25, Y+7	; 0x07
    3d6e:	fc 01       	movw	r30, r24
    3d70:	82 81       	ldd	r24, Z+2	; 0x02
    3d72:	93 81       	ldd	r25, Z+3	; 0x03
    3d74:	99 87       	std	Y+9, r25	; 0x09
    3d76:	88 87       	std	Y+8, r24	; 0x08

						if( xConstTickCount < xItemValue )
    3d78:	2a 81       	ldd	r18, Y+2	; 0x02
    3d7a:	3b 81       	ldd	r19, Y+3	; 0x03
    3d7c:	88 85       	ldd	r24, Y+8	; 0x08
    3d7e:	99 85       	ldd	r25, Y+9	; 0x09
    3d80:	28 17       	cp	r18, r24
    3d82:	39 07       	cpc	r19, r25
    3d84:	38 f4       	brcc	.+14     	; 0x3d94 <xTaskIncrementTick+0xf0>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    3d86:	88 85       	ldd	r24, Y+8	; 0x08
    3d88:	99 85       	ldd	r25, Y+9	; 0x09
    3d8a:	90 93 57 05 	sts	0x0557, r25
    3d8e:	80 93 56 05 	sts	0x0556, r24
							break;
    3d92:	47 c0       	rjmp	.+142    	; 0x3e22 <xTaskIncrementTick+0x17e>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3d94:	8e 81       	ldd	r24, Y+6	; 0x06
    3d96:	9f 81       	ldd	r25, Y+7	; 0x07
    3d98:	02 96       	adiw	r24, 0x02	; 2
    3d9a:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3d9e:	8e 81       	ldd	r24, Y+6	; 0x06
    3da0:	9f 81       	ldd	r25, Y+7	; 0x07
    3da2:	fc 01       	movw	r30, r24
    3da4:	84 89       	ldd	r24, Z+20	; 0x14
    3da6:	95 89       	ldd	r25, Z+21	; 0x15
    3da8:	89 2b       	or	r24, r25
    3daa:	29 f0       	breq	.+10     	; 0x3db6 <xTaskIncrementTick+0x112>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3dac:	8e 81       	ldd	r24, Y+6	; 0x06
    3dae:	9f 81       	ldd	r25, Y+7	; 0x07
    3db0:	0c 96       	adiw	r24, 0x0c	; 12
    3db2:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    3db6:	8e 81       	ldd	r24, Y+6	; 0x06
    3db8:	9f 81       	ldd	r25, Y+7	; 0x07
    3dba:	fc 01       	movw	r30, r24
    3dbc:	96 89       	ldd	r25, Z+22	; 0x16
    3dbe:	80 91 50 05 	lds	r24, 0x0550
    3dc2:	89 17       	cp	r24, r25
    3dc4:	30 f4       	brcc	.+12     	; 0x3dd2 <xTaskIncrementTick+0x12e>
    3dc6:	8e 81       	ldd	r24, Y+6	; 0x06
    3dc8:	9f 81       	ldd	r25, Y+7	; 0x07
    3dca:	fc 01       	movw	r30, r24
    3dcc:	86 89       	ldd	r24, Z+22	; 0x16
    3dce:	80 93 50 05 	sts	0x0550, r24
    3dd2:	8e 81       	ldd	r24, Y+6	; 0x06
    3dd4:	9f 81       	ldd	r25, Y+7	; 0x07
    3dd6:	ac 01       	movw	r20, r24
    3dd8:	4e 5f       	subi	r20, 0xFE	; 254
    3dda:	5f 4f       	sbci	r21, 0xFF	; 255
    3ddc:	8e 81       	ldd	r24, Y+6	; 0x06
    3dde:	9f 81       	ldd	r25, Y+7	; 0x07
    3de0:	fc 01       	movw	r30, r24
    3de2:	86 89       	ldd	r24, Z+22	; 0x16
    3de4:	28 2f       	mov	r18, r24
    3de6:	30 e0       	ldi	r19, 0x00	; 0
    3de8:	c9 01       	movw	r24, r18
    3dea:	88 0f       	add	r24, r24
    3dec:	99 1f       	adc	r25, r25
    3dee:	88 0f       	add	r24, r24
    3df0:	99 1f       	adc	r25, r25
    3df2:	88 0f       	add	r24, r24
    3df4:	99 1f       	adc	r25, r25
    3df6:	82 0f       	add	r24, r18
    3df8:	93 1f       	adc	r25, r19
    3dfa:	80 50       	subi	r24, 0x00	; 0
    3dfc:	9b 4f       	sbci	r25, 0xFB	; 251
    3dfe:	ba 01       	movw	r22, r20
    3e00:	0e 94 88 10 	call	0x2110	; 0x2110 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3e04:	8e 81       	ldd	r24, Y+6	; 0x06
    3e06:	9f 81       	ldd	r25, Y+7	; 0x07
    3e08:	fc 01       	movw	r30, r24
    3e0a:	26 89       	ldd	r18, Z+22	; 0x16
    3e0c:	80 91 fe 04 	lds	r24, 0x04FE
    3e10:	90 91 ff 04 	lds	r25, 0x04FF
    3e14:	fc 01       	movw	r30, r24
    3e16:	86 89       	ldd	r24, Z+22	; 0x16
    3e18:	28 17       	cp	r18, r24
    3e1a:	10 f0       	brcs	.+4      	; 0x3e20 <xTaskIncrementTick+0x17c>
							{
								xSwitchRequired = pdTRUE;
    3e1c:	81 e0       	ldi	r24, 0x01	; 1
    3e1e:	89 83       	std	Y+1, r24	; 0x01
								mtCOVERAGE_TEST_MARKER();
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
    3e20:	89 cf       	rjmp	.-238    	; 0x3d34 <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3e22:	80 91 fe 04 	lds	r24, 0x04FE
    3e26:	90 91 ff 04 	lds	r25, 0x04FF
    3e2a:	fc 01       	movw	r30, r24
    3e2c:	86 89       	ldd	r24, Z+22	; 0x16
    3e2e:	28 2f       	mov	r18, r24
    3e30:	30 e0       	ldi	r19, 0x00	; 0
    3e32:	c9 01       	movw	r24, r18
    3e34:	88 0f       	add	r24, r24
    3e36:	99 1f       	adc	r25, r25
    3e38:	88 0f       	add	r24, r24
    3e3a:	99 1f       	adc	r25, r25
    3e3c:	88 0f       	add	r24, r24
    3e3e:	99 1f       	adc	r25, r25
    3e40:	82 0f       	add	r24, r18
    3e42:	93 1f       	adc	r25, r19
    3e44:	80 50       	subi	r24, 0x00	; 0
    3e46:	9b 4f       	sbci	r25, 0xFB	; 251
    3e48:	fc 01       	movw	r30, r24
    3e4a:	80 81       	ld	r24, Z
    3e4c:	82 30       	cpi	r24, 0x02	; 2
    3e4e:	40 f0       	brcs	.+16     	; 0x3e60 <xTaskIncrementTick+0x1bc>
			{
				xSwitchRequired = pdTRUE;
    3e50:	81 e0       	ldi	r24, 0x01	; 1
    3e52:	89 83       	std	Y+1, r24	; 0x01
    3e54:	05 c0       	rjmp	.+10     	; 0x3e60 <xTaskIncrementTick+0x1bc>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    3e56:	80 91 52 05 	lds	r24, 0x0552
    3e5a:	8f 5f       	subi	r24, 0xFF	; 255
    3e5c:	80 93 52 05 	sts	0x0552, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    3e60:	80 91 53 05 	lds	r24, 0x0553
    3e64:	88 23       	and	r24, r24
    3e66:	11 f0       	breq	.+4      	; 0x3e6c <xTaskIncrementTick+0x1c8>
		{
			xSwitchRequired = pdTRUE;
    3e68:	81 e0       	ldi	r24, 0x01	; 1
    3e6a:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    3e6c:	89 81       	ldd	r24, Y+1	; 0x01
}
    3e6e:	29 96       	adiw	r28, 0x09	; 9
    3e70:	0f b6       	in	r0, 0x3f	; 63
    3e72:	f8 94       	cli
    3e74:	de bf       	out	0x3e, r29	; 62
    3e76:	0f be       	out	0x3f, r0	; 63
    3e78:	cd bf       	out	0x3d, r28	; 61
    3e7a:	df 91       	pop	r29
    3e7c:	cf 91       	pop	r28
    3e7e:	08 95       	ret

00003e80 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3e80:	cf 93       	push	r28
    3e82:	df 93       	push	r29
    3e84:	00 d0       	rcall	.+0      	; 0x3e86 <vTaskSwitchContext+0x6>
    3e86:	cd b7       	in	r28, 0x3d	; 61
    3e88:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3e8a:	80 91 58 05 	lds	r24, 0x0558
    3e8e:	88 23       	and	r24, r24
    3e90:	21 f0       	breq	.+8      	; 0x3e9a <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    3e92:	81 e0       	ldi	r24, 0x01	; 1
    3e94:	80 93 53 05 	sts	0x0553, r24
    3e98:	5d c0       	rjmp	.+186    	; 0x3f54 <vTaskSwitchContext+0xd4>
	}
	else
	{
		xYieldPending = pdFALSE;
    3e9a:	10 92 53 05 	sts	0x0553, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    3e9e:	05 c0       	rjmp	.+10     	; 0x3eaa <vTaskSwitchContext+0x2a>
    3ea0:	80 91 50 05 	lds	r24, 0x0550
    3ea4:	81 50       	subi	r24, 0x01	; 1
    3ea6:	80 93 50 05 	sts	0x0550, r24
    3eaa:	80 91 50 05 	lds	r24, 0x0550
    3eae:	28 2f       	mov	r18, r24
    3eb0:	30 e0       	ldi	r19, 0x00	; 0
    3eb2:	c9 01       	movw	r24, r18
    3eb4:	88 0f       	add	r24, r24
    3eb6:	99 1f       	adc	r25, r25
    3eb8:	88 0f       	add	r24, r24
    3eba:	99 1f       	adc	r25, r25
    3ebc:	88 0f       	add	r24, r24
    3ebe:	99 1f       	adc	r25, r25
    3ec0:	82 0f       	add	r24, r18
    3ec2:	93 1f       	adc	r25, r19
    3ec4:	80 50       	subi	r24, 0x00	; 0
    3ec6:	9b 4f       	sbci	r25, 0xFB	; 251
    3ec8:	fc 01       	movw	r30, r24
    3eca:	80 81       	ld	r24, Z
    3ecc:	88 23       	and	r24, r24
    3ece:	41 f3       	breq	.-48     	; 0x3ea0 <vTaskSwitchContext+0x20>
    3ed0:	80 91 50 05 	lds	r24, 0x0550
    3ed4:	28 2f       	mov	r18, r24
    3ed6:	30 e0       	ldi	r19, 0x00	; 0
    3ed8:	c9 01       	movw	r24, r18
    3eda:	88 0f       	add	r24, r24
    3edc:	99 1f       	adc	r25, r25
    3ede:	88 0f       	add	r24, r24
    3ee0:	99 1f       	adc	r25, r25
    3ee2:	88 0f       	add	r24, r24
    3ee4:	99 1f       	adc	r25, r25
    3ee6:	82 0f       	add	r24, r18
    3ee8:	93 1f       	adc	r25, r19
    3eea:	80 50       	subi	r24, 0x00	; 0
    3eec:	9b 4f       	sbci	r25, 0xFB	; 251
    3eee:	9a 83       	std	Y+2, r25	; 0x02
    3ef0:	89 83       	std	Y+1, r24	; 0x01
    3ef2:	89 81       	ldd	r24, Y+1	; 0x01
    3ef4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ef6:	fc 01       	movw	r30, r24
    3ef8:	81 81       	ldd	r24, Z+1	; 0x01
    3efa:	92 81       	ldd	r25, Z+2	; 0x02
    3efc:	fc 01       	movw	r30, r24
    3efe:	22 81       	ldd	r18, Z+2	; 0x02
    3f00:	33 81       	ldd	r19, Z+3	; 0x03
    3f02:	89 81       	ldd	r24, Y+1	; 0x01
    3f04:	9a 81       	ldd	r25, Y+2	; 0x02
    3f06:	fc 01       	movw	r30, r24
    3f08:	32 83       	std	Z+2, r19	; 0x02
    3f0a:	21 83       	std	Z+1, r18	; 0x01
    3f0c:	89 81       	ldd	r24, Y+1	; 0x01
    3f0e:	9a 81       	ldd	r25, Y+2	; 0x02
    3f10:	fc 01       	movw	r30, r24
    3f12:	21 81       	ldd	r18, Z+1	; 0x01
    3f14:	32 81       	ldd	r19, Z+2	; 0x02
    3f16:	89 81       	ldd	r24, Y+1	; 0x01
    3f18:	9a 81       	ldd	r25, Y+2	; 0x02
    3f1a:	03 96       	adiw	r24, 0x03	; 3
    3f1c:	28 17       	cp	r18, r24
    3f1e:	39 07       	cpc	r19, r25
    3f20:	69 f4       	brne	.+26     	; 0x3f3c <vTaskSwitchContext+0xbc>
    3f22:	89 81       	ldd	r24, Y+1	; 0x01
    3f24:	9a 81       	ldd	r25, Y+2	; 0x02
    3f26:	fc 01       	movw	r30, r24
    3f28:	81 81       	ldd	r24, Z+1	; 0x01
    3f2a:	92 81       	ldd	r25, Z+2	; 0x02
    3f2c:	fc 01       	movw	r30, r24
    3f2e:	22 81       	ldd	r18, Z+2	; 0x02
    3f30:	33 81       	ldd	r19, Z+3	; 0x03
    3f32:	89 81       	ldd	r24, Y+1	; 0x01
    3f34:	9a 81       	ldd	r25, Y+2	; 0x02
    3f36:	fc 01       	movw	r30, r24
    3f38:	32 83       	std	Z+2, r19	; 0x02
    3f3a:	21 83       	std	Z+1, r18	; 0x01
    3f3c:	89 81       	ldd	r24, Y+1	; 0x01
    3f3e:	9a 81       	ldd	r25, Y+2	; 0x02
    3f40:	fc 01       	movw	r30, r24
    3f42:	81 81       	ldd	r24, Z+1	; 0x01
    3f44:	92 81       	ldd	r25, Z+2	; 0x02
    3f46:	fc 01       	movw	r30, r24
    3f48:	86 81       	ldd	r24, Z+6	; 0x06
    3f4a:	97 81       	ldd	r25, Z+7	; 0x07
    3f4c:	90 93 ff 04 	sts	0x04FF, r25
    3f50:	80 93 fe 04 	sts	0x04FE, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3f54:	0f 90       	pop	r0
    3f56:	0f 90       	pop	r0
    3f58:	df 91       	pop	r29
    3f5a:	cf 91       	pop	r28
    3f5c:	08 95       	ret

00003f5e <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    3f5e:	cf 93       	push	r28
    3f60:	df 93       	push	r29
    3f62:	00 d0       	rcall	.+0      	; 0x3f64 <vTaskPlaceOnEventList+0x6>
    3f64:	00 d0       	rcall	.+0      	; 0x3f66 <vTaskPlaceOnEventList+0x8>
    3f66:	00 d0       	rcall	.+0      	; 0x3f68 <vTaskPlaceOnEventList+0xa>
    3f68:	cd b7       	in	r28, 0x3d	; 61
    3f6a:	de b7       	in	r29, 0x3e	; 62
    3f6c:	9c 83       	std	Y+4, r25	; 0x04
    3f6e:	8b 83       	std	Y+3, r24	; 0x03
    3f70:	7e 83       	std	Y+6, r23	; 0x06
    3f72:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3f74:	80 91 fe 04 	lds	r24, 0x04FE
    3f78:	90 91 ff 04 	lds	r25, 0x04FF
    3f7c:	9c 01       	movw	r18, r24
    3f7e:	24 5f       	subi	r18, 0xF4	; 244
    3f80:	3f 4f       	sbci	r19, 0xFF	; 255
    3f82:	8b 81       	ldd	r24, Y+3	; 0x03
    3f84:	9c 81       	ldd	r25, Y+4	; 0x04
    3f86:	b9 01       	movw	r22, r18
    3f88:	0e 94 d6 10 	call	0x21ac	; 0x21ac <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3f8c:	80 91 fe 04 	lds	r24, 0x04FE
    3f90:	90 91 ff 04 	lds	r25, 0x04FF
    3f94:	02 96       	adiw	r24, 0x02	; 2
    3f96:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    3f9a:	20 91 4e 05 	lds	r18, 0x054E
    3f9e:	30 91 4f 05 	lds	r19, 0x054F
    3fa2:	8d 81       	ldd	r24, Y+5	; 0x05
    3fa4:	9e 81       	ldd	r25, Y+6	; 0x06
    3fa6:	82 0f       	add	r24, r18
    3fa8:	93 1f       	adc	r25, r19
    3faa:	9a 83       	std	Y+2, r25	; 0x02
    3fac:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3fae:	89 81       	ldd	r24, Y+1	; 0x01
    3fb0:	9a 81       	ldd	r25, Y+2	; 0x02
    3fb2:	0e 94 9e 22 	call	0x453c	; 0x453c <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3fb6:	26 96       	adiw	r28, 0x06	; 6
    3fb8:	0f b6       	in	r0, 0x3f	; 63
    3fba:	f8 94       	cli
    3fbc:	de bf       	out	0x3e, r29	; 62
    3fbe:	0f be       	out	0x3f, r0	; 63
    3fc0:	cd bf       	out	0x3d, r28	; 61
    3fc2:	df 91       	pop	r29
    3fc4:	cf 91       	pop	r28
    3fc6:	08 95       	ret

00003fc8 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    3fc8:	cf 93       	push	r28
    3fca:	df 93       	push	r29
    3fcc:	cd b7       	in	r28, 0x3d	; 61
    3fce:	de b7       	in	r29, 0x3e	; 62
    3fd0:	28 97       	sbiw	r28, 0x08	; 8
    3fd2:	0f b6       	in	r0, 0x3f	; 63
    3fd4:	f8 94       	cli
    3fd6:	de bf       	out	0x3e, r29	; 62
    3fd8:	0f be       	out	0x3f, r0	; 63
    3fda:	cd bf       	out	0x3d, r28	; 61
    3fdc:	9c 83       	std	Y+4, r25	; 0x04
    3fde:	8b 83       	std	Y+3, r24	; 0x03
    3fe0:	7e 83       	std	Y+6, r23	; 0x06
    3fe2:	6d 83       	std	Y+5, r22	; 0x05
    3fe4:	58 87       	std	Y+8, r21	; 0x08
    3fe6:	4f 83       	std	Y+7, r20	; 0x07
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3fe8:	80 91 fe 04 	lds	r24, 0x04FE
    3fec:	90 91 ff 04 	lds	r25, 0x04FF
    3ff0:	2d 81       	ldd	r18, Y+5	; 0x05
    3ff2:	3e 81       	ldd	r19, Y+6	; 0x06
    3ff4:	30 68       	ori	r19, 0x80	; 128
    3ff6:	fc 01       	movw	r30, r24
    3ff8:	35 87       	std	Z+13, r19	; 0x0d
    3ffa:	24 87       	std	Z+12, r18	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3ffc:	80 91 fe 04 	lds	r24, 0x04FE
    4000:	90 91 ff 04 	lds	r25, 0x04FF
    4004:	9c 01       	movw	r18, r24
    4006:	24 5f       	subi	r18, 0xF4	; 244
    4008:	3f 4f       	sbci	r19, 0xFF	; 255
    400a:	8b 81       	ldd	r24, Y+3	; 0x03
    400c:	9c 81       	ldd	r25, Y+4	; 0x04
    400e:	b9 01       	movw	r22, r18
    4010:	0e 94 88 10 	call	0x2110	; 0x2110 <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4014:	80 91 fe 04 	lds	r24, 0x04FE
    4018:	90 91 ff 04 	lds	r25, 0x04FF
    401c:	02 96       	adiw	r24, 0x02	; 2
    401e:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    4022:	20 91 4e 05 	lds	r18, 0x054E
    4026:	30 91 4f 05 	lds	r19, 0x054F
    402a:	8f 81       	ldd	r24, Y+7	; 0x07
    402c:	98 85       	ldd	r25, Y+8	; 0x08
    402e:	82 0f       	add	r24, r18
    4030:	93 1f       	adc	r25, r19
    4032:	9a 83       	std	Y+2, r25	; 0x02
    4034:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    4036:	89 81       	ldd	r24, Y+1	; 0x01
    4038:	9a 81       	ldd	r25, Y+2	; 0x02
    403a:	0e 94 9e 22 	call	0x453c	; 0x453c <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    403e:	28 96       	adiw	r28, 0x08	; 8
    4040:	0f b6       	in	r0, 0x3f	; 63
    4042:	f8 94       	cli
    4044:	de bf       	out	0x3e, r29	; 62
    4046:	0f be       	out	0x3f, r0	; 63
    4048:	cd bf       	out	0x3d, r28	; 61
    404a:	df 91       	pop	r29
    404c:	cf 91       	pop	r28
    404e:	08 95       	ret

00004050 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4050:	cf 93       	push	r28
    4052:	df 93       	push	r29
    4054:	00 d0       	rcall	.+0      	; 0x4056 <xTaskRemoveFromEventList+0x6>
    4056:	00 d0       	rcall	.+0      	; 0x4058 <xTaskRemoveFromEventList+0x8>
    4058:	1f 92       	push	r1
    405a:	cd b7       	in	r28, 0x3d	; 61
    405c:	de b7       	in	r29, 0x3e	; 62
    405e:	9d 83       	std	Y+5, r25	; 0x05
    4060:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    4062:	8c 81       	ldd	r24, Y+4	; 0x04
    4064:	9d 81       	ldd	r25, Y+5	; 0x05
    4066:	fc 01       	movw	r30, r24
    4068:	85 81       	ldd	r24, Z+5	; 0x05
    406a:	96 81       	ldd	r25, Z+6	; 0x06
    406c:	fc 01       	movw	r30, r24
    406e:	86 81       	ldd	r24, Z+6	; 0x06
    4070:	97 81       	ldd	r25, Z+7	; 0x07
    4072:	9b 83       	std	Y+3, r25	; 0x03
    4074:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4076:	8a 81       	ldd	r24, Y+2	; 0x02
    4078:	9b 81       	ldd	r25, Y+3	; 0x03
    407a:	0c 96       	adiw	r24, 0x0c	; 12
    407c:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4080:	80 91 58 05 	lds	r24, 0x0558
    4084:	88 23       	and	r24, r24
    4086:	69 f5       	brne	.+90     	; 0x40e2 <xTaskRemoveFromEventList+0x92>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    4088:	8a 81       	ldd	r24, Y+2	; 0x02
    408a:	9b 81       	ldd	r25, Y+3	; 0x03
    408c:	02 96       	adiw	r24, 0x02	; 2
    408e:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4092:	8a 81       	ldd	r24, Y+2	; 0x02
    4094:	9b 81       	ldd	r25, Y+3	; 0x03
    4096:	fc 01       	movw	r30, r24
    4098:	96 89       	ldd	r25, Z+22	; 0x16
    409a:	80 91 50 05 	lds	r24, 0x0550
    409e:	89 17       	cp	r24, r25
    40a0:	30 f4       	brcc	.+12     	; 0x40ae <xTaskRemoveFromEventList+0x5e>
    40a2:	8a 81       	ldd	r24, Y+2	; 0x02
    40a4:	9b 81       	ldd	r25, Y+3	; 0x03
    40a6:	fc 01       	movw	r30, r24
    40a8:	86 89       	ldd	r24, Z+22	; 0x16
    40aa:	80 93 50 05 	sts	0x0550, r24
    40ae:	8a 81       	ldd	r24, Y+2	; 0x02
    40b0:	9b 81       	ldd	r25, Y+3	; 0x03
    40b2:	ac 01       	movw	r20, r24
    40b4:	4e 5f       	subi	r20, 0xFE	; 254
    40b6:	5f 4f       	sbci	r21, 0xFF	; 255
    40b8:	8a 81       	ldd	r24, Y+2	; 0x02
    40ba:	9b 81       	ldd	r25, Y+3	; 0x03
    40bc:	fc 01       	movw	r30, r24
    40be:	86 89       	ldd	r24, Z+22	; 0x16
    40c0:	28 2f       	mov	r18, r24
    40c2:	30 e0       	ldi	r19, 0x00	; 0
    40c4:	c9 01       	movw	r24, r18
    40c6:	88 0f       	add	r24, r24
    40c8:	99 1f       	adc	r25, r25
    40ca:	88 0f       	add	r24, r24
    40cc:	99 1f       	adc	r25, r25
    40ce:	88 0f       	add	r24, r24
    40d0:	99 1f       	adc	r25, r25
    40d2:	82 0f       	add	r24, r18
    40d4:	93 1f       	adc	r25, r19
    40d6:	80 50       	subi	r24, 0x00	; 0
    40d8:	9b 4f       	sbci	r25, 0xFB	; 251
    40da:	ba 01       	movw	r22, r20
    40dc:	0e 94 88 10 	call	0x2110	; 0x2110 <vListInsertEnd>
    40e0:	08 c0       	rjmp	.+16     	; 0x40f2 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    40e2:	8a 81       	ldd	r24, Y+2	; 0x02
    40e4:	9b 81       	ldd	r25, Y+3	; 0x03
    40e6:	0c 96       	adiw	r24, 0x0c	; 12
    40e8:	bc 01       	movw	r22, r24
    40ea:	8a e3       	ldi	r24, 0x3A	; 58
    40ec:	95 e0       	ldi	r25, 0x05	; 5
    40ee:	0e 94 88 10 	call	0x2110	; 0x2110 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    40f2:	8a 81       	ldd	r24, Y+2	; 0x02
    40f4:	9b 81       	ldd	r25, Y+3	; 0x03
    40f6:	fc 01       	movw	r30, r24
    40f8:	26 89       	ldd	r18, Z+22	; 0x16
    40fa:	80 91 fe 04 	lds	r24, 0x04FE
    40fe:	90 91 ff 04 	lds	r25, 0x04FF
    4102:	fc 01       	movw	r30, r24
    4104:	86 89       	ldd	r24, Z+22	; 0x16
    4106:	82 17       	cp	r24, r18
    4108:	30 f4       	brcc	.+12     	; 0x4116 <xTaskRemoveFromEventList+0xc6>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    410a:	81 e0       	ldi	r24, 0x01	; 1
    410c:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    410e:	81 e0       	ldi	r24, 0x01	; 1
    4110:	80 93 53 05 	sts	0x0553, r24
    4114:	01 c0       	rjmp	.+2      	; 0x4118 <xTaskRemoveFromEventList+0xc8>
	}
	else
	{
		xReturn = pdFALSE;
    4116:	19 82       	std	Y+1, r1	; 0x01
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    4118:	89 81       	ldd	r24, Y+1	; 0x01
}
    411a:	0f 90       	pop	r0
    411c:	0f 90       	pop	r0
    411e:	0f 90       	pop	r0
    4120:	0f 90       	pop	r0
    4122:	0f 90       	pop	r0
    4124:	df 91       	pop	r29
    4126:	cf 91       	pop	r28
    4128:	08 95       	ret

0000412a <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    412a:	cf 93       	push	r28
    412c:	df 93       	push	r29
    412e:	cd b7       	in	r28, 0x3d	; 61
    4130:	de b7       	in	r29, 0x3e	; 62
    4132:	27 97       	sbiw	r28, 0x07	; 7
    4134:	0f b6       	in	r0, 0x3f	; 63
    4136:	f8 94       	cli
    4138:	de bf       	out	0x3e, r29	; 62
    413a:	0f be       	out	0x3f, r0	; 63
    413c:	cd bf       	out	0x3d, r28	; 61
    413e:	9d 83       	std	Y+5, r25	; 0x05
    4140:	8c 83       	std	Y+4, r24	; 0x04
    4142:	7f 83       	std	Y+7, r23	; 0x07
    4144:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4146:	8e 81       	ldd	r24, Y+6	; 0x06
    4148:	9f 81       	ldd	r25, Y+7	; 0x07
    414a:	9c 01       	movw	r18, r24
    414c:	30 68       	ori	r19, 0x80	; 128
    414e:	8c 81       	ldd	r24, Y+4	; 0x04
    4150:	9d 81       	ldd	r25, Y+5	; 0x05
    4152:	fc 01       	movw	r30, r24
    4154:	31 83       	std	Z+1, r19	; 0x01
    4156:	20 83       	st	Z, r18

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    4158:	8c 81       	ldd	r24, Y+4	; 0x04
    415a:	9d 81       	ldd	r25, Y+5	; 0x05
    415c:	fc 01       	movw	r30, r24
    415e:	86 81       	ldd	r24, Z+6	; 0x06
    4160:	97 81       	ldd	r25, Z+7	; 0x07
    4162:	9b 83       	std	Y+3, r25	; 0x03
    4164:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    4166:	8c 81       	ldd	r24, Y+4	; 0x04
    4168:	9d 81       	ldd	r25, Y+5	; 0x05
    416a:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    416e:	8a 81       	ldd	r24, Y+2	; 0x02
    4170:	9b 81       	ldd	r25, Y+3	; 0x03
    4172:	02 96       	adiw	r24, 0x02	; 2
    4174:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    4178:	8a 81       	ldd	r24, Y+2	; 0x02
    417a:	9b 81       	ldd	r25, Y+3	; 0x03
    417c:	fc 01       	movw	r30, r24
    417e:	96 89       	ldd	r25, Z+22	; 0x16
    4180:	80 91 50 05 	lds	r24, 0x0550
    4184:	89 17       	cp	r24, r25
    4186:	30 f4       	brcc	.+12     	; 0x4194 <xTaskRemoveFromUnorderedEventList+0x6a>
    4188:	8a 81       	ldd	r24, Y+2	; 0x02
    418a:	9b 81       	ldd	r25, Y+3	; 0x03
    418c:	fc 01       	movw	r30, r24
    418e:	86 89       	ldd	r24, Z+22	; 0x16
    4190:	80 93 50 05 	sts	0x0550, r24
    4194:	8a 81       	ldd	r24, Y+2	; 0x02
    4196:	9b 81       	ldd	r25, Y+3	; 0x03
    4198:	ac 01       	movw	r20, r24
    419a:	4e 5f       	subi	r20, 0xFE	; 254
    419c:	5f 4f       	sbci	r21, 0xFF	; 255
    419e:	8a 81       	ldd	r24, Y+2	; 0x02
    41a0:	9b 81       	ldd	r25, Y+3	; 0x03
    41a2:	fc 01       	movw	r30, r24
    41a4:	86 89       	ldd	r24, Z+22	; 0x16
    41a6:	28 2f       	mov	r18, r24
    41a8:	30 e0       	ldi	r19, 0x00	; 0
    41aa:	c9 01       	movw	r24, r18
    41ac:	88 0f       	add	r24, r24
    41ae:	99 1f       	adc	r25, r25
    41b0:	88 0f       	add	r24, r24
    41b2:	99 1f       	adc	r25, r25
    41b4:	88 0f       	add	r24, r24
    41b6:	99 1f       	adc	r25, r25
    41b8:	82 0f       	add	r24, r18
    41ba:	93 1f       	adc	r25, r19
    41bc:	80 50       	subi	r24, 0x00	; 0
    41be:	9b 4f       	sbci	r25, 0xFB	; 251
    41c0:	ba 01       	movw	r22, r20
    41c2:	0e 94 88 10 	call	0x2110	; 0x2110 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    41c6:	8a 81       	ldd	r24, Y+2	; 0x02
    41c8:	9b 81       	ldd	r25, Y+3	; 0x03
    41ca:	fc 01       	movw	r30, r24
    41cc:	26 89       	ldd	r18, Z+22	; 0x16
    41ce:	80 91 fe 04 	lds	r24, 0x04FE
    41d2:	90 91 ff 04 	lds	r25, 0x04FF
    41d6:	fc 01       	movw	r30, r24
    41d8:	86 89       	ldd	r24, Z+22	; 0x16
    41da:	82 17       	cp	r24, r18
    41dc:	30 f4       	brcc	.+12     	; 0x41ea <xTaskRemoveFromUnorderedEventList+0xc0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    41de:	81 e0       	ldi	r24, 0x01	; 1
    41e0:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    41e2:	81 e0       	ldi	r24, 0x01	; 1
    41e4:	80 93 53 05 	sts	0x0553, r24
    41e8:	01 c0       	rjmp	.+2      	; 0x41ec <xTaskRemoveFromUnorderedEventList+0xc2>
	}
	else
	{
		xReturn = pdFALSE;
    41ea:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    41ec:	89 81       	ldd	r24, Y+1	; 0x01
}
    41ee:	27 96       	adiw	r28, 0x07	; 7
    41f0:	0f b6       	in	r0, 0x3f	; 63
    41f2:	f8 94       	cli
    41f4:	de bf       	out	0x3e, r29	; 62
    41f6:	0f be       	out	0x3f, r0	; 63
    41f8:	cd bf       	out	0x3d, r28	; 61
    41fa:	df 91       	pop	r29
    41fc:	cf 91       	pop	r28
    41fe:	08 95       	ret

00004200 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4200:	cf 93       	push	r28
    4202:	df 93       	push	r29
    4204:	00 d0       	rcall	.+0      	; 0x4206 <vTaskSetTimeOutState+0x6>
    4206:	cd b7       	in	r28, 0x3d	; 61
    4208:	de b7       	in	r29, 0x3e	; 62
    420a:	9a 83       	std	Y+2, r25	; 0x02
    420c:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    420e:	20 91 54 05 	lds	r18, 0x0554
    4212:	89 81       	ldd	r24, Y+1	; 0x01
    4214:	9a 81       	ldd	r25, Y+2	; 0x02
    4216:	fc 01       	movw	r30, r24
    4218:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    421a:	20 91 4e 05 	lds	r18, 0x054E
    421e:	30 91 4f 05 	lds	r19, 0x054F
    4222:	89 81       	ldd	r24, Y+1	; 0x01
    4224:	9a 81       	ldd	r25, Y+2	; 0x02
    4226:	fc 01       	movw	r30, r24
    4228:	32 83       	std	Z+2, r19	; 0x02
    422a:	21 83       	std	Z+1, r18	; 0x01
}
    422c:	0f 90       	pop	r0
    422e:	0f 90       	pop	r0
    4230:	df 91       	pop	r29
    4232:	cf 91       	pop	r28
    4234:	08 95       	ret

00004236 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    4236:	cf 93       	push	r28
    4238:	df 93       	push	r29
    423a:	cd b7       	in	r28, 0x3d	; 61
    423c:	de b7       	in	r29, 0x3e	; 62
    423e:	27 97       	sbiw	r28, 0x07	; 7
    4240:	0f b6       	in	r0, 0x3f	; 63
    4242:	f8 94       	cli
    4244:	de bf       	out	0x3e, r29	; 62
    4246:	0f be       	out	0x3f, r0	; 63
    4248:	cd bf       	out	0x3d, r28	; 61
    424a:	9d 83       	std	Y+5, r25	; 0x05
    424c:	8c 83       	std	Y+4, r24	; 0x04
    424e:	7f 83       	std	Y+7, r23	; 0x07
    4250:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4252:	0f b6       	in	r0, 0x3f	; 63
    4254:	f8 94       	cli
    4256:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    4258:	80 91 4e 05 	lds	r24, 0x054E
    425c:	90 91 4f 05 	lds	r25, 0x054F
    4260:	9b 83       	std	Y+3, r25	; 0x03
    4262:	8a 83       	std	Y+2, r24	; 0x02
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4264:	8c 81       	ldd	r24, Y+4	; 0x04
    4266:	9d 81       	ldd	r25, Y+5	; 0x05
    4268:	fc 01       	movw	r30, r24
    426a:	90 81       	ld	r25, Z
    426c:	80 91 54 05 	lds	r24, 0x0554
    4270:	98 17       	cp	r25, r24
    4272:	69 f0       	breq	.+26     	; 0x428e <xTaskCheckForTimeOut+0x58>
    4274:	8c 81       	ldd	r24, Y+4	; 0x04
    4276:	9d 81       	ldd	r25, Y+5	; 0x05
    4278:	fc 01       	movw	r30, r24
    427a:	21 81       	ldd	r18, Z+1	; 0x01
    427c:	32 81       	ldd	r19, Z+2	; 0x02
    427e:	8a 81       	ldd	r24, Y+2	; 0x02
    4280:	9b 81       	ldd	r25, Y+3	; 0x03
    4282:	82 17       	cp	r24, r18
    4284:	93 07       	cpc	r25, r19
    4286:	18 f0       	brcs	.+6      	; 0x428e <xTaskCheckForTimeOut+0x58>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    4288:	81 e0       	ldi	r24, 0x01	; 1
    428a:	89 83       	std	Y+1, r24	; 0x01
    428c:	30 c0       	rjmp	.+96     	; 0x42ee <xTaskCheckForTimeOut+0xb8>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    428e:	8c 81       	ldd	r24, Y+4	; 0x04
    4290:	9d 81       	ldd	r25, Y+5	; 0x05
    4292:	fc 01       	movw	r30, r24
    4294:	81 81       	ldd	r24, Z+1	; 0x01
    4296:	92 81       	ldd	r25, Z+2	; 0x02
    4298:	2a 81       	ldd	r18, Y+2	; 0x02
    429a:	3b 81       	ldd	r19, Y+3	; 0x03
    429c:	28 1b       	sub	r18, r24
    429e:	39 0b       	sbc	r19, r25
    42a0:	8e 81       	ldd	r24, Y+6	; 0x06
    42a2:	9f 81       	ldd	r25, Y+7	; 0x07
    42a4:	fc 01       	movw	r30, r24
    42a6:	80 81       	ld	r24, Z
    42a8:	91 81       	ldd	r25, Z+1	; 0x01
    42aa:	28 17       	cp	r18, r24
    42ac:	39 07       	cpc	r19, r25
    42ae:	e8 f4       	brcc	.+58     	; 0x42ea <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    42b0:	8e 81       	ldd	r24, Y+6	; 0x06
    42b2:	9f 81       	ldd	r25, Y+7	; 0x07
    42b4:	fc 01       	movw	r30, r24
    42b6:	20 81       	ld	r18, Z
    42b8:	31 81       	ldd	r19, Z+1	; 0x01
    42ba:	8c 81       	ldd	r24, Y+4	; 0x04
    42bc:	9d 81       	ldd	r25, Y+5	; 0x05
    42be:	fc 01       	movw	r30, r24
    42c0:	41 81       	ldd	r20, Z+1	; 0x01
    42c2:	52 81       	ldd	r21, Z+2	; 0x02
    42c4:	8a 81       	ldd	r24, Y+2	; 0x02
    42c6:	9b 81       	ldd	r25, Y+3	; 0x03
    42c8:	ba 01       	movw	r22, r20
    42ca:	68 1b       	sub	r22, r24
    42cc:	79 0b       	sbc	r23, r25
    42ce:	cb 01       	movw	r24, r22
    42d0:	28 0f       	add	r18, r24
    42d2:	39 1f       	adc	r19, r25
    42d4:	8e 81       	ldd	r24, Y+6	; 0x06
    42d6:	9f 81       	ldd	r25, Y+7	; 0x07
    42d8:	fc 01       	movw	r30, r24
    42da:	31 83       	std	Z+1, r19	; 0x01
    42dc:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    42de:	8c 81       	ldd	r24, Y+4	; 0x04
    42e0:	9d 81       	ldd	r25, Y+5	; 0x05
    42e2:	0e 94 00 21 	call	0x4200	; 0x4200 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    42e6:	19 82       	std	Y+1, r1	; 0x01
    42e8:	02 c0       	rjmp	.+4      	; 0x42ee <xTaskCheckForTimeOut+0xb8>
		}
		else
		{
			xReturn = pdTRUE;
    42ea:	81 e0       	ldi	r24, 0x01	; 1
    42ec:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    42ee:	0f 90       	pop	r0
    42f0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    42f2:	89 81       	ldd	r24, Y+1	; 0x01
}
    42f4:	27 96       	adiw	r28, 0x07	; 7
    42f6:	0f b6       	in	r0, 0x3f	; 63
    42f8:	f8 94       	cli
    42fa:	de bf       	out	0x3e, r29	; 62
    42fc:	0f be       	out	0x3f, r0	; 63
    42fe:	cd bf       	out	0x3d, r28	; 61
    4300:	df 91       	pop	r29
    4302:	cf 91       	pop	r28
    4304:	08 95       	ret

00004306 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4306:	cf 93       	push	r28
    4308:	df 93       	push	r29
    430a:	cd b7       	in	r28, 0x3d	; 61
    430c:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    430e:	81 e0       	ldi	r24, 0x01	; 1
    4310:	80 93 53 05 	sts	0x0553, r24
}
    4314:	df 91       	pop	r29
    4316:	cf 91       	pop	r28
    4318:	08 95       	ret

0000431a <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    431a:	cf 93       	push	r28
    431c:	df 93       	push	r29
    431e:	00 d0       	rcall	.+0      	; 0x4320 <prvIdleTask+0x6>
    4320:	cd b7       	in	r28, 0x3d	; 61
    4322:	de b7       	in	r29, 0x3e	; 62
    4324:	9a 83       	std	Y+2, r25	; 0x02
    4326:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    4328:	0e 94 5e 22 	call	0x44bc	; 0x44bc <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    432c:	80 91 00 05 	lds	r24, 0x0500
    4330:	82 30       	cpi	r24, 0x02	; 2
    4332:	10 f0       	brcs	.+4      	; 0x4338 <prvIdleTask+0x1e>
			{
				taskYIELD();
    4334:	0e 94 89 13 	call	0x2712	; 0x2712 <vPortYield>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    4338:	f7 cf       	rjmp	.-18     	; 0x4328 <prvIdleTask+0xe>

0000433a <prvInitialiseTCBVariables>:

#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    433a:	0f 93       	push	r16
    433c:	1f 93       	push	r17
    433e:	cf 93       	push	r28
    4340:	df 93       	push	r29
    4342:	cd b7       	in	r28, 0x3d	; 61
    4344:	de b7       	in	r29, 0x3e	; 62
    4346:	2a 97       	sbiw	r28, 0x0a	; 10
    4348:	0f b6       	in	r0, 0x3f	; 63
    434a:	f8 94       	cli
    434c:	de bf       	out	0x3e, r29	; 62
    434e:	0f be       	out	0x3f, r0	; 63
    4350:	cd bf       	out	0x3d, r28	; 61
    4352:	9b 83       	std	Y+3, r25	; 0x03
    4354:	8a 83       	std	Y+2, r24	; 0x02
    4356:	7d 83       	std	Y+5, r23	; 0x05
    4358:	6c 83       	std	Y+4, r22	; 0x04
    435a:	4e 83       	std	Y+6, r20	; 0x06
    435c:	38 87       	std	Y+8, r19	; 0x08
    435e:	2f 83       	std	Y+7, r18	; 0x07
    4360:	1a 87       	std	Y+10, r17	; 0x0a
    4362:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4364:	19 82       	std	Y+1, r1	; 0x01
    4366:	22 c0       	rjmp	.+68     	; 0x43ac <prvInitialiseTCBVariables+0x72>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    4368:	89 81       	ldd	r24, Y+1	; 0x01
    436a:	88 2f       	mov	r24, r24
    436c:	90 e0       	ldi	r25, 0x00	; 0
    436e:	29 81       	ldd	r18, Y+1	; 0x01
    4370:	22 2f       	mov	r18, r18
    4372:	30 e0       	ldi	r19, 0x00	; 0
    4374:	4c 81       	ldd	r20, Y+4	; 0x04
    4376:	5d 81       	ldd	r21, Y+5	; 0x05
    4378:	24 0f       	add	r18, r20
    437a:	35 1f       	adc	r19, r21
    437c:	f9 01       	movw	r30, r18
    437e:	40 81       	ld	r20, Z
    4380:	2a 81       	ldd	r18, Y+2	; 0x02
    4382:	3b 81       	ldd	r19, Y+3	; 0x03
    4384:	82 0f       	add	r24, r18
    4386:	93 1f       	adc	r25, r19
    4388:	49 96       	adiw	r24, 0x19	; 25
    438a:	fc 01       	movw	r30, r24
    438c:	40 83       	st	Z, r20

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    438e:	89 81       	ldd	r24, Y+1	; 0x01
    4390:	88 2f       	mov	r24, r24
    4392:	90 e0       	ldi	r25, 0x00	; 0
    4394:	2c 81       	ldd	r18, Y+4	; 0x04
    4396:	3d 81       	ldd	r19, Y+5	; 0x05
    4398:	82 0f       	add	r24, r18
    439a:	93 1f       	adc	r25, r19
    439c:	fc 01       	movw	r30, r24
    439e:	80 81       	ld	r24, Z
    43a0:	88 23       	and	r24, r24
    43a2:	09 f4       	brne	.+2      	; 0x43a6 <prvInitialiseTCBVariables+0x6c>
		{
			break;
    43a4:	06 c0       	rjmp	.+12     	; 0x43b2 <prvInitialiseTCBVariables+0x78>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    43a6:	89 81       	ldd	r24, Y+1	; 0x01
    43a8:	8f 5f       	subi	r24, 0xFF	; 255
    43aa:	89 83       	std	Y+1, r24	; 0x01
    43ac:	89 81       	ldd	r24, Y+1	; 0x01
    43ae:	88 30       	cpi	r24, 0x08	; 8
    43b0:	d8 f2       	brcs	.-74     	; 0x4368 <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    43b2:	8a 81       	ldd	r24, Y+2	; 0x02
    43b4:	9b 81       	ldd	r25, Y+3	; 0x03
    43b6:	fc 01       	movw	r30, r24
    43b8:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    43ba:	8e 81       	ldd	r24, Y+6	; 0x06
    43bc:	84 30       	cpi	r24, 0x04	; 4
    43be:	10 f0       	brcs	.+4      	; 0x43c4 <prvInitialiseTCBVariables+0x8a>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    43c0:	83 e0       	ldi	r24, 0x03	; 3
    43c2:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    43c4:	8a 81       	ldd	r24, Y+2	; 0x02
    43c6:	9b 81       	ldd	r25, Y+3	; 0x03
    43c8:	2e 81       	ldd	r18, Y+6	; 0x06
    43ca:	fc 01       	movw	r30, r24
    43cc:	26 8b       	std	Z+22, r18	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    43ce:	8a 81       	ldd	r24, Y+2	; 0x02
    43d0:	9b 81       	ldd	r25, Y+3	; 0x03
    43d2:	02 96       	adiw	r24, 0x02	; 2
    43d4:	0e 94 77 10 	call	0x20ee	; 0x20ee <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    43d8:	8a 81       	ldd	r24, Y+2	; 0x02
    43da:	9b 81       	ldd	r25, Y+3	; 0x03
    43dc:	0c 96       	adiw	r24, 0x0c	; 12
    43de:	0e 94 77 10 	call	0x20ee	; 0x20ee <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    43e2:	8a 81       	ldd	r24, Y+2	; 0x02
    43e4:	9b 81       	ldd	r25, Y+3	; 0x03
    43e6:	2a 81       	ldd	r18, Y+2	; 0x02
    43e8:	3b 81       	ldd	r19, Y+3	; 0x03
    43ea:	fc 01       	movw	r30, r24
    43ec:	31 87       	std	Z+9, r19	; 0x09
    43ee:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    43f0:	8e 81       	ldd	r24, Y+6	; 0x06
    43f2:	88 2f       	mov	r24, r24
    43f4:	90 e0       	ldi	r25, 0x00	; 0
    43f6:	24 e0       	ldi	r18, 0x04	; 4
    43f8:	30 e0       	ldi	r19, 0x00	; 0
    43fa:	28 1b       	sub	r18, r24
    43fc:	39 0b       	sbc	r19, r25
    43fe:	8a 81       	ldd	r24, Y+2	; 0x02
    4400:	9b 81       	ldd	r25, Y+3	; 0x03
    4402:	fc 01       	movw	r30, r24
    4404:	35 87       	std	Z+13, r19	; 0x0d
    4406:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    4408:	8a 81       	ldd	r24, Y+2	; 0x02
    440a:	9b 81       	ldd	r25, Y+3	; 0x03
    440c:	2a 81       	ldd	r18, Y+2	; 0x02
    440e:	3b 81       	ldd	r19, Y+3	; 0x03
    4410:	fc 01       	movw	r30, r24
    4412:	33 8b       	std	Z+19, r19	; 0x13
    4414:	22 8b       	std	Z+18, r18	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    4416:	8a 81       	ldd	r24, Y+2	; 0x02
    4418:	9b 81       	ldd	r25, Y+3	; 0x03
    441a:	fc 01       	movw	r30, r24
    441c:	11 a2       	std	Z+33, r1	; 0x21
    441e:	12 a2       	std	Z+34, r1	; 0x22
    4420:	13 a2       	std	Z+35, r1	; 0x23
    4422:	14 a2       	std	Z+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
    4424:	8a 81       	ldd	r24, Y+2	; 0x02
    4426:	9b 81       	ldd	r25, Y+3	; 0x03
    4428:	fc 01       	movw	r30, r24
    442a:	15 a2       	std	Z+37, r1	; 0x25
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    442c:	2a 96       	adiw	r28, 0x0a	; 10
    442e:	0f b6       	in	r0, 0x3f	; 63
    4430:	f8 94       	cli
    4432:	de bf       	out	0x3e, r29	; 62
    4434:	0f be       	out	0x3f, r0	; 63
    4436:	cd bf       	out	0x3d, r28	; 61
    4438:	df 91       	pop	r29
    443a:	cf 91       	pop	r28
    443c:	1f 91       	pop	r17
    443e:	0f 91       	pop	r16
    4440:	08 95       	ret

00004442 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4442:	cf 93       	push	r28
    4444:	df 93       	push	r29
    4446:	1f 92       	push	r1
    4448:	cd b7       	in	r28, 0x3d	; 61
    444a:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    444c:	19 82       	std	Y+1, r1	; 0x01
    444e:	13 c0       	rjmp	.+38     	; 0x4476 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4450:	89 81       	ldd	r24, Y+1	; 0x01
    4452:	28 2f       	mov	r18, r24
    4454:	30 e0       	ldi	r19, 0x00	; 0
    4456:	c9 01       	movw	r24, r18
    4458:	88 0f       	add	r24, r24
    445a:	99 1f       	adc	r25, r25
    445c:	88 0f       	add	r24, r24
    445e:	99 1f       	adc	r25, r25
    4460:	88 0f       	add	r24, r24
    4462:	99 1f       	adc	r25, r25
    4464:	82 0f       	add	r24, r18
    4466:	93 1f       	adc	r25, r19
    4468:	80 50       	subi	r24, 0x00	; 0
    446a:	9b 4f       	sbci	r25, 0xFB	; 251
    446c:	0e 94 42 10 	call	0x2084	; 0x2084 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4470:	89 81       	ldd	r24, Y+1	; 0x01
    4472:	8f 5f       	subi	r24, 0xFF	; 255
    4474:	89 83       	std	Y+1, r24	; 0x01
    4476:	89 81       	ldd	r24, Y+1	; 0x01
    4478:	84 30       	cpi	r24, 0x04	; 4
    447a:	50 f3       	brcs	.-44     	; 0x4450 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    447c:	84 e2       	ldi	r24, 0x24	; 36
    447e:	95 e0       	ldi	r25, 0x05	; 5
    4480:	0e 94 42 10 	call	0x2084	; 0x2084 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    4484:	8d e2       	ldi	r24, 0x2D	; 45
    4486:	95 e0       	ldi	r25, 0x05	; 5
    4488:	0e 94 42 10 	call	0x2084	; 0x2084 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    448c:	8a e3       	ldi	r24, 0x3A	; 58
    448e:	95 e0       	ldi	r25, 0x05	; 5
    4490:	0e 94 42 10 	call	0x2084	; 0x2084 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    4494:	83 e4       	ldi	r24, 0x43	; 67
    4496:	95 e0       	ldi	r25, 0x05	; 5
    4498:	0e 94 42 10 	call	0x2084	; 0x2084 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    449c:	84 e2       	ldi	r24, 0x24	; 36
    449e:	95 e0       	ldi	r25, 0x05	; 5
    44a0:	90 93 37 05 	sts	0x0537, r25
    44a4:	80 93 36 05 	sts	0x0536, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    44a8:	8d e2       	ldi	r24, 0x2D	; 45
    44aa:	95 e0       	ldi	r25, 0x05	; 5
    44ac:	90 93 39 05 	sts	0x0539, r25
    44b0:	80 93 38 05 	sts	0x0538, r24
}
    44b4:	0f 90       	pop	r0
    44b6:	df 91       	pop	r29
    44b8:	cf 91       	pop	r28
    44ba:	08 95       	ret

000044bc <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    44bc:	cf 93       	push	r28
    44be:	df 93       	push	r29
    44c0:	00 d0       	rcall	.+0      	; 0x44c2 <prvCheckTasksWaitingTermination+0x6>
    44c2:	1f 92       	push	r1
    44c4:	cd b7       	in	r28, 0x3d	; 61
    44c6:	de b7       	in	r29, 0x3e	; 62
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    44c8:	2f c0       	rjmp	.+94     	; 0x4528 <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
    44ca:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    44ce:	90 91 43 05 	lds	r25, 0x0543
    44d2:	81 e0       	ldi	r24, 0x01	; 1
    44d4:	99 23       	and	r25, r25
    44d6:	09 f0       	breq	.+2      	; 0x44da <prvCheckTasksWaitingTermination+0x1e>
    44d8:	80 e0       	ldi	r24, 0x00	; 0
    44da:	89 83       	std	Y+1, r24	; 0x01
			}
			( void ) xTaskResumeAll();
    44dc:	0e 94 8f 1d 	call	0x3b1e	; 0x3b1e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    44e0:	89 81       	ldd	r24, Y+1	; 0x01
    44e2:	88 23       	and	r24, r24
    44e4:	09 f5       	brne	.+66     	; 0x4528 <prvCheckTasksWaitingTermination+0x6c>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    44e6:	0f b6       	in	r0, 0x3f	; 63
    44e8:	f8 94       	cli
    44ea:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    44ec:	80 91 48 05 	lds	r24, 0x0548
    44f0:	90 91 49 05 	lds	r25, 0x0549
    44f4:	fc 01       	movw	r30, r24
    44f6:	86 81       	ldd	r24, Z+6	; 0x06
    44f8:	97 81       	ldd	r25, Z+7	; 0x07
    44fa:	9b 83       	std	Y+3, r25	; 0x03
    44fc:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    44fe:	8a 81       	ldd	r24, Y+2	; 0x02
    4500:	9b 81       	ldd	r25, Y+3	; 0x03
    4502:	02 96       	adiw	r24, 0x02	; 2
    4504:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>
					--uxCurrentNumberOfTasks;
    4508:	80 91 4d 05 	lds	r24, 0x054D
    450c:	81 50       	subi	r24, 0x01	; 1
    450e:	80 93 4d 05 	sts	0x054D, r24
					--uxTasksDeleted;
    4512:	80 91 4c 05 	lds	r24, 0x054C
    4516:	81 50       	subi	r24, 0x01	; 1
    4518:	80 93 4c 05 	sts	0x054C, r24
				}
				taskEXIT_CRITICAL();
    451c:	0f 90       	pop	r0
    451e:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    4520:	8a 81       	ldd	r24, Y+2	; 0x02
    4522:	9b 81       	ldd	r25, Y+3	; 0x03
    4524:	0e 94 2b 23 	call	0x4656	; 0x4656 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    4528:	80 91 4c 05 	lds	r24, 0x054C
    452c:	88 23       	and	r24, r24
    452e:	69 f6       	brne	.-102    	; 0x44ca <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    4530:	0f 90       	pop	r0
    4532:	0f 90       	pop	r0
    4534:	0f 90       	pop	r0
    4536:	df 91       	pop	r29
    4538:	cf 91       	pop	r28
    453a:	08 95       	ret

0000453c <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    453c:	cf 93       	push	r28
    453e:	df 93       	push	r29
    4540:	00 d0       	rcall	.+0      	; 0x4542 <prvAddCurrentTaskToDelayedList+0x6>
    4542:	cd b7       	in	r28, 0x3d	; 61
    4544:	de b7       	in	r29, 0x3e	; 62
    4546:	9a 83       	std	Y+2, r25	; 0x02
    4548:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    454a:	80 91 fe 04 	lds	r24, 0x04FE
    454e:	90 91 ff 04 	lds	r25, 0x04FF
    4552:	29 81       	ldd	r18, Y+1	; 0x01
    4554:	3a 81       	ldd	r19, Y+2	; 0x02
    4556:	fc 01       	movw	r30, r24
    4558:	33 83       	std	Z+3, r19	; 0x03
    455a:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    455c:	80 91 4e 05 	lds	r24, 0x054E
    4560:	90 91 4f 05 	lds	r25, 0x054F
    4564:	29 81       	ldd	r18, Y+1	; 0x01
    4566:	3a 81       	ldd	r19, Y+2	; 0x02
    4568:	28 17       	cp	r18, r24
    456a:	39 07       	cpc	r19, r25
    456c:	78 f4       	brcc	.+30     	; 0x458c <prvAddCurrentTaskToDelayedList+0x50>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    456e:	80 91 fe 04 	lds	r24, 0x04FE
    4572:	90 91 ff 04 	lds	r25, 0x04FF
    4576:	9c 01       	movw	r18, r24
    4578:	2e 5f       	subi	r18, 0xFE	; 254
    457a:	3f 4f       	sbci	r19, 0xFF	; 255
    457c:	80 91 38 05 	lds	r24, 0x0538
    4580:	90 91 39 05 	lds	r25, 0x0539
    4584:	b9 01       	movw	r22, r18
    4586:	0e 94 d6 10 	call	0x21ac	; 0x21ac <vListInsert>
    458a:	1d c0       	rjmp	.+58     	; 0x45c6 <prvAddCurrentTaskToDelayedList+0x8a>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    458c:	80 91 fe 04 	lds	r24, 0x04FE
    4590:	90 91 ff 04 	lds	r25, 0x04FF
    4594:	9c 01       	movw	r18, r24
    4596:	2e 5f       	subi	r18, 0xFE	; 254
    4598:	3f 4f       	sbci	r19, 0xFF	; 255
    459a:	80 91 36 05 	lds	r24, 0x0536
    459e:	90 91 37 05 	lds	r25, 0x0537
    45a2:	b9 01       	movw	r22, r18
    45a4:	0e 94 d6 10 	call	0x21ac	; 0x21ac <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    45a8:	80 91 56 05 	lds	r24, 0x0556
    45ac:	90 91 57 05 	lds	r25, 0x0557
    45b0:	29 81       	ldd	r18, Y+1	; 0x01
    45b2:	3a 81       	ldd	r19, Y+2	; 0x02
    45b4:	28 17       	cp	r18, r24
    45b6:	39 07       	cpc	r19, r25
    45b8:	30 f4       	brcc	.+12     	; 0x45c6 <prvAddCurrentTaskToDelayedList+0x8a>
		{
			xNextTaskUnblockTime = xTimeToWake;
    45ba:	89 81       	ldd	r24, Y+1	; 0x01
    45bc:	9a 81       	ldd	r25, Y+2	; 0x02
    45be:	90 93 57 05 	sts	0x0557, r25
    45c2:	80 93 56 05 	sts	0x0556, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    45c6:	0f 90       	pop	r0
    45c8:	0f 90       	pop	r0
    45ca:	df 91       	pop	r29
    45cc:	cf 91       	pop	r28
    45ce:	08 95       	ret

000045d0 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    45d0:	cf 93       	push	r28
    45d2:	df 93       	push	r29
    45d4:	cd b7       	in	r28, 0x3d	; 61
    45d6:	de b7       	in	r29, 0x3e	; 62
    45d8:	28 97       	sbiw	r28, 0x08	; 8
    45da:	0f b6       	in	r0, 0x3f	; 63
    45dc:	f8 94       	cli
    45de:	de bf       	out	0x3e, r29	; 62
    45e0:	0f be       	out	0x3f, r0	; 63
    45e2:	cd bf       	out	0x3d, r28	; 61
    45e4:	9e 83       	std	Y+6, r25	; 0x06
    45e6:	8d 83       	std	Y+5, r24	; 0x05
    45e8:	78 87       	std	Y+8, r23	; 0x08
    45ea:	6f 83       	std	Y+7, r22	; 0x07
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    45ec:	8f 81       	ldd	r24, Y+7	; 0x07
    45ee:	98 85       	ldd	r25, Y+8	; 0x08
    45f0:	89 2b       	or	r24, r25
    45f2:	29 f4       	brne	.+10     	; 0x45fe <prvAllocateTCBAndStack+0x2e>
    45f4:	8d 81       	ldd	r24, Y+5	; 0x05
    45f6:	9e 81       	ldd	r25, Y+6	; 0x06
    45f8:	0e 94 a8 14 	call	0x2950	; 0x2950 <pvPortMalloc>
    45fc:	02 c0       	rjmp	.+4      	; 0x4602 <prvAllocateTCBAndStack+0x32>
    45fe:	8f 81       	ldd	r24, Y+7	; 0x07
    4600:	98 85       	ldd	r25, Y+8	; 0x08
    4602:	9c 83       	std	Y+4, r25	; 0x04
    4604:	8b 83       	std	Y+3, r24	; 0x03

		if( pxStack != NULL )
    4606:	8b 81       	ldd	r24, Y+3	; 0x03
    4608:	9c 81       	ldd	r25, Y+4	; 0x04
    460a:	89 2b       	or	r24, r25
    460c:	b9 f0       	breq	.+46     	; 0x463c <prvAllocateTCBAndStack+0x6c>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    460e:	86 e2       	ldi	r24, 0x26	; 38
    4610:	90 e0       	ldi	r25, 0x00	; 0
    4612:	0e 94 a8 14 	call	0x2950	; 0x2950 <pvPortMalloc>
    4616:	9a 83       	std	Y+2, r25	; 0x02
    4618:	89 83       	std	Y+1, r24	; 0x01

			if( pxNewTCB != NULL )
    461a:	89 81       	ldd	r24, Y+1	; 0x01
    461c:	9a 81       	ldd	r25, Y+2	; 0x02
    461e:	89 2b       	or	r24, r25
    4620:	41 f0       	breq	.+16     	; 0x4632 <prvAllocateTCBAndStack+0x62>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    4622:	89 81       	ldd	r24, Y+1	; 0x01
    4624:	9a 81       	ldd	r25, Y+2	; 0x02
    4626:	2b 81       	ldd	r18, Y+3	; 0x03
    4628:	3c 81       	ldd	r19, Y+4	; 0x04
    462a:	fc 01       	movw	r30, r24
    462c:	30 8f       	std	Z+24, r19	; 0x18
    462e:	27 8b       	std	Z+23, r18	; 0x17
    4630:	07 c0       	rjmp	.+14     	; 0x4640 <prvAllocateTCBAndStack+0x70>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    4632:	8b 81       	ldd	r24, Y+3	; 0x03
    4634:	9c 81       	ldd	r25, Y+4	; 0x04
    4636:	0e 94 fd 14 	call	0x29fa	; 0x29fa <vPortFree>
    463a:	02 c0       	rjmp	.+4      	; 0x4640 <prvAllocateTCBAndStack+0x70>
			}
		}
		else
		{
			pxNewTCB = NULL;
    463c:	1a 82       	std	Y+2, r1	; 0x02
    463e:	19 82       	std	Y+1, r1	; 0x01
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
		}
		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
	}

	return pxNewTCB;
    4640:	89 81       	ldd	r24, Y+1	; 0x01
    4642:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4644:	28 96       	adiw	r28, 0x08	; 8
    4646:	0f b6       	in	r0, 0x3f	; 63
    4648:	f8 94       	cli
    464a:	de bf       	out	0x3e, r29	; 62
    464c:	0f be       	out	0x3f, r0	; 63
    464e:	cd bf       	out	0x3d, r28	; 61
    4650:	df 91       	pop	r29
    4652:	cf 91       	pop	r28
    4654:	08 95       	ret

00004656 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    4656:	cf 93       	push	r28
    4658:	df 93       	push	r29
    465a:	00 d0       	rcall	.+0      	; 0x465c <prvDeleteTCB+0x6>
    465c:	cd b7       	in	r28, 0x3d	; 61
    465e:	de b7       	in	r29, 0x3e	; 62
    4660:	9a 83       	std	Y+2, r25	; 0x02
    4662:	89 83       	std	Y+1, r24	; 0x01
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
    4664:	89 81       	ldd	r24, Y+1	; 0x01
    4666:	9a 81       	ldd	r25, Y+2	; 0x02
    4668:	fc 01       	movw	r30, r24
    466a:	87 89       	ldd	r24, Z+23	; 0x17
    466c:	90 8d       	ldd	r25, Z+24	; 0x18
    466e:	0e 94 fd 14 	call	0x29fa	; 0x29fa <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
    4672:	89 81       	ldd	r24, Y+1	; 0x01
    4674:	9a 81       	ldd	r25, Y+2	; 0x02
    4676:	0e 94 fd 14 	call	0x29fa	; 0x29fa <vPortFree>
	}
    467a:	0f 90       	pop	r0
    467c:	0f 90       	pop	r0
    467e:	df 91       	pop	r29
    4680:	cf 91       	pop	r28
    4682:	08 95       	ret

00004684 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4684:	cf 93       	push	r28
    4686:	df 93       	push	r29
    4688:	00 d0       	rcall	.+0      	; 0x468a <prvResetNextTaskUnblockTime+0x6>
    468a:	cd b7       	in	r28, 0x3d	; 61
    468c:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    468e:	80 91 36 05 	lds	r24, 0x0536
    4692:	90 91 37 05 	lds	r25, 0x0537
    4696:	fc 01       	movw	r30, r24
    4698:	80 81       	ld	r24, Z
    469a:	88 23       	and	r24, r24
    469c:	39 f4       	brne	.+14     	; 0x46ac <prvResetNextTaskUnblockTime+0x28>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    469e:	8f ef       	ldi	r24, 0xFF	; 255
    46a0:	9f ef       	ldi	r25, 0xFF	; 255
    46a2:	90 93 57 05 	sts	0x0557, r25
    46a6:	80 93 56 05 	sts	0x0556, r24
    46aa:	15 c0       	rjmp	.+42     	; 0x46d6 <prvResetNextTaskUnblockTime+0x52>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    46ac:	80 91 36 05 	lds	r24, 0x0536
    46b0:	90 91 37 05 	lds	r25, 0x0537
    46b4:	fc 01       	movw	r30, r24
    46b6:	85 81       	ldd	r24, Z+5	; 0x05
    46b8:	96 81       	ldd	r25, Z+6	; 0x06
    46ba:	fc 01       	movw	r30, r24
    46bc:	86 81       	ldd	r24, Z+6	; 0x06
    46be:	97 81       	ldd	r25, Z+7	; 0x07
    46c0:	9a 83       	std	Y+2, r25	; 0x02
    46c2:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    46c4:	89 81       	ldd	r24, Y+1	; 0x01
    46c6:	9a 81       	ldd	r25, Y+2	; 0x02
    46c8:	fc 01       	movw	r30, r24
    46ca:	82 81       	ldd	r24, Z+2	; 0x02
    46cc:	93 81       	ldd	r25, Z+3	; 0x03
    46ce:	90 93 57 05 	sts	0x0557, r25
    46d2:	80 93 56 05 	sts	0x0556, r24
	}
}
    46d6:	0f 90       	pop	r0
    46d8:	0f 90       	pop	r0
    46da:	df 91       	pop	r29
    46dc:	cf 91       	pop	r28
    46de:	08 95       	ret

000046e0 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    46e0:	cf 93       	push	r28
    46e2:	df 93       	push	r29
    46e4:	00 d0       	rcall	.+0      	; 0x46e6 <uxTaskResetEventItemValue+0x6>
    46e6:	cd b7       	in	r28, 0x3d	; 61
    46e8:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    46ea:	80 91 fe 04 	lds	r24, 0x04FE
    46ee:	90 91 ff 04 	lds	r25, 0x04FF
    46f2:	fc 01       	movw	r30, r24
    46f4:	84 85       	ldd	r24, Z+12	; 0x0c
    46f6:	95 85       	ldd	r25, Z+13	; 0x0d
    46f8:	9a 83       	std	Y+2, r25	; 0x02
    46fa:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    46fc:	80 91 fe 04 	lds	r24, 0x04FE
    4700:	90 91 ff 04 	lds	r25, 0x04FF
    4704:	20 91 fe 04 	lds	r18, 0x04FE
    4708:	30 91 ff 04 	lds	r19, 0x04FF
    470c:	f9 01       	movw	r30, r18
    470e:	26 89       	ldd	r18, Z+22	; 0x16
    4710:	22 2f       	mov	r18, r18
    4712:	30 e0       	ldi	r19, 0x00	; 0
    4714:	44 e0       	ldi	r20, 0x04	; 4
    4716:	50 e0       	ldi	r21, 0x00	; 0
    4718:	ba 01       	movw	r22, r20
    471a:	62 1b       	sub	r22, r18
    471c:	73 0b       	sbc	r23, r19
    471e:	9b 01       	movw	r18, r22
    4720:	fc 01       	movw	r30, r24
    4722:	35 87       	std	Z+13, r19	; 0x0d
    4724:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
    4726:	89 81       	ldd	r24, Y+1	; 0x01
    4728:	9a 81       	ldd	r25, Y+2	; 0x02
}
    472a:	0f 90       	pop	r0
    472c:	0f 90       	pop	r0
    472e:	df 91       	pop	r29
    4730:	cf 91       	pop	r28
    4732:	08 95       	ret

00004734 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    4734:	cf 93       	push	r28
    4736:	df 93       	push	r29
    4738:	cd b7       	in	r28, 0x3d	; 61
    473a:	de b7       	in	r29, 0x3e	; 62
    473c:	29 97       	sbiw	r28, 0x09	; 9
    473e:	0f b6       	in	r0, 0x3f	; 63
    4740:	f8 94       	cli
    4742:	de bf       	out	0x3e, r29	; 62
    4744:	0f be       	out	0x3f, r0	; 63
    4746:	cd bf       	out	0x3d, r28	; 61
    4748:	8f 83       	std	Y+7, r24	; 0x07
    474a:	79 87       	std	Y+9, r23	; 0x09
    474c:	68 87       	std	Y+8, r22	; 0x08
	TickType_t xTimeToWake;
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    474e:	0f b6       	in	r0, 0x3f	; 63
    4750:	f8 94       	cli
    4752:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    4754:	80 91 fe 04 	lds	r24, 0x04FE
    4758:	90 91 ff 04 	lds	r25, 0x04FF
    475c:	fc 01       	movw	r30, r24
    475e:	81 a1       	ldd	r24, Z+33	; 0x21
    4760:	92 a1       	ldd	r25, Z+34	; 0x22
    4762:	a3 a1       	ldd	r26, Z+35	; 0x23
    4764:	b4 a1       	ldd	r27, Z+36	; 0x24
    4766:	89 2b       	or	r24, r25
    4768:	8a 2b       	or	r24, r26
    476a:	8b 2b       	or	r24, r27
    476c:	11 f5       	brne	.+68     	; 0x47b2 <ulTaskNotifyTake+0x7e>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    476e:	80 91 fe 04 	lds	r24, 0x04FE
    4772:	90 91 ff 04 	lds	r25, 0x04FF
    4776:	21 e0       	ldi	r18, 0x01	; 1
    4778:	fc 01       	movw	r30, r24
    477a:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    477c:	88 85       	ldd	r24, Y+8	; 0x08
    477e:	99 85       	ldd	r25, Y+9	; 0x09
    4780:	89 2b       	or	r24, r25
    4782:	b9 f0       	breq	.+46     	; 0x47b2 <ulTaskNotifyTake+0x7e>
				{
					/* The task is going to block.  First it must be removed
					from the ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    4784:	80 91 fe 04 	lds	r24, 0x04FE
    4788:	90 91 ff 04 	lds	r25, 0x04FF
    478c:	02 96       	adiw	r24, 0x02	; 2
    478e:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>
					{
							/* Calculate the time at which the task should be
							woken if the event does not occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    4792:	20 91 4e 05 	lds	r18, 0x054E
    4796:	30 91 4f 05 	lds	r19, 0x054F
    479a:	88 85       	ldd	r24, Y+8	; 0x08
    479c:	99 85       	ldd	r25, Y+9	; 0x09
    479e:	82 0f       	add	r24, r18
    47a0:	93 1f       	adc	r25, r19
    47a2:	9a 83       	std	Y+2, r25	; 0x02
    47a4:	89 83       	std	Y+1, r24	; 0x01
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    47a6:	89 81       	ldd	r24, Y+1	; 0x01
    47a8:	9a 81       	ldd	r25, Y+2	; 0x02
    47aa:	0e 94 9e 22 	call	0x453c	; 0x453c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    47ae:	0e 94 89 13 	call	0x2712	; 0x2712 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    47b2:	0f 90       	pop	r0
    47b4:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    47b6:	0f b6       	in	r0, 0x3f	; 63
    47b8:	f8 94       	cli
    47ba:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    47bc:	80 91 fe 04 	lds	r24, 0x04FE
    47c0:	90 91 ff 04 	lds	r25, 0x04FF
    47c4:	fc 01       	movw	r30, r24
    47c6:	81 a1       	ldd	r24, Z+33	; 0x21
    47c8:	92 a1       	ldd	r25, Z+34	; 0x22
    47ca:	a3 a1       	ldd	r26, Z+35	; 0x23
    47cc:	b4 a1       	ldd	r27, Z+36	; 0x24
    47ce:	8b 83       	std	Y+3, r24	; 0x03
    47d0:	9c 83       	std	Y+4, r25	; 0x04
    47d2:	ad 83       	std	Y+5, r26	; 0x05
    47d4:	be 83       	std	Y+6, r27	; 0x06

			if( ulReturn != 0UL )
    47d6:	8b 81       	ldd	r24, Y+3	; 0x03
    47d8:	9c 81       	ldd	r25, Y+4	; 0x04
    47da:	ad 81       	ldd	r26, Y+5	; 0x05
    47dc:	be 81       	ldd	r27, Y+6	; 0x06
    47de:	89 2b       	or	r24, r25
    47e0:	8a 2b       	or	r24, r26
    47e2:	8b 2b       	or	r24, r27
    47e4:	f1 f0       	breq	.+60     	; 0x4822 <ulTaskNotifyTake+0xee>
			{
				if( xClearCountOnExit != pdFALSE )
    47e6:	8f 81       	ldd	r24, Y+7	; 0x07
    47e8:	88 23       	and	r24, r24
    47ea:	51 f0       	breq	.+20     	; 0x4800 <ulTaskNotifyTake+0xcc>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    47ec:	80 91 fe 04 	lds	r24, 0x04FE
    47f0:	90 91 ff 04 	lds	r25, 0x04FF
    47f4:	fc 01       	movw	r30, r24
    47f6:	11 a2       	std	Z+33, r1	; 0x21
    47f8:	12 a2       	std	Z+34, r1	; 0x22
    47fa:	13 a2       	std	Z+35, r1	; 0x23
    47fc:	14 a2       	std	Z+36, r1	; 0x24
    47fe:	11 c0       	rjmp	.+34     	; 0x4822 <ulTaskNotifyTake+0xee>
				}
				else
				{
					( pxCurrentTCB->ulNotifiedValue )--;
    4800:	20 91 fe 04 	lds	r18, 0x04FE
    4804:	30 91 ff 04 	lds	r19, 0x04FF
    4808:	f9 01       	movw	r30, r18
    480a:	81 a1       	ldd	r24, Z+33	; 0x21
    480c:	92 a1       	ldd	r25, Z+34	; 0x22
    480e:	a3 a1       	ldd	r26, Z+35	; 0x23
    4810:	b4 a1       	ldd	r27, Z+36	; 0x24
    4812:	01 97       	sbiw	r24, 0x01	; 1
    4814:	a1 09       	sbc	r26, r1
    4816:	b1 09       	sbc	r27, r1
    4818:	f9 01       	movw	r30, r18
    481a:	81 a3       	std	Z+33, r24	; 0x21
    481c:	92 a3       	std	Z+34, r25	; 0x22
    481e:	a3 a3       	std	Z+35, r26	; 0x23
    4820:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    4822:	80 91 fe 04 	lds	r24, 0x04FE
    4826:	90 91 ff 04 	lds	r25, 0x04FF
    482a:	fc 01       	movw	r30, r24
    482c:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    482e:	0f 90       	pop	r0
    4830:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    4832:	8b 81       	ldd	r24, Y+3	; 0x03
    4834:	9c 81       	ldd	r25, Y+4	; 0x04
    4836:	ad 81       	ldd	r26, Y+5	; 0x05
    4838:	be 81       	ldd	r27, Y+6	; 0x06
	}
    483a:	bc 01       	movw	r22, r24
    483c:	cd 01       	movw	r24, r26
    483e:	29 96       	adiw	r28, 0x09	; 9
    4840:	0f b6       	in	r0, 0x3f	; 63
    4842:	f8 94       	cli
    4844:	de bf       	out	0x3e, r29	; 62
    4846:	0f be       	out	0x3f, r0	; 63
    4848:	cd bf       	out	0x3d, r28	; 61
    484a:	df 91       	pop	r29
    484c:	cf 91       	pop	r28
    484e:	08 95       	ret

00004850 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    4850:	ef 92       	push	r14
    4852:	ff 92       	push	r15
    4854:	0f 93       	push	r16
    4856:	1f 93       	push	r17
    4858:	cf 93       	push	r28
    485a:	df 93       	push	r29
    485c:	cd b7       	in	r28, 0x3d	; 61
    485e:	de b7       	in	r29, 0x3e	; 62
    4860:	2f 97       	sbiw	r28, 0x0f	; 15
    4862:	0f b6       	in	r0, 0x3f	; 63
    4864:	f8 94       	cli
    4866:	de bf       	out	0x3e, r29	; 62
    4868:	0f be       	out	0x3f, r0	; 63
    486a:	cd bf       	out	0x3d, r28	; 61
    486c:	6c 83       	std	Y+4, r22	; 0x04
    486e:	7d 83       	std	Y+5, r23	; 0x05
    4870:	8e 83       	std	Y+6, r24	; 0x06
    4872:	9f 83       	std	Y+7, r25	; 0x07
    4874:	28 87       	std	Y+8, r18	; 0x08
    4876:	39 87       	std	Y+9, r19	; 0x09
    4878:	4a 87       	std	Y+10, r20	; 0x0a
    487a:	5b 87       	std	Y+11, r21	; 0x0b
    487c:	1d 87       	std	Y+13, r17	; 0x0d
    487e:	0c 87       	std	Y+12, r16	; 0x0c
    4880:	ff 86       	std	Y+15, r15	; 0x0f
    4882:	ee 86       	std	Y+14, r14	; 0x0e
	TickType_t xTimeToWake;
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    4884:	0f b6       	in	r0, 0x3f	; 63
    4886:	f8 94       	cli
    4888:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->eNotifyState != eNotified )
    488a:	80 91 fe 04 	lds	r24, 0x04FE
    488e:	90 91 ff 04 	lds	r25, 0x04FF
    4892:	fc 01       	movw	r30, r24
    4894:	85 a1       	ldd	r24, Z+37	; 0x25
    4896:	82 30       	cpi	r24, 0x02	; 2
    4898:	e1 f1       	breq	.+120    	; 0x4912 <xTaskNotifyWait+0xc2>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    489a:	60 91 fe 04 	lds	r22, 0x04FE
    489e:	70 91 ff 04 	lds	r23, 0x04FF
    48a2:	fb 01       	movw	r30, r22
    48a4:	21 a1       	ldd	r18, Z+33	; 0x21
    48a6:	32 a1       	ldd	r19, Z+34	; 0x22
    48a8:	43 a1       	ldd	r20, Z+35	; 0x23
    48aa:	54 a1       	ldd	r21, Z+36	; 0x24
    48ac:	8c 81       	ldd	r24, Y+4	; 0x04
    48ae:	9d 81       	ldd	r25, Y+5	; 0x05
    48b0:	ae 81       	ldd	r26, Y+6	; 0x06
    48b2:	bf 81       	ldd	r27, Y+7	; 0x07
    48b4:	80 95       	com	r24
    48b6:	90 95       	com	r25
    48b8:	a0 95       	com	r26
    48ba:	b0 95       	com	r27
    48bc:	82 23       	and	r24, r18
    48be:	93 23       	and	r25, r19
    48c0:	a4 23       	and	r26, r20
    48c2:	b5 23       	and	r27, r21
    48c4:	fb 01       	movw	r30, r22
    48c6:	81 a3       	std	Z+33, r24	; 0x21
    48c8:	92 a3       	std	Z+34, r25	; 0x22
    48ca:	a3 a3       	std	Z+35, r26	; 0x23
    48cc:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    48ce:	80 91 fe 04 	lds	r24, 0x04FE
    48d2:	90 91 ff 04 	lds	r25, 0x04FF
    48d6:	21 e0       	ldi	r18, 0x01	; 1
    48d8:	fc 01       	movw	r30, r24
    48da:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    48dc:	8e 85       	ldd	r24, Y+14	; 0x0e
    48de:	9f 85       	ldd	r25, Y+15	; 0x0f
    48e0:	89 2b       	or	r24, r25
    48e2:	b9 f0       	breq	.+46     	; 0x4912 <xTaskNotifyWait+0xc2>
				{
					/* The task is going to block.  First it must be removed
					from the	ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    48e4:	80 91 fe 04 	lds	r24, 0x04FE
    48e8:	90 91 ff 04 	lds	r25, 0x04FF
    48ec:	02 96       	adiw	r24, 0x02	; 2
    48ee:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>
					{
							/* Calculate the time at which the task should be
							woken if the event does not occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    48f2:	20 91 4e 05 	lds	r18, 0x054E
    48f6:	30 91 4f 05 	lds	r19, 0x054F
    48fa:	8e 85       	ldd	r24, Y+14	; 0x0e
    48fc:	9f 85       	ldd	r25, Y+15	; 0x0f
    48fe:	82 0f       	add	r24, r18
    4900:	93 1f       	adc	r25, r19
    4902:	9b 83       	std	Y+3, r25	; 0x03
    4904:	8a 83       	std	Y+2, r24	; 0x02
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    4906:	8a 81       	ldd	r24, Y+2	; 0x02
    4908:	9b 81       	ldd	r25, Y+3	; 0x03
    490a:	0e 94 9e 22 	call	0x453c	; 0x453c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    490e:	0e 94 89 13 	call	0x2712	; 0x2712 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4912:	0f 90       	pop	r0
    4914:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4916:	0f b6       	in	r0, 0x3f	; 63
    4918:	f8 94       	cli
    491a:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    491c:	8c 85       	ldd	r24, Y+12	; 0x0c
    491e:	9d 85       	ldd	r25, Y+13	; 0x0d
    4920:	89 2b       	or	r24, r25
    4922:	81 f0       	breq	.+32     	; 0x4944 <xTaskNotifyWait+0xf4>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    4924:	80 91 fe 04 	lds	r24, 0x04FE
    4928:	90 91 ff 04 	lds	r25, 0x04FF
    492c:	fc 01       	movw	r30, r24
    492e:	81 a1       	ldd	r24, Z+33	; 0x21
    4930:	92 a1       	ldd	r25, Z+34	; 0x22
    4932:	a3 a1       	ldd	r26, Z+35	; 0x23
    4934:	b4 a1       	ldd	r27, Z+36	; 0x24
    4936:	2c 85       	ldd	r18, Y+12	; 0x0c
    4938:	3d 85       	ldd	r19, Y+13	; 0x0d
    493a:	f9 01       	movw	r30, r18
    493c:	80 83       	st	Z, r24
    493e:	91 83       	std	Z+1, r25	; 0x01
    4940:	a2 83       	std	Z+2, r26	; 0x02
    4942:	b3 83       	std	Z+3, r27	; 0x03

			/* If eNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
    4944:	80 91 fe 04 	lds	r24, 0x04FE
    4948:	90 91 ff 04 	lds	r25, 0x04FF
    494c:	fc 01       	movw	r30, r24
    494e:	85 a1       	ldd	r24, Z+37	; 0x25
    4950:	81 30       	cpi	r24, 0x01	; 1
    4952:	11 f4       	brne	.+4      	; 0x4958 <xTaskNotifyWait+0x108>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4954:	19 82       	std	Y+1, r1	; 0x01
    4956:	1c c0       	rjmp	.+56     	; 0x4990 <xTaskNotifyWait+0x140>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    4958:	60 91 fe 04 	lds	r22, 0x04FE
    495c:	70 91 ff 04 	lds	r23, 0x04FF
    4960:	fb 01       	movw	r30, r22
    4962:	21 a1       	ldd	r18, Z+33	; 0x21
    4964:	32 a1       	ldd	r19, Z+34	; 0x22
    4966:	43 a1       	ldd	r20, Z+35	; 0x23
    4968:	54 a1       	ldd	r21, Z+36	; 0x24
    496a:	88 85       	ldd	r24, Y+8	; 0x08
    496c:	99 85       	ldd	r25, Y+9	; 0x09
    496e:	aa 85       	ldd	r26, Y+10	; 0x0a
    4970:	bb 85       	ldd	r27, Y+11	; 0x0b
    4972:	80 95       	com	r24
    4974:	90 95       	com	r25
    4976:	a0 95       	com	r26
    4978:	b0 95       	com	r27
    497a:	82 23       	and	r24, r18
    497c:	93 23       	and	r25, r19
    497e:	a4 23       	and	r26, r20
    4980:	b5 23       	and	r27, r21
    4982:	fb 01       	movw	r30, r22
    4984:	81 a3       	std	Z+33, r24	; 0x21
    4986:	92 a3       	std	Z+34, r25	; 0x22
    4988:	a3 a3       	std	Z+35, r26	; 0x23
    498a:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    498c:	81 e0       	ldi	r24, 0x01	; 1
    498e:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    4990:	80 91 fe 04 	lds	r24, 0x04FE
    4994:	90 91 ff 04 	lds	r25, 0x04FF
    4998:	fc 01       	movw	r30, r24
    499a:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    499c:	0f 90       	pop	r0
    499e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    49a0:	89 81       	ldd	r24, Y+1	; 0x01
	}
    49a2:	2f 96       	adiw	r28, 0x0f	; 15
    49a4:	0f b6       	in	r0, 0x3f	; 63
    49a6:	f8 94       	cli
    49a8:	de bf       	out	0x3e, r29	; 62
    49aa:	0f be       	out	0x3f, r0	; 63
    49ac:	cd bf       	out	0x3d, r28	; 61
    49ae:	df 91       	pop	r29
    49b0:	cf 91       	pop	r28
    49b2:	1f 91       	pop	r17
    49b4:	0f 91       	pop	r16
    49b6:	ff 90       	pop	r15
    49b8:	ef 90       	pop	r14
    49ba:	08 95       	ret

000049bc <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    49bc:	0f 93       	push	r16
    49be:	1f 93       	push	r17
    49c0:	cf 93       	push	r28
    49c2:	df 93       	push	r29
    49c4:	cd b7       	in	r28, 0x3d	; 61
    49c6:	de b7       	in	r29, 0x3e	; 62
    49c8:	2d 97       	sbiw	r28, 0x0d	; 13
    49ca:	0f b6       	in	r0, 0x3f	; 63
    49cc:	f8 94       	cli
    49ce:	de bf       	out	0x3e, r29	; 62
    49d0:	0f be       	out	0x3f, r0	; 63
    49d2:	cd bf       	out	0x3d, r28	; 61
    49d4:	9e 83       	std	Y+6, r25	; 0x06
    49d6:	8d 83       	std	Y+5, r24	; 0x05
    49d8:	4f 83       	std	Y+7, r20	; 0x07
    49da:	58 87       	std	Y+8, r21	; 0x08
    49dc:	69 87       	std	Y+9, r22	; 0x09
    49de:	7a 87       	std	Y+10, r23	; 0x0a
    49e0:	2b 87       	std	Y+11, r18	; 0x0b
    49e2:	1d 87       	std	Y+13, r17	; 0x0d
    49e4:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    49e6:	81 e0       	ldi	r24, 0x01	; 1
    49e8:	89 83       	std	Y+1, r24	; 0x01

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
    49ea:	8d 81       	ldd	r24, Y+5	; 0x05
    49ec:	9e 81       	ldd	r25, Y+6	; 0x06
    49ee:	9b 83       	std	Y+3, r25	; 0x03
    49f0:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    49f2:	0f b6       	in	r0, 0x3f	; 63
    49f4:	f8 94       	cli
    49f6:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    49f8:	8c 85       	ldd	r24, Y+12	; 0x0c
    49fa:	9d 85       	ldd	r25, Y+13	; 0x0d
    49fc:	89 2b       	or	r24, r25
    49fe:	71 f0       	breq	.+28     	; 0x4a1c <xTaskGenericNotify+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4a00:	8a 81       	ldd	r24, Y+2	; 0x02
    4a02:	9b 81       	ldd	r25, Y+3	; 0x03
    4a04:	fc 01       	movw	r30, r24
    4a06:	81 a1       	ldd	r24, Z+33	; 0x21
    4a08:	92 a1       	ldd	r25, Z+34	; 0x22
    4a0a:	a3 a1       	ldd	r26, Z+35	; 0x23
    4a0c:	b4 a1       	ldd	r27, Z+36	; 0x24
    4a0e:	2c 85       	ldd	r18, Y+12	; 0x0c
    4a10:	3d 85       	ldd	r19, Y+13	; 0x0d
    4a12:	f9 01       	movw	r30, r18
    4a14:	80 83       	st	Z, r24
    4a16:	91 83       	std	Z+1, r25	; 0x01
    4a18:	a2 83       	std	Z+2, r26	; 0x02
    4a1a:	b3 83       	std	Z+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    4a1c:	8a 81       	ldd	r24, Y+2	; 0x02
    4a1e:	9b 81       	ldd	r25, Y+3	; 0x03
    4a20:	fc 01       	movw	r30, r24
    4a22:	85 a1       	ldd	r24, Z+37	; 0x25
    4a24:	8c 83       	std	Y+4, r24	; 0x04

			pxTCB->eNotifyState = eNotified;
    4a26:	8a 81       	ldd	r24, Y+2	; 0x02
    4a28:	9b 81       	ldd	r25, Y+3	; 0x03
    4a2a:	22 e0       	ldi	r18, 0x02	; 2
    4a2c:	fc 01       	movw	r30, r24
    4a2e:	25 a3       	std	Z+37, r18	; 0x25

			switch( eAction )
    4a30:	8b 85       	ldd	r24, Y+11	; 0x0b
    4a32:	88 2f       	mov	r24, r24
    4a34:	90 e0       	ldi	r25, 0x00	; 0
    4a36:	82 30       	cpi	r24, 0x02	; 2
    4a38:	91 05       	cpc	r25, r1
    4a3a:	31 f1       	breq	.+76     	; 0x4a88 <xTaskGenericNotify+0xcc>
    4a3c:	83 30       	cpi	r24, 0x03	; 3
    4a3e:	91 05       	cpc	r25, r1
    4a40:	34 f4       	brge	.+12     	; 0x4a4e <xTaskGenericNotify+0x92>
    4a42:	00 97       	sbiw	r24, 0x00	; 0
    4a44:	09 f4       	brne	.+2      	; 0x4a48 <xTaskGenericNotify+0x8c>
    4a46:	4f c0       	rjmp	.+158    	; 0x4ae6 <xTaskGenericNotify+0x12a>
    4a48:	01 97       	sbiw	r24, 0x01	; 1
    4a4a:	39 f0       	breq	.+14     	; 0x4a5a <xTaskGenericNotify+0x9e>
    4a4c:	4d c0       	rjmp	.+154    	; 0x4ae8 <xTaskGenericNotify+0x12c>
    4a4e:	83 30       	cpi	r24, 0x03	; 3
    4a50:	91 05       	cpc	r25, r1
    4a52:	61 f1       	breq	.+88     	; 0x4aac <xTaskGenericNotify+0xf0>
    4a54:	04 97       	sbiw	r24, 0x04	; 4
    4a56:	b1 f1       	breq	.+108    	; 0x4ac4 <xTaskGenericNotify+0x108>
    4a58:	47 c0       	rjmp	.+142    	; 0x4ae8 <xTaskGenericNotify+0x12c>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4a5a:	8a 81       	ldd	r24, Y+2	; 0x02
    4a5c:	9b 81       	ldd	r25, Y+3	; 0x03
    4a5e:	fc 01       	movw	r30, r24
    4a60:	21 a1       	ldd	r18, Z+33	; 0x21
    4a62:	32 a1       	ldd	r19, Z+34	; 0x22
    4a64:	43 a1       	ldd	r20, Z+35	; 0x23
    4a66:	54 a1       	ldd	r21, Z+36	; 0x24
    4a68:	8f 81       	ldd	r24, Y+7	; 0x07
    4a6a:	98 85       	ldd	r25, Y+8	; 0x08
    4a6c:	a9 85       	ldd	r26, Y+9	; 0x09
    4a6e:	ba 85       	ldd	r27, Y+10	; 0x0a
    4a70:	82 2b       	or	r24, r18
    4a72:	93 2b       	or	r25, r19
    4a74:	a4 2b       	or	r26, r20
    4a76:	b5 2b       	or	r27, r21
    4a78:	2a 81       	ldd	r18, Y+2	; 0x02
    4a7a:	3b 81       	ldd	r19, Y+3	; 0x03
    4a7c:	f9 01       	movw	r30, r18
    4a7e:	81 a3       	std	Z+33, r24	; 0x21
    4a80:	92 a3       	std	Z+34, r25	; 0x22
    4a82:	a3 a3       	std	Z+35, r26	; 0x23
    4a84:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    4a86:	30 c0       	rjmp	.+96     	; 0x4ae8 <xTaskGenericNotify+0x12c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4a88:	8a 81       	ldd	r24, Y+2	; 0x02
    4a8a:	9b 81       	ldd	r25, Y+3	; 0x03
    4a8c:	fc 01       	movw	r30, r24
    4a8e:	81 a1       	ldd	r24, Z+33	; 0x21
    4a90:	92 a1       	ldd	r25, Z+34	; 0x22
    4a92:	a3 a1       	ldd	r26, Z+35	; 0x23
    4a94:	b4 a1       	ldd	r27, Z+36	; 0x24
    4a96:	01 96       	adiw	r24, 0x01	; 1
    4a98:	a1 1d       	adc	r26, r1
    4a9a:	b1 1d       	adc	r27, r1
    4a9c:	2a 81       	ldd	r18, Y+2	; 0x02
    4a9e:	3b 81       	ldd	r19, Y+3	; 0x03
    4aa0:	f9 01       	movw	r30, r18
    4aa2:	81 a3       	std	Z+33, r24	; 0x21
    4aa4:	92 a3       	std	Z+34, r25	; 0x22
    4aa6:	a3 a3       	std	Z+35, r26	; 0x23
    4aa8:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    4aaa:	1e c0       	rjmp	.+60     	; 0x4ae8 <xTaskGenericNotify+0x12c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4aac:	2a 81       	ldd	r18, Y+2	; 0x02
    4aae:	3b 81       	ldd	r19, Y+3	; 0x03
    4ab0:	8f 81       	ldd	r24, Y+7	; 0x07
    4ab2:	98 85       	ldd	r25, Y+8	; 0x08
    4ab4:	a9 85       	ldd	r26, Y+9	; 0x09
    4ab6:	ba 85       	ldd	r27, Y+10	; 0x0a
    4ab8:	f9 01       	movw	r30, r18
    4aba:	81 a3       	std	Z+33, r24	; 0x21
    4abc:	92 a3       	std	Z+34, r25	; 0x22
    4abe:	a3 a3       	std	Z+35, r26	; 0x23
    4ac0:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    4ac2:	12 c0       	rjmp	.+36     	; 0x4ae8 <xTaskGenericNotify+0x12c>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    4ac4:	8c 81       	ldd	r24, Y+4	; 0x04
    4ac6:	82 30       	cpi	r24, 0x02	; 2
    4ac8:	61 f0       	breq	.+24     	; 0x4ae2 <xTaskGenericNotify+0x126>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4aca:	2a 81       	ldd	r18, Y+2	; 0x02
    4acc:	3b 81       	ldd	r19, Y+3	; 0x03
    4ace:	8f 81       	ldd	r24, Y+7	; 0x07
    4ad0:	98 85       	ldd	r25, Y+8	; 0x08
    4ad2:	a9 85       	ldd	r26, Y+9	; 0x09
    4ad4:	ba 85       	ldd	r27, Y+10	; 0x0a
    4ad6:	f9 01       	movw	r30, r18
    4ad8:	81 a3       	std	Z+33, r24	; 0x21
    4ada:	92 a3       	std	Z+34, r25	; 0x22
    4adc:	a3 a3       	std	Z+35, r26	; 0x23
    4ade:	b4 a3       	std	Z+36, r27	; 0x24
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    4ae0:	03 c0       	rjmp	.+6      	; 0x4ae8 <xTaskGenericNotify+0x12c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4ae2:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    4ae4:	01 c0       	rjmp	.+2      	; 0x4ae8 <xTaskGenericNotify+0x12c>

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
    4ae6:	00 00       	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    4ae8:	8c 81       	ldd	r24, Y+4	; 0x04
    4aea:	81 30       	cpi	r24, 0x01	; 1
    4aec:	d1 f5       	brne	.+116    	; 0x4b62 <xTaskGenericNotify+0x1a6>
			{
				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    4aee:	8a 81       	ldd	r24, Y+2	; 0x02
    4af0:	9b 81       	ldd	r25, Y+3	; 0x03
    4af2:	02 96       	adiw	r24, 0x02	; 2
    4af4:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    4af8:	8a 81       	ldd	r24, Y+2	; 0x02
    4afa:	9b 81       	ldd	r25, Y+3	; 0x03
    4afc:	fc 01       	movw	r30, r24
    4afe:	96 89       	ldd	r25, Z+22	; 0x16
    4b00:	80 91 50 05 	lds	r24, 0x0550
    4b04:	89 17       	cp	r24, r25
    4b06:	30 f4       	brcc	.+12     	; 0x4b14 <xTaskGenericNotify+0x158>
    4b08:	8a 81       	ldd	r24, Y+2	; 0x02
    4b0a:	9b 81       	ldd	r25, Y+3	; 0x03
    4b0c:	fc 01       	movw	r30, r24
    4b0e:	86 89       	ldd	r24, Z+22	; 0x16
    4b10:	80 93 50 05 	sts	0x0550, r24
    4b14:	8a 81       	ldd	r24, Y+2	; 0x02
    4b16:	9b 81       	ldd	r25, Y+3	; 0x03
    4b18:	ac 01       	movw	r20, r24
    4b1a:	4e 5f       	subi	r20, 0xFE	; 254
    4b1c:	5f 4f       	sbci	r21, 0xFF	; 255
    4b1e:	8a 81       	ldd	r24, Y+2	; 0x02
    4b20:	9b 81       	ldd	r25, Y+3	; 0x03
    4b22:	fc 01       	movw	r30, r24
    4b24:	86 89       	ldd	r24, Z+22	; 0x16
    4b26:	28 2f       	mov	r18, r24
    4b28:	30 e0       	ldi	r19, 0x00	; 0
    4b2a:	c9 01       	movw	r24, r18
    4b2c:	88 0f       	add	r24, r24
    4b2e:	99 1f       	adc	r25, r25
    4b30:	88 0f       	add	r24, r24
    4b32:	99 1f       	adc	r25, r25
    4b34:	88 0f       	add	r24, r24
    4b36:	99 1f       	adc	r25, r25
    4b38:	82 0f       	add	r24, r18
    4b3a:	93 1f       	adc	r25, r19
    4b3c:	80 50       	subi	r24, 0x00	; 0
    4b3e:	9b 4f       	sbci	r25, 0xFB	; 251
    4b40:	ba 01       	movw	r22, r20
    4b42:	0e 94 88 10 	call	0x2110	; 0x2110 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4b46:	8a 81       	ldd	r24, Y+2	; 0x02
    4b48:	9b 81       	ldd	r25, Y+3	; 0x03
    4b4a:	fc 01       	movw	r30, r24
    4b4c:	26 89       	ldd	r18, Z+22	; 0x16
    4b4e:	80 91 fe 04 	lds	r24, 0x04FE
    4b52:	90 91 ff 04 	lds	r25, 0x04FF
    4b56:	fc 01       	movw	r30, r24
    4b58:	86 89       	ldd	r24, Z+22	; 0x16
    4b5a:	82 17       	cp	r24, r18
    4b5c:	10 f4       	brcc	.+4      	; 0x4b62 <xTaskGenericNotify+0x1a6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    4b5e:	0e 94 89 13 	call	0x2712	; 0x2712 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4b62:	0f 90       	pop	r0
    4b64:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4b66:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4b68:	2d 96       	adiw	r28, 0x0d	; 13
    4b6a:	0f b6       	in	r0, 0x3f	; 63
    4b6c:	f8 94       	cli
    4b6e:	de bf       	out	0x3e, r29	; 62
    4b70:	0f be       	out	0x3f, r0	; 63
    4b72:	cd bf       	out	0x3d, r28	; 61
    4b74:	df 91       	pop	r29
    4b76:	cf 91       	pop	r28
    4b78:	1f 91       	pop	r17
    4b7a:	0f 91       	pop	r16
    4b7c:	08 95       	ret

00004b7e <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4b7e:	ef 92       	push	r14
    4b80:	ff 92       	push	r15
    4b82:	0f 93       	push	r16
    4b84:	1f 93       	push	r17
    4b86:	cf 93       	push	r28
    4b88:	df 93       	push	r29
    4b8a:	cd b7       	in	r28, 0x3d	; 61
    4b8c:	de b7       	in	r29, 0x3e	; 62
    4b8e:	60 97       	sbiw	r28, 0x10	; 16
    4b90:	0f b6       	in	r0, 0x3f	; 63
    4b92:	f8 94       	cli
    4b94:	de bf       	out	0x3e, r29	; 62
    4b96:	0f be       	out	0x3f, r0	; 63
    4b98:	cd bf       	out	0x3d, r28	; 61
    4b9a:	9f 83       	std	Y+7, r25	; 0x07
    4b9c:	8e 83       	std	Y+6, r24	; 0x06
    4b9e:	48 87       	std	Y+8, r20	; 0x08
    4ba0:	59 87       	std	Y+9, r21	; 0x09
    4ba2:	6a 87       	std	Y+10, r22	; 0x0a
    4ba4:	7b 87       	std	Y+11, r23	; 0x0b
    4ba6:	2c 87       	std	Y+12, r18	; 0x0c
    4ba8:	1e 87       	std	Y+14, r17	; 0x0e
    4baa:	0d 87       	std	Y+13, r16	; 0x0d
    4bac:	f8 8a       	std	Y+16, r15	; 0x10
    4bae:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    4bb0:	81 e0       	ldi	r24, 0x01	; 1
    4bb2:	89 83       	std	Y+1, r24	; 0x01
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    4bb4:	8e 81       	ldd	r24, Y+6	; 0x06
    4bb6:	9f 81       	ldd	r25, Y+7	; 0x07
    4bb8:	9b 83       	std	Y+3, r25	; 0x03
    4bba:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4bbc:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( pulPreviousNotificationValue != NULL )
    4bbe:	8d 85       	ldd	r24, Y+13	; 0x0d
    4bc0:	9e 85       	ldd	r25, Y+14	; 0x0e
    4bc2:	89 2b       	or	r24, r25
    4bc4:	71 f0       	breq	.+28     	; 0x4be2 <xTaskGenericNotifyFromISR+0x64>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4bc6:	8a 81       	ldd	r24, Y+2	; 0x02
    4bc8:	9b 81       	ldd	r25, Y+3	; 0x03
    4bca:	fc 01       	movw	r30, r24
    4bcc:	81 a1       	ldd	r24, Z+33	; 0x21
    4bce:	92 a1       	ldd	r25, Z+34	; 0x22
    4bd0:	a3 a1       	ldd	r26, Z+35	; 0x23
    4bd2:	b4 a1       	ldd	r27, Z+36	; 0x24
    4bd4:	2d 85       	ldd	r18, Y+13	; 0x0d
    4bd6:	3e 85       	ldd	r19, Y+14	; 0x0e
    4bd8:	f9 01       	movw	r30, r18
    4bda:	80 83       	st	Z, r24
    4bdc:	91 83       	std	Z+1, r25	; 0x01
    4bde:	a2 83       	std	Z+2, r26	; 0x02
    4be0:	b3 83       	std	Z+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    4be2:	8a 81       	ldd	r24, Y+2	; 0x02
    4be4:	9b 81       	ldd	r25, Y+3	; 0x03
    4be6:	fc 01       	movw	r30, r24
    4be8:	85 a1       	ldd	r24, Z+37	; 0x25
    4bea:	8d 83       	std	Y+5, r24	; 0x05
			pxTCB->eNotifyState = eNotified;
    4bec:	8a 81       	ldd	r24, Y+2	; 0x02
    4bee:	9b 81       	ldd	r25, Y+3	; 0x03
    4bf0:	22 e0       	ldi	r18, 0x02	; 2
    4bf2:	fc 01       	movw	r30, r24
    4bf4:	25 a3       	std	Z+37, r18	; 0x25

			switch( eAction )
    4bf6:	8c 85       	ldd	r24, Y+12	; 0x0c
    4bf8:	88 2f       	mov	r24, r24
    4bfa:	90 e0       	ldi	r25, 0x00	; 0
    4bfc:	82 30       	cpi	r24, 0x02	; 2
    4bfe:	91 05       	cpc	r25, r1
    4c00:	31 f1       	breq	.+76     	; 0x4c4e <xTaskGenericNotifyFromISR+0xd0>
    4c02:	83 30       	cpi	r24, 0x03	; 3
    4c04:	91 05       	cpc	r25, r1
    4c06:	34 f4       	brge	.+12     	; 0x4c14 <xTaskGenericNotifyFromISR+0x96>
    4c08:	00 97       	sbiw	r24, 0x00	; 0
    4c0a:	09 f4       	brne	.+2      	; 0x4c0e <xTaskGenericNotifyFromISR+0x90>
    4c0c:	4f c0       	rjmp	.+158    	; 0x4cac <xTaskGenericNotifyFromISR+0x12e>
    4c0e:	01 97       	sbiw	r24, 0x01	; 1
    4c10:	39 f0       	breq	.+14     	; 0x4c20 <xTaskGenericNotifyFromISR+0xa2>
    4c12:	4d c0       	rjmp	.+154    	; 0x4cae <xTaskGenericNotifyFromISR+0x130>
    4c14:	83 30       	cpi	r24, 0x03	; 3
    4c16:	91 05       	cpc	r25, r1
    4c18:	61 f1       	breq	.+88     	; 0x4c72 <xTaskGenericNotifyFromISR+0xf4>
    4c1a:	04 97       	sbiw	r24, 0x04	; 4
    4c1c:	b1 f1       	breq	.+108    	; 0x4c8a <xTaskGenericNotifyFromISR+0x10c>
    4c1e:	47 c0       	rjmp	.+142    	; 0x4cae <xTaskGenericNotifyFromISR+0x130>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4c20:	8a 81       	ldd	r24, Y+2	; 0x02
    4c22:	9b 81       	ldd	r25, Y+3	; 0x03
    4c24:	fc 01       	movw	r30, r24
    4c26:	21 a1       	ldd	r18, Z+33	; 0x21
    4c28:	32 a1       	ldd	r19, Z+34	; 0x22
    4c2a:	43 a1       	ldd	r20, Z+35	; 0x23
    4c2c:	54 a1       	ldd	r21, Z+36	; 0x24
    4c2e:	88 85       	ldd	r24, Y+8	; 0x08
    4c30:	99 85       	ldd	r25, Y+9	; 0x09
    4c32:	aa 85       	ldd	r26, Y+10	; 0x0a
    4c34:	bb 85       	ldd	r27, Y+11	; 0x0b
    4c36:	82 2b       	or	r24, r18
    4c38:	93 2b       	or	r25, r19
    4c3a:	a4 2b       	or	r26, r20
    4c3c:	b5 2b       	or	r27, r21
    4c3e:	2a 81       	ldd	r18, Y+2	; 0x02
    4c40:	3b 81       	ldd	r19, Y+3	; 0x03
    4c42:	f9 01       	movw	r30, r18
    4c44:	81 a3       	std	Z+33, r24	; 0x21
    4c46:	92 a3       	std	Z+34, r25	; 0x22
    4c48:	a3 a3       	std	Z+35, r26	; 0x23
    4c4a:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    4c4c:	30 c0       	rjmp	.+96     	; 0x4cae <xTaskGenericNotifyFromISR+0x130>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4c4e:	8a 81       	ldd	r24, Y+2	; 0x02
    4c50:	9b 81       	ldd	r25, Y+3	; 0x03
    4c52:	fc 01       	movw	r30, r24
    4c54:	81 a1       	ldd	r24, Z+33	; 0x21
    4c56:	92 a1       	ldd	r25, Z+34	; 0x22
    4c58:	a3 a1       	ldd	r26, Z+35	; 0x23
    4c5a:	b4 a1       	ldd	r27, Z+36	; 0x24
    4c5c:	01 96       	adiw	r24, 0x01	; 1
    4c5e:	a1 1d       	adc	r26, r1
    4c60:	b1 1d       	adc	r27, r1
    4c62:	2a 81       	ldd	r18, Y+2	; 0x02
    4c64:	3b 81       	ldd	r19, Y+3	; 0x03
    4c66:	f9 01       	movw	r30, r18
    4c68:	81 a3       	std	Z+33, r24	; 0x21
    4c6a:	92 a3       	std	Z+34, r25	; 0x22
    4c6c:	a3 a3       	std	Z+35, r26	; 0x23
    4c6e:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    4c70:	1e c0       	rjmp	.+60     	; 0x4cae <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4c72:	2a 81       	ldd	r18, Y+2	; 0x02
    4c74:	3b 81       	ldd	r19, Y+3	; 0x03
    4c76:	88 85       	ldd	r24, Y+8	; 0x08
    4c78:	99 85       	ldd	r25, Y+9	; 0x09
    4c7a:	aa 85       	ldd	r26, Y+10	; 0x0a
    4c7c:	bb 85       	ldd	r27, Y+11	; 0x0b
    4c7e:	f9 01       	movw	r30, r18
    4c80:	81 a3       	std	Z+33, r24	; 0x21
    4c82:	92 a3       	std	Z+34, r25	; 0x22
    4c84:	a3 a3       	std	Z+35, r26	; 0x23
    4c86:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    4c88:	12 c0       	rjmp	.+36     	; 0x4cae <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    4c8a:	8d 81       	ldd	r24, Y+5	; 0x05
    4c8c:	82 30       	cpi	r24, 0x02	; 2
    4c8e:	61 f0       	breq	.+24     	; 0x4ca8 <xTaskGenericNotifyFromISR+0x12a>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4c90:	2a 81       	ldd	r18, Y+2	; 0x02
    4c92:	3b 81       	ldd	r19, Y+3	; 0x03
    4c94:	88 85       	ldd	r24, Y+8	; 0x08
    4c96:	99 85       	ldd	r25, Y+9	; 0x09
    4c98:	aa 85       	ldd	r26, Y+10	; 0x0a
    4c9a:	bb 85       	ldd	r27, Y+11	; 0x0b
    4c9c:	f9 01       	movw	r30, r18
    4c9e:	81 a3       	std	Z+33, r24	; 0x21
    4ca0:	92 a3       	std	Z+34, r25	; 0x22
    4ca2:	a3 a3       	std	Z+35, r26	; 0x23
    4ca4:	b4 a3       	std	Z+36, r27	; 0x24
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    4ca6:	03 c0       	rjmp	.+6      	; 0x4cae <xTaskGenericNotifyFromISR+0x130>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4ca8:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    4caa:	01 c0       	rjmp	.+2      	; 0x4cae <xTaskGenericNotifyFromISR+0x130>

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
    4cac:	00 00       	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    4cae:	8d 81       	ldd	r24, Y+5	; 0x05
    4cb0:	81 30       	cpi	r24, 0x01	; 1
    4cb2:	09 f0       	breq	.+2      	; 0x4cb6 <xTaskGenericNotifyFromISR+0x138>
    4cb4:	4e c0       	rjmp	.+156    	; 0x4d52 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4cb6:	80 91 58 05 	lds	r24, 0x0558
    4cba:	88 23       	and	r24, r24
    4cbc:	69 f5       	brne	.+90     	; 0x4d18 <xTaskGenericNotifyFromISR+0x19a>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    4cbe:	8a 81       	ldd	r24, Y+2	; 0x02
    4cc0:	9b 81       	ldd	r25, Y+3	; 0x03
    4cc2:	02 96       	adiw	r24, 0x02	; 2
    4cc4:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4cc8:	8a 81       	ldd	r24, Y+2	; 0x02
    4cca:	9b 81       	ldd	r25, Y+3	; 0x03
    4ccc:	fc 01       	movw	r30, r24
    4cce:	96 89       	ldd	r25, Z+22	; 0x16
    4cd0:	80 91 50 05 	lds	r24, 0x0550
    4cd4:	89 17       	cp	r24, r25
    4cd6:	30 f4       	brcc	.+12     	; 0x4ce4 <xTaskGenericNotifyFromISR+0x166>
    4cd8:	8a 81       	ldd	r24, Y+2	; 0x02
    4cda:	9b 81       	ldd	r25, Y+3	; 0x03
    4cdc:	fc 01       	movw	r30, r24
    4cde:	86 89       	ldd	r24, Z+22	; 0x16
    4ce0:	80 93 50 05 	sts	0x0550, r24
    4ce4:	8a 81       	ldd	r24, Y+2	; 0x02
    4ce6:	9b 81       	ldd	r25, Y+3	; 0x03
    4ce8:	ac 01       	movw	r20, r24
    4cea:	4e 5f       	subi	r20, 0xFE	; 254
    4cec:	5f 4f       	sbci	r21, 0xFF	; 255
    4cee:	8a 81       	ldd	r24, Y+2	; 0x02
    4cf0:	9b 81       	ldd	r25, Y+3	; 0x03
    4cf2:	fc 01       	movw	r30, r24
    4cf4:	86 89       	ldd	r24, Z+22	; 0x16
    4cf6:	28 2f       	mov	r18, r24
    4cf8:	30 e0       	ldi	r19, 0x00	; 0
    4cfa:	c9 01       	movw	r24, r18
    4cfc:	88 0f       	add	r24, r24
    4cfe:	99 1f       	adc	r25, r25
    4d00:	88 0f       	add	r24, r24
    4d02:	99 1f       	adc	r25, r25
    4d04:	88 0f       	add	r24, r24
    4d06:	99 1f       	adc	r25, r25
    4d08:	82 0f       	add	r24, r18
    4d0a:	93 1f       	adc	r25, r19
    4d0c:	80 50       	subi	r24, 0x00	; 0
    4d0e:	9b 4f       	sbci	r25, 0xFB	; 251
    4d10:	ba 01       	movw	r22, r20
    4d12:	0e 94 88 10 	call	0x2110	; 0x2110 <vListInsertEnd>
    4d16:	08 c0       	rjmp	.+16     	; 0x4d28 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4d18:	8a 81       	ldd	r24, Y+2	; 0x02
    4d1a:	9b 81       	ldd	r25, Y+3	; 0x03
    4d1c:	0c 96       	adiw	r24, 0x0c	; 12
    4d1e:	bc 01       	movw	r22, r24
    4d20:	8a e3       	ldi	r24, 0x3A	; 58
    4d22:	95 e0       	ldi	r25, 0x05	; 5
    4d24:	0e 94 88 10 	call	0x2110	; 0x2110 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4d28:	8a 81       	ldd	r24, Y+2	; 0x02
    4d2a:	9b 81       	ldd	r25, Y+3	; 0x03
    4d2c:	fc 01       	movw	r30, r24
    4d2e:	26 89       	ldd	r18, Z+22	; 0x16
    4d30:	80 91 fe 04 	lds	r24, 0x04FE
    4d34:	90 91 ff 04 	lds	r25, 0x04FF
    4d38:	fc 01       	movw	r30, r24
    4d3a:	86 89       	ldd	r24, Z+22	; 0x16
    4d3c:	82 17       	cp	r24, r18
    4d3e:	48 f4       	brcc	.+18     	; 0x4d52 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4d40:	8f 85       	ldd	r24, Y+15	; 0x0f
    4d42:	98 89       	ldd	r25, Y+16	; 0x10
    4d44:	89 2b       	or	r24, r25
    4d46:	29 f0       	breq	.+10     	; 0x4d52 <xTaskGenericNotifyFromISR+0x1d4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4d48:	8f 85       	ldd	r24, Y+15	; 0x0f
    4d4a:	98 89       	ldd	r25, Y+16	; 0x10
    4d4c:	21 e0       	ldi	r18, 0x01	; 1
    4d4e:	fc 01       	movw	r30, r24
    4d50:	20 83       	st	Z, r18
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    4d52:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4d54:	60 96       	adiw	r28, 0x10	; 16
    4d56:	0f b6       	in	r0, 0x3f	; 63
    4d58:	f8 94       	cli
    4d5a:	de bf       	out	0x3e, r29	; 62
    4d5c:	0f be       	out	0x3f, r0	; 63
    4d5e:	cd bf       	out	0x3d, r28	; 61
    4d60:	df 91       	pop	r29
    4d62:	cf 91       	pop	r28
    4d64:	1f 91       	pop	r17
    4d66:	0f 91       	pop	r16
    4d68:	ff 90       	pop	r15
    4d6a:	ef 90       	pop	r14
    4d6c:	08 95       	ret

00004d6e <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4d6e:	cf 93       	push	r28
    4d70:	df 93       	push	r29
    4d72:	cd b7       	in	r28, 0x3d	; 61
    4d74:	de b7       	in	r29, 0x3e	; 62
    4d76:	28 97       	sbiw	r28, 0x08	; 8
    4d78:	0f b6       	in	r0, 0x3f	; 63
    4d7a:	f8 94       	cli
    4d7c:	de bf       	out	0x3e, r29	; 62
    4d7e:	0f be       	out	0x3f, r0	; 63
    4d80:	cd bf       	out	0x3d, r28	; 61
    4d82:	9e 83       	std	Y+6, r25	; 0x06
    4d84:	8d 83       	std	Y+5, r24	; 0x05
    4d86:	78 87       	std	Y+8, r23	; 0x08
    4d88:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    4d8a:	8d 81       	ldd	r24, Y+5	; 0x05
    4d8c:	9e 81       	ldd	r25, Y+6	; 0x06
    4d8e:	9a 83       	std	Y+2, r25	; 0x02
    4d90:	89 83       	std	Y+1, r24	; 0x01

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4d92:	1b 82       	std	Y+3, r1	; 0x03
		{
			eOriginalNotifyState = pxTCB->eNotifyState;
    4d94:	89 81       	ldd	r24, Y+1	; 0x01
    4d96:	9a 81       	ldd	r25, Y+2	; 0x02
    4d98:	fc 01       	movw	r30, r24
    4d9a:	85 a1       	ldd	r24, Z+37	; 0x25
    4d9c:	8c 83       	std	Y+4, r24	; 0x04
			pxTCB->eNotifyState = eNotified;
    4d9e:	89 81       	ldd	r24, Y+1	; 0x01
    4da0:	9a 81       	ldd	r25, Y+2	; 0x02
    4da2:	22 e0       	ldi	r18, 0x02	; 2
    4da4:	fc 01       	movw	r30, r24
    4da6:	25 a3       	std	Z+37, r18	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    4da8:	89 81       	ldd	r24, Y+1	; 0x01
    4daa:	9a 81       	ldd	r25, Y+2	; 0x02
    4dac:	fc 01       	movw	r30, r24
    4dae:	81 a1       	ldd	r24, Z+33	; 0x21
    4db0:	92 a1       	ldd	r25, Z+34	; 0x22
    4db2:	a3 a1       	ldd	r26, Z+35	; 0x23
    4db4:	b4 a1       	ldd	r27, Z+36	; 0x24
    4db6:	01 96       	adiw	r24, 0x01	; 1
    4db8:	a1 1d       	adc	r26, r1
    4dba:	b1 1d       	adc	r27, r1
    4dbc:	29 81       	ldd	r18, Y+1	; 0x01
    4dbe:	3a 81       	ldd	r19, Y+2	; 0x02
    4dc0:	f9 01       	movw	r30, r18
    4dc2:	81 a3       	std	Z+33, r24	; 0x21
    4dc4:	92 a3       	std	Z+34, r25	; 0x22
    4dc6:	a3 a3       	std	Z+35, r26	; 0x23
    4dc8:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    4dca:	8c 81       	ldd	r24, Y+4	; 0x04
    4dcc:	81 30       	cpi	r24, 0x01	; 1
    4dce:	09 f0       	breq	.+2      	; 0x4dd2 <vTaskNotifyGiveFromISR+0x64>
    4dd0:	4e c0       	rjmp	.+156    	; 0x4e6e <vTaskNotifyGiveFromISR+0x100>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4dd2:	80 91 58 05 	lds	r24, 0x0558
    4dd6:	88 23       	and	r24, r24
    4dd8:	69 f5       	brne	.+90     	; 0x4e34 <vTaskNotifyGiveFromISR+0xc6>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    4dda:	89 81       	ldd	r24, Y+1	; 0x01
    4ddc:	9a 81       	ldd	r25, Y+2	; 0x02
    4dde:	02 96       	adiw	r24, 0x02	; 2
    4de0:	0e 94 4d 11 	call	0x229a	; 0x229a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4de4:	89 81       	ldd	r24, Y+1	; 0x01
    4de6:	9a 81       	ldd	r25, Y+2	; 0x02
    4de8:	fc 01       	movw	r30, r24
    4dea:	96 89       	ldd	r25, Z+22	; 0x16
    4dec:	80 91 50 05 	lds	r24, 0x0550
    4df0:	89 17       	cp	r24, r25
    4df2:	30 f4       	brcc	.+12     	; 0x4e00 <vTaskNotifyGiveFromISR+0x92>
    4df4:	89 81       	ldd	r24, Y+1	; 0x01
    4df6:	9a 81       	ldd	r25, Y+2	; 0x02
    4df8:	fc 01       	movw	r30, r24
    4dfa:	86 89       	ldd	r24, Z+22	; 0x16
    4dfc:	80 93 50 05 	sts	0x0550, r24
    4e00:	89 81       	ldd	r24, Y+1	; 0x01
    4e02:	9a 81       	ldd	r25, Y+2	; 0x02
    4e04:	ac 01       	movw	r20, r24
    4e06:	4e 5f       	subi	r20, 0xFE	; 254
    4e08:	5f 4f       	sbci	r21, 0xFF	; 255
    4e0a:	89 81       	ldd	r24, Y+1	; 0x01
    4e0c:	9a 81       	ldd	r25, Y+2	; 0x02
    4e0e:	fc 01       	movw	r30, r24
    4e10:	86 89       	ldd	r24, Z+22	; 0x16
    4e12:	28 2f       	mov	r18, r24
    4e14:	30 e0       	ldi	r19, 0x00	; 0
    4e16:	c9 01       	movw	r24, r18
    4e18:	88 0f       	add	r24, r24
    4e1a:	99 1f       	adc	r25, r25
    4e1c:	88 0f       	add	r24, r24
    4e1e:	99 1f       	adc	r25, r25
    4e20:	88 0f       	add	r24, r24
    4e22:	99 1f       	adc	r25, r25
    4e24:	82 0f       	add	r24, r18
    4e26:	93 1f       	adc	r25, r19
    4e28:	80 50       	subi	r24, 0x00	; 0
    4e2a:	9b 4f       	sbci	r25, 0xFB	; 251
    4e2c:	ba 01       	movw	r22, r20
    4e2e:	0e 94 88 10 	call	0x2110	; 0x2110 <vListInsertEnd>
    4e32:	08 c0       	rjmp	.+16     	; 0x4e44 <vTaskNotifyGiveFromISR+0xd6>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4e34:	89 81       	ldd	r24, Y+1	; 0x01
    4e36:	9a 81       	ldd	r25, Y+2	; 0x02
    4e38:	0c 96       	adiw	r24, 0x0c	; 12
    4e3a:	bc 01       	movw	r22, r24
    4e3c:	8a e3       	ldi	r24, 0x3A	; 58
    4e3e:	95 e0       	ldi	r25, 0x05	; 5
    4e40:	0e 94 88 10 	call	0x2110	; 0x2110 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4e44:	89 81       	ldd	r24, Y+1	; 0x01
    4e46:	9a 81       	ldd	r25, Y+2	; 0x02
    4e48:	fc 01       	movw	r30, r24
    4e4a:	26 89       	ldd	r18, Z+22	; 0x16
    4e4c:	80 91 fe 04 	lds	r24, 0x04FE
    4e50:	90 91 ff 04 	lds	r25, 0x04FF
    4e54:	fc 01       	movw	r30, r24
    4e56:	86 89       	ldd	r24, Z+22	; 0x16
    4e58:	82 17       	cp	r24, r18
    4e5a:	48 f4       	brcc	.+18     	; 0x4e6e <vTaskNotifyGiveFromISR+0x100>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4e5c:	8f 81       	ldd	r24, Y+7	; 0x07
    4e5e:	98 85       	ldd	r25, Y+8	; 0x08
    4e60:	89 2b       	or	r24, r25
    4e62:	29 f0       	breq	.+10     	; 0x4e6e <vTaskNotifyGiveFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4e64:	8f 81       	ldd	r24, Y+7	; 0x07
    4e66:	98 85       	ldd	r25, Y+8	; 0x08
    4e68:	21 e0       	ldi	r18, 0x01	; 1
    4e6a:	fc 01       	movw	r30, r24
    4e6c:	20 83       	st	Z, r18
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    4e6e:	28 96       	adiw	r28, 0x08	; 8
    4e70:	0f b6       	in	r0, 0x3f	; 63
    4e72:	f8 94       	cli
    4e74:	de bf       	out	0x3e, r29	; 62
    4e76:	0f be       	out	0x3f, r0	; 63
    4e78:	cd bf       	out	0x3d, r28	; 61
    4e7a:	df 91       	pop	r29
    4e7c:	cf 91       	pop	r28
    4e7e:	08 95       	ret

00004e80 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    4e80:	cf 93       	push	r28
    4e82:	df 93       	push	r29
    4e84:	00 d0       	rcall	.+0      	; 0x4e86 <xTaskNotifyStateClear+0x6>
    4e86:	00 d0       	rcall	.+0      	; 0x4e88 <xTaskNotifyStateClear+0x8>
    4e88:	1f 92       	push	r1
    4e8a:	cd b7       	in	r28, 0x3d	; 61
    4e8c:	de b7       	in	r29, 0x3e	; 62
    4e8e:	9d 83       	std	Y+5, r25	; 0x05
    4e90:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		pxTCB = ( TCB_t * ) xTask;
    4e92:	8c 81       	ldd	r24, Y+4	; 0x04
    4e94:	9d 81       	ldd	r25, Y+5	; 0x05
    4e96:	9b 83       	std	Y+3, r25	; 0x03
    4e98:	8a 83       	std	Y+2, r24	; 0x02

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( pxTCB );
    4e9a:	8a 81       	ldd	r24, Y+2	; 0x02
    4e9c:	9b 81       	ldd	r25, Y+3	; 0x03
    4e9e:	89 2b       	or	r24, r25
    4ea0:	29 f4       	brne	.+10     	; 0x4eac <xTaskNotifyStateClear+0x2c>
    4ea2:	80 91 fe 04 	lds	r24, 0x04FE
    4ea6:	90 91 ff 04 	lds	r25, 0x04FF
    4eaa:	02 c0       	rjmp	.+4      	; 0x4eb0 <xTaskNotifyStateClear+0x30>
    4eac:	8a 81       	ldd	r24, Y+2	; 0x02
    4eae:	9b 81       	ldd	r25, Y+3	; 0x03
    4eb0:	9b 83       	std	Y+3, r25	; 0x03
    4eb2:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    4eb4:	0f b6       	in	r0, 0x3f	; 63
    4eb6:	f8 94       	cli
    4eb8:	0f 92       	push	r0
		{
			if( pxTCB->eNotifyState == eNotified )
    4eba:	8a 81       	ldd	r24, Y+2	; 0x02
    4ebc:	9b 81       	ldd	r25, Y+3	; 0x03
    4ebe:	fc 01       	movw	r30, r24
    4ec0:	85 a1       	ldd	r24, Z+37	; 0x25
    4ec2:	82 30       	cpi	r24, 0x02	; 2
    4ec4:	39 f4       	brne	.+14     	; 0x4ed4 <xTaskNotifyStateClear+0x54>
			{
				pxTCB->eNotifyState = eNotWaitingNotification;
    4ec6:	8a 81       	ldd	r24, Y+2	; 0x02
    4ec8:	9b 81       	ldd	r25, Y+3	; 0x03
    4eca:	fc 01       	movw	r30, r24
    4ecc:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    4ece:	81 e0       	ldi	r24, 0x01	; 1
    4ed0:	89 83       	std	Y+1, r24	; 0x01
    4ed2:	01 c0       	rjmp	.+2      	; 0x4ed6 <xTaskNotifyStateClear+0x56>
			}
			else
			{
				xReturn = pdFAIL;
    4ed4:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    4ed6:	0f 90       	pop	r0
    4ed8:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4eda:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4edc:	0f 90       	pop	r0
    4ede:	0f 90       	pop	r0
    4ee0:	0f 90       	pop	r0
    4ee2:	0f 90       	pop	r0
    4ee4:	0f 90       	pop	r0
    4ee6:	df 91       	pop	r29
    4ee8:	cf 91       	pop	r28
    4eea:	08 95       	ret

00004eec <vMCUStatusTask>:
/* MCU Status task
 * Toggles the MCU status LED, to blink at 2Hz
 * Rate: 4Hz
 * Priority: 1 (lowest)
 */
void vMCUStatusTask(void *pvParameters) {
    4eec:	cf 93       	push	r28
    4eee:	df 93       	push	r29
    4ef0:	00 d0       	rcall	.+0      	; 0x4ef2 <vMCUStatusTask+0x6>
    4ef2:	1f 92       	push	r1
    4ef4:	cd b7       	in	r28, 0x3d	; 61
    4ef6:	de b7       	in	r29, 0x3e	; 62
    4ef8:	9b 83       	std	Y+3, r25	; 0x03
    4efa:	8a 83       	std	Y+2, r24	; 0x02
	// Make compiler happy
	(void) pvParameters;
	// Task variables
	Bool currentValue = 0;	// false
    4efc:	19 82       	std	Y+1, r1	; 0x01
	// Setup MCU status pin as output
	config_io_pin(MCU_STATUS_PORT, MCU_STATUS_CH, IO_DIR_OUTPUT);
    4efe:	41 e0       	ldi	r20, 0x01	; 1
    4f00:	60 e0       	ldi	r22, 0x00	; 0
    4f02:	81 e0       	ldi	r24, 0x01	; 1
    4f04:	0e 94 de 27 	call	0x4fbc	; 0x4fbc <config_io_pin>
	
	for(;;) {
		// Flip value
		currentValue = !currentValue;
    4f08:	81 e0       	ldi	r24, 0x01	; 1
    4f0a:	99 81       	ldd	r25, Y+1	; 0x01
    4f0c:	99 23       	and	r25, r25
    4f0e:	09 f0       	breq	.+2      	; 0x4f12 <vMCUStatusTask+0x26>
    4f10:	80 e0       	ldi	r24, 0x00	; 0
    4f12:	89 83       	std	Y+1, r24	; 0x01
		// Write out value
		set_io_pin(MCU_STATUS_PORT, MCU_STATUS_CH, currentValue);
    4f14:	49 81       	ldd	r20, Y+1	; 0x01
    4f16:	60 e0       	ldi	r22, 0x00	; 0
    4f18:	81 e0       	ldi	r24, 0x01	; 1
    4f1a:	0e 94 1d 28 	call	0x503a	; 0x503a <set_io_pin>
		// Delay 250ms for 4Hz
		vTaskDelay((TickType_t)250); 
    4f1e:	8a ef       	ldi	r24, 0xFA	; 250
    4f20:	90 e0       	ldi	r25, 0x00	; 0
    4f22:	0e 94 06 1d 	call	0x3a0c	; 0x3a0c <vTaskDelay>
	}
    4f26:	f0 cf       	rjmp	.-32     	; 0x4f08 <vMCUStatusTask+0x1c>

00004f28 <vHeartbeatTask>:
/* Heartbeat task
 * Sends a node heartbeat out on the CANBus
 * Rate: 10Hz
 * Priority: 3
 */
void vHeartbeatTask(void *pvParameters) {
    4f28:	cf 93       	push	r28
    4f2a:	df 93       	push	r29
    4f2c:	00 d0       	rcall	.+0      	; 0x4f2e <vHeartbeatTask+0x6>
    4f2e:	00 d0       	rcall	.+0      	; 0x4f30 <vHeartbeatTask+0x8>
    4f30:	cd b7       	in	r28, 0x3d	; 61
    4f32:	de b7       	in	r29, 0x3e	; 62
    4f34:	9c 83       	std	Y+4, r25	; 0x04
    4f36:	8b 83       	std	Y+3, r24	; 0x03
	(void) pvParameters;
	// Data to send
	HeartbeatFSM data;
	
	// Setup values
	data.currentState = RTD;
    4f38:	82 e0       	ldi	r24, 0x02	; 2
    4f3a:	89 83       	std	Y+1, r24	; 0x01
	data.someData = 10;
    4f3c:	8a e0       	ldi	r24, 0x0A	; 10
    4f3e:	8a 83       	std	Y+2, r24	; 0x02
	
	for(;;) {
		// Transmit the data
		can_tx(FSM_HEARTBEAT_ID, (uint8_t *)&data, sizeof(HeartbeatFSM));
    4f40:	42 e0       	ldi	r20, 0x02	; 2
    4f42:	ce 01       	movw	r24, r28
    4f44:	01 96       	adiw	r24, 0x01	; 1
    4f46:	bc 01       	movw	r22, r24
    4f48:	84 e0       	ldi	r24, 0x04	; 4
    4f4a:	92 e0       	ldi	r25, 0x02	; 2
    4f4c:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <can_tx>
		// Delay 100ms
		vTaskDelay((TickType_t)100); 
    4f50:	84 e6       	ldi	r24, 0x64	; 100
    4f52:	90 e0       	ldi	r25, 0x00	; 0
    4f54:	0e 94 06 1d 	call	0x3a0c	; 0x3a0c <vTaskDelay>
	}
    4f58:	f3 cf       	rjmp	.-26     	; 0x4f40 <vHeartbeatTask+0x18>

00004f5a <vCANSendTask>:
/* Send over CAN
 * 
 * 
 * 
 */
void vCANSendTask(void *pvParameters) {
    4f5a:	cf 93       	push	r28
    4f5c:	df 93       	push	r29
    4f5e:	00 d0       	rcall	.+0      	; 0x4f60 <vCANSendTask+0x6>
    4f60:	cd b7       	in	r28, 0x3d	; 61
    4f62:	de b7       	in	r29, 0x3e	; 62
    4f64:	9a 83       	std	Y+2, r25	; 0x02
    4f66:	89 83       	std	Y+1, r24	; 0x01
	// Make compiler happy
	(void) pvParameters;
}
    4f68:	0f 90       	pop	r0
    4f6a:	0f 90       	pop	r0
    4f6c:	df 91       	pop	r29
    4f6e:	cf 91       	pop	r28
    4f70:	08 95       	ret

00004f72 <vCANReceiveTask>:
/* Receive from CAN
 * 
 * 
 * 
 */
void vCANReceiveTask(void *pvParameters) {
    4f72:	cf 93       	push	r28
    4f74:	df 93       	push	r29
    4f76:	00 d0       	rcall	.+0      	; 0x4f78 <vCANReceiveTask+0x6>
    4f78:	cd b7       	in	r28, 0x3d	; 61
    4f7a:	de b7       	in	r29, 0x3e	; 62
    4f7c:	9a 83       	std	Y+2, r25	; 0x02
    4f7e:	89 83       	std	Y+1, r24	; 0x01
	// Make compiler happy
	(void) pvParameters;
    4f80:	0f 90       	pop	r0
    4f82:	0f 90       	pop	r0
    4f84:	df 91       	pop	r29
    4f86:	cf 91       	pop	r28
    4f88:	08 95       	ret

00004f8a <adc_read>:
    4f8a:	90 91 7c 00 	lds	r25, 0x007C
    4f8e:	90 7e       	andi	r25, 0xE0	; 224
    4f90:	90 93 7c 00 	sts	0x007C, r25
    4f94:	8d 30       	cpi	r24, 0x0D	; 13
    4f96:	08 f0       	brcs	.+2      	; 0x4f9a <adc_read+0x10>
    4f98:	82 e1       	ldi	r24, 0x12	; 18
    4f9a:	90 91 7c 00 	lds	r25, 0x007C
    4f9e:	89 2b       	or	r24, r25
    4fa0:	80 93 7c 00 	sts	0x007C, r24
    4fa4:	80 91 7a 00 	lds	r24, 0x007A
    4fa8:	80 64       	ori	r24, 0x40	; 64
    4faa:	80 93 7a 00 	sts	0x007A, r24
    4fae:	80 91 7a 00 	lds	r24, 0x007A
    4fb2:	86 fd       	sbrc	r24, 6
    4fb4:	fc cf       	rjmp	.-8      	; 0x4fae <adc_read+0x24>
    4fb6:	80 91 79 00 	lds	r24, 0x0079
    4fba:	08 95       	ret

00004fbc <config_io_pin>:
    4fbc:	81 30       	cpi	r24, 0x01	; 1
    4fbe:	b9 f0       	breq	.+46     	; 0x4fee <config_io_pin+0x32>
    4fc0:	18 f0       	brcs	.+6      	; 0x4fc8 <config_io_pin+0xc>
    4fc2:	82 30       	cpi	r24, 0x02	; 2
    4fc4:	39 f1       	breq	.+78     	; 0x5014 <config_io_pin+0x58>
    4fc6:	08 95       	ret
    4fc8:	84 b1       	in	r24, 0x04	; 4
    4fca:	24 b1       	in	r18, 0x04	; 4
    4fcc:	50 e0       	ldi	r21, 0x00	; 0
    4fce:	51 95       	neg	r21
    4fd0:	41 95       	neg	r20
    4fd2:	51 09       	sbc	r21, r1
    4fd4:	48 27       	eor	r20, r24
    4fd6:	81 e0       	ldi	r24, 0x01	; 1
    4fd8:	90 e0       	ldi	r25, 0x00	; 0
    4fda:	02 c0       	rjmp	.+4      	; 0x4fe0 <config_io_pin+0x24>
    4fdc:	88 0f       	add	r24, r24
    4fde:	99 1f       	adc	r25, r25
    4fe0:	6a 95       	dec	r22
    4fe2:	e2 f7       	brpl	.-8      	; 0x4fdc <config_io_pin+0x20>
    4fe4:	48 23       	and	r20, r24
    4fe6:	59 23       	and	r21, r25
    4fe8:	42 27       	eor	r20, r18
    4fea:	44 b9       	out	0x04, r20	; 4
    4fec:	08 95       	ret
    4fee:	87 b1       	in	r24, 0x07	; 7
    4ff0:	27 b1       	in	r18, 0x07	; 7
    4ff2:	50 e0       	ldi	r21, 0x00	; 0
    4ff4:	51 95       	neg	r21
    4ff6:	41 95       	neg	r20
    4ff8:	51 09       	sbc	r21, r1
    4ffa:	48 27       	eor	r20, r24
    4ffc:	81 e0       	ldi	r24, 0x01	; 1
    4ffe:	90 e0       	ldi	r25, 0x00	; 0
    5000:	02 c0       	rjmp	.+4      	; 0x5006 <config_io_pin+0x4a>
    5002:	88 0f       	add	r24, r24
    5004:	99 1f       	adc	r25, r25
    5006:	6a 95       	dec	r22
    5008:	e2 f7       	brpl	.-8      	; 0x5002 <config_io_pin+0x46>
    500a:	48 23       	and	r20, r24
    500c:	59 23       	and	r21, r25
    500e:	42 27       	eor	r20, r18
    5010:	47 b9       	out	0x07, r20	; 7
    5012:	08 95       	ret
    5014:	8a b1       	in	r24, 0x0a	; 10
    5016:	2a b1       	in	r18, 0x0a	; 10
    5018:	50 e0       	ldi	r21, 0x00	; 0
    501a:	51 95       	neg	r21
    501c:	41 95       	neg	r20
    501e:	51 09       	sbc	r21, r1
    5020:	48 27       	eor	r20, r24
    5022:	81 e0       	ldi	r24, 0x01	; 1
    5024:	90 e0       	ldi	r25, 0x00	; 0
    5026:	02 c0       	rjmp	.+4      	; 0x502c <config_io_pin+0x70>
    5028:	88 0f       	add	r24, r24
    502a:	99 1f       	adc	r25, r25
    502c:	6a 95       	dec	r22
    502e:	e2 f7       	brpl	.-8      	; 0x5028 <config_io_pin+0x6c>
    5030:	48 23       	and	r20, r24
    5032:	59 23       	and	r21, r25
    5034:	42 27       	eor	r20, r18
    5036:	4a b9       	out	0x0a, r20	; 10
    5038:	08 95       	ret

0000503a <set_io_pin>:
    503a:	81 30       	cpi	r24, 0x01	; 1
    503c:	b9 f0       	breq	.+46     	; 0x506c <set_io_pin+0x32>
    503e:	18 f0       	brcs	.+6      	; 0x5046 <set_io_pin+0xc>
    5040:	82 30       	cpi	r24, 0x02	; 2
    5042:	39 f1       	breq	.+78     	; 0x5092 <set_io_pin+0x58>
    5044:	08 95       	ret
    5046:	85 b1       	in	r24, 0x05	; 5
    5048:	25 b1       	in	r18, 0x05	; 5
    504a:	50 e0       	ldi	r21, 0x00	; 0
    504c:	51 95       	neg	r21
    504e:	41 95       	neg	r20
    5050:	51 09       	sbc	r21, r1
    5052:	48 27       	eor	r20, r24
    5054:	81 e0       	ldi	r24, 0x01	; 1
    5056:	90 e0       	ldi	r25, 0x00	; 0
    5058:	02 c0       	rjmp	.+4      	; 0x505e <set_io_pin+0x24>
    505a:	88 0f       	add	r24, r24
    505c:	99 1f       	adc	r25, r25
    505e:	6a 95       	dec	r22
    5060:	e2 f7       	brpl	.-8      	; 0x505a <set_io_pin+0x20>
    5062:	48 23       	and	r20, r24
    5064:	59 23       	and	r21, r25
    5066:	42 27       	eor	r20, r18
    5068:	45 b9       	out	0x05, r20	; 5
    506a:	08 95       	ret
    506c:	88 b1       	in	r24, 0x08	; 8
    506e:	28 b1       	in	r18, 0x08	; 8
    5070:	50 e0       	ldi	r21, 0x00	; 0
    5072:	51 95       	neg	r21
    5074:	41 95       	neg	r20
    5076:	51 09       	sbc	r21, r1
    5078:	48 27       	eor	r20, r24
    507a:	81 e0       	ldi	r24, 0x01	; 1
    507c:	90 e0       	ldi	r25, 0x00	; 0
    507e:	02 c0       	rjmp	.+4      	; 0x5084 <set_io_pin+0x4a>
    5080:	88 0f       	add	r24, r24
    5082:	99 1f       	adc	r25, r25
    5084:	6a 95       	dec	r22
    5086:	e2 f7       	brpl	.-8      	; 0x5080 <set_io_pin+0x46>
    5088:	48 23       	and	r20, r24
    508a:	59 23       	and	r21, r25
    508c:	42 27       	eor	r20, r18
    508e:	48 b9       	out	0x08, r20	; 8
    5090:	08 95       	ret
    5092:	8b b1       	in	r24, 0x0b	; 11
    5094:	2b b1       	in	r18, 0x0b	; 11
    5096:	50 e0       	ldi	r21, 0x00	; 0
    5098:	51 95       	neg	r21
    509a:	41 95       	neg	r20
    509c:	51 09       	sbc	r21, r1
    509e:	48 27       	eor	r20, r24
    50a0:	81 e0       	ldi	r24, 0x01	; 1
    50a2:	90 e0       	ldi	r25, 0x00	; 0
    50a4:	02 c0       	rjmp	.+4      	; 0x50aa <set_io_pin+0x70>
    50a6:	88 0f       	add	r24, r24
    50a8:	99 1f       	adc	r25, r25
    50aa:	6a 95       	dec	r22
    50ac:	e2 f7       	brpl	.-8      	; 0x50a6 <set_io_pin+0x6c>
    50ae:	48 23       	and	r20, r24
    50b0:	59 23       	and	r21, r25
    50b2:	42 27       	eor	r20, r18
    50b4:	4b b9       	out	0x0b, r20	; 11
    50b6:	08 95       	ret

000050b8 <__tablejump2__>:
    50b8:	ee 0f       	add	r30, r30
    50ba:	ff 1f       	adc	r31, r31
    50bc:	05 90       	lpm	r0, Z+
    50be:	f4 91       	lpm	r31, Z
    50c0:	e0 2d       	mov	r30, r0
    50c2:	09 94       	ijmp

000050c4 <memcpy>:
    50c4:	fb 01       	movw	r30, r22
    50c6:	dc 01       	movw	r26, r24
    50c8:	02 c0       	rjmp	.+4      	; 0x50ce <memcpy+0xa>
    50ca:	01 90       	ld	r0, Z+
    50cc:	0d 92       	st	X+, r0
    50ce:	41 50       	subi	r20, 0x01	; 1
    50d0:	50 40       	sbci	r21, 0x00	; 0
    50d2:	d8 f7       	brcc	.-10     	; 0x50ca <memcpy+0x6>
    50d4:	08 95       	ret

000050d6 <_exit>:
    50d6:	f8 94       	cli

000050d8 <__stop_program>:
    50d8:	ff cf       	rjmp	.-2      	; 0x50d8 <__stop_program>
