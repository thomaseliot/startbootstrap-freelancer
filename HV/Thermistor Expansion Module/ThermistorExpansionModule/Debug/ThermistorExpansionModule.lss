
ThermistorExpansionModule.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000022  00800100  000010b8  0000114c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000010b8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000a56  00800122  00800122  0000116e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000116e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000011a0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000310  00000000  00000000  000011e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000034fe  00000000  00000000  000014f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d81  00000000  00000000  000049ee  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001316  00000000  00000000  0000576f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000007f8  00000000  00000000  00006a88  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000010d6  00000000  00000000  00007280  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002888  00000000  00000000  00008356  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000002f8  00000000  00000000  0000abde  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 66 03 	jmp	0x6cc	; 0x6cc <__vector_12>
      34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d0 e1       	ldi	r29, 0x10	; 16
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	11 e0       	ldi	r17, 0x01	; 1
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	e8 eb       	ldi	r30, 0xB8	; 184
      90:	f0 e1       	ldi	r31, 0x10	; 16
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	a2 32       	cpi	r26, 0x22	; 34
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	2b e0       	ldi	r18, 0x0B	; 11
      a0:	a2 e2       	ldi	r26, 0x22	; 34
      a2:	b1 e0       	ldi	r27, 0x01	; 1
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	a8 37       	cpi	r26, 0x78	; 120
      aa:	b2 07       	cpc	r27, r18
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 22 01 	call	0x244	; 0x244 <main>
      b2:	0c 94 5a 08 	jmp	0x10b4	; 0x10b4 <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <initAdc>:
#include "adc.h"

/* init_adc
 * Initialize the ADC
 */
void initAdc(void) {
      ba:	a0 e0       	ldi	r26, 0x00	; 0
      bc:	b1 e0       	ldi	r27, 0x01	; 1
      be:	e2 e2       	ldi	r30, 0x22	; 34
      c0:	f1 e0       	ldi	r31, 0x01	; 1
      c2:	2a e3       	ldi	r18, 0x3A	; 58
      c4:	31 e0       	ldi	r19, 0x01	; 1
	int i;
	// Initialize channel storage struct
	for(i = THERM1; i <= THERM8; i++) {
		ADCMeta meta = {adcChannelMap[i], 0};
      c6:	8d 91       	ld	r24, X+
		adcChannels[i] = meta;
      c8:	80 83       	st	Z, r24
      ca:	12 82       	std	Z+2, r1	; 0x02
      cc:	11 82       	std	Z+1, r1	; 0x01
      ce:	33 96       	adiw	r30, 0x03	; 3
 * Initialize the ADC
 */
void initAdc(void) {
	int i;
	// Initialize channel storage struct
	for(i = THERM1; i <= THERM8; i++) {
      d0:	e2 17       	cp	r30, r18
      d2:	f3 07       	cpc	r31, r19
      d4:	c1 f7       	brne	.-16     	; 0xc6 <initAdc+0xc>
		adcChannels[i] = meta;
	}
	
	// Set configuration registers
	// Set ADC prescaler to 16 - 1MHz sample rate @ 16MHz
	ADCSRA |= (1 << ADPS2) | (0 << ADPS1) | (0 << ADPS0); 
      d6:	ea e7       	ldi	r30, 0x7A	; 122
      d8:	f0 e0       	ldi	r31, 0x00	; 0
      da:	80 81       	ld	r24, Z
      dc:	84 60       	ori	r24, 0x04	; 4
      de:	80 83       	st	Z, r24
	
	// Left adjust ADC result to allow easy 8 bit reading
	ADMUX  |= (1 << ADLAR);
      e0:	ac e7       	ldi	r26, 0x7C	; 124
      e2:	b0 e0       	ldi	r27, 0x00	; 0
      e4:	8c 91       	ld	r24, X
      e6:	80 62       	ori	r24, 0x20	; 32
      e8:	8c 93       	st	X, r24
	// Set ADC high speed mode
	ADCSRB |= (1 << ADHSM);
      ea:	ab e7       	ldi	r26, 0x7B	; 123
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	8c 91       	ld	r24, X
      f0:	80 68       	ori	r24, 0x80	; 128
      f2:	8c 93       	st	X, r24
	
	// No MUX values needed to be changed for initialization
	// Set ADC reference to AREF (AREFEN = 1, ISRCEN = 0, REFS1 = 0, REFS0 = 0)
	ADCSRB |= (1 << AREFEN);
      f4:	8c 91       	ld	r24, X
      f6:	80 62       	ori	r24, 0x20	; 32
      f8:	8c 93       	st	X, r24
	// Enable ADC
	ADCSRA |= (1 << ADEN);
      fa:	80 81       	ld	r24, Z
      fc:	80 68       	ori	r24, 0x80	; 128
      fe:	80 83       	st	Z, r24
     100:	08 95       	ret

00000102 <adcRead>:
 *	ch: the channel number to read
 * Returns: the result of the conversion, 8-bit
 */
uint16_t adcRead(uint8_t ch) {
	// Critical section **********************************************************
	taskENTER_CRITICAL();
     102:	0f b6       	in	r0, 0x3f	; 63
     104:	f8 94       	cli
     106:	0f 92       	push	r0
	// Set which channel to read. Leave all ADMUX bits as is except MUX4-0
	if(ch > 12) ch = 18;	// Read ground if invalid channel
     108:	8d 30       	cpi	r24, 0x0D	; 13
     10a:	08 f0       	brcs	.+2      	; 0x10e <adcRead+0xc>
     10c:	82 e1       	ldi	r24, 0x12	; 18
	ADMUX &= 0xE0;					// Clear MUX bits
     10e:	ec e7       	ldi	r30, 0x7C	; 124
     110:	f0 e0       	ldi	r31, 0x00	; 0
     112:	90 81       	ld	r25, Z
     114:	90 7e       	andi	r25, 0xE0	; 224
     116:	90 83       	st	Z, r25
	ADMUX |= ch;				// Set MUX to channel
     118:	90 81       	ld	r25, Z
     11a:	89 2b       	or	r24, r25
     11c:	80 83       	st	Z, r24
	
	// Set ADC start conversion bit
	ADCSRA |= (1 << ADSC);
     11e:	ea e7       	ldi	r30, 0x7A	; 122
     120:	f0 e0       	ldi	r31, 0x00	; 0
     122:	80 81       	ld	r24, Z
     124:	80 64       	ori	r24, 0x40	; 64
     126:	80 83       	st	Z, r24
	taskEXIT_CRITICAL();
     128:	0f 90       	pop	r0
     12a:	0f be       	out	0x3f, r0	; 63
	//****************************************************************************
	
	// Wait for ADCSRA bit ADSC to go low for data conversion to complete
	while(ADCSRA & (1 << ADSC)) {
     12c:	80 81       	ld	r24, Z
     12e:	86 fd       	sbrc	r24, 6
     130:	fd cf       	rjmp	.-6      	; 0x12c <adcRead+0x2a>
		// the ADC values as atomically as possible.
		// taskYIELD();
	}
	
	// Return read channel
	return ADCH;
     132:	80 91 79 00 	lds	r24, 0x0079
}
     136:	90 e0       	ldi	r25, 0x00	; 0
     138:	08 95       	ret

0000013a <adcReadUpdate>:
 * Read an ADC channel and updates the ADC value struct
 * Arguments:
 *	ch: the channel enumeration ID to read
 * Returns: the result of the conversion, 8-bit
 */
void adcReadUpdate(ADCChannel ch) {
     13a:	cf 93       	push	r28
     13c:	df 93       	push	r29
	uint8_t physicalChannel;
	uint16_t channelValue;
	
	// Convert ADCChannel to physical channel
	physicalChannel = adcChannelMap[ch];
     13e:	c8 2f       	mov	r28, r24
     140:	d0 e0       	ldi	r29, 0x00	; 0
     142:	fe 01       	movw	r30, r28
     144:	e0 50       	subi	r30, 0x00	; 0
     146:	ff 4f       	sbci	r31, 0xFF	; 255
	
	// Read channel
	channelValue = adcRead(physicalChannel);
     148:	80 81       	ld	r24, Z
     14a:	0e 94 81 00 	call	0x102	; 0x102 <adcRead>
	
	// Update struct
	adcChannels[ch].currentValue = channelValue;
     14e:	9e 01       	movw	r18, r28
     150:	22 0f       	add	r18, r18
     152:	33 1f       	adc	r19, r19
     154:	c2 0f       	add	r28, r18
     156:	d3 1f       	adc	r29, r19
     158:	ce 5d       	subi	r28, 0xDE	; 222
     15a:	de 4f       	sbci	r29, 0xFE	; 254
     15c:	9a 83       	std	Y+2, r25	; 0x02
     15e:	89 83       	std	Y+1, r24	; 0x01
}
     160:	df 91       	pop	r29
     162:	cf 91       	pop	r28
     164:	08 95       	ret

00000166 <spiSetClockDivider>:
 * Set the clock divider to the specified rate
 * 
 * @param rate the rate to set to
 */
void spiSetClockDivider(SPI_CLOCK_DIV_t rate) {
	SPCR = (SPCR & ~SPI_CLOCK_MASK) | ((uint8_t)rate & SPI_CLOCK_MASK);
     166:	9c b5       	in	r25, 0x2c	; 44
     168:	28 2f       	mov	r18, r24
     16a:	23 70       	andi	r18, 0x03	; 3
     16c:	9c 7f       	andi	r25, 0xFC	; 252
     16e:	92 2b       	or	r25, r18
     170:	9c bd       	out	0x2c, r25	; 44
	SPSR = (SPSR & ~SPI_2XCLOCK_MASK) | (((uint8_t)rate >> 2) & SPI_2XCLOCK_MASK);
     172:	9d b5       	in	r25, 0x2d	; 45
     174:	82 fb       	bst	r24, 2
     176:	88 27       	eor	r24, r24
     178:	80 f9       	bld	r24, 0
     17a:	9e 7f       	andi	r25, 0xFE	; 254
     17c:	89 2b       	or	r24, r25
     17e:	8d bd       	out	0x2d, r24	; 45
     180:	08 95       	ret

00000182 <spiSetBitOrder>:
 * Set the specified bit order
 * 
 * @param bitOrder the bit order to set to
 */
void spiSetBitOrder(uint8_t bitOrder) {
	if(bitOrder == SPI_LSBFIRST) {
     182:	81 11       	cpse	r24, r1
     184:	04 c0       	rjmp	.+8      	; 0x18e <spiSetBitOrder+0xc>
		SPCR |= _BV(DORD);
     186:	8c b5       	in	r24, 0x2c	; 44
     188:	80 62       	ori	r24, 0x20	; 32
     18a:	8c bd       	out	0x2c, r24	; 44
     18c:	08 95       	ret
	} else {
		SPCR &= ~(_BV(DORD));
     18e:	8c b5       	in	r24, 0x2c	; 44
     190:	8f 7d       	andi	r24, 0xDF	; 223
     192:	8c bd       	out	0x2c, r24	; 44
     194:	08 95       	ret

00000196 <spiSetDataMode>:
 * Set the data mode to the specified mode
 * 
 * @param mode the mode to set to
 */
void spiSetDataMode(SPI_MODE_t mode) {
	SPCR = (SPCR & ~SPI_MODE_MASK) | (uint8_t) mode;
     196:	9c b5       	in	r25, 0x2c	; 44
     198:	93 7f       	andi	r25, 0xF3	; 243
     19a:	89 2b       	or	r24, r25
     19c:	8c bd       	out	0x2c, r24	; 44
     19e:	08 95       	ret

000001a0 <spiSelect>:
 * Select the specified slave
 * 
 * @param slave the slave to select
 */
void spiSelect(SPISlave slave) {
	taskENTER_CRITICAL();
     1a0:	0f b6       	in	r0, 0x3f	; 63
     1a2:	f8 94       	cli
     1a4:	0f 92       	push	r0
	// Set pin low
	set_io_pin(slave.port, slave.pin, LOW);
     1a6:	40 e0       	ldi	r20, 0x00	; 0
     1a8:	69 2f       	mov	r22, r25
     1aa:	0e 94 1b 08 	call	0x1036	; 0x1036 <set_io_pin>
	taskEXIT_CRITICAL();
     1ae:	0f 90       	pop	r0
     1b0:	0f be       	out	0x3f, r0	; 63
     1b2:	08 95       	ret

000001b4 <spiDeselect>:
 * Deselect the specified slave
 * 
 * @param slave the slave to select
 */
void spiDeselect(SPISlave slave) {
	taskENTER_CRITICAL();
     1b4:	0f b6       	in	r0, 0x3f	; 63
     1b6:	f8 94       	cli
     1b8:	0f 92       	push	r0
	// Set pin high
	set_io_pin(slave.port, slave.pin, HIGH);
     1ba:	41 e0       	ldi	r20, 0x01	; 1
     1bc:	69 2f       	mov	r22, r25
     1be:	0e 94 1b 08 	call	0x1036	; 0x1036 <set_io_pin>
	taskEXIT_CRITICAL();
     1c2:	0f 90       	pop	r0
     1c4:	0f be       	out	0x3f, r0	; 63
     1c6:	08 95       	ret

000001c8 <spiDeselectAll>:
 */
void spiDeselectAll(void) {
	// Function variables
	uint8_t i;
	
	taskENTER_CRITICAL();
     1c8:	0f b6       	in	r0, 0x3f	; 63
     1ca:	f8 94       	cli
     1cc:	0f 92       	push	r0
	// Loop through each slave and deselect it
	for(i = 0; i < NUM_SLAVES; i++) {
		spiDeselect(spiSlaves[i]);
     1ce:	80 91 08 01 	lds	r24, 0x0108
     1d2:	90 91 09 01 	lds	r25, 0x0109
     1d6:	0e 94 da 00 	call	0x1b4	; 0x1b4 <spiDeselect>
	}
	taskEXIT_CRITICAL();
     1da:	0f 90       	pop	r0
     1dc:	0f be       	out	0x3f, r0	; 63
     1de:	08 95       	ret

000001e0 <spiInit>:
void spiInit(void) {
	// Function variables
	uint8_t i;
	
	// Set digital pin directions for MISO/MOSI/SCK
	config_io_pin(SPI_MISO_PORT, SPI_MISO_PIN, IO_DIR_INPUT);
     1e0:	40 e0       	ldi	r20, 0x00	; 0
     1e2:	60 e0       	ldi	r22, 0x00	; 0
     1e4:	80 e0       	ldi	r24, 0x00	; 0
     1e6:	0e 94 dc 07 	call	0xfb8	; 0xfb8 <config_io_pin>
	config_io_pin(SPI_MOSI_PORT, SPI_MOSI_PIN, IO_DIR_OUTPUT);
     1ea:	41 e0       	ldi	r20, 0x01	; 1
     1ec:	61 e0       	ldi	r22, 0x01	; 1
     1ee:	80 e0       	ldi	r24, 0x00	; 0
     1f0:	0e 94 dc 07 	call	0xfb8	; 0xfb8 <config_io_pin>
	config_io_pin(SPI_SCK_PORT, SPI_SCK_PIN, IO_DIR_OUTPUT); 
     1f4:	41 e0       	ldi	r20, 0x01	; 1
     1f6:	67 e0       	ldi	r22, 0x07	; 7
     1f8:	80 e0       	ldi	r24, 0x00	; 0
     1fa:	0e 94 dc 07 	call	0xfb8	; 0xfb8 <config_io_pin>
	
	// Set digital pin direction for default SS
	// Note that this must be output, or SPI could go into slave mode
	config_io_pin(SPI_SS_PORT, SPI_SS_PIN, IO_DIR_OUTPUT);
     1fe:	41 e0       	ldi	r20, 0x01	; 1
     200:	61 e0       	ldi	r22, 0x01	; 1
     202:	81 e0       	ldi	r24, 0x01	; 1
     204:	0e 94 dc 07 	call	0xfb8	; 0xfb8 <config_io_pin>
	
	// Set digital pin directions for all slaves. If they are connected
	// to the default SS, this will just be redundant.
	for(i = 0; i < NUM_SLAVES; i++) {
		config_io_pin(spiSlaves[i].port, spiSlaves[i].pin, IO_DIR_OUTPUT);
     208:	41 e0       	ldi	r20, 0x01	; 1
     20a:	61 e0       	ldi	r22, 0x01	; 1
     20c:	81 e0       	ldi	r24, 0x01	; 1
     20e:	0e 94 dc 07 	call	0xfb8	; 0xfb8 <config_io_pin>
	}
	
	// Deselect all slaves
	spiDeselectAll();
     212:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <spiDeselectAll>
	
	// Enable SPI, and Master
	SPCR = (1 << SPE) | (1 << MSTR); 
     216:	80 e5       	ldi	r24, 0x50	; 80
     218:	8c bd       	out	0x2c, r24	; 44
	
	// Read SPSR and SPDR to clear them
	i = SPSR;
     21a:	8d b5       	in	r24, 0x2d	; 45
	i = SPDR;
     21c:	8e b5       	in	r24, 0x2e	; 46
     21e:	08 95       	ret

00000220 <SPI_transaction>:
 *		read_only - if set to 1, the data register will not be touched before the transaction begins. 
 * 
 * Returns:
 *		received byte
 */
uint8_t SPI_transaction(uint8_t byte, uint8_t read_only) {
     220:	28 2f       	mov	r18, r24
	// Make sure SPI module has been enabled
	if( !(SPCR & _BV(SPE)) ) return 0;
     222:	9c b5       	in	r25, 0x2c	; 44
     224:	89 2f       	mov	r24, r25
     226:	80 74       	andi	r24, 0x40	; 64
     228:	96 ff       	sbrs	r25, 6
     22a:	07 c0       	rjmp	.+14     	; 0x23a <SPI_transaction+0x1a>
	
	// Set data register
	if (!read_only) {
     22c:	61 11       	cpse	r22, r1
     22e:	01 c0       	rjmp	.+2      	; 0x232 <SPI_transaction+0x12>
		SPDR = byte;	
     230:	2e bd       	out	0x2e, r18	; 46
	}
	
	// Wait for transfer to complete
	while (!(SPSR & (1 << SPIF)));
     232:	0d b4       	in	r0, 0x2d	; 45
     234:	07 fe       	sbrs	r0, 7
     236:	fd cf       	rjmp	.-6      	; 0x232 <SPI_transaction+0x12>
	
	// Return received value
	return SPDR;
     238:	8e b5       	in	r24, 0x2e	; 46
}
     23a:	08 95       	ret

0000023c <spiWrite>:
 * 
 * Returns:
 *		void
 */
void spiWrite(uint8_t byte) {
	(void)SPI_transaction(byte, 0);
     23c:	60 e0       	ldi	r22, 0x00	; 0
     23e:	0e 94 10 01 	call	0x220	; 0x220 <SPI_transaction>
     242:	08 95       	ret

00000244 <main>:
#include "spi.h"


// Main function, runs once
int main(void)
{	
     244:	af 92       	push	r10
     246:	bf 92       	push	r11
     248:	cf 92       	push	r12
     24a:	df 92       	push	r13
     24c:	ef 92       	push	r14
     24e:	ff 92       	push	r15
     250:	0f 93       	push	r16
	// Initialize ADC
	initAdc();
     252:	0e 94 5d 00 	call	0xba	; 0xba <initAdc>
	
	// Initialize SPI
	spiInit();
     256:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <spiInit>
	spiSetClockDivider(SPI_CLOCK_DIV64);
     25a:	82 e0       	ldi	r24, 0x02	; 2
     25c:	0e 94 b3 00 	call	0x166	; 0x166 <spiSetClockDivider>
	spiSetBitOrder(SPI_MSBFIRST);
     260:	81 e0       	ldi	r24, 0x01	; 1
     262:	0e 94 c1 00 	call	0x182	; 0x182 <spiSetBitOrder>
	spiSetDataMode(SPI_MODE1);
     266:	84 e0       	ldi	r24, 0x04	; 4
     268:	0e 94 cb 00 	call	0x196	; 0x196 <spiSetDataMode>
	
	// Hold both thermistor out relays open
	config_io_pin(OPEN_FAULT_PORT, OPEN_FAULT_CH, IO_DIR_OUTPUT);
     26c:	41 e0       	ldi	r20, 0x01	; 1
     26e:	67 e0       	ldi	r22, 0x07	; 7
     270:	81 e0       	ldi	r24, 0x01	; 1
     272:	0e 94 dc 07 	call	0xfb8	; 0xfb8 <config_io_pin>
	config_io_pin(SHORT_FAULT_PORT, SHORT_FAULT_CH, IO_DIR_OUTPUT);
     276:	41 e0       	ldi	r20, 0x01	; 1
     278:	60 e0       	ldi	r22, 0x00	; 0
     27a:	82 e0       	ldi	r24, 0x02	; 2
     27c:	0e 94 dc 07 	call	0xfb8	; 0xfb8 <config_io_pin>
	set_io_pin(OPEN_FAULT_PORT, OPEN_FAULT_CH, HIGH);
     280:	41 e0       	ldi	r20, 0x01	; 1
     282:	67 e0       	ldi	r22, 0x07	; 7
     284:	81 e0       	ldi	r24, 0x01	; 1
     286:	0e 94 1b 08 	call	0x1036	; 0x1036 <set_io_pin>
	set_io_pin(SHORT_FAULT_PORT, SHORT_FAULT_CH, LOW);
     28a:	40 e0       	ldi	r20, 0x00	; 0
     28c:	60 e0       	ldi	r22, 0x00	; 0
     28e:	82 e0       	ldi	r24, 0x02	; 2
     290:	0e 94 1b 08 	call	0x1036	; 0x1036 <set_io_pin>
	
	// Create the MCU status task, to blink the LED
	// Rate: 4Hz
    xTaskCreate(vMCUStatusTask, "STATUS", configMINIMAL_STACK_SIZE, 
     294:	a1 2c       	mov	r10, r1
     296:	b1 2c       	mov	r11, r1
     298:	c1 2c       	mov	r12, r1
     29a:	d1 2c       	mov	r13, r1
     29c:	e1 2c       	mov	r14, r1
     29e:	f1 2c       	mov	r15, r1
     2a0:	01 e0       	ldi	r16, 0x01	; 1
     2a2:	20 e0       	ldi	r18, 0x00	; 0
     2a4:	30 e0       	ldi	r19, 0x00	; 0
     2a6:	44 e6       	ldi	r20, 0x64	; 100
     2a8:	50 e0       	ldi	r21, 0x00	; 0
     2aa:	6a e0       	ldi	r22, 0x0A	; 10
     2ac:	71 e0       	ldi	r23, 0x01	; 1
     2ae:	89 e7       	ldi	r24, 0x79	; 121
     2b0:	97 e0       	ldi	r25, 0x07	; 7
     2b2:	0e 94 f5 03 	call	0x7ea	; 0x7ea <xTaskGenericCreate>
		NULL, MCU_STATUS_TASK_PRIORITY, NULL);
	
	// Create ADC read task
	// Rate: 100Hz
	xTaskCreate(vADCSampleTask, "ADC", configMINIMAL_STACK_SIZE,
     2b6:	04 e0       	ldi	r16, 0x04	; 4
     2b8:	20 e0       	ldi	r18, 0x00	; 0
     2ba:	30 e0       	ldi	r19, 0x00	; 0
     2bc:	44 e6       	ldi	r20, 0x64	; 100
     2be:	50 e0       	ldi	r21, 0x00	; 0
     2c0:	61 e1       	ldi	r22, 0x11	; 17
     2c2:	71 e0       	ldi	r23, 0x01	; 1
     2c4:	86 e9       	ldi	r24, 0x96	; 150
     2c6:	97 e0       	ldi	r25, 0x07	; 7
     2c8:	0e 94 f5 03 	call	0x7ea	; 0x7ea <xTaskGenericCreate>
	// Create thermistor read task
	//xTaskCreate(vThermistorReadTask, "TEMPIN", configMINIMAL_STACK_SIZE,
	//	NULL, THERMISTOR_READ_TASK_PRIORITY, NULL);
	
	// Create thermistor write task
	xTaskCreate(vThermistorWriteTask, "TEMPOUT", configMINIMAL_STACK_SIZE,
     2cc:	03 e0       	ldi	r16, 0x03	; 3
     2ce:	20 e0       	ldi	r18, 0x00	; 0
     2d0:	30 e0       	ldi	r19, 0x00	; 0
     2d2:	44 e6       	ldi	r20, 0x64	; 100
     2d4:	50 e0       	ldi	r21, 0x00	; 0
     2d6:	65 e1       	ldi	r22, 0x15	; 21
     2d8:	71 e0       	ldi	r23, 0x01	; 1
     2da:	8e ea       	ldi	r24, 0xAE	; 174
     2dc:	97 e0       	ldi	r25, 0x07	; 7
     2de:	0e 94 f5 03 	call	0x7ea	; 0x7ea <xTaskGenericCreate>
		NULL, THERMISTOR_WRITE_TASK_PRIORITY, NULL);
	
	// Start the scheduler
	vTaskStartScheduler();
     2e2:	0e 94 0c 05 	call	0xa18	; 0xa18 <vTaskStartScheduler>
	
	// Return, the scheduler handles the rest
	return 0;
}
     2e6:	80 e0       	ldi	r24, 0x00	; 0
     2e8:	90 e0       	ldi	r25, 0x00	; 0
     2ea:	0f 91       	pop	r16
     2ec:	ff 90       	pop	r15
     2ee:	ef 90       	pop	r14
     2f0:	df 90       	pop	r13
     2f2:	cf 90       	pop	r12
     2f4:	bf 90       	pop	r11
     2f6:	af 90       	pop	r10
     2f8:	08 95       	ret

000002fa <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     2fa:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2fc:	03 96       	adiw	r24, 0x03	; 3
     2fe:	92 83       	std	Z+2, r25	; 0x02
     300:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     302:	2f ef       	ldi	r18, 0xFF	; 255
     304:	3f ef       	ldi	r19, 0xFF	; 255
     306:	34 83       	std	Z+4, r19	; 0x04
     308:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     30a:	96 83       	std	Z+6, r25	; 0x06
     30c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     30e:	90 87       	std	Z+8, r25	; 0x08
     310:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     312:	10 82       	st	Z, r1
     314:	08 95       	ret

00000316 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     316:	fc 01       	movw	r30, r24
     318:	11 86       	std	Z+9, r1	; 0x09
     31a:	10 86       	std	Z+8, r1	; 0x08
     31c:	08 95       	ret

0000031e <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     31e:	cf 93       	push	r28
     320:	df 93       	push	r29
     322:	9c 01       	movw	r18, r24
     324:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     326:	dc 01       	movw	r26, r24
     328:	11 96       	adiw	r26, 0x01	; 1
     32a:	cd 91       	ld	r28, X+
     32c:	dc 91       	ld	r29, X
     32e:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     330:	d3 83       	std	Z+3, r29	; 0x03
     332:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     334:	8c 81       	ldd	r24, Y+4	; 0x04
     336:	9d 81       	ldd	r25, Y+5	; 0x05
     338:	95 83       	std	Z+5, r25	; 0x05
     33a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     33c:	8c 81       	ldd	r24, Y+4	; 0x04
     33e:	9d 81       	ldd	r25, Y+5	; 0x05
     340:	dc 01       	movw	r26, r24
     342:	13 96       	adiw	r26, 0x03	; 3
     344:	7c 93       	st	X, r23
     346:	6e 93       	st	-X, r22
     348:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     34a:	7d 83       	std	Y+5, r23	; 0x05
     34c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     34e:	31 87       	std	Z+9, r19	; 0x09
     350:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     352:	f9 01       	movw	r30, r18
     354:	80 81       	ld	r24, Z
     356:	8f 5f       	subi	r24, 0xFF	; 255
     358:	80 83       	st	Z, r24
}
     35a:	df 91       	pop	r29
     35c:	cf 91       	pop	r28
     35e:	08 95       	ret

00000360 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     360:	cf 93       	push	r28
     362:	df 93       	push	r29
     364:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     366:	48 81       	ld	r20, Y
     368:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     36a:	4f 3f       	cpi	r20, 0xFF	; 255
     36c:	2f ef       	ldi	r18, 0xFF	; 255
     36e:	52 07       	cpc	r21, r18
     370:	21 f4       	brne	.+8      	; 0x37a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     372:	fc 01       	movw	r30, r24
     374:	a7 81       	ldd	r26, Z+7	; 0x07
     376:	b0 85       	ldd	r27, Z+8	; 0x08
     378:	0d c0       	rjmp	.+26     	; 0x394 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     37a:	dc 01       	movw	r26, r24
     37c:	13 96       	adiw	r26, 0x03	; 3
     37e:	01 c0       	rjmp	.+2      	; 0x382 <vListInsert+0x22>
     380:	df 01       	movw	r26, r30
     382:	12 96       	adiw	r26, 0x02	; 2
     384:	ed 91       	ld	r30, X+
     386:	fc 91       	ld	r31, X
     388:	13 97       	sbiw	r26, 0x03	; 3
     38a:	20 81       	ld	r18, Z
     38c:	31 81       	ldd	r19, Z+1	; 0x01
     38e:	42 17       	cp	r20, r18
     390:	53 07       	cpc	r21, r19
     392:	b0 f7       	brcc	.-20     	; 0x380 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     394:	12 96       	adiw	r26, 0x02	; 2
     396:	ed 91       	ld	r30, X+
     398:	fc 91       	ld	r31, X
     39a:	13 97       	sbiw	r26, 0x03	; 3
     39c:	fb 83       	std	Y+3, r31	; 0x03
     39e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     3a0:	d5 83       	std	Z+5, r29	; 0x05
     3a2:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     3a4:	bd 83       	std	Y+5, r27	; 0x05
     3a6:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     3a8:	13 96       	adiw	r26, 0x03	; 3
     3aa:	dc 93       	st	X, r29
     3ac:	ce 93       	st	-X, r28
     3ae:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     3b0:	99 87       	std	Y+9, r25	; 0x09
     3b2:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     3b4:	fc 01       	movw	r30, r24
     3b6:	20 81       	ld	r18, Z
     3b8:	2f 5f       	subi	r18, 0xFF	; 255
     3ba:	20 83       	st	Z, r18
}
     3bc:	df 91       	pop	r29
     3be:	cf 91       	pop	r28
     3c0:	08 95       	ret

000003c2 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     3c2:	cf 93       	push	r28
     3c4:	df 93       	push	r29
     3c6:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     3c8:	a0 85       	ldd	r26, Z+8	; 0x08
     3ca:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     3cc:	c2 81       	ldd	r28, Z+2	; 0x02
     3ce:	d3 81       	ldd	r29, Z+3	; 0x03
     3d0:	84 81       	ldd	r24, Z+4	; 0x04
     3d2:	95 81       	ldd	r25, Z+5	; 0x05
     3d4:	9d 83       	std	Y+5, r25	; 0x05
     3d6:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     3d8:	c4 81       	ldd	r28, Z+4	; 0x04
     3da:	d5 81       	ldd	r29, Z+5	; 0x05
     3dc:	82 81       	ldd	r24, Z+2	; 0x02
     3de:	93 81       	ldd	r25, Z+3	; 0x03
     3e0:	9b 83       	std	Y+3, r25	; 0x03
     3e2:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     3e4:	11 96       	adiw	r26, 0x01	; 1
     3e6:	cd 91       	ld	r28, X+
     3e8:	dc 91       	ld	r29, X
     3ea:	12 97       	sbiw	r26, 0x02	; 2
     3ec:	ce 17       	cp	r28, r30
     3ee:	df 07       	cpc	r29, r31
     3f0:	31 f4       	brne	.+12     	; 0x3fe <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     3f2:	8c 81       	ldd	r24, Y+4	; 0x04
     3f4:	9d 81       	ldd	r25, Y+5	; 0x05
     3f6:	12 96       	adiw	r26, 0x02	; 2
     3f8:	9c 93       	st	X, r25
     3fa:	8e 93       	st	-X, r24
     3fc:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     3fe:	11 86       	std	Z+9, r1	; 0x09
     400:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     402:	8c 91       	ld	r24, X
     404:	81 50       	subi	r24, 0x01	; 1
     406:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     408:	df 91       	pop	r29
     40a:	cf 91       	pop	r28
     40c:	08 95       	ret

0000040e <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     40e:	31 e1       	ldi	r19, 0x11	; 17
     410:	fc 01       	movw	r30, r24
     412:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     414:	31 97       	sbiw	r30, 0x01	; 1
     416:	22 e2       	ldi	r18, 0x22	; 34
     418:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     41a:	31 97       	sbiw	r30, 0x01	; 1
     41c:	a3 e3       	ldi	r26, 0x33	; 51
     41e:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     420:	31 97       	sbiw	r30, 0x01	; 1
     422:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     424:	31 97       	sbiw	r30, 0x01	; 1
     426:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     428:	31 97       	sbiw	r30, 0x01	; 1
     42a:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     42c:	31 97       	sbiw	r30, 0x01	; 1
     42e:	60 e8       	ldi	r22, 0x80	; 128
     430:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     432:	31 97       	sbiw	r30, 0x01	; 1
     434:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     436:	31 97       	sbiw	r30, 0x01	; 1
     438:	62 e0       	ldi	r22, 0x02	; 2
     43a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     43c:	31 97       	sbiw	r30, 0x01	; 1
     43e:	63 e0       	ldi	r22, 0x03	; 3
     440:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     442:	31 97       	sbiw	r30, 0x01	; 1
     444:	64 e0       	ldi	r22, 0x04	; 4
     446:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     448:	31 97       	sbiw	r30, 0x01	; 1
     44a:	65 e0       	ldi	r22, 0x05	; 5
     44c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     44e:	31 97       	sbiw	r30, 0x01	; 1
     450:	66 e0       	ldi	r22, 0x06	; 6
     452:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     454:	31 97       	sbiw	r30, 0x01	; 1
     456:	67 e0       	ldi	r22, 0x07	; 7
     458:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     45a:	31 97       	sbiw	r30, 0x01	; 1
     45c:	68 e0       	ldi	r22, 0x08	; 8
     45e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     460:	31 97       	sbiw	r30, 0x01	; 1
     462:	69 e0       	ldi	r22, 0x09	; 9
     464:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     466:	31 97       	sbiw	r30, 0x01	; 1
     468:	60 e1       	ldi	r22, 0x10	; 16
     46a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     46c:	31 97       	sbiw	r30, 0x01	; 1
     46e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     470:	31 97       	sbiw	r30, 0x01	; 1
     472:	32 e1       	ldi	r19, 0x12	; 18
     474:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     476:	31 97       	sbiw	r30, 0x01	; 1
     478:	33 e1       	ldi	r19, 0x13	; 19
     47a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     47c:	31 97       	sbiw	r30, 0x01	; 1
     47e:	34 e1       	ldi	r19, 0x14	; 20
     480:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     482:	31 97       	sbiw	r30, 0x01	; 1
     484:	35 e1       	ldi	r19, 0x15	; 21
     486:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     488:	31 97       	sbiw	r30, 0x01	; 1
     48a:	36 e1       	ldi	r19, 0x16	; 22
     48c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     48e:	31 97       	sbiw	r30, 0x01	; 1
     490:	37 e1       	ldi	r19, 0x17	; 23
     492:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     494:	31 97       	sbiw	r30, 0x01	; 1
     496:	38 e1       	ldi	r19, 0x18	; 24
     498:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     49a:	31 97       	sbiw	r30, 0x01	; 1
     49c:	39 e1       	ldi	r19, 0x19	; 25
     49e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     4a0:	31 97       	sbiw	r30, 0x01	; 1
     4a2:	30 e2       	ldi	r19, 0x20	; 32
     4a4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     4a6:	31 97       	sbiw	r30, 0x01	; 1
     4a8:	31 e2       	ldi	r19, 0x21	; 33
     4aa:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     4ac:	31 97       	sbiw	r30, 0x01	; 1
     4ae:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     4b0:	31 97       	sbiw	r30, 0x01	; 1
     4b2:	23 e2       	ldi	r18, 0x23	; 35
     4b4:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     4b6:	31 97       	sbiw	r30, 0x01	; 1
     4b8:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     4ba:	31 97       	sbiw	r30, 0x01	; 1
     4bc:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     4be:	31 97       	sbiw	r30, 0x01	; 1
     4c0:	26 e2       	ldi	r18, 0x26	; 38
     4c2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     4c4:	31 97       	sbiw	r30, 0x01	; 1
     4c6:	27 e2       	ldi	r18, 0x27	; 39
     4c8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     4ca:	31 97       	sbiw	r30, 0x01	; 1
     4cc:	28 e2       	ldi	r18, 0x28	; 40
     4ce:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     4d0:	31 97       	sbiw	r30, 0x01	; 1
     4d2:	29 e2       	ldi	r18, 0x29	; 41
     4d4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     4d6:	31 97       	sbiw	r30, 0x01	; 1
     4d8:	20 e3       	ldi	r18, 0x30	; 48
     4da:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     4dc:	31 97       	sbiw	r30, 0x01	; 1
     4de:	21 e3       	ldi	r18, 0x31	; 49
     4e0:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     4e2:	86 97       	sbiw	r24, 0x26	; 38
     4e4:	08 95       	ret

000004e6 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     4e6:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
     4ea:	89 ef       	ldi	r24, 0xF9	; 249
     4ec:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     4f0:	8b e0       	ldi	r24, 0x0B	; 11
     4f2:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
     4f6:	ef e6       	ldi	r30, 0x6F	; 111
     4f8:	f0 e0       	ldi	r31, 0x00	; 0
     4fa:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     4fc:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
     4fe:	80 83       	st	Z, r24
	
	TCNT1 = 0;
     500:	10 92 85 00 	sts	0x0085, r1
     504:	10 92 84 00 	sts	0x0084, r1
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     508:	a0 91 76 0b 	lds	r26, 0x0B76
     50c:	b0 91 77 0b 	lds	r27, 0x0B77
     510:	cd 91       	ld	r28, X+
     512:	cd bf       	out	0x3d, r28	; 61
     514:	dd 91       	ld	r29, X+
     516:	de bf       	out	0x3e, r29	; 62
     518:	ff 91       	pop	r31
     51a:	ef 91       	pop	r30
     51c:	df 91       	pop	r29
     51e:	cf 91       	pop	r28
     520:	bf 91       	pop	r27
     522:	af 91       	pop	r26
     524:	9f 91       	pop	r25
     526:	8f 91       	pop	r24
     528:	7f 91       	pop	r23
     52a:	6f 91       	pop	r22
     52c:	5f 91       	pop	r21
     52e:	4f 91       	pop	r20
     530:	3f 91       	pop	r19
     532:	2f 91       	pop	r18
     534:	1f 91       	pop	r17
     536:	0f 91       	pop	r16
     538:	ff 90       	pop	r15
     53a:	ef 90       	pop	r14
     53c:	df 90       	pop	r13
     53e:	cf 90       	pop	r12
     540:	bf 90       	pop	r11
     542:	af 90       	pop	r10
     544:	9f 90       	pop	r9
     546:	8f 90       	pop	r8
     548:	7f 90       	pop	r7
     54a:	6f 90       	pop	r6
     54c:	5f 90       	pop	r5
     54e:	4f 90       	pop	r4
     550:	3f 90       	pop	r3
     552:	2f 90       	pop	r2
     554:	1f 90       	pop	r1
     556:	0f 90       	pop	r0
     558:	0f be       	out	0x3f, r0	; 63
     55a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     55c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     55e:	81 e0       	ldi	r24, 0x01	; 1
     560:	08 95       	ret

00000562 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     562:	0f 92       	push	r0
     564:	0f b6       	in	r0, 0x3f	; 63
     566:	f8 94       	cli
     568:	0f 92       	push	r0
     56a:	1f 92       	push	r1
     56c:	11 24       	eor	r1, r1
     56e:	2f 92       	push	r2
     570:	3f 92       	push	r3
     572:	4f 92       	push	r4
     574:	5f 92       	push	r5
     576:	6f 92       	push	r6
     578:	7f 92       	push	r7
     57a:	8f 92       	push	r8
     57c:	9f 92       	push	r9
     57e:	af 92       	push	r10
     580:	bf 92       	push	r11
     582:	cf 92       	push	r12
     584:	df 92       	push	r13
     586:	ef 92       	push	r14
     588:	ff 92       	push	r15
     58a:	0f 93       	push	r16
     58c:	1f 93       	push	r17
     58e:	2f 93       	push	r18
     590:	3f 93       	push	r19
     592:	4f 93       	push	r20
     594:	5f 93       	push	r21
     596:	6f 93       	push	r22
     598:	7f 93       	push	r23
     59a:	8f 93       	push	r24
     59c:	9f 93       	push	r25
     59e:	af 93       	push	r26
     5a0:	bf 93       	push	r27
     5a2:	cf 93       	push	r28
     5a4:	df 93       	push	r29
     5a6:	ef 93       	push	r30
     5a8:	ff 93       	push	r31
     5aa:	a0 91 76 0b 	lds	r26, 0x0B76
     5ae:	b0 91 77 0b 	lds	r27, 0x0B77
     5b2:	0d b6       	in	r0, 0x3d	; 61
     5b4:	0d 92       	st	X+, r0
     5b6:	0e b6       	in	r0, 0x3e	; 62
     5b8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     5ba:	0e 94 0c 07 	call	0xe18	; 0xe18 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     5be:	a0 91 76 0b 	lds	r26, 0x0B76
     5c2:	b0 91 77 0b 	lds	r27, 0x0B77
     5c6:	cd 91       	ld	r28, X+
     5c8:	cd bf       	out	0x3d, r28	; 61
     5ca:	dd 91       	ld	r29, X+
     5cc:	de bf       	out	0x3e, r29	; 62
     5ce:	ff 91       	pop	r31
     5d0:	ef 91       	pop	r30
     5d2:	df 91       	pop	r29
     5d4:	cf 91       	pop	r28
     5d6:	bf 91       	pop	r27
     5d8:	af 91       	pop	r26
     5da:	9f 91       	pop	r25
     5dc:	8f 91       	pop	r24
     5de:	7f 91       	pop	r23
     5e0:	6f 91       	pop	r22
     5e2:	5f 91       	pop	r21
     5e4:	4f 91       	pop	r20
     5e6:	3f 91       	pop	r19
     5e8:	2f 91       	pop	r18
     5ea:	1f 91       	pop	r17
     5ec:	0f 91       	pop	r16
     5ee:	ff 90       	pop	r15
     5f0:	ef 90       	pop	r14
     5f2:	df 90       	pop	r13
     5f4:	cf 90       	pop	r12
     5f6:	bf 90       	pop	r11
     5f8:	af 90       	pop	r10
     5fa:	9f 90       	pop	r9
     5fc:	8f 90       	pop	r8
     5fe:	7f 90       	pop	r7
     600:	6f 90       	pop	r6
     602:	5f 90       	pop	r5
     604:	4f 90       	pop	r4
     606:	3f 90       	pop	r3
     608:	2f 90       	pop	r2
     60a:	1f 90       	pop	r1
     60c:	0f 90       	pop	r0
     60e:	0f be       	out	0x3f, r0	; 63
     610:	0f 90       	pop	r0

	asm volatile ( "ret" );
     612:	08 95       	ret

00000614 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     614:	0f 92       	push	r0
     616:	0f b6       	in	r0, 0x3f	; 63
     618:	f8 94       	cli
     61a:	0f 92       	push	r0
     61c:	1f 92       	push	r1
     61e:	11 24       	eor	r1, r1
     620:	2f 92       	push	r2
     622:	3f 92       	push	r3
     624:	4f 92       	push	r4
     626:	5f 92       	push	r5
     628:	6f 92       	push	r6
     62a:	7f 92       	push	r7
     62c:	8f 92       	push	r8
     62e:	9f 92       	push	r9
     630:	af 92       	push	r10
     632:	bf 92       	push	r11
     634:	cf 92       	push	r12
     636:	df 92       	push	r13
     638:	ef 92       	push	r14
     63a:	ff 92       	push	r15
     63c:	0f 93       	push	r16
     63e:	1f 93       	push	r17
     640:	2f 93       	push	r18
     642:	3f 93       	push	r19
     644:	4f 93       	push	r20
     646:	5f 93       	push	r21
     648:	6f 93       	push	r22
     64a:	7f 93       	push	r23
     64c:	8f 93       	push	r24
     64e:	9f 93       	push	r25
     650:	af 93       	push	r26
     652:	bf 93       	push	r27
     654:	cf 93       	push	r28
     656:	df 93       	push	r29
     658:	ef 93       	push	r30
     65a:	ff 93       	push	r31
     65c:	a0 91 76 0b 	lds	r26, 0x0B76
     660:	b0 91 77 0b 	lds	r27, 0x0B77
     664:	0d b6       	in	r0, 0x3d	; 61
     666:	0d 92       	st	X+, r0
     668:	0e b6       	in	r0, 0x3e	; 62
     66a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     66c:	0e 94 4e 05 	call	0xa9c	; 0xa9c <xTaskIncrementTick>
     670:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     672:	0e 94 0c 07 	call	0xe18	; 0xe18 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     676:	a0 91 76 0b 	lds	r26, 0x0B76
     67a:	b0 91 77 0b 	lds	r27, 0x0B77
     67e:	cd 91       	ld	r28, X+
     680:	cd bf       	out	0x3d, r28	; 61
     682:	dd 91       	ld	r29, X+
     684:	de bf       	out	0x3e, r29	; 62
     686:	ff 91       	pop	r31
     688:	ef 91       	pop	r30
     68a:	df 91       	pop	r29
     68c:	cf 91       	pop	r28
     68e:	bf 91       	pop	r27
     690:	af 91       	pop	r26
     692:	9f 91       	pop	r25
     694:	8f 91       	pop	r24
     696:	7f 91       	pop	r23
     698:	6f 91       	pop	r22
     69a:	5f 91       	pop	r21
     69c:	4f 91       	pop	r20
     69e:	3f 91       	pop	r19
     6a0:	2f 91       	pop	r18
     6a2:	1f 91       	pop	r17
     6a4:	0f 91       	pop	r16
     6a6:	ff 90       	pop	r15
     6a8:	ef 90       	pop	r14
     6aa:	df 90       	pop	r13
     6ac:	cf 90       	pop	r12
     6ae:	bf 90       	pop	r11
     6b0:	af 90       	pop	r10
     6b2:	9f 90       	pop	r9
     6b4:	8f 90       	pop	r8
     6b6:	7f 90       	pop	r7
     6b8:	6f 90       	pop	r6
     6ba:	5f 90       	pop	r5
     6bc:	4f 90       	pop	r4
     6be:	3f 90       	pop	r3
     6c0:	2f 90       	pop	r2
     6c2:	1f 90       	pop	r1
     6c4:	0f 90       	pop	r0
     6c6:	0f be       	out	0x3f, r0	; 63
     6c8:	0f 90       	pop	r0

	asm volatile ( "ret" );
     6ca:	08 95       	ret

000006cc <__vector_12>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	ISR(TIMER1_COMPA_vect, ISR_NAKED)
	{
		vPortYieldFromTick();
     6cc:	0e 94 0a 03 	call	0x614	; 0x614 <vPortYieldFromTick>
		asm volatile ( "reti" );
     6d0:	18 95       	reti

000006d2 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     6d2:	cf 93       	push	r28
     6d4:	df 93       	push	r29
     6d6:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     6d8:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     6dc:	80 91 3a 01 	lds	r24, 0x013A
     6e0:	90 91 3b 01 	lds	r25, 0x013B
     6e4:	89 2b       	or	r24, r25
     6e6:	31 f4       	brne	.+12     	; 0x6f4 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     6e8:	8f e3       	ldi	r24, 0x3F	; 63
     6ea:	91 e0       	ldi	r25, 0x01	; 1
     6ec:	90 93 3b 01 	sts	0x013B, r25
     6f0:	80 93 3a 01 	sts	0x013A, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     6f4:	20 91 3c 01 	lds	r18, 0x013C
     6f8:	30 91 3d 01 	lds	r19, 0x013D
     6fc:	ce 01       	movw	r24, r28
     6fe:	82 0f       	add	r24, r18
     700:	93 1f       	adc	r25, r19
     702:	83 3c       	cpi	r24, 0xC3	; 195
     704:	49 e0       	ldi	r20, 0x09	; 9
     706:	94 07       	cpc	r25, r20
     708:	70 f4       	brcc	.+28     	; 0x726 <pvPortMalloc+0x54>
     70a:	28 17       	cp	r18, r24
     70c:	39 07       	cpc	r19, r25
     70e:	70 f4       	brcc	.+28     	; 0x72c <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     710:	c0 91 3a 01 	lds	r28, 0x013A
     714:	d0 91 3b 01 	lds	r29, 0x013B
     718:	c2 0f       	add	r28, r18
     71a:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     71c:	90 93 3d 01 	sts	0x013D, r25
     720:	80 93 3c 01 	sts	0x013C, r24
     724:	05 c0       	rjmp	.+10     	; 0x730 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     726:	c0 e0       	ldi	r28, 0x00	; 0
     728:	d0 e0       	ldi	r29, 0x00	; 0
     72a:	02 c0       	rjmp	.+4      	; 0x730 <pvPortMalloc+0x5e>
     72c:	c0 e0       	ldi	r28, 0x00	; 0
     72e:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     730:	0e 94 0b 06 	call	0xc16	; 0xc16 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     734:	ce 01       	movw	r24, r28
     736:	df 91       	pop	r29
     738:	cf 91       	pop	r28
     73a:	08 95       	ret

0000073c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     73c:	08 95       	ret

0000073e <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     73e:	e0 91 2c 0b 	lds	r30, 0x0B2C
     742:	f0 91 2d 0b 	lds	r31, 0x0B2D
     746:	80 81       	ld	r24, Z
     748:	81 11       	cpse	r24, r1
     74a:	07 c0       	rjmp	.+14     	; 0x75a <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     74c:	8f ef       	ldi	r24, 0xFF	; 255
     74e:	9f ef       	ldi	r25, 0xFF	; 255
     750:	90 93 04 0b 	sts	0x0B04, r25
     754:	80 93 03 0b 	sts	0x0B03, r24
     758:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     75a:	e0 91 2c 0b 	lds	r30, 0x0B2C
     75e:	f0 91 2d 0b 	lds	r31, 0x0B2D
     762:	05 80       	ldd	r0, Z+5	; 0x05
     764:	f6 81       	ldd	r31, Z+6	; 0x06
     766:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
     768:	06 80       	ldd	r0, Z+6	; 0x06
     76a:	f7 81       	ldd	r31, Z+7	; 0x07
     76c:	e0 2d       	mov	r30, r0
     76e:	82 81       	ldd	r24, Z+2	; 0x02
     770:	93 81       	ldd	r25, Z+3	; 0x03
     772:	90 93 04 0b 	sts	0x0B04, r25
     776:	80 93 03 0b 	sts	0x0B03, r24
     77a:	08 95       	ret

0000077c <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
     77c:	cf 93       	push	r28
     77e:	df 93       	push	r29
     780:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     782:	e0 91 76 0b 	lds	r30, 0x0B76
     786:	f0 91 77 0b 	lds	r31, 0x0B77
     78a:	93 83       	std	Z+3, r25	; 0x03
     78c:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
     78e:	80 91 0b 0b 	lds	r24, 0x0B0B
     792:	90 91 0c 0b 	lds	r25, 0x0B0C
     796:	c8 17       	cp	r28, r24
     798:	d9 07       	cpc	r29, r25
     79a:	68 f4       	brcc	.+26     	; 0x7b6 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     79c:	60 91 76 0b 	lds	r22, 0x0B76
     7a0:	70 91 77 0b 	lds	r23, 0x0B77
     7a4:	80 91 2a 0b 	lds	r24, 0x0B2A
     7a8:	90 91 2b 0b 	lds	r25, 0x0B2B
     7ac:	6e 5f       	subi	r22, 0xFE	; 254
     7ae:	7f 4f       	sbci	r23, 0xFF	; 255
     7b0:	0e 94 b0 01 	call	0x360	; 0x360 <vListInsert>
     7b4:	17 c0       	rjmp	.+46     	; 0x7e4 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     7b6:	60 91 76 0b 	lds	r22, 0x0B76
     7ba:	70 91 77 0b 	lds	r23, 0x0B77
     7be:	80 91 2c 0b 	lds	r24, 0x0B2C
     7c2:	90 91 2d 0b 	lds	r25, 0x0B2D
     7c6:	6e 5f       	subi	r22, 0xFE	; 254
     7c8:	7f 4f       	sbci	r23, 0xFF	; 255
     7ca:	0e 94 b0 01 	call	0x360	; 0x360 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
     7ce:	80 91 03 0b 	lds	r24, 0x0B03
     7d2:	90 91 04 0b 	lds	r25, 0x0B04
     7d6:	c8 17       	cp	r28, r24
     7d8:	d9 07       	cpc	r29, r25
     7da:	20 f4       	brcc	.+8      	; 0x7e4 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
     7dc:	d0 93 04 0b 	sts	0x0B04, r29
     7e0:	c0 93 03 0b 	sts	0x0B03, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     7e4:	df 91       	pop	r29
     7e6:	cf 91       	pop	r28
     7e8:	08 95       	ret

000007ea <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
     7ea:	4f 92       	push	r4
     7ec:	5f 92       	push	r5
     7ee:	6f 92       	push	r6
     7f0:	7f 92       	push	r7
     7f2:	8f 92       	push	r8
     7f4:	9f 92       	push	r9
     7f6:	af 92       	push	r10
     7f8:	bf 92       	push	r11
     7fa:	cf 92       	push	r12
     7fc:	df 92       	push	r13
     7fe:	ef 92       	push	r14
     800:	ff 92       	push	r15
     802:	0f 93       	push	r16
     804:	1f 93       	push	r17
     806:	cf 93       	push	r28
     808:	df 93       	push	r29
     80a:	4c 01       	movw	r8, r24
     80c:	eb 01       	movw	r28, r22
     80e:	5a 01       	movw	r10, r20
     810:	29 01       	movw	r4, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     812:	c1 14       	cp	r12, r1
     814:	d1 04       	cpc	r13, r1
     816:	39 f4       	brne	.+14     	; 0x826 <xTaskGenericCreate+0x3c>
     818:	ca 01       	movw	r24, r20
     81a:	0e 94 69 03 	call	0x6d2	; 0x6d2 <pvPortMalloc>
     81e:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
     820:	89 2b       	or	r24, r25
     822:	09 f4       	brne	.+2      	; 0x826 <xTaskGenericCreate+0x3c>
     824:	e7 c0       	rjmp	.+462    	; 0x9f4 <xTaskGenericCreate+0x20a>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     826:	86 e2       	ldi	r24, 0x26	; 38
     828:	90 e0       	ldi	r25, 0x00	; 0
     82a:	0e 94 69 03 	call	0x6d2	; 0x6d2 <pvPortMalloc>
     82e:	3c 01       	movw	r6, r24

			if( pxNewTCB != NULL )
     830:	00 97       	sbiw	r24, 0x00	; 0
     832:	79 f0       	breq	.+30     	; 0x852 <xTaskGenericCreate+0x68>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
     834:	fc 01       	movw	r30, r24
     836:	d0 8e       	std	Z+24, r13	; 0x18
     838:	c7 8a       	std	Z+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
     83a:	f1 e0       	ldi	r31, 0x01	; 1
     83c:	af 1a       	sub	r10, r31
     83e:	b1 08       	sbc	r11, r1
     840:	ca 0c       	add	r12, r10
     842:	db 1c       	adc	r13, r11
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     844:	88 81       	ld	r24, Y
     846:	f3 01       	movw	r30, r6
     848:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     84a:	88 81       	ld	r24, Y
     84c:	81 11       	cpse	r24, r1
     84e:	05 c0       	rjmp	.+10     	; 0x85a <xTaskGenericCreate+0x70>
     850:	14 c0       	rjmp	.+40     	; 0x87a <xTaskGenericCreate+0x90>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
     852:	c6 01       	movw	r24, r12
     854:	0e 94 9e 03 	call	0x73c	; 0x73c <vPortFree>
     858:	cd c0       	rjmp	.+410    	; 0x9f4 <xTaskGenericCreate+0x20a>
     85a:	d3 01       	movw	r26, r6
     85c:	5a 96       	adiw	r26, 0x1a	; 26
     85e:	fe 01       	movw	r30, r28
     860:	31 96       	adiw	r30, 0x01	; 1
     862:	9e 01       	movw	r18, r28
     864:	28 5f       	subi	r18, 0xF8	; 248
     866:	3f 4f       	sbci	r19, 0xFF	; 255
     868:	ef 01       	movw	r28, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     86a:	81 91       	ld	r24, Z+
     86c:	8d 93       	st	X+, r24

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     86e:	88 81       	ld	r24, Y
     870:	88 23       	and	r24, r24
     872:	19 f0       	breq	.+6      	; 0x87a <xTaskGenericCreate+0x90>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     874:	e2 17       	cp	r30, r18
     876:	f3 07       	cpc	r31, r19
     878:	b9 f7       	brne	.-18     	; 0x868 <xTaskGenericCreate+0x7e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     87a:	f3 01       	movw	r30, r6
     87c:	10 a2       	std	Z+32, r1	; 0x20
     87e:	10 2f       	mov	r17, r16
     880:	06 30       	cpi	r16, 0x06	; 6
     882:	08 f0       	brcs	.+2      	; 0x886 <xTaskGenericCreate+0x9c>
     884:	15 e0       	ldi	r17, 0x05	; 5
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
     886:	f3 01       	movw	r30, r6
     888:	16 8b       	std	Z+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     88a:	e3 01       	movw	r28, r6
     88c:	22 96       	adiw	r28, 0x02	; 2
     88e:	ce 01       	movw	r24, r28
     890:	0e 94 8b 01 	call	0x316	; 0x316 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     894:	c3 01       	movw	r24, r6
     896:	0c 96       	adiw	r24, 0x0c	; 12
     898:	0e 94 8b 01 	call	0x316	; 0x316 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     89c:	f3 01       	movw	r30, r6
     89e:	71 86       	std	Z+9, r7	; 0x09
     8a0:	60 86       	std	Z+8, r6	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     8a2:	86 e0       	ldi	r24, 0x06	; 6
     8a4:	90 e0       	ldi	r25, 0x00	; 0
     8a6:	81 1b       	sub	r24, r17
     8a8:	91 09       	sbc	r25, r1
     8aa:	95 87       	std	Z+13, r25	; 0x0d
     8ac:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     8ae:	73 8a       	std	Z+19, r7	; 0x13
     8b0:	62 8a       	std	Z+18, r6	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
     8b2:	11 a2       	std	Z+33, r1	; 0x21
     8b4:	12 a2       	std	Z+34, r1	; 0x22
     8b6:	13 a2       	std	Z+35, r1	; 0x23
     8b8:	14 a2       	std	Z+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
     8ba:	15 a2       	std	Z+37, r1	; 0x25
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     8bc:	a2 01       	movw	r20, r4
     8be:	b4 01       	movw	r22, r8
     8c0:	c6 01       	movw	r24, r12
     8c2:	0e 94 07 02 	call	0x40e	; 0x40e <pxPortInitialiseStack>
     8c6:	f3 01       	movw	r30, r6
     8c8:	91 83       	std	Z+1, r25	; 0x01
     8ca:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
     8cc:	e1 14       	cp	r14, r1
     8ce:	f1 04       	cpc	r15, r1
     8d0:	19 f0       	breq	.+6      	; 0x8d8 <xTaskGenericCreate+0xee>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     8d2:	f7 01       	movw	r30, r14
     8d4:	71 82       	std	Z+1, r7	; 0x01
     8d6:	60 82       	st	Z, r6
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
     8d8:	0f b6       	in	r0, 0x3f	; 63
     8da:	f8 94       	cli
     8dc:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     8de:	80 91 0d 0b 	lds	r24, 0x0B0D
     8e2:	8f 5f       	subi	r24, 0xFF	; 255
     8e4:	80 93 0d 0b 	sts	0x0B0D, r24
			if( pxCurrentTCB == NULL )
     8e8:	80 91 76 0b 	lds	r24, 0x0B76
     8ec:	90 91 77 0b 	lds	r25, 0x0B77
     8f0:	89 2b       	or	r24, r25
     8f2:	09 f0       	breq	.+2      	; 0x8f6 <xTaskGenericCreate+0x10c>
     8f4:	3f c0       	rjmp	.+126    	; 0x974 <xTaskGenericCreate+0x18a>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     8f6:	70 92 77 0b 	sts	0x0B77, r7
     8fa:	60 92 76 0b 	sts	0x0B76, r6

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     8fe:	80 91 0d 0b 	lds	r24, 0x0B0D
     902:	81 30       	cpi	r24, 0x01	; 1
     904:	09 f0       	breq	.+2      	; 0x908 <xTaskGenericCreate+0x11e>
     906:	45 c0       	rjmp	.+138    	; 0x992 <xTaskGenericCreate+0x1a8>
     908:	0f 2e       	mov	r0, r31
     90a:	f0 e4       	ldi	r31, 0x40	; 64
     90c:	ef 2e       	mov	r14, r31
     90e:	fb e0       	ldi	r31, 0x0B	; 11
     910:	ff 2e       	mov	r15, r31
     912:	f0 2d       	mov	r31, r0
     914:	0f 2e       	mov	r0, r31
     916:	f6 e7       	ldi	r31, 0x76	; 118
     918:	cf 2e       	mov	r12, r31
     91a:	fb e0       	ldi	r31, 0x0B	; 11
     91c:	df 2e       	mov	r13, r31
     91e:	f0 2d       	mov	r31, r0
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     920:	c7 01       	movw	r24, r14
     922:	0e 94 7d 01 	call	0x2fa	; 0x2fa <vListInitialise>
     926:	f9 e0       	ldi	r31, 0x09	; 9
     928:	ef 0e       	add	r14, r31
     92a:	f1 1c       	adc	r15, r1

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
     92c:	ec 14       	cp	r14, r12
     92e:	fd 04       	cpc	r15, r13
     930:	b9 f7       	brne	.-18     	; 0x920 <xTaskGenericCreate+0x136>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
     932:	87 e3       	ldi	r24, 0x37	; 55
     934:	9b e0       	ldi	r25, 0x0B	; 11
     936:	0e 94 7d 01 	call	0x2fa	; 0x2fa <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     93a:	8e e2       	ldi	r24, 0x2E	; 46
     93c:	9b e0       	ldi	r25, 0x0B	; 11
     93e:	0e 94 7d 01 	call	0x2fa	; 0x2fa <vListInitialise>
	vListInitialise( &xPendingReadyList );
     942:	81 e2       	ldi	r24, 0x21	; 33
     944:	9b e0       	ldi	r25, 0x0B	; 11
     946:	0e 94 7d 01 	call	0x2fa	; 0x2fa <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     94a:	88 e1       	ldi	r24, 0x18	; 24
     94c:	9b e0       	ldi	r25, 0x0B	; 11
     94e:	0e 94 7d 01 	call	0x2fa	; 0x2fa <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     952:	8e e0       	ldi	r24, 0x0E	; 14
     954:	9b e0       	ldi	r25, 0x0B	; 11
     956:	0e 94 7d 01 	call	0x2fa	; 0x2fa <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     95a:	87 e3       	ldi	r24, 0x37	; 55
     95c:	9b e0       	ldi	r25, 0x0B	; 11
     95e:	90 93 2d 0b 	sts	0x0B2D, r25
     962:	80 93 2c 0b 	sts	0x0B2C, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     966:	8e e2       	ldi	r24, 0x2E	; 46
     968:	9b e0       	ldi	r25, 0x0B	; 11
     96a:	90 93 2b 0b 	sts	0x0B2B, r25
     96e:	80 93 2a 0b 	sts	0x0B2A, r24
     972:	0f c0       	rjmp	.+30     	; 0x992 <xTaskGenericCreate+0x1a8>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     974:	80 91 09 0b 	lds	r24, 0x0B09
     978:	81 11       	cpse	r24, r1
     97a:	0b c0       	rjmp	.+22     	; 0x992 <xTaskGenericCreate+0x1a8>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     97c:	e0 91 76 0b 	lds	r30, 0x0B76
     980:	f0 91 77 0b 	lds	r31, 0x0B77
     984:	86 89       	ldd	r24, Z+22	; 0x16
     986:	08 17       	cp	r16, r24
     988:	20 f0       	brcs	.+8      	; 0x992 <xTaskGenericCreate+0x1a8>
					{
						pxCurrentTCB = pxNewTCB;
     98a:	70 92 77 0b 	sts	0x0B77, r7
     98e:	60 92 76 0b 	sts	0x0B76, r6
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
     992:	80 91 05 0b 	lds	r24, 0x0B05
     996:	8f 5f       	subi	r24, 0xFF	; 255
     998:	80 93 05 0b 	sts	0x0B05, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
     99c:	f3 01       	movw	r30, r6
     99e:	86 89       	ldd	r24, Z+22	; 0x16
     9a0:	90 91 0a 0b 	lds	r25, 0x0B0A
     9a4:	98 17       	cp	r25, r24
     9a6:	10 f4       	brcc	.+4      	; 0x9ac <xTaskGenericCreate+0x1c2>
     9a8:	80 93 0a 0b 	sts	0x0B0A, r24
     9ac:	90 e0       	ldi	r25, 0x00	; 0
     9ae:	9c 01       	movw	r18, r24
     9b0:	22 0f       	add	r18, r18
     9b2:	33 1f       	adc	r19, r19
     9b4:	22 0f       	add	r18, r18
     9b6:	33 1f       	adc	r19, r19
     9b8:	22 0f       	add	r18, r18
     9ba:	33 1f       	adc	r19, r19
     9bc:	82 0f       	add	r24, r18
     9be:	93 1f       	adc	r25, r19
     9c0:	be 01       	movw	r22, r28
     9c2:	80 5c       	subi	r24, 0xC0	; 192
     9c4:	94 4f       	sbci	r25, 0xF4	; 244
     9c6:	0e 94 8f 01 	call	0x31e	; 0x31e <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     9ca:	0f 90       	pop	r0
     9cc:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
     9ce:	80 91 09 0b 	lds	r24, 0x0B09
     9d2:	88 23       	and	r24, r24
     9d4:	59 f0       	breq	.+22     	; 0x9ec <xTaskGenericCreate+0x202>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     9d6:	e0 91 76 0b 	lds	r30, 0x0B76
     9da:	f0 91 77 0b 	lds	r31, 0x0B77
     9de:	86 89       	ldd	r24, Z+22	; 0x16
     9e0:	80 17       	cp	r24, r16
     9e2:	30 f4       	brcc	.+12     	; 0x9f0 <xTaskGenericCreate+0x206>
			{
				taskYIELD_IF_USING_PREEMPTION();
     9e4:	0e 94 b1 02 	call	0x562	; 0x562 <vPortYield>
     9e8:	81 e0       	ldi	r24, 0x01	; 1
     9ea:	05 c0       	rjmp	.+10     	; 0x9f6 <xTaskGenericCreate+0x20c>
     9ec:	81 e0       	ldi	r24, 0x01	; 1
     9ee:	03 c0       	rjmp	.+6      	; 0x9f6 <xTaskGenericCreate+0x20c>
     9f0:	81 e0       	ldi	r24, 0x01	; 1
     9f2:	01 c0       	rjmp	.+2      	; 0x9f6 <xTaskGenericCreate+0x20c>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     9f4:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
     9f6:	df 91       	pop	r29
     9f8:	cf 91       	pop	r28
     9fa:	1f 91       	pop	r17
     9fc:	0f 91       	pop	r16
     9fe:	ff 90       	pop	r15
     a00:	ef 90       	pop	r14
     a02:	df 90       	pop	r13
     a04:	cf 90       	pop	r12
     a06:	bf 90       	pop	r11
     a08:	af 90       	pop	r10
     a0a:	9f 90       	pop	r9
     a0c:	8f 90       	pop	r8
     a0e:	7f 90       	pop	r7
     a10:	6f 90       	pop	r6
     a12:	5f 90       	pop	r5
     a14:	4f 90       	pop	r4
     a16:	08 95       	ret

00000a18 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     a18:	af 92       	push	r10
     a1a:	bf 92       	push	r11
     a1c:	cf 92       	push	r12
     a1e:	df 92       	push	r13
     a20:	ef 92       	push	r14
     a22:	ff 92       	push	r15
     a24:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
     a26:	a1 2c       	mov	r10, r1
     a28:	b1 2c       	mov	r11, r1
     a2a:	c1 2c       	mov	r12, r1
     a2c:	d1 2c       	mov	r13, r1
     a2e:	e1 2c       	mov	r14, r1
     a30:	f1 2c       	mov	r15, r1
     a32:	00 e0       	ldi	r16, 0x00	; 0
     a34:	20 e0       	ldi	r18, 0x00	; 0
     a36:	30 e0       	ldi	r19, 0x00	; 0
     a38:	44 e6       	ldi	r20, 0x64	; 100
     a3a:	50 e0       	ldi	r21, 0x00	; 0
     a3c:	6d e1       	ldi	r22, 0x1D	; 29
     a3e:	71 e0       	ldi	r23, 0x01	; 1
     a40:	8f ec       	ldi	r24, 0xCF	; 207
     a42:	96 e0       	ldi	r25, 0x06	; 6
     a44:	0e 94 f5 03 	call	0x7ea	; 0x7ea <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     a48:	81 30       	cpi	r24, 0x01	; 1
     a4a:	81 f4       	brne	.+32     	; 0xa6c <vTaskStartScheduler+0x54>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     a4c:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     a4e:	8f ef       	ldi	r24, 0xFF	; 255
     a50:	9f ef       	ldi	r25, 0xFF	; 255
     a52:	90 93 04 0b 	sts	0x0B04, r25
     a56:	80 93 03 0b 	sts	0x0B03, r24
		xSchedulerRunning = pdTRUE;
     a5a:	81 e0       	ldi	r24, 0x01	; 1
     a5c:	80 93 09 0b 	sts	0x0B09, r24
		xTickCount = ( TickType_t ) 0U;
     a60:	10 92 0c 0b 	sts	0x0B0C, r1
     a64:	10 92 0b 0b 	sts	0x0B0B, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     a68:	0e 94 73 02 	call	0x4e6	; 0x4e6 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     a6c:	0f 91       	pop	r16
     a6e:	ff 90       	pop	r15
     a70:	ef 90       	pop	r14
     a72:	df 90       	pop	r13
     a74:	cf 90       	pop	r12
     a76:	bf 90       	pop	r11
     a78:	af 90       	pop	r10
     a7a:	08 95       	ret

00000a7c <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     a7c:	80 91 02 0b 	lds	r24, 0x0B02
     a80:	8f 5f       	subi	r24, 0xFF	; 255
     a82:	80 93 02 0b 	sts	0x0B02, r24
     a86:	08 95       	ret

00000a88 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     a88:	0f b6       	in	r0, 0x3f	; 63
     a8a:	f8 94       	cli
     a8c:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     a8e:	80 91 0b 0b 	lds	r24, 0x0B0B
     a92:	90 91 0c 0b 	lds	r25, 0x0B0C
	}
	portTICK_TYPE_EXIT_CRITICAL();
     a96:	0f 90       	pop	r0
     a98:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     a9a:	08 95       	ret

00000a9c <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     a9c:	cf 92       	push	r12
     a9e:	df 92       	push	r13
     aa0:	ef 92       	push	r14
     aa2:	ff 92       	push	r15
     aa4:	0f 93       	push	r16
     aa6:	1f 93       	push	r17
     aa8:	cf 93       	push	r28
     aaa:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     aac:	80 91 02 0b 	lds	r24, 0x0B02
     ab0:	81 11       	cpse	r24, r1
     ab2:	9b c0       	rjmp	.+310    	; 0xbea <xTaskIncrementTick+0x14e>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
     ab4:	80 91 0b 0b 	lds	r24, 0x0B0B
     ab8:	90 91 0c 0b 	lds	r25, 0x0B0C
     abc:	01 96       	adiw	r24, 0x01	; 1
     abe:	90 93 0c 0b 	sts	0x0B0C, r25
     ac2:	80 93 0b 0b 	sts	0x0B0B, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     ac6:	e0 90 0b 0b 	lds	r14, 0x0B0B
     aca:	f0 90 0c 0b 	lds	r15, 0x0B0C

			if( xConstTickCount == ( TickType_t ) 0U )
     ace:	e1 14       	cp	r14, r1
     ad0:	f1 04       	cpc	r15, r1
     ad2:	b9 f4       	brne	.+46     	; 0xb02 <xTaskIncrementTick+0x66>
			{
				taskSWITCH_DELAYED_LISTS();
     ad4:	80 91 2c 0b 	lds	r24, 0x0B2C
     ad8:	90 91 2d 0b 	lds	r25, 0x0B2D
     adc:	20 91 2a 0b 	lds	r18, 0x0B2A
     ae0:	30 91 2b 0b 	lds	r19, 0x0B2B
     ae4:	30 93 2d 0b 	sts	0x0B2D, r19
     ae8:	20 93 2c 0b 	sts	0x0B2C, r18
     aec:	90 93 2b 0b 	sts	0x0B2B, r25
     af0:	80 93 2a 0b 	sts	0x0B2A, r24
     af4:	80 91 06 0b 	lds	r24, 0x0B06
     af8:	8f 5f       	subi	r24, 0xFF	; 255
     afa:	80 93 06 0b 	sts	0x0B06, r24
     afe:	0e 94 9f 03 	call	0x73e	; 0x73e <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
     b02:	80 91 03 0b 	lds	r24, 0x0B03
     b06:	90 91 04 0b 	lds	r25, 0x0B04
     b0a:	e8 16       	cp	r14, r24
     b0c:	f9 06       	cpc	r15, r25
     b0e:	10 f4       	brcc	.+4      	; 0xb14 <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     b10:	d1 2c       	mov	r13, r1
     b12:	53 c0       	rjmp	.+166    	; 0xbba <xTaskIncrementTick+0x11e>
     b14:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
     b16:	cc 24       	eor	r12, r12
     b18:	c3 94       	inc	r12
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     b1a:	e0 91 2c 0b 	lds	r30, 0x0B2C
     b1e:	f0 91 2d 0b 	lds	r31, 0x0B2D
     b22:	90 81       	ld	r25, Z
     b24:	91 11       	cpse	r25, r1
     b26:	07 c0       	rjmp	.+14     	; 0xb36 <xTaskIncrementTick+0x9a>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
     b28:	8f ef       	ldi	r24, 0xFF	; 255
     b2a:	9f ef       	ldi	r25, 0xFF	; 255
     b2c:	90 93 04 0b 	sts	0x0B04, r25
     b30:	80 93 03 0b 	sts	0x0B03, r24
						break;
     b34:	42 c0       	rjmp	.+132    	; 0xbba <xTaskIncrementTick+0x11e>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     b36:	e0 91 2c 0b 	lds	r30, 0x0B2C
     b3a:	f0 91 2d 0b 	lds	r31, 0x0B2D
     b3e:	05 80       	ldd	r0, Z+5	; 0x05
     b40:	f6 81       	ldd	r31, Z+6	; 0x06
     b42:	e0 2d       	mov	r30, r0
     b44:	c6 81       	ldd	r28, Z+6	; 0x06
     b46:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     b48:	2a 81       	ldd	r18, Y+2	; 0x02
     b4a:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
     b4c:	e2 16       	cp	r14, r18
     b4e:	f3 06       	cpc	r15, r19
     b50:	28 f4       	brcc	.+10     	; 0xb5c <xTaskIncrementTick+0xc0>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
     b52:	30 93 04 0b 	sts	0x0B04, r19
     b56:	20 93 03 0b 	sts	0x0B03, r18
							break;
     b5a:	2f c0       	rjmp	.+94     	; 0xbba <xTaskIncrementTick+0x11e>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     b5c:	8e 01       	movw	r16, r28
     b5e:	0e 5f       	subi	r16, 0xFE	; 254
     b60:	1f 4f       	sbci	r17, 0xFF	; 255
     b62:	c8 01       	movw	r24, r16
     b64:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     b68:	8c 89       	ldd	r24, Y+20	; 0x14
     b6a:	9d 89       	ldd	r25, Y+21	; 0x15
     b6c:	89 2b       	or	r24, r25
     b6e:	21 f0       	breq	.+8      	; 0xb78 <xTaskIncrementTick+0xdc>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     b70:	ce 01       	movw	r24, r28
     b72:	0c 96       	adiw	r24, 0x0c	; 12
     b74:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
     b78:	2e 89       	ldd	r18, Y+22	; 0x16
     b7a:	80 91 0a 0b 	lds	r24, 0x0B0A
     b7e:	82 17       	cp	r24, r18
     b80:	10 f4       	brcc	.+4      	; 0xb86 <xTaskIncrementTick+0xea>
     b82:	20 93 0a 0b 	sts	0x0B0A, r18
     b86:	30 e0       	ldi	r19, 0x00	; 0
     b88:	c9 01       	movw	r24, r18
     b8a:	88 0f       	add	r24, r24
     b8c:	99 1f       	adc	r25, r25
     b8e:	88 0f       	add	r24, r24
     b90:	99 1f       	adc	r25, r25
     b92:	88 0f       	add	r24, r24
     b94:	99 1f       	adc	r25, r25
     b96:	82 0f       	add	r24, r18
     b98:	93 1f       	adc	r25, r19
     b9a:	b8 01       	movw	r22, r16
     b9c:	80 5c       	subi	r24, 0xC0	; 192
     b9e:	94 4f       	sbci	r25, 0xF4	; 244
     ba0:	0e 94 8f 01 	call	0x31e	; 0x31e <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     ba4:	e0 91 76 0b 	lds	r30, 0x0B76
     ba8:	f0 91 77 0b 	lds	r31, 0x0B77
     bac:	9e 89       	ldd	r25, Y+22	; 0x16
     bae:	86 89       	ldd	r24, Z+22	; 0x16
     bb0:	98 17       	cp	r25, r24
     bb2:	08 f4       	brcc	.+2      	; 0xbb6 <xTaskIncrementTick+0x11a>
     bb4:	b2 cf       	rjmp	.-156    	; 0xb1a <xTaskIncrementTick+0x7e>
							{
								xSwitchRequired = pdTRUE;
     bb6:	dc 2c       	mov	r13, r12
     bb8:	b0 cf       	rjmp	.-160    	; 0xb1a <xTaskIncrementTick+0x7e>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     bba:	e0 91 76 0b 	lds	r30, 0x0B76
     bbe:	f0 91 77 0b 	lds	r31, 0x0B77
     bc2:	86 89       	ldd	r24, Z+22	; 0x16
     bc4:	90 e0       	ldi	r25, 0x00	; 0
     bc6:	fc 01       	movw	r30, r24
     bc8:	ee 0f       	add	r30, r30
     bca:	ff 1f       	adc	r31, r31
     bcc:	ee 0f       	add	r30, r30
     bce:	ff 1f       	adc	r31, r31
     bd0:	ee 0f       	add	r30, r30
     bd2:	ff 1f       	adc	r31, r31
     bd4:	8e 0f       	add	r24, r30
     bd6:	9f 1f       	adc	r25, r31
     bd8:	fc 01       	movw	r30, r24
     bda:	e0 5c       	subi	r30, 0xC0	; 192
     bdc:	f4 4f       	sbci	r31, 0xF4	; 244
     bde:	80 81       	ld	r24, Z
     be0:	82 30       	cpi	r24, 0x02	; 2
     be2:	48 f0       	brcs	.+18     	; 0xbf6 <xTaskIncrementTick+0x15a>
			{
				xSwitchRequired = pdTRUE;
     be4:	dd 24       	eor	r13, r13
     be6:	d3 94       	inc	r13
     be8:	06 c0       	rjmp	.+12     	; 0xbf6 <xTaskIncrementTick+0x15a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     bea:	80 91 08 0b 	lds	r24, 0x0B08
     bee:	8f 5f       	subi	r24, 0xFF	; 255
     bf0:	80 93 08 0b 	sts	0x0B08, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     bf4:	d1 2c       	mov	r13, r1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     bf6:	80 91 07 0b 	lds	r24, 0x0B07
     bfa:	88 23       	and	r24, r24
     bfc:	11 f0       	breq	.+4      	; 0xc02 <xTaskIncrementTick+0x166>
		{
			xSwitchRequired = pdTRUE;
     bfe:	dd 24       	eor	r13, r13
     c00:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     c02:	8d 2d       	mov	r24, r13
     c04:	df 91       	pop	r29
     c06:	cf 91       	pop	r28
     c08:	1f 91       	pop	r17
     c0a:	0f 91       	pop	r16
     c0c:	ff 90       	pop	r15
     c0e:	ef 90       	pop	r14
     c10:	df 90       	pop	r13
     c12:	cf 90       	pop	r12
     c14:	08 95       	ret

00000c16 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     c16:	df 92       	push	r13
     c18:	ef 92       	push	r14
     c1a:	ff 92       	push	r15
     c1c:	0f 93       	push	r16
     c1e:	1f 93       	push	r17
     c20:	cf 93       	push	r28
     c22:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     c24:	0f b6       	in	r0, 0x3f	; 63
     c26:	f8 94       	cli
     c28:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     c2a:	80 91 02 0b 	lds	r24, 0x0B02
     c2e:	81 50       	subi	r24, 0x01	; 1
     c30:	80 93 02 0b 	sts	0x0B02, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c34:	80 91 02 0b 	lds	r24, 0x0B02
     c38:	81 11       	cpse	r24, r1
     c3a:	62 c0       	rjmp	.+196    	; 0xd00 <xTaskResumeAll+0xea>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     c3c:	80 91 0d 0b 	lds	r24, 0x0B0D
     c40:	81 11       	cpse	r24, r1
     c42:	33 c0       	rjmp	.+102    	; 0xcaa <xTaskResumeAll+0x94>
     c44:	60 c0       	rjmp	.+192    	; 0xd06 <xTaskResumeAll+0xf0>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     c46:	d7 01       	movw	r26, r14
     c48:	15 96       	adiw	r26, 0x05	; 5
     c4a:	ed 91       	ld	r30, X+
     c4c:	fc 91       	ld	r31, X
     c4e:	16 97       	sbiw	r26, 0x06	; 6
     c50:	c6 81       	ldd	r28, Z+6	; 0x06
     c52:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     c54:	ce 01       	movw	r24, r28
     c56:	0c 96       	adiw	r24, 0x0c	; 12
     c58:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     c5c:	8e 01       	movw	r16, r28
     c5e:	0e 5f       	subi	r16, 0xFE	; 254
     c60:	1f 4f       	sbci	r17, 0xFF	; 255
     c62:	c8 01       	movw	r24, r16
     c64:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     c68:	2e 89       	ldd	r18, Y+22	; 0x16
     c6a:	80 91 0a 0b 	lds	r24, 0x0B0A
     c6e:	82 17       	cp	r24, r18
     c70:	10 f4       	brcc	.+4      	; 0xc76 <xTaskResumeAll+0x60>
     c72:	20 93 0a 0b 	sts	0x0B0A, r18
     c76:	30 e0       	ldi	r19, 0x00	; 0
     c78:	c9 01       	movw	r24, r18
     c7a:	88 0f       	add	r24, r24
     c7c:	99 1f       	adc	r25, r25
     c7e:	88 0f       	add	r24, r24
     c80:	99 1f       	adc	r25, r25
     c82:	88 0f       	add	r24, r24
     c84:	99 1f       	adc	r25, r25
     c86:	82 0f       	add	r24, r18
     c88:	93 1f       	adc	r25, r19
     c8a:	b8 01       	movw	r22, r16
     c8c:	80 5c       	subi	r24, 0xC0	; 192
     c8e:	94 4f       	sbci	r25, 0xF4	; 244
     c90:	0e 94 8f 01 	call	0x31e	; 0x31e <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     c94:	e0 91 76 0b 	lds	r30, 0x0B76
     c98:	f0 91 77 0b 	lds	r31, 0x0B77
     c9c:	9e 89       	ldd	r25, Y+22	; 0x16
     c9e:	86 89       	ldd	r24, Z+22	; 0x16
     ca0:	98 17       	cp	r25, r24
     ca2:	58 f0       	brcs	.+22     	; 0xcba <xTaskResumeAll+0xa4>
					{
						xYieldPending = pdTRUE;
     ca4:	d0 92 07 0b 	sts	0x0B07, r13
     ca8:	08 c0       	rjmp	.+16     	; 0xcba <xTaskResumeAll+0xa4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     caa:	0f 2e       	mov	r0, r31
     cac:	f1 e2       	ldi	r31, 0x21	; 33
     cae:	ef 2e       	mov	r14, r31
     cb0:	fb e0       	ldi	r31, 0x0B	; 11
     cb2:	ff 2e       	mov	r15, r31
     cb4:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     cb6:	dd 24       	eor	r13, r13
     cb8:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     cba:	f7 01       	movw	r30, r14
     cbc:	80 81       	ld	r24, Z
     cbe:	81 11       	cpse	r24, r1
     cc0:	c2 cf       	rjmp	.-124    	; 0xc46 <xTaskResumeAll+0x30>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
     cc2:	80 91 08 0b 	lds	r24, 0x0B08
     cc6:	88 23       	and	r24, r24
     cc8:	99 f0       	breq	.+38     	; 0xcf0 <xTaskResumeAll+0xda>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     cca:	80 91 08 0b 	lds	r24, 0x0B08
     cce:	88 23       	and	r24, r24
     cd0:	79 f0       	breq	.+30     	; 0xcf0 <xTaskResumeAll+0xda>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
     cd2:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
     cd4:	0e 94 4e 05 	call	0xa9c	; 0xa9c <xTaskIncrementTick>
     cd8:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
     cda:	c0 93 07 0b 	sts	0x0B07, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
     cde:	80 91 08 0b 	lds	r24, 0x0B08
     ce2:	81 50       	subi	r24, 0x01	; 1
     ce4:	80 93 08 0b 	sts	0x0B08, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     ce8:	80 91 08 0b 	lds	r24, 0x0B08
     cec:	81 11       	cpse	r24, r1
     cee:	f2 cf       	rjmp	.-28     	; 0xcd4 <xTaskResumeAll+0xbe>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
     cf0:	80 91 07 0b 	lds	r24, 0x0B07
     cf4:	81 30       	cpi	r24, 0x01	; 1
     cf6:	31 f4       	brne	.+12     	; 0xd04 <xTaskResumeAll+0xee>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     cf8:	0e 94 b1 02 	call	0x562	; 0x562 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     cfc:	81 e0       	ldi	r24, 0x01	; 1
     cfe:	03 c0       	rjmp	.+6      	; 0xd06 <xTaskResumeAll+0xf0>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
     d00:	80 e0       	ldi	r24, 0x00	; 0
     d02:	01 c0       	rjmp	.+2      	; 0xd06 <xTaskResumeAll+0xf0>
     d04:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     d06:	0f 90       	pop	r0
     d08:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     d0a:	df 91       	pop	r29
     d0c:	cf 91       	pop	r28
     d0e:	1f 91       	pop	r17
     d10:	0f 91       	pop	r16
     d12:	ff 90       	pop	r15
     d14:	ef 90       	pop	r14
     d16:	df 90       	pop	r13
     d18:	08 95       	ret

00000d1a <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     d1a:	0f 93       	push	r16
     d1c:	1f 93       	push	r17
     d1e:	cf 93       	push	r28
     d20:	df 93       	push	r29
     d22:	8c 01       	movw	r16, r24
     d24:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     d26:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     d2a:	80 91 0b 0b 	lds	r24, 0x0B0B
     d2e:	90 91 0c 0b 	lds	r25, 0x0B0C

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     d32:	f8 01       	movw	r30, r16
     d34:	20 81       	ld	r18, Z
     d36:	31 81       	ldd	r19, Z+1	; 0x01
     d38:	c2 0f       	add	r28, r18
     d3a:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
     d3c:	82 17       	cp	r24, r18
     d3e:	93 07       	cpc	r25, r19
     d40:	48 f4       	brcc	.+18     	; 0xd54 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     d42:	c2 17       	cp	r28, r18
     d44:	d3 07       	cpc	r29, r19
     d46:	10 f5       	brcc	.+68     	; 0xd8c <vTaskDelayUntil+0x72>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     d48:	d1 83       	std	Z+1, r29	; 0x01
     d4a:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
     d4c:	8c 17       	cp	r24, r28
     d4e:	9d 07       	cpc	r25, r29
     d50:	90 f4       	brcc	.+36     	; 0xd76 <vTaskDelayUntil+0x5c>
     d52:	07 c0       	rjmp	.+14     	; 0xd62 <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     d54:	c2 17       	cp	r28, r18
     d56:	d3 07       	cpc	r29, r19
     d58:	a8 f0       	brcs	.+42     	; 0xd84 <vTaskDelayUntil+0x6a>
     d5a:	8c 17       	cp	r24, r28
     d5c:	9d 07       	cpc	r25, r29
     d5e:	90 f0       	brcs	.+36     	; 0xd84 <vTaskDelayUntil+0x6a>
     d60:	15 c0       	rjmp	.+42     	; 0xd8c <vTaskDelayUntil+0x72>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     d62:	80 91 76 0b 	lds	r24, 0x0B76
     d66:	90 91 77 0b 	lds	r25, 0x0B77
     d6a:	02 96       	adiw	r24, 0x02	; 2
     d6c:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
     d70:	ce 01       	movw	r24, r28
     d72:	0e 94 be 03 	call	0x77c	; 0x77c <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     d76:	0e 94 0b 06 	call	0xc16	; 0xc16 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     d7a:	81 11       	cpse	r24, r1
     d7c:	0b c0       	rjmp	.+22     	; 0xd94 <vTaskDelayUntil+0x7a>
		{
			portYIELD_WITHIN_API();
     d7e:	0e 94 b1 02 	call	0x562	; 0x562 <vPortYield>
     d82:	08 c0       	rjmp	.+16     	; 0xd94 <vTaskDelayUntil+0x7a>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     d84:	f8 01       	movw	r30, r16
     d86:	d1 83       	std	Z+1, r29	; 0x01
     d88:	c0 83       	st	Z, r28
     d8a:	eb cf       	rjmp	.-42     	; 0xd62 <vTaskDelayUntil+0x48>
     d8c:	f8 01       	movw	r30, r16
     d8e:	d1 83       	std	Z+1, r29	; 0x01
     d90:	c0 83       	st	Z, r28
     d92:	f1 cf       	rjmp	.-30     	; 0xd76 <vTaskDelayUntil+0x5c>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     d94:	df 91       	pop	r29
     d96:	cf 91       	pop	r28
     d98:	1f 91       	pop	r17
     d9a:	0f 91       	pop	r16
     d9c:	08 95       	ret

00000d9e <prvIdleTask>:
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     d9e:	08 e1       	ldi	r16, 0x18	; 24
     da0:	1b e0       	ldi	r17, 0x0B	; 11

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     da2:	0f 2e       	mov	r0, r31
     da4:	f0 e4       	ldi	r31, 0x40	; 64
     da6:	ef 2e       	mov	r14, r31
     da8:	fb e0       	ldi	r31, 0x0B	; 11
     daa:	ff 2e       	mov	r15, r31
     dac:	f0 2d       	mov	r31, r0
     dae:	29 c0       	rjmp	.+82     	; 0xe02 <prvIdleTask+0x64>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
     db0:	0e 94 3e 05 	call	0xa7c	; 0xa7c <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     db4:	d8 01       	movw	r26, r16
     db6:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
     db8:	0e 94 0b 06 	call	0xc16	; 0xc16 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
     dbc:	cc 23       	and	r28, r28
     dbe:	09 f1       	breq	.+66     	; 0xe02 <prvIdleTask+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
     dc0:	0f b6       	in	r0, 0x3f	; 63
     dc2:	f8 94       	cli
     dc4:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
     dc6:	d8 01       	movw	r26, r16
     dc8:	15 96       	adiw	r26, 0x05	; 5
     dca:	ed 91       	ld	r30, X+
     dcc:	fc 91       	ld	r31, X
     dce:	16 97       	sbiw	r26, 0x06	; 6
     dd0:	c6 81       	ldd	r28, Z+6	; 0x06
     dd2:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     dd4:	ce 01       	movw	r24, r28
     dd6:	02 96       	adiw	r24, 0x02	; 2
     dd8:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <uxListRemove>
					--uxCurrentNumberOfTasks;
     ddc:	80 91 0d 0b 	lds	r24, 0x0B0D
     de0:	81 50       	subi	r24, 0x01	; 1
     de2:	80 93 0d 0b 	sts	0x0B0D, r24
					--uxTasksDeleted;
     de6:	80 91 17 0b 	lds	r24, 0x0B17
     dea:	81 50       	subi	r24, 0x01	; 1
     dec:	80 93 17 0b 	sts	0x0B17, r24
				}
				taskEXIT_CRITICAL();
     df0:	0f 90       	pop	r0
     df2:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
     df4:	8f 89       	ldd	r24, Y+23	; 0x17
     df6:	98 8d       	ldd	r25, Y+24	; 0x18
     df8:	0e 94 9e 03 	call	0x73c	; 0x73c <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
     dfc:	ce 01       	movw	r24, r28
     dfe:	0e 94 9e 03 	call	0x73c	; 0x73c <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
     e02:	80 91 17 0b 	lds	r24, 0x0B17
     e06:	81 11       	cpse	r24, r1
     e08:	d3 cf       	rjmp	.-90     	; 0xdb0 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     e0a:	f7 01       	movw	r30, r14
     e0c:	80 81       	ld	r24, Z
     e0e:	82 30       	cpi	r24, 0x02	; 2
     e10:	c0 f3       	brcs	.-16     	; 0xe02 <prvIdleTask+0x64>
			{
				taskYIELD();
     e12:	0e 94 b1 02 	call	0x562	; 0x562 <vPortYield>
     e16:	f5 cf       	rjmp	.-22     	; 0xe02 <prvIdleTask+0x64>

00000e18 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     e18:	80 91 02 0b 	lds	r24, 0x0B02
     e1c:	88 23       	and	r24, r24
     e1e:	21 f0       	breq	.+8      	; 0xe28 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     e20:	81 e0       	ldi	r24, 0x01	; 1
     e22:	80 93 07 0b 	sts	0x0B07, r24
     e26:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     e28:	10 92 07 0b 	sts	0x0B07, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     e2c:	80 91 0a 0b 	lds	r24, 0x0B0A
     e30:	90 e0       	ldi	r25, 0x00	; 0
     e32:	fc 01       	movw	r30, r24
     e34:	ee 0f       	add	r30, r30
     e36:	ff 1f       	adc	r31, r31
     e38:	ee 0f       	add	r30, r30
     e3a:	ff 1f       	adc	r31, r31
     e3c:	ee 0f       	add	r30, r30
     e3e:	ff 1f       	adc	r31, r31
     e40:	8e 0f       	add	r24, r30
     e42:	9f 1f       	adc	r25, r31
     e44:	fc 01       	movw	r30, r24
     e46:	e0 5c       	subi	r30, 0xC0	; 192
     e48:	f4 4f       	sbci	r31, 0xF4	; 244
     e4a:	80 81       	ld	r24, Z
     e4c:	81 11       	cpse	r24, r1
     e4e:	17 c0       	rjmp	.+46     	; 0xe7e <vTaskSwitchContext+0x66>
     e50:	80 91 0a 0b 	lds	r24, 0x0B0A
     e54:	81 50       	subi	r24, 0x01	; 1
     e56:	80 93 0a 0b 	sts	0x0B0A, r24
     e5a:	80 91 0a 0b 	lds	r24, 0x0B0A
     e5e:	90 e0       	ldi	r25, 0x00	; 0
     e60:	fc 01       	movw	r30, r24
     e62:	ee 0f       	add	r30, r30
     e64:	ff 1f       	adc	r31, r31
     e66:	ee 0f       	add	r30, r30
     e68:	ff 1f       	adc	r31, r31
     e6a:	ee 0f       	add	r30, r30
     e6c:	ff 1f       	adc	r31, r31
     e6e:	8e 0f       	add	r24, r30
     e70:	9f 1f       	adc	r25, r31
     e72:	fc 01       	movw	r30, r24
     e74:	e0 5c       	subi	r30, 0xC0	; 192
     e76:	f4 4f       	sbci	r31, 0xF4	; 244
     e78:	80 81       	ld	r24, Z
     e7a:	88 23       	and	r24, r24
     e7c:	49 f3       	breq	.-46     	; 0xe50 <vTaskSwitchContext+0x38>
     e7e:	80 91 0a 0b 	lds	r24, 0x0B0A
     e82:	90 e0       	ldi	r25, 0x00	; 0
     e84:	9c 01       	movw	r18, r24
     e86:	22 0f       	add	r18, r18
     e88:	33 1f       	adc	r19, r19
     e8a:	22 0f       	add	r18, r18
     e8c:	33 1f       	adc	r19, r19
     e8e:	22 0f       	add	r18, r18
     e90:	33 1f       	adc	r19, r19
     e92:	28 0f       	add	r18, r24
     e94:	39 1f       	adc	r19, r25
     e96:	d9 01       	movw	r26, r18
     e98:	a0 5c       	subi	r26, 0xC0	; 192
     e9a:	b4 4f       	sbci	r27, 0xF4	; 244
     e9c:	11 96       	adiw	r26, 0x01	; 1
     e9e:	ed 91       	ld	r30, X+
     ea0:	fc 91       	ld	r31, X
     ea2:	12 97       	sbiw	r26, 0x02	; 2
     ea4:	02 80       	ldd	r0, Z+2	; 0x02
     ea6:	f3 81       	ldd	r31, Z+3	; 0x03
     ea8:	e0 2d       	mov	r30, r0
     eaa:	12 96       	adiw	r26, 0x02	; 2
     eac:	fc 93       	st	X, r31
     eae:	ee 93       	st	-X, r30
     eb0:	11 97       	sbiw	r26, 0x01	; 1
     eb2:	2d 5b       	subi	r18, 0xBD	; 189
     eb4:	34 4f       	sbci	r19, 0xF4	; 244
     eb6:	e2 17       	cp	r30, r18
     eb8:	f3 07       	cpc	r31, r19
     eba:	29 f4       	brne	.+10     	; 0xec6 <vTaskSwitchContext+0xae>
     ebc:	22 81       	ldd	r18, Z+2	; 0x02
     ebe:	33 81       	ldd	r19, Z+3	; 0x03
     ec0:	fd 01       	movw	r30, r26
     ec2:	32 83       	std	Z+2, r19	; 0x02
     ec4:	21 83       	std	Z+1, r18	; 0x01
     ec6:	fc 01       	movw	r30, r24
     ec8:	ee 0f       	add	r30, r30
     eca:	ff 1f       	adc	r31, r31
     ecc:	ee 0f       	add	r30, r30
     ece:	ff 1f       	adc	r31, r31
     ed0:	ee 0f       	add	r30, r30
     ed2:	ff 1f       	adc	r31, r31
     ed4:	8e 0f       	add	r24, r30
     ed6:	9f 1f       	adc	r25, r31
     ed8:	fc 01       	movw	r30, r24
     eda:	e0 5c       	subi	r30, 0xC0	; 192
     edc:	f4 4f       	sbci	r31, 0xF4	; 244
     ede:	01 80       	ldd	r0, Z+1	; 0x01
     ee0:	f2 81       	ldd	r31, Z+2	; 0x02
     ee2:	e0 2d       	mov	r30, r0
     ee4:	86 81       	ldd	r24, Z+6	; 0x06
     ee6:	97 81       	ldd	r25, Z+7	; 0x07
     ee8:	90 93 77 0b 	sts	0x0B77, r25
     eec:	80 93 76 0b 	sts	0x0B76, r24
     ef0:	08 95       	ret

00000ef2 <vMCUStatusTask>:
/* MCU Status task
 * Toggles the MCU status LED, to blink at 2Hz
 * Rate: 4Hz
 * Priority: 1 (lowest)
 */
void vMCUStatusTask(void *pvParameters) {
     ef2:	cf 93       	push	r28
     ef4:	df 93       	push	r29
     ef6:	00 d0       	rcall	.+0      	; 0xef8 <vMCUStatusTask+0x6>
     ef8:	cd b7       	in	r28, 0x3d	; 61
     efa:	de b7       	in	r29, 0x3e	; 62
	// Make compiler happy
	(void) pvParameters;
	
	// Previous wake time pointer, initialized to current tick count.
	// This gets updated by vTaskDelayUntil every time it is called
	TickType_t xLastWakeTime = xTaskGetTickCount();
     efc:	0e 94 44 05 	call	0xa88	; 0xa88 <xTaskGetTickCount>
     f00:	9a 83       	std	Y+2, r25	; 0x02
     f02:	89 83       	std	Y+1, r24	; 0x01
	
	// Task variables
	bool currentValue = 0;	// false
	
	// Setup MCU status pin as output
	config_io_pin(MCU_STATUS_PORT, MCU_STATUS_CH, IO_DIR_OUTPUT);
     f04:	41 e0       	ldi	r20, 0x01	; 1
     f06:	60 e0       	ldi	r22, 0x00	; 0
     f08:	81 e0       	ldi	r24, 0x01	; 1
     f0a:	0e 94 dc 07 	call	0xfb8	; 0xfb8 <config_io_pin>
	
	// Period
	const TickType_t xPeriod = 1000 / MCU_STATUS_TASK_RATE;		// In ticks (ms)
	
	// Task variables
	bool currentValue = 0;	// false
     f0e:	10 e0       	ldi	r17, 0x00	; 0
	config_io_pin(MCU_STATUS_PORT, MCU_STATUS_CH, IO_DIR_OUTPUT);
	
	// Executes infinitely with defined period using vTaskDelayUntil
	for(;;) {
		// Flip value
		currentValue = !currentValue;
     f10:	01 e0       	ldi	r16, 0x01	; 1
     f12:	10 27       	eor	r17, r16
		// Write out value
		set_io_pin(MCU_STATUS_PORT, MCU_STATUS_CH, currentValue);
     f14:	41 2f       	mov	r20, r17
     f16:	60 e0       	ldi	r22, 0x00	; 0
     f18:	80 2f       	mov	r24, r16
     f1a:	0e 94 1b 08 	call	0x1036	; 0x1036 <set_io_pin>
		// Delay until next period
		vTaskDelayUntil(&xLastWakeTime, xPeriod); 
     f1e:	6a ef       	ldi	r22, 0xFA	; 250
     f20:	70 e0       	ldi	r23, 0x00	; 0
     f22:	ce 01       	movw	r24, r28
     f24:	01 96       	adiw	r24, 0x01	; 1
     f26:	0e 94 8d 06 	call	0xd1a	; 0xd1a <vTaskDelayUntil>
	}
     f2a:	f3 cf       	rjmp	.-26     	; 0xf12 <vMCUStatusTask+0x20>

00000f2c <vADCSampleTask>:
/* ADC sample task
 * Samples all ADC channels
 * Rate: 100Hz
 * Priority: 5 (highest)
 */
void vADCSampleTask(void *pvParameters) {
     f2c:	cf 93       	push	r28
     f2e:	df 93       	push	r29
     f30:	00 d0       	rcall	.+0      	; 0xf32 <vADCSampleTask+0x6>
     f32:	cd b7       	in	r28, 0x3d	; 61
     f34:	de b7       	in	r29, 0x3e	; 62
	// Make compiler happy
	(void) pvParameters;
	
	// Previous wake time pointer, initialized to current tick count.
	// This gets updated by vTaskDelayUntil every time it is called
	TickType_t xLastWakeTime = xTaskGetTickCount();
     f36:	0e 94 44 05 	call	0xa88	; 0xa88 <xTaskGetTickCount>
     f3a:	9a 83       	std	Y+2, r25	; 0x02
     f3c:	89 83       	std	Y+1, r24	; 0x01
/* ADC sample task
 * Samples all ADC channels
 * Rate: 100Hz
 * Priority: 5 (highest)
 */
void vADCSampleTask(void *pvParameters) {
     f3e:	00 e0       	ldi	r16, 0x00	; 0
     f40:	10 2f       	mov	r17, r16
	// Executes infinitely with defined period using vTaskDelayUntil
	for(;;) {
		// Loop through and sample all thermistors
		for(i = THERM1; i <= THERM8; i++) {
			// Update ADC value in struct
			adcReadUpdate(i);
     f42:	81 2f       	mov	r24, r17
     f44:	0e 94 9d 00 	call	0x13a	; 0x13a <adcReadUpdate>
     f48:	1f 5f       	subi	r17, 0xFF	; 255
	unsigned i;
	
	// Executes infinitely with defined period using vTaskDelayUntil
	for(;;) {
		// Loop through and sample all thermistors
		for(i = THERM1; i <= THERM8; i++) {
     f4a:	18 30       	cpi	r17, 0x08	; 8
     f4c:	d1 f7       	brne	.-12     	; 0xf42 <vADCSampleTask+0x16>
			// Update ADC value in struct
			adcReadUpdate(i);
		}
		
		// Delay until next period
   		vTaskDelayUntil(&xLastWakeTime, xPeriod);
     f4e:	6a e0       	ldi	r22, 0x0A	; 10
     f50:	70 e0       	ldi	r23, 0x00	; 0
     f52:	ce 01       	movw	r24, r28
     f54:	01 96       	adiw	r24, 0x01	; 1
     f56:	0e 94 8d 06 	call	0xd1a	; 0xd1a <vTaskDelayUntil>
	}
     f5a:	f2 cf       	rjmp	.-28     	; 0xf40 <vADCSampleTask+0x14>

00000f5c <vThermistorWriteTask>:
/* Thermistor Write Task
 * Writes out the thermistor value to the digital pots
 * Rate: 100Hz
 * Priority: 3
 */
void vThermistorWriteTask(void *pvParameters) {
     f5c:	cf 93       	push	r28
     f5e:	df 93       	push	r29
     f60:	00 d0       	rcall	.+0      	; 0xf62 <vThermistorWriteTask+0x6>
     f62:	cd b7       	in	r28, 0x3d	; 61
     f64:	de b7       	in	r29, 0x3e	; 62
	
	// Function variables
	uint16_t valueToWrite = 0x0150;
	uint8_t upperByte, lowerByte;
	uint8_t command;
	SPISlave thermPots = spiSlaves[POT_SYNC];
     f66:	01 e0       	ldi	r16, 0x01	; 1
     f68:	11 e0       	ldi	r17, 0x01	; 1
	
	// Previous wake time pointer, initialized to current tick count.
	// This gets updated by vTaskDelayUntil every time it is called
	TickType_t xLastWakeTime = xTaskGetTickCount();
     f6a:	0e 94 44 05 	call	0xa88	; 0xa88 <xTaskGetTickCount>
     f6e:	9a 83       	std	Y+2, r25	; 0x02
     f70:	89 83       	std	Y+1, r24	; 0x01
	
	// Initialize the pot
	// Enable RDAC register write access
	upperByte = 0x1C;
	lowerByte = 0x02;
	spiSelect(thermPots);
     f72:	81 e0       	ldi	r24, 0x01	; 1
     f74:	91 e0       	ldi	r25, 0x01	; 1
     f76:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <spiSelect>
	spiWrite(upperByte);
     f7a:	8c e1       	ldi	r24, 0x1C	; 28
     f7c:	0e 94 1e 01 	call	0x23c	; 0x23c <spiWrite>
	spiWrite(lowerByte);
     f80:	82 e0       	ldi	r24, 0x02	; 2
     f82:	0e 94 1e 01 	call	0x23c	; 0x23c <spiWrite>
	spiDeselect(thermPots);
     f86:	81 e0       	ldi	r24, 0x01	; 1
     f88:	91 e0       	ldi	r25, 0x01	; 1
     f8a:	0e 94 da 00 	call	0x1b4	; 0x1b4 <spiDeselect>
		command = 0x01;
		upperByte = (command << 2) || (valueToWrite >> 6);
		lowerByte = valueToWrite << 2;
		
		// Write
		spiSelect(thermPots);
     f8e:	80 2f       	mov	r24, r16
     f90:	91 2f       	mov	r25, r17
     f92:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <spiSelect>
		spiWrite(upperByte);
     f96:	81 e0       	ldi	r24, 0x01	; 1
     f98:	0e 94 1e 01 	call	0x23c	; 0x23c <spiWrite>
		spiWrite(lowerByte);
     f9c:	80 e4       	ldi	r24, 0x40	; 64
     f9e:	0e 94 1e 01 	call	0x23c	; 0x23c <spiWrite>
		spiDeselect(thermPots);
     fa2:	80 2f       	mov	r24, r16
     fa4:	91 2f       	mov	r25, r17
     fa6:	0e 94 da 00 	call	0x1b4	; 0x1b4 <spiDeselect>
		
		// Delay until next period
		vTaskDelayUntil(&xLastWakeTime, xPeriod);
     faa:	6a e0       	ldi	r22, 0x0A	; 10
     fac:	70 e0       	ldi	r23, 0x00	; 0
     fae:	ce 01       	movw	r24, r28
     fb0:	01 96       	adiw	r24, 0x01	; 1
     fb2:	0e 94 8d 06 	call	0xd1a	; 0xd1a <vTaskDelayUntil>
	
	// Executes infinitely with defined period using vTaskDelayUntil
	for(;;) {
		// Setup bytes to write
		command = 0x01;
		upperByte = (command << 2) || (valueToWrite >> 6);
     fb6:	eb cf       	rjmp	.-42     	; 0xf8e <vThermistorWriteTask+0x32>

00000fb8 <config_io_pin>:
 *  port_ch: the channel to set, 0-7
 *  dir: the direction, IO_DIR_INPUT or IO_DIR_OUTPUT
 * Returns: void
 */
void config_io_pin(uint8_t port, uint8_t port_ch, uint8_t dir) {
	switch(port){
     fb8:	81 30       	cpi	r24, 0x01	; 1
     fba:	b9 f0       	breq	.+46     	; 0xfea <config_io_pin+0x32>
     fbc:	18 f0       	brcs	.+6      	; 0xfc4 <config_io_pin+0xc>
     fbe:	82 30       	cpi	r24, 0x02	; 2
     fc0:	39 f1       	breq	.+78     	; 0x1010 <config_io_pin+0x58>
     fc2:	08 95       	ret
		case IO_PORTB:
			// Crazy bit trickery that sets specific bit to value
			// without touching other bits
			DDRB ^= ((-dir) ^ DDRB) & (1 << port_ch);
     fc4:	84 b1       	in	r24, 0x04	; 4
     fc6:	24 b1       	in	r18, 0x04	; 4
     fc8:	50 e0       	ldi	r21, 0x00	; 0
     fca:	51 95       	neg	r21
     fcc:	41 95       	neg	r20
     fce:	51 09       	sbc	r21, r1
     fd0:	48 27       	eor	r20, r24
     fd2:	81 e0       	ldi	r24, 0x01	; 1
     fd4:	90 e0       	ldi	r25, 0x00	; 0
     fd6:	02 c0       	rjmp	.+4      	; 0xfdc <config_io_pin+0x24>
     fd8:	88 0f       	add	r24, r24
     fda:	99 1f       	adc	r25, r25
     fdc:	6a 95       	dec	r22
     fde:	e2 f7       	brpl	.-8      	; 0xfd8 <config_io_pin+0x20>
     fe0:	48 23       	and	r20, r24
     fe2:	59 23       	and	r21, r25
     fe4:	42 27       	eor	r20, r18
     fe6:	44 b9       	out	0x04, r20	; 4
			break;
     fe8:	08 95       	ret
		case IO_PORTC:
			DDRC ^= ((-dir) ^ DDRC) & (1 << port_ch);
     fea:	87 b1       	in	r24, 0x07	; 7
     fec:	27 b1       	in	r18, 0x07	; 7
     fee:	50 e0       	ldi	r21, 0x00	; 0
     ff0:	51 95       	neg	r21
     ff2:	41 95       	neg	r20
     ff4:	51 09       	sbc	r21, r1
     ff6:	48 27       	eor	r20, r24
     ff8:	81 e0       	ldi	r24, 0x01	; 1
     ffa:	90 e0       	ldi	r25, 0x00	; 0
     ffc:	02 c0       	rjmp	.+4      	; 0x1002 <config_io_pin+0x4a>
     ffe:	88 0f       	add	r24, r24
    1000:	99 1f       	adc	r25, r25
    1002:	6a 95       	dec	r22
    1004:	e2 f7       	brpl	.-8      	; 0xffe <config_io_pin+0x46>
    1006:	48 23       	and	r20, r24
    1008:	59 23       	and	r21, r25
    100a:	42 27       	eor	r20, r18
    100c:	47 b9       	out	0x07, r20	; 7
			break;
    100e:	08 95       	ret
		case IO_PORTD:
			DDRD ^= ((-dir) ^ DDRD) & (1 << port_ch);
    1010:	8a b1       	in	r24, 0x0a	; 10
    1012:	2a b1       	in	r18, 0x0a	; 10
    1014:	50 e0       	ldi	r21, 0x00	; 0
    1016:	51 95       	neg	r21
    1018:	41 95       	neg	r20
    101a:	51 09       	sbc	r21, r1
    101c:	48 27       	eor	r20, r24
    101e:	81 e0       	ldi	r24, 0x01	; 1
    1020:	90 e0       	ldi	r25, 0x00	; 0
    1022:	02 c0       	rjmp	.+4      	; 0x1028 <config_io_pin+0x70>
    1024:	88 0f       	add	r24, r24
    1026:	99 1f       	adc	r25, r25
    1028:	6a 95       	dec	r22
    102a:	e2 f7       	brpl	.-8      	; 0x1024 <config_io_pin+0x6c>
    102c:	48 23       	and	r20, r24
    102e:	59 23       	and	r21, r25
    1030:	42 27       	eor	r20, r18
    1032:	4a b9       	out	0x0a, r20	; 10
    1034:	08 95       	ret

00001036 <set_io_pin>:
 *  port_ch: the channel to set, 0-7
 *  val: the value, HIGH or LOW
 * Returns: void
 */
void set_io_pin(uint8_t port, uint8_t port_ch, uint8_t val) {
	switch(port){
    1036:	81 30       	cpi	r24, 0x01	; 1
    1038:	b9 f0       	breq	.+46     	; 0x1068 <set_io_pin+0x32>
    103a:	18 f0       	brcs	.+6      	; 0x1042 <set_io_pin+0xc>
    103c:	82 30       	cpi	r24, 0x02	; 2
    103e:	39 f1       	breq	.+78     	; 0x108e <set_io_pin+0x58>
    1040:	08 95       	ret
		case IO_PORTB:
			// Crazy bit trickery that sets specific bit to value
			// without touching other bits
			PORTB ^= ((-val) ^ PORTB) & (1 << port_ch);
    1042:	85 b1       	in	r24, 0x05	; 5
    1044:	25 b1       	in	r18, 0x05	; 5
    1046:	50 e0       	ldi	r21, 0x00	; 0
    1048:	51 95       	neg	r21
    104a:	41 95       	neg	r20
    104c:	51 09       	sbc	r21, r1
    104e:	48 27       	eor	r20, r24
    1050:	81 e0       	ldi	r24, 0x01	; 1
    1052:	90 e0       	ldi	r25, 0x00	; 0
    1054:	02 c0       	rjmp	.+4      	; 0x105a <set_io_pin+0x24>
    1056:	88 0f       	add	r24, r24
    1058:	99 1f       	adc	r25, r25
    105a:	6a 95       	dec	r22
    105c:	e2 f7       	brpl	.-8      	; 0x1056 <set_io_pin+0x20>
    105e:	48 23       	and	r20, r24
    1060:	59 23       	and	r21, r25
    1062:	42 27       	eor	r20, r18
    1064:	45 b9       	out	0x05, r20	; 5
			break;
    1066:	08 95       	ret
		case IO_PORTC:
			PORTC ^= ((-val) ^ PORTC) & (1 << port_ch);
    1068:	88 b1       	in	r24, 0x08	; 8
    106a:	28 b1       	in	r18, 0x08	; 8
    106c:	50 e0       	ldi	r21, 0x00	; 0
    106e:	51 95       	neg	r21
    1070:	41 95       	neg	r20
    1072:	51 09       	sbc	r21, r1
    1074:	48 27       	eor	r20, r24
    1076:	81 e0       	ldi	r24, 0x01	; 1
    1078:	90 e0       	ldi	r25, 0x00	; 0
    107a:	02 c0       	rjmp	.+4      	; 0x1080 <set_io_pin+0x4a>
    107c:	88 0f       	add	r24, r24
    107e:	99 1f       	adc	r25, r25
    1080:	6a 95       	dec	r22
    1082:	e2 f7       	brpl	.-8      	; 0x107c <set_io_pin+0x46>
    1084:	48 23       	and	r20, r24
    1086:	59 23       	and	r21, r25
    1088:	42 27       	eor	r20, r18
    108a:	48 b9       	out	0x08, r20	; 8
			break;
    108c:	08 95       	ret
		case IO_PORTD:
			PORTD ^= ((-val) ^ PORTD) & (1 << port_ch);
    108e:	8b b1       	in	r24, 0x0b	; 11
    1090:	2b b1       	in	r18, 0x0b	; 11
    1092:	50 e0       	ldi	r21, 0x00	; 0
    1094:	51 95       	neg	r21
    1096:	41 95       	neg	r20
    1098:	51 09       	sbc	r21, r1
    109a:	48 27       	eor	r20, r24
    109c:	81 e0       	ldi	r24, 0x01	; 1
    109e:	90 e0       	ldi	r25, 0x00	; 0
    10a0:	02 c0       	rjmp	.+4      	; 0x10a6 <set_io_pin+0x70>
    10a2:	88 0f       	add	r24, r24
    10a4:	99 1f       	adc	r25, r25
    10a6:	6a 95       	dec	r22
    10a8:	e2 f7       	brpl	.-8      	; 0x10a2 <set_io_pin+0x6c>
    10aa:	48 23       	and	r20, r24
    10ac:	59 23       	and	r21, r25
    10ae:	42 27       	eor	r20, r18
    10b0:	4b b9       	out	0x0b, r20	; 11
    10b2:	08 95       	ret

000010b4 <_exit>:
    10b4:	f8 94       	cli

000010b6 <__stop_program>:
    10b6:	ff cf       	rjmp	.-2      	; 0x10b6 <__stop_program>
