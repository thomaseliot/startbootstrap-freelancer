
ThermistorExpansionModule.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002a  00800100  000011fc  00001290  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000011fc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000a56  0080012a  0080012a  000012ba  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000012ba  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000012ec  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000310  00000000  00000000  0000132c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000036ee  00000000  00000000  0000163c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d5d  00000000  00000000  00004d2a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001377  00000000  00000000  00005a87  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000808  00000000  00000000  00006e00  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000010d7  00000000  00000000  00007608  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000028d7  00000000  00000000  000086df  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000002f8  00000000  00000000  0000afb6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 67 03 	jmp	0x6ce	; 0x6ce <__vector_12>
      34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d0 e1       	ldi	r29, 0x10	; 16
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	11 e0       	ldi	r17, 0x01	; 1
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	ec ef       	ldi	r30, 0xFC	; 252
      90:	f1 e1       	ldi	r31, 0x11	; 17
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	aa 32       	cpi	r26, 0x2A	; 42
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	2b e0       	ldi	r18, 0x0B	; 11
      a0:	aa e2       	ldi	r26, 0x2A	; 42
      a2:	b1 e0       	ldi	r27, 0x01	; 1
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	a0 38       	cpi	r26, 0x80	; 128
      aa:	b2 07       	cpc	r27, r18
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 18 01 	call	0x230	; 0x230 <main>
      b2:	0c 94 fc 08 	jmp	0x11f8	; 0x11f8 <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <initADC>:
#include "adc.h"

/* ititAdc
 * Initialize the ADC
 */
void initADC(void) {
      ba:	a0 e0       	ldi	r26, 0x00	; 0
      bc:	b1 e0       	ldi	r27, 0x01	; 1
      be:	ea e2       	ldi	r30, 0x2A	; 42
      c0:	f1 e0       	ldi	r31, 0x01	; 1
      c2:	22 e4       	ldi	r18, 0x42	; 66
      c4:	31 e0       	ldi	r19, 0x01	; 1
	int i;
	// Initialize channel storage struct
	for(i = THERM1; i <= THERM8; i++) {
		ADCMeta meta = {adcChannelMap[i], 0};
      c6:	8d 91       	ld	r24, X+
		adcChannels[i] = meta;
      c8:	80 83       	st	Z, r24
      ca:	12 82       	std	Z+2, r1	; 0x02
      cc:	11 82       	std	Z+1, r1	; 0x01
      ce:	33 96       	adiw	r30, 0x03	; 3
 * Initialize the ADC
 */
void initADC(void) {
	int i;
	// Initialize channel storage struct
	for(i = THERM1; i <= THERM8; i++) {
      d0:	e2 17       	cp	r30, r18
      d2:	f3 07       	cpc	r31, r19
      d4:	c1 f7       	brne	.-16     	; 0xc6 <initADC+0xc>
		adcChannels[i] = meta;
	}
	
	// Set configuration registers
	// Set ADC prescaler to 128 - 1MHz sample rate @ 16MHz
	ADCSRA |= (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0); 
      d6:	ea e7       	ldi	r30, 0x7A	; 122
      d8:	f0 e0       	ldi	r31, 0x00	; 0
      da:	80 81       	ld	r24, Z
      dc:	87 60       	ori	r24, 0x07	; 7
      de:	80 83       	st	Z, r24
	
	// Left adjust ADC result to allow easy 8 bit reading
	ADMUX  |= (1 << ADLAR);
      e0:	ac e7       	ldi	r26, 0x7C	; 124
      e2:	b0 e0       	ldi	r27, 0x00	; 0
      e4:	8c 91       	ld	r24, X
      e6:	80 62       	ori	r24, 0x20	; 32
      e8:	8c 93       	st	X, r24
	// Set ADC high speed mode
	ADCSRB |= (1 << ADHSM);
      ea:	ab e7       	ldi	r26, 0x7B	; 123
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	8c 91       	ld	r24, X
      f0:	80 68       	ori	r24, 0x80	; 128
      f2:	8c 93       	st	X, r24
	
	// No MUX values needed to be changed for initialization
	// Set ADC reference to AREF (AREFEN = 1, ISRCEN = 0, REFS1 = 0, REFS0 = 0)
	ADCSRB |= (1 << AREFEN);
      f4:	8c 91       	ld	r24, X
      f6:	80 62       	ori	r24, 0x20	; 32
      f8:	8c 93       	st	X, r24
	// Enable ADC
	ADCSRA |= (1 << ADEN);
      fa:	80 81       	ld	r24, Z
      fc:	80 68       	ori	r24, 0x80	; 128
      fe:	80 83       	st	Z, r24
     100:	08 95       	ret

00000102 <readADC>:
 *	ch: the channel number to read
 * Returns: the result of the conversion, 8-bit
 */
uint16_t readADC(uint8_t ch) {
	// Critical section **********************************************************
	taskENTER_CRITICAL();
     102:	0f b6       	in	r0, 0x3f	; 63
     104:	f8 94       	cli
     106:	0f 92       	push	r0
	// Set which channel to read. Leave all ADMUX bits as is except MUX4-0
	if(ch > 12) ch = 18;	// Read ground if invalid channel
     108:	8d 30       	cpi	r24, 0x0D	; 13
     10a:	08 f0       	brcs	.+2      	; 0x10e <readADC+0xc>
     10c:	82 e1       	ldi	r24, 0x12	; 18
	ADMUX &= 0xE0;					// Clear MUX bits
     10e:	ec e7       	ldi	r30, 0x7C	; 124
     110:	f0 e0       	ldi	r31, 0x00	; 0
     112:	90 81       	ld	r25, Z
     114:	90 7e       	andi	r25, 0xE0	; 224
     116:	90 83       	st	Z, r25
	ADMUX |= ch;				// Set MUX to channel
     118:	90 81       	ld	r25, Z
     11a:	89 2b       	or	r24, r25
     11c:	80 83       	st	Z, r24
	
	// Set ADC start conversion bit
	ADCSRA |= (1 << ADSC);
     11e:	ea e7       	ldi	r30, 0x7A	; 122
     120:	f0 e0       	ldi	r31, 0x00	; 0
     122:	80 81       	ld	r24, Z
     124:	80 64       	ori	r24, 0x40	; 64
     126:	80 83       	st	Z, r24
	taskEXIT_CRITICAL();
     128:	0f 90       	pop	r0
     12a:	0f be       	out	0x3f, r0	; 63
	//****************************************************************************
	
	// Wait for ADCSRA bit ADSC to go low for data conversion to complete
	while(ADCSRA & (1 << ADSC)) {
     12c:	80 81       	ld	r24, Z
     12e:	86 fd       	sbrc	r24, 6
     130:	fd cf       	rjmp	.-6      	; 0x12c <readADC+0x2a>
		// the ADC values as atomically as possible.
		// taskYIELD();
	}
	
	// Return read channel
	return ADCH;
     132:	80 91 79 00 	lds	r24, 0x0079
}
     136:	90 e0       	ldi	r25, 0x00	; 0
     138:	08 95       	ret

0000013a <updateADC>:
 * Read an ADC channel and updates the ADC value struct
 * Arguments:
 *	ch: the channel enumeration ID to read
 * Returns: the result of the conversion, 8-bit
 */
void updateADC(ADCChannel ch) {
     13a:	cf 93       	push	r28
     13c:	df 93       	push	r29
	uint8_t physicalChannel;
	uint16_t channelValue;
	
	// Convert ADCChannel to physical channel
	physicalChannel = adcChannelMap[ch];
     13e:	c8 2f       	mov	r28, r24
     140:	d0 e0       	ldi	r29, 0x00	; 0
     142:	fe 01       	movw	r30, r28
     144:	e0 50       	subi	r30, 0x00	; 0
     146:	ff 4f       	sbci	r31, 0xFF	; 255
	
	// Read channel
	channelValue = readADC(physicalChannel);
     148:	80 81       	ld	r24, Z
     14a:	0e 94 81 00 	call	0x102	; 0x102 <readADC>
	
	// Update struct
	adcChannels[ch].currentValue = channelValue;
     14e:	9e 01       	movw	r18, r28
     150:	22 0f       	add	r18, r18
     152:	33 1f       	adc	r19, r19
     154:	c2 0f       	add	r28, r18
     156:	d3 1f       	adc	r29, r19
     158:	c6 5d       	subi	r28, 0xD6	; 214
     15a:	de 4f       	sbci	r29, 0xFE	; 254
     15c:	9a 83       	std	Y+2, r25	; 0x02
     15e:	89 83       	std	Y+1, r24	; 0x01
}
     160:	df 91       	pop	r29
     162:	cf 91       	pop	r28
     164:	08 95       	ret

00000166 <spiSetClockDivider>:
 * Set the clock divider to the specified rate
 * 
 * @param rate the rate to set to
 */
void spiSetClockDivider(SPI_CLOCK_DIV_t rate) {
	SPCR = (SPCR & ~SPI_CLOCK_MASK) | ((uint8_t)rate & SPI_CLOCK_MASK);
     166:	9c b5       	in	r25, 0x2c	; 44
     168:	28 2f       	mov	r18, r24
     16a:	23 70       	andi	r18, 0x03	; 3
     16c:	9c 7f       	andi	r25, 0xFC	; 252
     16e:	92 2b       	or	r25, r18
     170:	9c bd       	out	0x2c, r25	; 44
	SPSR = (SPSR & ~SPI_2XCLOCK_MASK) | (((uint8_t)rate >> 2) & SPI_2XCLOCK_MASK);
     172:	9d b5       	in	r25, 0x2d	; 45
     174:	82 fb       	bst	r24, 2
     176:	88 27       	eor	r24, r24
     178:	80 f9       	bld	r24, 0
     17a:	9e 7f       	andi	r25, 0xFE	; 254
     17c:	89 2b       	or	r24, r25
     17e:	8d bd       	out	0x2d, r24	; 45
     180:	08 95       	ret

00000182 <spiSetBitOrder>:
 * Set the specified bit order
 * 
 * @param bitOrder the bit order to set to
 */
void spiSetBitOrder(uint8_t bitOrder) {
	if(bitOrder == SPI_LSBFIRST) {
     182:	81 11       	cpse	r24, r1
     184:	04 c0       	rjmp	.+8      	; 0x18e <spiSetBitOrder+0xc>
		SPCR |= _BV(DORD);
     186:	8c b5       	in	r24, 0x2c	; 44
     188:	80 62       	ori	r24, 0x20	; 32
     18a:	8c bd       	out	0x2c, r24	; 44
     18c:	08 95       	ret
	} else {
		SPCR &= ~(_BV(DORD));
     18e:	8c b5       	in	r24, 0x2c	; 44
     190:	8f 7d       	andi	r24, 0xDF	; 223
     192:	8c bd       	out	0x2c, r24	; 44
     194:	08 95       	ret

00000196 <spiSetDataMode>:
 * Set the data mode to the specified mode
 * 
 * @param mode the mode to set to
 */
void spiSetDataMode(SPI_MODE_t mode) {
	SPCR = (SPCR & ~SPI_MODE_MASK) | (uint8_t) mode;
     196:	9c b5       	in	r25, 0x2c	; 44
     198:	93 7f       	andi	r25, 0xF3	; 243
     19a:	89 2b       	or	r24, r25
     19c:	8c bd       	out	0x2c, r24	; 44
     19e:	08 95       	ret

000001a0 <spiSelect>:
 * Select the specified slave
 * 
 * @param slave the slave to select
 */
void spiSelect(SPISlave slave) {
	taskENTER_CRITICAL();
     1a0:	0f b6       	in	r0, 0x3f	; 63
     1a2:	f8 94       	cli
     1a4:	0f 92       	push	r0
	// Set pin low
	setPin(slave.port, slave.pin, LOW);
     1a6:	40 e0       	ldi	r20, 0x00	; 0
     1a8:	69 2f       	mov	r22, r25
     1aa:	0e 94 bd 08 	call	0x117a	; 0x117a <setPin>
	taskEXIT_CRITICAL();
     1ae:	0f 90       	pop	r0
     1b0:	0f be       	out	0x3f, r0	; 63
     1b2:	08 95       	ret

000001b4 <spiDeselect>:
 * Deselect the specified slave
 * 
 * @param slave the slave to select
 */
void spiDeselect(SPISlave slave) {
	taskENTER_CRITICAL();
     1b4:	0f b6       	in	r0, 0x3f	; 63
     1b6:	f8 94       	cli
     1b8:	0f 92       	push	r0
	// Set pin high
	setPin(slave.port, slave.pin, HIGH);
     1ba:	41 e0       	ldi	r20, 0x01	; 1
     1bc:	69 2f       	mov	r22, r25
     1be:	0e 94 bd 08 	call	0x117a	; 0x117a <setPin>
	taskEXIT_CRITICAL();
     1c2:	0f 90       	pop	r0
     1c4:	0f be       	out	0x3f, r0	; 63
     1c6:	08 95       	ret

000001c8 <spiDeselectAll>:
 */
void spiDeselectAll(void) {
	// Function variables
	uint8_t i;
	
	taskENTER_CRITICAL();
     1c8:	0f b6       	in	r0, 0x3f	; 63
     1ca:	f8 94       	cli
     1cc:	0f 92       	push	r0
	// Loop through each slave and deselect it
	for(i = 0; i < NUM_SLAVES; i++) {
		spiDeselect(spiSlaves[i]);
     1ce:	80 91 08 01 	lds	r24, 0x0108
     1d2:	90 91 09 01 	lds	r25, 0x0109
     1d6:	0e 94 da 00 	call	0x1b4	; 0x1b4 <spiDeselect>
	}
	taskEXIT_CRITICAL();
     1da:	0f 90       	pop	r0
     1dc:	0f be       	out	0x3f, r0	; 63
     1de:	08 95       	ret

000001e0 <spiInit>:
void spiInit(void) {
	// Function variables
	uint8_t i;
	
	// Set digital pin directions for MISO/MOSI/SCK
	pinMode(SPI_MISO_PORT, SPI_MISO_PIN, IO_DIR_INPUT);
     1e0:	40 e0       	ldi	r20, 0x00	; 0
     1e2:	60 e0       	ldi	r22, 0x00	; 0
     1e4:	80 e0       	ldi	r24, 0x00	; 0
     1e6:	0e 94 7e 08 	call	0x10fc	; 0x10fc <pinMode>
	pinMode(SPI_MOSI_PORT, SPI_MOSI_PIN, IO_DIR_OUTPUT);
     1ea:	41 e0       	ldi	r20, 0x01	; 1
     1ec:	61 e0       	ldi	r22, 0x01	; 1
     1ee:	80 e0       	ldi	r24, 0x00	; 0
     1f0:	0e 94 7e 08 	call	0x10fc	; 0x10fc <pinMode>
	pinMode(SPI_SCK_PORT, SPI_SCK_PIN, IO_DIR_OUTPUT); 
     1f4:	41 e0       	ldi	r20, 0x01	; 1
     1f6:	67 e0       	ldi	r22, 0x07	; 7
     1f8:	80 e0       	ldi	r24, 0x00	; 0
     1fa:	0e 94 7e 08 	call	0x10fc	; 0x10fc <pinMode>
	
	// Set digital pin direction for default SS
	// Note that this must be output, or SPI could go into slave mode
	pinMode(SPI_SS_PORT, SPI_SS_PIN, IO_DIR_OUTPUT);
     1fe:	41 e0       	ldi	r20, 0x01	; 1
     200:	61 e0       	ldi	r22, 0x01	; 1
     202:	81 e0       	ldi	r24, 0x01	; 1
     204:	0e 94 7e 08 	call	0x10fc	; 0x10fc <pinMode>
	
	// Set digital pin directions for all slaves. If they are connected
	// to the default SS, this will just be redundant.
	for(i = 0; i < NUM_SLAVES; i++) {
		pinMode(spiSlaves[i].port, spiSlaves[i].pin, IO_DIR_OUTPUT);
     208:	41 e0       	ldi	r20, 0x01	; 1
     20a:	61 e0       	ldi	r22, 0x01	; 1
     20c:	81 e0       	ldi	r24, 0x01	; 1
     20e:	0e 94 7e 08 	call	0x10fc	; 0x10fc <pinMode>
	}
	
	// Deselect all slaves
	spiDeselectAll();
     212:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <spiDeselectAll>
	
	// Enable SPI, and Master
	SPCR = (1 << SPE) | (1 << MSTR); 
     216:	80 e5       	ldi	r24, 0x50	; 80
     218:	8c bd       	out	0x2c, r24	; 44
	
	// Read SPSR and SPDR to clear them
	i = SPSR;
     21a:	8d b5       	in	r24, 0x2d	; 45
	i = SPDR;
     21c:	8e b5       	in	r24, 0x2e	; 46
     21e:	08 95       	ret

00000220 <spiWrite>:
 * Returns:
 *		void
 */
void spiWrite(uint8_t byte) {
	// Make sure SPI module has been enabled
	if( !(SPCR & _BV(SPE)) ) return;
     220:	0c b4       	in	r0, 0x2c	; 44
     222:	06 fe       	sbrs	r0, 6
     224:	04 c0       	rjmp	.+8      	; 0x22e <spiWrite+0xe>
	
	// Set data register
	SPDR = byte;
     226:	8e bd       	out	0x2e, r24	; 46
	
	// Wait for transfer to complete
	while (!(SPSR & (1 << SPIF)));
     228:	0d b4       	in	r0, 0x2d	; 45
     22a:	07 fe       	sbrs	r0, 7
     22c:	fd cf       	rjmp	.-6      	; 0x228 <spiWrite+0x8>
     22e:	08 95       	ret

00000230 <main>:
#include "spi.h"


// Main function, runs once
int main(void)
{	
     230:	af 92       	push	r10
     232:	bf 92       	push	r11
     234:	cf 92       	push	r12
     236:	df 92       	push	r13
     238:	ef 92       	push	r14
     23a:	ff 92       	push	r15
     23c:	0f 93       	push	r16
	// Initialize ADC
	initADC();
     23e:	0e 94 5d 00 	call	0xba	; 0xba <initADC>
	
	// Initialize SPI
	spiInit();
     242:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <spiInit>
	spiSetClockDivider(SPI_CLOCK_DIV64);
     246:	82 e0       	ldi	r24, 0x02	; 2
     248:	0e 94 b3 00 	call	0x166	; 0x166 <spiSetClockDivider>
	spiSetBitOrder(SPI_MSBFIRST);
     24c:	81 e0       	ldi	r24, 0x01	; 1
     24e:	0e 94 c1 00 	call	0x182	; 0x182 <spiSetBitOrder>
	spiSetDataMode(SPI_MODE1);
     252:	84 e0       	ldi	r24, 0x04	; 4
     254:	0e 94 cb 00 	call	0x196	; 0x196 <spiSetDataMode>
	
	// Hold both thermistor out relays open
	pinMode(OPEN_FAULT_PORT, OPEN_FAULT_CH, IO_DIR_OUTPUT);
     258:	41 e0       	ldi	r20, 0x01	; 1
     25a:	67 e0       	ldi	r22, 0x07	; 7
     25c:	81 e0       	ldi	r24, 0x01	; 1
     25e:	0e 94 7e 08 	call	0x10fc	; 0x10fc <pinMode>
	pinMode(SHORT_FAULT_PORT, SHORT_FAULT_CH, IO_DIR_OUTPUT);
     262:	41 e0       	ldi	r20, 0x01	; 1
     264:	60 e0       	ldi	r22, 0x00	; 0
     266:	82 e0       	ldi	r24, 0x02	; 2
     268:	0e 94 7e 08 	call	0x10fc	; 0x10fc <pinMode>
	setPin(OPEN_FAULT_PORT, OPEN_FAULT_CH, HIGH);
     26c:	41 e0       	ldi	r20, 0x01	; 1
     26e:	67 e0       	ldi	r22, 0x07	; 7
     270:	81 e0       	ldi	r24, 0x01	; 1
     272:	0e 94 bd 08 	call	0x117a	; 0x117a <setPin>
	setPin(SHORT_FAULT_PORT, SHORT_FAULT_CH, HIGH);
     276:	41 e0       	ldi	r20, 0x01	; 1
     278:	60 e0       	ldi	r22, 0x00	; 0
     27a:	82 e0       	ldi	r24, 0x02	; 2
     27c:	0e 94 bd 08 	call	0x117a	; 0x117a <setPin>
	
	// Create the MCU status task, to blink the LED
	// Rate: 4Hz
    xTaskCreate(vMCUStatusTask, "STATUS", configMINIMAL_STACK_SIZE, 
     280:	a1 2c       	mov	r10, r1
     282:	b1 2c       	mov	r11, r1
     284:	c1 2c       	mov	r12, r1
     286:	d1 2c       	mov	r13, r1
     288:	e1 2c       	mov	r14, r1
     28a:	f1 2c       	mov	r15, r1
     28c:	01 e0       	ldi	r16, 0x01	; 1
     28e:	20 e0       	ldi	r18, 0x00	; 0
     290:	30 e0       	ldi	r19, 0x00	; 0
     292:	44 e6       	ldi	r20, 0x64	; 100
     294:	50 e0       	ldi	r21, 0x00	; 0
     296:	6a e0       	ldi	r22, 0x0A	; 10
     298:	71 e0       	ldi	r23, 0x01	; 1
     29a:	8a e7       	ldi	r24, 0x7A	; 122
     29c:	97 e0       	ldi	r25, 0x07	; 7
     29e:	0e 94 f6 03 	call	0x7ec	; 0x7ec <xTaskGenericCreate>
		NULL, MCU_STATUS_TASK_PRIORITY, NULL);
	
	// Create ADC read task
	// Rate: 100Hz
	xTaskCreate(vADCSampleTask, "ADC", configMINIMAL_STACK_SIZE,
     2a2:	04 e0       	ldi	r16, 0x04	; 4
     2a4:	20 e0       	ldi	r18, 0x00	; 0
     2a6:	30 e0       	ldi	r19, 0x00	; 0
     2a8:	44 e6       	ldi	r20, 0x64	; 100
     2aa:	50 e0       	ldi	r21, 0x00	; 0
     2ac:	61 e1       	ldi	r22, 0x11	; 17
     2ae:	71 e0       	ldi	r23, 0x01	; 1
     2b0:	87 e9       	ldi	r24, 0x97	; 151
     2b2:	97 e0       	ldi	r25, 0x07	; 7
     2b4:	0e 94 f6 03 	call	0x7ec	; 0x7ec <xTaskGenericCreate>
	// Create thermistor read task
	//xTaskCreate(vThermistorReadTask, "TEMPIN", configMINIMAL_STACK_SIZE,
	//	NULL, THERMISTOR_READ_TASK_PRIORITY, NULL);
	
	// Create thermistor write task
	xTaskCreate(vThermistorWriteTask, "TEMPOUT", configMINIMAL_STACK_SIZE,
     2b8:	03 e0       	ldi	r16, 0x03	; 3
     2ba:	20 e0       	ldi	r18, 0x00	; 0
     2bc:	30 e0       	ldi	r19, 0x00	; 0
     2be:	44 e6       	ldi	r20, 0x64	; 100
     2c0:	50 e0       	ldi	r21, 0x00	; 0
     2c2:	65 e1       	ldi	r22, 0x15	; 21
     2c4:	71 e0       	ldi	r23, 0x01	; 1
     2c6:	8a ed       	ldi	r24, 0xDA	; 218
     2c8:	97 e0       	ldi	r25, 0x07	; 7
     2ca:	0e 94 f6 03 	call	0x7ec	; 0x7ec <xTaskGenericCreate>
		NULL, THERMISTOR_WRITE_TASK_PRIORITY, NULL);
		
	// Create watchdog kick task
	xTaskCreate(vWatchdogTask, "EXTWDT", configMINIMAL_STACK_SIZE,
     2ce:	05 e0       	ldi	r16, 0x05	; 5
     2d0:	20 e0       	ldi	r18, 0x00	; 0
     2d2:	30 e0       	ldi	r19, 0x00	; 0
     2d4:	44 e6       	ldi	r20, 0x64	; 100
     2d6:	50 e0       	ldi	r21, 0x00	; 0
     2d8:	6d e1       	ldi	r22, 0x1D	; 29
     2da:	71 e0       	ldi	r23, 0x01	; 1
     2dc:	8f ea       	ldi	r24, 0xAF	; 175
     2de:	97 e0       	ldi	r25, 0x07	; 7
     2e0:	0e 94 f6 03 	call	0x7ec	; 0x7ec <xTaskGenericCreate>
		NULL, WATCHDOG_TASK_PRIORITY, NULL);
	
	// Start the scheduler
	vTaskStartScheduler();
     2e4:	0e 94 0d 05 	call	0xa1a	; 0xa1a <vTaskStartScheduler>
	
	// Return, the scheduler handles the rest
	return 0;
}
     2e8:	80 e0       	ldi	r24, 0x00	; 0
     2ea:	90 e0       	ldi	r25, 0x00	; 0
     2ec:	0f 91       	pop	r16
     2ee:	ff 90       	pop	r15
     2f0:	ef 90       	pop	r14
     2f2:	df 90       	pop	r13
     2f4:	cf 90       	pop	r12
     2f6:	bf 90       	pop	r11
     2f8:	af 90       	pop	r10
     2fa:	08 95       	ret

000002fc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     2fc:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2fe:	03 96       	adiw	r24, 0x03	; 3
     300:	92 83       	std	Z+2, r25	; 0x02
     302:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     304:	2f ef       	ldi	r18, 0xFF	; 255
     306:	3f ef       	ldi	r19, 0xFF	; 255
     308:	34 83       	std	Z+4, r19	; 0x04
     30a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     30c:	96 83       	std	Z+6, r25	; 0x06
     30e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     310:	90 87       	std	Z+8, r25	; 0x08
     312:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     314:	10 82       	st	Z, r1
     316:	08 95       	ret

00000318 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     318:	fc 01       	movw	r30, r24
     31a:	11 86       	std	Z+9, r1	; 0x09
     31c:	10 86       	std	Z+8, r1	; 0x08
     31e:	08 95       	ret

00000320 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     320:	cf 93       	push	r28
     322:	df 93       	push	r29
     324:	9c 01       	movw	r18, r24
     326:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     328:	dc 01       	movw	r26, r24
     32a:	11 96       	adiw	r26, 0x01	; 1
     32c:	cd 91       	ld	r28, X+
     32e:	dc 91       	ld	r29, X
     330:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     332:	d3 83       	std	Z+3, r29	; 0x03
     334:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     336:	8c 81       	ldd	r24, Y+4	; 0x04
     338:	9d 81       	ldd	r25, Y+5	; 0x05
     33a:	95 83       	std	Z+5, r25	; 0x05
     33c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     33e:	8c 81       	ldd	r24, Y+4	; 0x04
     340:	9d 81       	ldd	r25, Y+5	; 0x05
     342:	dc 01       	movw	r26, r24
     344:	13 96       	adiw	r26, 0x03	; 3
     346:	7c 93       	st	X, r23
     348:	6e 93       	st	-X, r22
     34a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     34c:	7d 83       	std	Y+5, r23	; 0x05
     34e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     350:	31 87       	std	Z+9, r19	; 0x09
     352:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     354:	f9 01       	movw	r30, r18
     356:	80 81       	ld	r24, Z
     358:	8f 5f       	subi	r24, 0xFF	; 255
     35a:	80 83       	st	Z, r24
}
     35c:	df 91       	pop	r29
     35e:	cf 91       	pop	r28
     360:	08 95       	ret

00000362 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     362:	cf 93       	push	r28
     364:	df 93       	push	r29
     366:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     368:	48 81       	ld	r20, Y
     36a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     36c:	4f 3f       	cpi	r20, 0xFF	; 255
     36e:	2f ef       	ldi	r18, 0xFF	; 255
     370:	52 07       	cpc	r21, r18
     372:	21 f4       	brne	.+8      	; 0x37c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     374:	fc 01       	movw	r30, r24
     376:	a7 81       	ldd	r26, Z+7	; 0x07
     378:	b0 85       	ldd	r27, Z+8	; 0x08
     37a:	0d c0       	rjmp	.+26     	; 0x396 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     37c:	dc 01       	movw	r26, r24
     37e:	13 96       	adiw	r26, 0x03	; 3
     380:	01 c0       	rjmp	.+2      	; 0x384 <vListInsert+0x22>
     382:	df 01       	movw	r26, r30
     384:	12 96       	adiw	r26, 0x02	; 2
     386:	ed 91       	ld	r30, X+
     388:	fc 91       	ld	r31, X
     38a:	13 97       	sbiw	r26, 0x03	; 3
     38c:	20 81       	ld	r18, Z
     38e:	31 81       	ldd	r19, Z+1	; 0x01
     390:	42 17       	cp	r20, r18
     392:	53 07       	cpc	r21, r19
     394:	b0 f7       	brcc	.-20     	; 0x382 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     396:	12 96       	adiw	r26, 0x02	; 2
     398:	ed 91       	ld	r30, X+
     39a:	fc 91       	ld	r31, X
     39c:	13 97       	sbiw	r26, 0x03	; 3
     39e:	fb 83       	std	Y+3, r31	; 0x03
     3a0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     3a2:	d5 83       	std	Z+5, r29	; 0x05
     3a4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     3a6:	bd 83       	std	Y+5, r27	; 0x05
     3a8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     3aa:	13 96       	adiw	r26, 0x03	; 3
     3ac:	dc 93       	st	X, r29
     3ae:	ce 93       	st	-X, r28
     3b0:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     3b2:	99 87       	std	Y+9, r25	; 0x09
     3b4:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     3b6:	fc 01       	movw	r30, r24
     3b8:	20 81       	ld	r18, Z
     3ba:	2f 5f       	subi	r18, 0xFF	; 255
     3bc:	20 83       	st	Z, r18
}
     3be:	df 91       	pop	r29
     3c0:	cf 91       	pop	r28
     3c2:	08 95       	ret

000003c4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     3c4:	cf 93       	push	r28
     3c6:	df 93       	push	r29
     3c8:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     3ca:	a0 85       	ldd	r26, Z+8	; 0x08
     3cc:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     3ce:	c2 81       	ldd	r28, Z+2	; 0x02
     3d0:	d3 81       	ldd	r29, Z+3	; 0x03
     3d2:	84 81       	ldd	r24, Z+4	; 0x04
     3d4:	95 81       	ldd	r25, Z+5	; 0x05
     3d6:	9d 83       	std	Y+5, r25	; 0x05
     3d8:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     3da:	c4 81       	ldd	r28, Z+4	; 0x04
     3dc:	d5 81       	ldd	r29, Z+5	; 0x05
     3de:	82 81       	ldd	r24, Z+2	; 0x02
     3e0:	93 81       	ldd	r25, Z+3	; 0x03
     3e2:	9b 83       	std	Y+3, r25	; 0x03
     3e4:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     3e6:	11 96       	adiw	r26, 0x01	; 1
     3e8:	cd 91       	ld	r28, X+
     3ea:	dc 91       	ld	r29, X
     3ec:	12 97       	sbiw	r26, 0x02	; 2
     3ee:	ce 17       	cp	r28, r30
     3f0:	df 07       	cpc	r29, r31
     3f2:	31 f4       	brne	.+12     	; 0x400 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     3f4:	8c 81       	ldd	r24, Y+4	; 0x04
     3f6:	9d 81       	ldd	r25, Y+5	; 0x05
     3f8:	12 96       	adiw	r26, 0x02	; 2
     3fa:	9c 93       	st	X, r25
     3fc:	8e 93       	st	-X, r24
     3fe:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     400:	11 86       	std	Z+9, r1	; 0x09
     402:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     404:	8c 91       	ld	r24, X
     406:	81 50       	subi	r24, 0x01	; 1
     408:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     40a:	df 91       	pop	r29
     40c:	cf 91       	pop	r28
     40e:	08 95       	ret

00000410 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     410:	31 e1       	ldi	r19, 0x11	; 17
     412:	fc 01       	movw	r30, r24
     414:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     416:	31 97       	sbiw	r30, 0x01	; 1
     418:	22 e2       	ldi	r18, 0x22	; 34
     41a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     41c:	31 97       	sbiw	r30, 0x01	; 1
     41e:	a3 e3       	ldi	r26, 0x33	; 51
     420:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     422:	31 97       	sbiw	r30, 0x01	; 1
     424:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     426:	31 97       	sbiw	r30, 0x01	; 1
     428:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     42a:	31 97       	sbiw	r30, 0x01	; 1
     42c:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     42e:	31 97       	sbiw	r30, 0x01	; 1
     430:	60 e8       	ldi	r22, 0x80	; 128
     432:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     434:	31 97       	sbiw	r30, 0x01	; 1
     436:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     438:	31 97       	sbiw	r30, 0x01	; 1
     43a:	62 e0       	ldi	r22, 0x02	; 2
     43c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     43e:	31 97       	sbiw	r30, 0x01	; 1
     440:	63 e0       	ldi	r22, 0x03	; 3
     442:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     444:	31 97       	sbiw	r30, 0x01	; 1
     446:	64 e0       	ldi	r22, 0x04	; 4
     448:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     44a:	31 97       	sbiw	r30, 0x01	; 1
     44c:	65 e0       	ldi	r22, 0x05	; 5
     44e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     450:	31 97       	sbiw	r30, 0x01	; 1
     452:	66 e0       	ldi	r22, 0x06	; 6
     454:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     456:	31 97       	sbiw	r30, 0x01	; 1
     458:	67 e0       	ldi	r22, 0x07	; 7
     45a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     45c:	31 97       	sbiw	r30, 0x01	; 1
     45e:	68 e0       	ldi	r22, 0x08	; 8
     460:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     462:	31 97       	sbiw	r30, 0x01	; 1
     464:	69 e0       	ldi	r22, 0x09	; 9
     466:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     468:	31 97       	sbiw	r30, 0x01	; 1
     46a:	60 e1       	ldi	r22, 0x10	; 16
     46c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     46e:	31 97       	sbiw	r30, 0x01	; 1
     470:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     472:	31 97       	sbiw	r30, 0x01	; 1
     474:	32 e1       	ldi	r19, 0x12	; 18
     476:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     478:	31 97       	sbiw	r30, 0x01	; 1
     47a:	33 e1       	ldi	r19, 0x13	; 19
     47c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     47e:	31 97       	sbiw	r30, 0x01	; 1
     480:	34 e1       	ldi	r19, 0x14	; 20
     482:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     484:	31 97       	sbiw	r30, 0x01	; 1
     486:	35 e1       	ldi	r19, 0x15	; 21
     488:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     48a:	31 97       	sbiw	r30, 0x01	; 1
     48c:	36 e1       	ldi	r19, 0x16	; 22
     48e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     490:	31 97       	sbiw	r30, 0x01	; 1
     492:	37 e1       	ldi	r19, 0x17	; 23
     494:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     496:	31 97       	sbiw	r30, 0x01	; 1
     498:	38 e1       	ldi	r19, 0x18	; 24
     49a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     49c:	31 97       	sbiw	r30, 0x01	; 1
     49e:	39 e1       	ldi	r19, 0x19	; 25
     4a0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     4a2:	31 97       	sbiw	r30, 0x01	; 1
     4a4:	30 e2       	ldi	r19, 0x20	; 32
     4a6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     4a8:	31 97       	sbiw	r30, 0x01	; 1
     4aa:	31 e2       	ldi	r19, 0x21	; 33
     4ac:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     4ae:	31 97       	sbiw	r30, 0x01	; 1
     4b0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     4b2:	31 97       	sbiw	r30, 0x01	; 1
     4b4:	23 e2       	ldi	r18, 0x23	; 35
     4b6:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     4b8:	31 97       	sbiw	r30, 0x01	; 1
     4ba:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     4bc:	31 97       	sbiw	r30, 0x01	; 1
     4be:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     4c0:	31 97       	sbiw	r30, 0x01	; 1
     4c2:	26 e2       	ldi	r18, 0x26	; 38
     4c4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     4c6:	31 97       	sbiw	r30, 0x01	; 1
     4c8:	27 e2       	ldi	r18, 0x27	; 39
     4ca:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     4cc:	31 97       	sbiw	r30, 0x01	; 1
     4ce:	28 e2       	ldi	r18, 0x28	; 40
     4d0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     4d2:	31 97       	sbiw	r30, 0x01	; 1
     4d4:	29 e2       	ldi	r18, 0x29	; 41
     4d6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     4d8:	31 97       	sbiw	r30, 0x01	; 1
     4da:	20 e3       	ldi	r18, 0x30	; 48
     4dc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     4de:	31 97       	sbiw	r30, 0x01	; 1
     4e0:	21 e3       	ldi	r18, 0x31	; 49
     4e2:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     4e4:	86 97       	sbiw	r24, 0x26	; 38
     4e6:	08 95       	ret

000004e8 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     4e8:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
     4ec:	89 ef       	ldi	r24, 0xF9	; 249
     4ee:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     4f2:	8b e0       	ldi	r24, 0x0B	; 11
     4f4:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
     4f8:	ef e6       	ldi	r30, 0x6F	; 111
     4fa:	f0 e0       	ldi	r31, 0x00	; 0
     4fc:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     4fe:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
     500:	80 83       	st	Z, r24
	
	TCNT1 = 0;
     502:	10 92 85 00 	sts	0x0085, r1
     506:	10 92 84 00 	sts	0x0084, r1
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     50a:	a0 91 7e 0b 	lds	r26, 0x0B7E
     50e:	b0 91 7f 0b 	lds	r27, 0x0B7F
     512:	cd 91       	ld	r28, X+
     514:	cd bf       	out	0x3d, r28	; 61
     516:	dd 91       	ld	r29, X+
     518:	de bf       	out	0x3e, r29	; 62
     51a:	ff 91       	pop	r31
     51c:	ef 91       	pop	r30
     51e:	df 91       	pop	r29
     520:	cf 91       	pop	r28
     522:	bf 91       	pop	r27
     524:	af 91       	pop	r26
     526:	9f 91       	pop	r25
     528:	8f 91       	pop	r24
     52a:	7f 91       	pop	r23
     52c:	6f 91       	pop	r22
     52e:	5f 91       	pop	r21
     530:	4f 91       	pop	r20
     532:	3f 91       	pop	r19
     534:	2f 91       	pop	r18
     536:	1f 91       	pop	r17
     538:	0f 91       	pop	r16
     53a:	ff 90       	pop	r15
     53c:	ef 90       	pop	r14
     53e:	df 90       	pop	r13
     540:	cf 90       	pop	r12
     542:	bf 90       	pop	r11
     544:	af 90       	pop	r10
     546:	9f 90       	pop	r9
     548:	8f 90       	pop	r8
     54a:	7f 90       	pop	r7
     54c:	6f 90       	pop	r6
     54e:	5f 90       	pop	r5
     550:	4f 90       	pop	r4
     552:	3f 90       	pop	r3
     554:	2f 90       	pop	r2
     556:	1f 90       	pop	r1
     558:	0f 90       	pop	r0
     55a:	0f be       	out	0x3f, r0	; 63
     55c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     55e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     560:	81 e0       	ldi	r24, 0x01	; 1
     562:	08 95       	ret

00000564 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     564:	0f 92       	push	r0
     566:	0f b6       	in	r0, 0x3f	; 63
     568:	f8 94       	cli
     56a:	0f 92       	push	r0
     56c:	1f 92       	push	r1
     56e:	11 24       	eor	r1, r1
     570:	2f 92       	push	r2
     572:	3f 92       	push	r3
     574:	4f 92       	push	r4
     576:	5f 92       	push	r5
     578:	6f 92       	push	r6
     57a:	7f 92       	push	r7
     57c:	8f 92       	push	r8
     57e:	9f 92       	push	r9
     580:	af 92       	push	r10
     582:	bf 92       	push	r11
     584:	cf 92       	push	r12
     586:	df 92       	push	r13
     588:	ef 92       	push	r14
     58a:	ff 92       	push	r15
     58c:	0f 93       	push	r16
     58e:	1f 93       	push	r17
     590:	2f 93       	push	r18
     592:	3f 93       	push	r19
     594:	4f 93       	push	r20
     596:	5f 93       	push	r21
     598:	6f 93       	push	r22
     59a:	7f 93       	push	r23
     59c:	8f 93       	push	r24
     59e:	9f 93       	push	r25
     5a0:	af 93       	push	r26
     5a2:	bf 93       	push	r27
     5a4:	cf 93       	push	r28
     5a6:	df 93       	push	r29
     5a8:	ef 93       	push	r30
     5aa:	ff 93       	push	r31
     5ac:	a0 91 7e 0b 	lds	r26, 0x0B7E
     5b0:	b0 91 7f 0b 	lds	r27, 0x0B7F
     5b4:	0d b6       	in	r0, 0x3d	; 61
     5b6:	0d 92       	st	X+, r0
     5b8:	0e b6       	in	r0, 0x3e	; 62
     5ba:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     5bc:	0e 94 0d 07 	call	0xe1a	; 0xe1a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     5c0:	a0 91 7e 0b 	lds	r26, 0x0B7E
     5c4:	b0 91 7f 0b 	lds	r27, 0x0B7F
     5c8:	cd 91       	ld	r28, X+
     5ca:	cd bf       	out	0x3d, r28	; 61
     5cc:	dd 91       	ld	r29, X+
     5ce:	de bf       	out	0x3e, r29	; 62
     5d0:	ff 91       	pop	r31
     5d2:	ef 91       	pop	r30
     5d4:	df 91       	pop	r29
     5d6:	cf 91       	pop	r28
     5d8:	bf 91       	pop	r27
     5da:	af 91       	pop	r26
     5dc:	9f 91       	pop	r25
     5de:	8f 91       	pop	r24
     5e0:	7f 91       	pop	r23
     5e2:	6f 91       	pop	r22
     5e4:	5f 91       	pop	r21
     5e6:	4f 91       	pop	r20
     5e8:	3f 91       	pop	r19
     5ea:	2f 91       	pop	r18
     5ec:	1f 91       	pop	r17
     5ee:	0f 91       	pop	r16
     5f0:	ff 90       	pop	r15
     5f2:	ef 90       	pop	r14
     5f4:	df 90       	pop	r13
     5f6:	cf 90       	pop	r12
     5f8:	bf 90       	pop	r11
     5fa:	af 90       	pop	r10
     5fc:	9f 90       	pop	r9
     5fe:	8f 90       	pop	r8
     600:	7f 90       	pop	r7
     602:	6f 90       	pop	r6
     604:	5f 90       	pop	r5
     606:	4f 90       	pop	r4
     608:	3f 90       	pop	r3
     60a:	2f 90       	pop	r2
     60c:	1f 90       	pop	r1
     60e:	0f 90       	pop	r0
     610:	0f be       	out	0x3f, r0	; 63
     612:	0f 90       	pop	r0

	asm volatile ( "ret" );
     614:	08 95       	ret

00000616 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     616:	0f 92       	push	r0
     618:	0f b6       	in	r0, 0x3f	; 63
     61a:	f8 94       	cli
     61c:	0f 92       	push	r0
     61e:	1f 92       	push	r1
     620:	11 24       	eor	r1, r1
     622:	2f 92       	push	r2
     624:	3f 92       	push	r3
     626:	4f 92       	push	r4
     628:	5f 92       	push	r5
     62a:	6f 92       	push	r6
     62c:	7f 92       	push	r7
     62e:	8f 92       	push	r8
     630:	9f 92       	push	r9
     632:	af 92       	push	r10
     634:	bf 92       	push	r11
     636:	cf 92       	push	r12
     638:	df 92       	push	r13
     63a:	ef 92       	push	r14
     63c:	ff 92       	push	r15
     63e:	0f 93       	push	r16
     640:	1f 93       	push	r17
     642:	2f 93       	push	r18
     644:	3f 93       	push	r19
     646:	4f 93       	push	r20
     648:	5f 93       	push	r21
     64a:	6f 93       	push	r22
     64c:	7f 93       	push	r23
     64e:	8f 93       	push	r24
     650:	9f 93       	push	r25
     652:	af 93       	push	r26
     654:	bf 93       	push	r27
     656:	cf 93       	push	r28
     658:	df 93       	push	r29
     65a:	ef 93       	push	r30
     65c:	ff 93       	push	r31
     65e:	a0 91 7e 0b 	lds	r26, 0x0B7E
     662:	b0 91 7f 0b 	lds	r27, 0x0B7F
     666:	0d b6       	in	r0, 0x3d	; 61
     668:	0d 92       	st	X+, r0
     66a:	0e b6       	in	r0, 0x3e	; 62
     66c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     66e:	0e 94 4f 05 	call	0xa9e	; 0xa9e <xTaskIncrementTick>
     672:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     674:	0e 94 0d 07 	call	0xe1a	; 0xe1a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     678:	a0 91 7e 0b 	lds	r26, 0x0B7E
     67c:	b0 91 7f 0b 	lds	r27, 0x0B7F
     680:	cd 91       	ld	r28, X+
     682:	cd bf       	out	0x3d, r28	; 61
     684:	dd 91       	ld	r29, X+
     686:	de bf       	out	0x3e, r29	; 62
     688:	ff 91       	pop	r31
     68a:	ef 91       	pop	r30
     68c:	df 91       	pop	r29
     68e:	cf 91       	pop	r28
     690:	bf 91       	pop	r27
     692:	af 91       	pop	r26
     694:	9f 91       	pop	r25
     696:	8f 91       	pop	r24
     698:	7f 91       	pop	r23
     69a:	6f 91       	pop	r22
     69c:	5f 91       	pop	r21
     69e:	4f 91       	pop	r20
     6a0:	3f 91       	pop	r19
     6a2:	2f 91       	pop	r18
     6a4:	1f 91       	pop	r17
     6a6:	0f 91       	pop	r16
     6a8:	ff 90       	pop	r15
     6aa:	ef 90       	pop	r14
     6ac:	df 90       	pop	r13
     6ae:	cf 90       	pop	r12
     6b0:	bf 90       	pop	r11
     6b2:	af 90       	pop	r10
     6b4:	9f 90       	pop	r9
     6b6:	8f 90       	pop	r8
     6b8:	7f 90       	pop	r7
     6ba:	6f 90       	pop	r6
     6bc:	5f 90       	pop	r5
     6be:	4f 90       	pop	r4
     6c0:	3f 90       	pop	r3
     6c2:	2f 90       	pop	r2
     6c4:	1f 90       	pop	r1
     6c6:	0f 90       	pop	r0
     6c8:	0f be       	out	0x3f, r0	; 63
     6ca:	0f 90       	pop	r0

	asm volatile ( "ret" );
     6cc:	08 95       	ret

000006ce <__vector_12>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	ISR(TIMER1_COMPA_vect, ISR_NAKED)
	{
		vPortYieldFromTick();
     6ce:	0e 94 0b 03 	call	0x616	; 0x616 <vPortYieldFromTick>
		asm volatile ( "reti" );
     6d2:	18 95       	reti

000006d4 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     6d4:	cf 93       	push	r28
     6d6:	df 93       	push	r29
     6d8:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     6da:	0e 94 3f 05 	call	0xa7e	; 0xa7e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     6de:	80 91 42 01 	lds	r24, 0x0142
     6e2:	90 91 43 01 	lds	r25, 0x0143
     6e6:	89 2b       	or	r24, r25
     6e8:	31 f4       	brne	.+12     	; 0x6f6 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     6ea:	87 e4       	ldi	r24, 0x47	; 71
     6ec:	91 e0       	ldi	r25, 0x01	; 1
     6ee:	90 93 43 01 	sts	0x0143, r25
     6f2:	80 93 42 01 	sts	0x0142, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     6f6:	20 91 44 01 	lds	r18, 0x0144
     6fa:	30 91 45 01 	lds	r19, 0x0145
     6fe:	ce 01       	movw	r24, r28
     700:	82 0f       	add	r24, r18
     702:	93 1f       	adc	r25, r19
     704:	83 3c       	cpi	r24, 0xC3	; 195
     706:	49 e0       	ldi	r20, 0x09	; 9
     708:	94 07       	cpc	r25, r20
     70a:	70 f4       	brcc	.+28     	; 0x728 <pvPortMalloc+0x54>
     70c:	28 17       	cp	r18, r24
     70e:	39 07       	cpc	r19, r25
     710:	70 f4       	brcc	.+28     	; 0x72e <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     712:	c0 91 42 01 	lds	r28, 0x0142
     716:	d0 91 43 01 	lds	r29, 0x0143
     71a:	c2 0f       	add	r28, r18
     71c:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     71e:	90 93 45 01 	sts	0x0145, r25
     722:	80 93 44 01 	sts	0x0144, r24
     726:	05 c0       	rjmp	.+10     	; 0x732 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     728:	c0 e0       	ldi	r28, 0x00	; 0
     72a:	d0 e0       	ldi	r29, 0x00	; 0
     72c:	02 c0       	rjmp	.+4      	; 0x732 <pvPortMalloc+0x5e>
     72e:	c0 e0       	ldi	r28, 0x00	; 0
     730:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     732:	0e 94 0c 06 	call	0xc18	; 0xc18 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     736:	ce 01       	movw	r24, r28
     738:	df 91       	pop	r29
     73a:	cf 91       	pop	r28
     73c:	08 95       	ret

0000073e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     73e:	08 95       	ret

00000740 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     740:	e0 91 34 0b 	lds	r30, 0x0B34
     744:	f0 91 35 0b 	lds	r31, 0x0B35
     748:	80 81       	ld	r24, Z
     74a:	81 11       	cpse	r24, r1
     74c:	07 c0       	rjmp	.+14     	; 0x75c <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     74e:	8f ef       	ldi	r24, 0xFF	; 255
     750:	9f ef       	ldi	r25, 0xFF	; 255
     752:	90 93 0c 0b 	sts	0x0B0C, r25
     756:	80 93 0b 0b 	sts	0x0B0B, r24
     75a:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     75c:	e0 91 34 0b 	lds	r30, 0x0B34
     760:	f0 91 35 0b 	lds	r31, 0x0B35
     764:	05 80       	ldd	r0, Z+5	; 0x05
     766:	f6 81       	ldd	r31, Z+6	; 0x06
     768:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
     76a:	06 80       	ldd	r0, Z+6	; 0x06
     76c:	f7 81       	ldd	r31, Z+7	; 0x07
     76e:	e0 2d       	mov	r30, r0
     770:	82 81       	ldd	r24, Z+2	; 0x02
     772:	93 81       	ldd	r25, Z+3	; 0x03
     774:	90 93 0c 0b 	sts	0x0B0C, r25
     778:	80 93 0b 0b 	sts	0x0B0B, r24
     77c:	08 95       	ret

0000077e <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
     77e:	cf 93       	push	r28
     780:	df 93       	push	r29
     782:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     784:	e0 91 7e 0b 	lds	r30, 0x0B7E
     788:	f0 91 7f 0b 	lds	r31, 0x0B7F
     78c:	93 83       	std	Z+3, r25	; 0x03
     78e:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
     790:	80 91 13 0b 	lds	r24, 0x0B13
     794:	90 91 14 0b 	lds	r25, 0x0B14
     798:	c8 17       	cp	r28, r24
     79a:	d9 07       	cpc	r29, r25
     79c:	68 f4       	brcc	.+26     	; 0x7b8 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     79e:	60 91 7e 0b 	lds	r22, 0x0B7E
     7a2:	70 91 7f 0b 	lds	r23, 0x0B7F
     7a6:	80 91 32 0b 	lds	r24, 0x0B32
     7aa:	90 91 33 0b 	lds	r25, 0x0B33
     7ae:	6e 5f       	subi	r22, 0xFE	; 254
     7b0:	7f 4f       	sbci	r23, 0xFF	; 255
     7b2:	0e 94 b1 01 	call	0x362	; 0x362 <vListInsert>
     7b6:	17 c0       	rjmp	.+46     	; 0x7e6 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     7b8:	60 91 7e 0b 	lds	r22, 0x0B7E
     7bc:	70 91 7f 0b 	lds	r23, 0x0B7F
     7c0:	80 91 34 0b 	lds	r24, 0x0B34
     7c4:	90 91 35 0b 	lds	r25, 0x0B35
     7c8:	6e 5f       	subi	r22, 0xFE	; 254
     7ca:	7f 4f       	sbci	r23, 0xFF	; 255
     7cc:	0e 94 b1 01 	call	0x362	; 0x362 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
     7d0:	80 91 0b 0b 	lds	r24, 0x0B0B
     7d4:	90 91 0c 0b 	lds	r25, 0x0B0C
     7d8:	c8 17       	cp	r28, r24
     7da:	d9 07       	cpc	r29, r25
     7dc:	20 f4       	brcc	.+8      	; 0x7e6 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
     7de:	d0 93 0c 0b 	sts	0x0B0C, r29
     7e2:	c0 93 0b 0b 	sts	0x0B0B, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     7e6:	df 91       	pop	r29
     7e8:	cf 91       	pop	r28
     7ea:	08 95       	ret

000007ec <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
     7ec:	4f 92       	push	r4
     7ee:	5f 92       	push	r5
     7f0:	6f 92       	push	r6
     7f2:	7f 92       	push	r7
     7f4:	8f 92       	push	r8
     7f6:	9f 92       	push	r9
     7f8:	af 92       	push	r10
     7fa:	bf 92       	push	r11
     7fc:	cf 92       	push	r12
     7fe:	df 92       	push	r13
     800:	ef 92       	push	r14
     802:	ff 92       	push	r15
     804:	0f 93       	push	r16
     806:	1f 93       	push	r17
     808:	cf 93       	push	r28
     80a:	df 93       	push	r29
     80c:	4c 01       	movw	r8, r24
     80e:	eb 01       	movw	r28, r22
     810:	5a 01       	movw	r10, r20
     812:	29 01       	movw	r4, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     814:	c1 14       	cp	r12, r1
     816:	d1 04       	cpc	r13, r1
     818:	39 f4       	brne	.+14     	; 0x828 <xTaskGenericCreate+0x3c>
     81a:	ca 01       	movw	r24, r20
     81c:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <pvPortMalloc>
     820:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
     822:	89 2b       	or	r24, r25
     824:	09 f4       	brne	.+2      	; 0x828 <xTaskGenericCreate+0x3c>
     826:	e7 c0       	rjmp	.+462    	; 0x9f6 <xTaskGenericCreate+0x20a>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     828:	86 e2       	ldi	r24, 0x26	; 38
     82a:	90 e0       	ldi	r25, 0x00	; 0
     82c:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <pvPortMalloc>
     830:	3c 01       	movw	r6, r24

			if( pxNewTCB != NULL )
     832:	00 97       	sbiw	r24, 0x00	; 0
     834:	79 f0       	breq	.+30     	; 0x854 <xTaskGenericCreate+0x68>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
     836:	fc 01       	movw	r30, r24
     838:	d0 8e       	std	Z+24, r13	; 0x18
     83a:	c7 8a       	std	Z+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
     83c:	f1 e0       	ldi	r31, 0x01	; 1
     83e:	af 1a       	sub	r10, r31
     840:	b1 08       	sbc	r11, r1
     842:	ca 0c       	add	r12, r10
     844:	db 1c       	adc	r13, r11
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     846:	88 81       	ld	r24, Y
     848:	f3 01       	movw	r30, r6
     84a:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     84c:	88 81       	ld	r24, Y
     84e:	81 11       	cpse	r24, r1
     850:	05 c0       	rjmp	.+10     	; 0x85c <xTaskGenericCreate+0x70>
     852:	14 c0       	rjmp	.+40     	; 0x87c <xTaskGenericCreate+0x90>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
     854:	c6 01       	movw	r24, r12
     856:	0e 94 9f 03 	call	0x73e	; 0x73e <vPortFree>
     85a:	cd c0       	rjmp	.+410    	; 0x9f6 <xTaskGenericCreate+0x20a>
     85c:	d3 01       	movw	r26, r6
     85e:	5a 96       	adiw	r26, 0x1a	; 26
     860:	fe 01       	movw	r30, r28
     862:	31 96       	adiw	r30, 0x01	; 1
     864:	9e 01       	movw	r18, r28
     866:	28 5f       	subi	r18, 0xF8	; 248
     868:	3f 4f       	sbci	r19, 0xFF	; 255
     86a:	ef 01       	movw	r28, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     86c:	81 91       	ld	r24, Z+
     86e:	8d 93       	st	X+, r24

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     870:	88 81       	ld	r24, Y
     872:	88 23       	and	r24, r24
     874:	19 f0       	breq	.+6      	; 0x87c <xTaskGenericCreate+0x90>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     876:	e2 17       	cp	r30, r18
     878:	f3 07       	cpc	r31, r19
     87a:	b9 f7       	brne	.-18     	; 0x86a <xTaskGenericCreate+0x7e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     87c:	f3 01       	movw	r30, r6
     87e:	10 a2       	std	Z+32, r1	; 0x20
     880:	10 2f       	mov	r17, r16
     882:	06 30       	cpi	r16, 0x06	; 6
     884:	08 f0       	brcs	.+2      	; 0x888 <xTaskGenericCreate+0x9c>
     886:	15 e0       	ldi	r17, 0x05	; 5
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
     888:	f3 01       	movw	r30, r6
     88a:	16 8b       	std	Z+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     88c:	e3 01       	movw	r28, r6
     88e:	22 96       	adiw	r28, 0x02	; 2
     890:	ce 01       	movw	r24, r28
     892:	0e 94 8c 01 	call	0x318	; 0x318 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     896:	c3 01       	movw	r24, r6
     898:	0c 96       	adiw	r24, 0x0c	; 12
     89a:	0e 94 8c 01 	call	0x318	; 0x318 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     89e:	f3 01       	movw	r30, r6
     8a0:	71 86       	std	Z+9, r7	; 0x09
     8a2:	60 86       	std	Z+8, r6	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     8a4:	86 e0       	ldi	r24, 0x06	; 6
     8a6:	90 e0       	ldi	r25, 0x00	; 0
     8a8:	81 1b       	sub	r24, r17
     8aa:	91 09       	sbc	r25, r1
     8ac:	95 87       	std	Z+13, r25	; 0x0d
     8ae:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     8b0:	73 8a       	std	Z+19, r7	; 0x13
     8b2:	62 8a       	std	Z+18, r6	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
     8b4:	11 a2       	std	Z+33, r1	; 0x21
     8b6:	12 a2       	std	Z+34, r1	; 0x22
     8b8:	13 a2       	std	Z+35, r1	; 0x23
     8ba:	14 a2       	std	Z+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
     8bc:	15 a2       	std	Z+37, r1	; 0x25
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     8be:	a2 01       	movw	r20, r4
     8c0:	b4 01       	movw	r22, r8
     8c2:	c6 01       	movw	r24, r12
     8c4:	0e 94 08 02 	call	0x410	; 0x410 <pxPortInitialiseStack>
     8c8:	f3 01       	movw	r30, r6
     8ca:	91 83       	std	Z+1, r25	; 0x01
     8cc:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
     8ce:	e1 14       	cp	r14, r1
     8d0:	f1 04       	cpc	r15, r1
     8d2:	19 f0       	breq	.+6      	; 0x8da <xTaskGenericCreate+0xee>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     8d4:	f7 01       	movw	r30, r14
     8d6:	71 82       	std	Z+1, r7	; 0x01
     8d8:	60 82       	st	Z, r6
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
     8da:	0f b6       	in	r0, 0x3f	; 63
     8dc:	f8 94       	cli
     8de:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     8e0:	80 91 15 0b 	lds	r24, 0x0B15
     8e4:	8f 5f       	subi	r24, 0xFF	; 255
     8e6:	80 93 15 0b 	sts	0x0B15, r24
			if( pxCurrentTCB == NULL )
     8ea:	80 91 7e 0b 	lds	r24, 0x0B7E
     8ee:	90 91 7f 0b 	lds	r25, 0x0B7F
     8f2:	89 2b       	or	r24, r25
     8f4:	09 f0       	breq	.+2      	; 0x8f8 <xTaskGenericCreate+0x10c>
     8f6:	3f c0       	rjmp	.+126    	; 0x976 <xTaskGenericCreate+0x18a>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     8f8:	70 92 7f 0b 	sts	0x0B7F, r7
     8fc:	60 92 7e 0b 	sts	0x0B7E, r6

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     900:	80 91 15 0b 	lds	r24, 0x0B15
     904:	81 30       	cpi	r24, 0x01	; 1
     906:	09 f0       	breq	.+2      	; 0x90a <xTaskGenericCreate+0x11e>
     908:	45 c0       	rjmp	.+138    	; 0x994 <xTaskGenericCreate+0x1a8>
     90a:	0f 2e       	mov	r0, r31
     90c:	f8 e4       	ldi	r31, 0x48	; 72
     90e:	ef 2e       	mov	r14, r31
     910:	fb e0       	ldi	r31, 0x0B	; 11
     912:	ff 2e       	mov	r15, r31
     914:	f0 2d       	mov	r31, r0
     916:	0f 2e       	mov	r0, r31
     918:	fe e7       	ldi	r31, 0x7E	; 126
     91a:	cf 2e       	mov	r12, r31
     91c:	fb e0       	ldi	r31, 0x0B	; 11
     91e:	df 2e       	mov	r13, r31
     920:	f0 2d       	mov	r31, r0
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     922:	c7 01       	movw	r24, r14
     924:	0e 94 7e 01 	call	0x2fc	; 0x2fc <vListInitialise>
     928:	f9 e0       	ldi	r31, 0x09	; 9
     92a:	ef 0e       	add	r14, r31
     92c:	f1 1c       	adc	r15, r1

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
     92e:	ec 14       	cp	r14, r12
     930:	fd 04       	cpc	r15, r13
     932:	b9 f7       	brne	.-18     	; 0x922 <xTaskGenericCreate+0x136>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
     934:	8f e3       	ldi	r24, 0x3F	; 63
     936:	9b e0       	ldi	r25, 0x0B	; 11
     938:	0e 94 7e 01 	call	0x2fc	; 0x2fc <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     93c:	86 e3       	ldi	r24, 0x36	; 54
     93e:	9b e0       	ldi	r25, 0x0B	; 11
     940:	0e 94 7e 01 	call	0x2fc	; 0x2fc <vListInitialise>
	vListInitialise( &xPendingReadyList );
     944:	89 e2       	ldi	r24, 0x29	; 41
     946:	9b e0       	ldi	r25, 0x0B	; 11
     948:	0e 94 7e 01 	call	0x2fc	; 0x2fc <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     94c:	80 e2       	ldi	r24, 0x20	; 32
     94e:	9b e0       	ldi	r25, 0x0B	; 11
     950:	0e 94 7e 01 	call	0x2fc	; 0x2fc <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     954:	86 e1       	ldi	r24, 0x16	; 22
     956:	9b e0       	ldi	r25, 0x0B	; 11
     958:	0e 94 7e 01 	call	0x2fc	; 0x2fc <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     95c:	8f e3       	ldi	r24, 0x3F	; 63
     95e:	9b e0       	ldi	r25, 0x0B	; 11
     960:	90 93 35 0b 	sts	0x0B35, r25
     964:	80 93 34 0b 	sts	0x0B34, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     968:	86 e3       	ldi	r24, 0x36	; 54
     96a:	9b e0       	ldi	r25, 0x0B	; 11
     96c:	90 93 33 0b 	sts	0x0B33, r25
     970:	80 93 32 0b 	sts	0x0B32, r24
     974:	0f c0       	rjmp	.+30     	; 0x994 <xTaskGenericCreate+0x1a8>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     976:	80 91 11 0b 	lds	r24, 0x0B11
     97a:	81 11       	cpse	r24, r1
     97c:	0b c0       	rjmp	.+22     	; 0x994 <xTaskGenericCreate+0x1a8>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     97e:	e0 91 7e 0b 	lds	r30, 0x0B7E
     982:	f0 91 7f 0b 	lds	r31, 0x0B7F
     986:	86 89       	ldd	r24, Z+22	; 0x16
     988:	08 17       	cp	r16, r24
     98a:	20 f0       	brcs	.+8      	; 0x994 <xTaskGenericCreate+0x1a8>
					{
						pxCurrentTCB = pxNewTCB;
     98c:	70 92 7f 0b 	sts	0x0B7F, r7
     990:	60 92 7e 0b 	sts	0x0B7E, r6
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
     994:	80 91 0d 0b 	lds	r24, 0x0B0D
     998:	8f 5f       	subi	r24, 0xFF	; 255
     99a:	80 93 0d 0b 	sts	0x0B0D, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
     99e:	f3 01       	movw	r30, r6
     9a0:	86 89       	ldd	r24, Z+22	; 0x16
     9a2:	90 91 12 0b 	lds	r25, 0x0B12
     9a6:	98 17       	cp	r25, r24
     9a8:	10 f4       	brcc	.+4      	; 0x9ae <xTaskGenericCreate+0x1c2>
     9aa:	80 93 12 0b 	sts	0x0B12, r24
     9ae:	90 e0       	ldi	r25, 0x00	; 0
     9b0:	9c 01       	movw	r18, r24
     9b2:	22 0f       	add	r18, r18
     9b4:	33 1f       	adc	r19, r19
     9b6:	22 0f       	add	r18, r18
     9b8:	33 1f       	adc	r19, r19
     9ba:	22 0f       	add	r18, r18
     9bc:	33 1f       	adc	r19, r19
     9be:	82 0f       	add	r24, r18
     9c0:	93 1f       	adc	r25, r19
     9c2:	be 01       	movw	r22, r28
     9c4:	88 5b       	subi	r24, 0xB8	; 184
     9c6:	94 4f       	sbci	r25, 0xF4	; 244
     9c8:	0e 94 90 01 	call	0x320	; 0x320 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     9cc:	0f 90       	pop	r0
     9ce:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
     9d0:	80 91 11 0b 	lds	r24, 0x0B11
     9d4:	88 23       	and	r24, r24
     9d6:	59 f0       	breq	.+22     	; 0x9ee <xTaskGenericCreate+0x202>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     9d8:	e0 91 7e 0b 	lds	r30, 0x0B7E
     9dc:	f0 91 7f 0b 	lds	r31, 0x0B7F
     9e0:	86 89       	ldd	r24, Z+22	; 0x16
     9e2:	80 17       	cp	r24, r16
     9e4:	30 f4       	brcc	.+12     	; 0x9f2 <xTaskGenericCreate+0x206>
			{
				taskYIELD_IF_USING_PREEMPTION();
     9e6:	0e 94 b2 02 	call	0x564	; 0x564 <vPortYield>
     9ea:	81 e0       	ldi	r24, 0x01	; 1
     9ec:	05 c0       	rjmp	.+10     	; 0x9f8 <xTaskGenericCreate+0x20c>
     9ee:	81 e0       	ldi	r24, 0x01	; 1
     9f0:	03 c0       	rjmp	.+6      	; 0x9f8 <xTaskGenericCreate+0x20c>
     9f2:	81 e0       	ldi	r24, 0x01	; 1
     9f4:	01 c0       	rjmp	.+2      	; 0x9f8 <xTaskGenericCreate+0x20c>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     9f6:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
     9f8:	df 91       	pop	r29
     9fa:	cf 91       	pop	r28
     9fc:	1f 91       	pop	r17
     9fe:	0f 91       	pop	r16
     a00:	ff 90       	pop	r15
     a02:	ef 90       	pop	r14
     a04:	df 90       	pop	r13
     a06:	cf 90       	pop	r12
     a08:	bf 90       	pop	r11
     a0a:	af 90       	pop	r10
     a0c:	9f 90       	pop	r9
     a0e:	8f 90       	pop	r8
     a10:	7f 90       	pop	r7
     a12:	6f 90       	pop	r6
     a14:	5f 90       	pop	r5
     a16:	4f 90       	pop	r4
     a18:	08 95       	ret

00000a1a <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     a1a:	af 92       	push	r10
     a1c:	bf 92       	push	r11
     a1e:	cf 92       	push	r12
     a20:	df 92       	push	r13
     a22:	ef 92       	push	r14
     a24:	ff 92       	push	r15
     a26:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
     a28:	a1 2c       	mov	r10, r1
     a2a:	b1 2c       	mov	r11, r1
     a2c:	c1 2c       	mov	r12, r1
     a2e:	d1 2c       	mov	r13, r1
     a30:	e1 2c       	mov	r14, r1
     a32:	f1 2c       	mov	r15, r1
     a34:	00 e0       	ldi	r16, 0x00	; 0
     a36:	20 e0       	ldi	r18, 0x00	; 0
     a38:	30 e0       	ldi	r19, 0x00	; 0
     a3a:	44 e6       	ldi	r20, 0x64	; 100
     a3c:	50 e0       	ldi	r21, 0x00	; 0
     a3e:	64 e2       	ldi	r22, 0x24	; 36
     a40:	71 e0       	ldi	r23, 0x01	; 1
     a42:	80 ed       	ldi	r24, 0xD0	; 208
     a44:	96 e0       	ldi	r25, 0x06	; 6
     a46:	0e 94 f6 03 	call	0x7ec	; 0x7ec <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     a4a:	81 30       	cpi	r24, 0x01	; 1
     a4c:	81 f4       	brne	.+32     	; 0xa6e <vTaskStartScheduler+0x54>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     a4e:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     a50:	8f ef       	ldi	r24, 0xFF	; 255
     a52:	9f ef       	ldi	r25, 0xFF	; 255
     a54:	90 93 0c 0b 	sts	0x0B0C, r25
     a58:	80 93 0b 0b 	sts	0x0B0B, r24
		xSchedulerRunning = pdTRUE;
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	80 93 11 0b 	sts	0x0B11, r24
		xTickCount = ( TickType_t ) 0U;
     a62:	10 92 14 0b 	sts	0x0B14, r1
     a66:	10 92 13 0b 	sts	0x0B13, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     a6a:	0e 94 74 02 	call	0x4e8	; 0x4e8 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     a6e:	0f 91       	pop	r16
     a70:	ff 90       	pop	r15
     a72:	ef 90       	pop	r14
     a74:	df 90       	pop	r13
     a76:	cf 90       	pop	r12
     a78:	bf 90       	pop	r11
     a7a:	af 90       	pop	r10
     a7c:	08 95       	ret

00000a7e <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     a7e:	80 91 0a 0b 	lds	r24, 0x0B0A
     a82:	8f 5f       	subi	r24, 0xFF	; 255
     a84:	80 93 0a 0b 	sts	0x0B0A, r24
     a88:	08 95       	ret

00000a8a <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     a8a:	0f b6       	in	r0, 0x3f	; 63
     a8c:	f8 94       	cli
     a8e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     a90:	80 91 13 0b 	lds	r24, 0x0B13
     a94:	90 91 14 0b 	lds	r25, 0x0B14
	}
	portTICK_TYPE_EXIT_CRITICAL();
     a98:	0f 90       	pop	r0
     a9a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     a9c:	08 95       	ret

00000a9e <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     a9e:	cf 92       	push	r12
     aa0:	df 92       	push	r13
     aa2:	ef 92       	push	r14
     aa4:	ff 92       	push	r15
     aa6:	0f 93       	push	r16
     aa8:	1f 93       	push	r17
     aaa:	cf 93       	push	r28
     aac:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     aae:	80 91 0a 0b 	lds	r24, 0x0B0A
     ab2:	81 11       	cpse	r24, r1
     ab4:	9b c0       	rjmp	.+310    	; 0xbec <xTaskIncrementTick+0x14e>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
     ab6:	80 91 13 0b 	lds	r24, 0x0B13
     aba:	90 91 14 0b 	lds	r25, 0x0B14
     abe:	01 96       	adiw	r24, 0x01	; 1
     ac0:	90 93 14 0b 	sts	0x0B14, r25
     ac4:	80 93 13 0b 	sts	0x0B13, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     ac8:	e0 90 13 0b 	lds	r14, 0x0B13
     acc:	f0 90 14 0b 	lds	r15, 0x0B14

			if( xConstTickCount == ( TickType_t ) 0U )
     ad0:	e1 14       	cp	r14, r1
     ad2:	f1 04       	cpc	r15, r1
     ad4:	b9 f4       	brne	.+46     	; 0xb04 <xTaskIncrementTick+0x66>
			{
				taskSWITCH_DELAYED_LISTS();
     ad6:	80 91 34 0b 	lds	r24, 0x0B34
     ada:	90 91 35 0b 	lds	r25, 0x0B35
     ade:	20 91 32 0b 	lds	r18, 0x0B32
     ae2:	30 91 33 0b 	lds	r19, 0x0B33
     ae6:	30 93 35 0b 	sts	0x0B35, r19
     aea:	20 93 34 0b 	sts	0x0B34, r18
     aee:	90 93 33 0b 	sts	0x0B33, r25
     af2:	80 93 32 0b 	sts	0x0B32, r24
     af6:	80 91 0e 0b 	lds	r24, 0x0B0E
     afa:	8f 5f       	subi	r24, 0xFF	; 255
     afc:	80 93 0e 0b 	sts	0x0B0E, r24
     b00:	0e 94 a0 03 	call	0x740	; 0x740 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
     b04:	80 91 0b 0b 	lds	r24, 0x0B0B
     b08:	90 91 0c 0b 	lds	r25, 0x0B0C
     b0c:	e8 16       	cp	r14, r24
     b0e:	f9 06       	cpc	r15, r25
     b10:	10 f4       	brcc	.+4      	; 0xb16 <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     b12:	d1 2c       	mov	r13, r1
     b14:	53 c0       	rjmp	.+166    	; 0xbbc <xTaskIncrementTick+0x11e>
     b16:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
     b18:	cc 24       	eor	r12, r12
     b1a:	c3 94       	inc	r12
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     b1c:	e0 91 34 0b 	lds	r30, 0x0B34
     b20:	f0 91 35 0b 	lds	r31, 0x0B35
     b24:	90 81       	ld	r25, Z
     b26:	91 11       	cpse	r25, r1
     b28:	07 c0       	rjmp	.+14     	; 0xb38 <xTaskIncrementTick+0x9a>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
     b2a:	8f ef       	ldi	r24, 0xFF	; 255
     b2c:	9f ef       	ldi	r25, 0xFF	; 255
     b2e:	90 93 0c 0b 	sts	0x0B0C, r25
     b32:	80 93 0b 0b 	sts	0x0B0B, r24
						break;
     b36:	42 c0       	rjmp	.+132    	; 0xbbc <xTaskIncrementTick+0x11e>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     b38:	e0 91 34 0b 	lds	r30, 0x0B34
     b3c:	f0 91 35 0b 	lds	r31, 0x0B35
     b40:	05 80       	ldd	r0, Z+5	; 0x05
     b42:	f6 81       	ldd	r31, Z+6	; 0x06
     b44:	e0 2d       	mov	r30, r0
     b46:	c6 81       	ldd	r28, Z+6	; 0x06
     b48:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     b4a:	2a 81       	ldd	r18, Y+2	; 0x02
     b4c:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
     b4e:	e2 16       	cp	r14, r18
     b50:	f3 06       	cpc	r15, r19
     b52:	28 f4       	brcc	.+10     	; 0xb5e <xTaskIncrementTick+0xc0>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
     b54:	30 93 0c 0b 	sts	0x0B0C, r19
     b58:	20 93 0b 0b 	sts	0x0B0B, r18
							break;
     b5c:	2f c0       	rjmp	.+94     	; 0xbbc <xTaskIncrementTick+0x11e>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     b5e:	8e 01       	movw	r16, r28
     b60:	0e 5f       	subi	r16, 0xFE	; 254
     b62:	1f 4f       	sbci	r17, 0xFF	; 255
     b64:	c8 01       	movw	r24, r16
     b66:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     b6a:	8c 89       	ldd	r24, Y+20	; 0x14
     b6c:	9d 89       	ldd	r25, Y+21	; 0x15
     b6e:	89 2b       	or	r24, r25
     b70:	21 f0       	breq	.+8      	; 0xb7a <xTaskIncrementTick+0xdc>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     b72:	ce 01       	movw	r24, r28
     b74:	0c 96       	adiw	r24, 0x0c	; 12
     b76:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
     b7a:	2e 89       	ldd	r18, Y+22	; 0x16
     b7c:	80 91 12 0b 	lds	r24, 0x0B12
     b80:	82 17       	cp	r24, r18
     b82:	10 f4       	brcc	.+4      	; 0xb88 <xTaskIncrementTick+0xea>
     b84:	20 93 12 0b 	sts	0x0B12, r18
     b88:	30 e0       	ldi	r19, 0x00	; 0
     b8a:	c9 01       	movw	r24, r18
     b8c:	88 0f       	add	r24, r24
     b8e:	99 1f       	adc	r25, r25
     b90:	88 0f       	add	r24, r24
     b92:	99 1f       	adc	r25, r25
     b94:	88 0f       	add	r24, r24
     b96:	99 1f       	adc	r25, r25
     b98:	82 0f       	add	r24, r18
     b9a:	93 1f       	adc	r25, r19
     b9c:	b8 01       	movw	r22, r16
     b9e:	88 5b       	subi	r24, 0xB8	; 184
     ba0:	94 4f       	sbci	r25, 0xF4	; 244
     ba2:	0e 94 90 01 	call	0x320	; 0x320 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     ba6:	e0 91 7e 0b 	lds	r30, 0x0B7E
     baa:	f0 91 7f 0b 	lds	r31, 0x0B7F
     bae:	9e 89       	ldd	r25, Y+22	; 0x16
     bb0:	86 89       	ldd	r24, Z+22	; 0x16
     bb2:	98 17       	cp	r25, r24
     bb4:	08 f4       	brcc	.+2      	; 0xbb8 <xTaskIncrementTick+0x11a>
     bb6:	b2 cf       	rjmp	.-156    	; 0xb1c <xTaskIncrementTick+0x7e>
							{
								xSwitchRequired = pdTRUE;
     bb8:	dc 2c       	mov	r13, r12
     bba:	b0 cf       	rjmp	.-160    	; 0xb1c <xTaskIncrementTick+0x7e>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     bbc:	e0 91 7e 0b 	lds	r30, 0x0B7E
     bc0:	f0 91 7f 0b 	lds	r31, 0x0B7F
     bc4:	86 89       	ldd	r24, Z+22	; 0x16
     bc6:	90 e0       	ldi	r25, 0x00	; 0
     bc8:	fc 01       	movw	r30, r24
     bca:	ee 0f       	add	r30, r30
     bcc:	ff 1f       	adc	r31, r31
     bce:	ee 0f       	add	r30, r30
     bd0:	ff 1f       	adc	r31, r31
     bd2:	ee 0f       	add	r30, r30
     bd4:	ff 1f       	adc	r31, r31
     bd6:	8e 0f       	add	r24, r30
     bd8:	9f 1f       	adc	r25, r31
     bda:	fc 01       	movw	r30, r24
     bdc:	e8 5b       	subi	r30, 0xB8	; 184
     bde:	f4 4f       	sbci	r31, 0xF4	; 244
     be0:	80 81       	ld	r24, Z
     be2:	82 30       	cpi	r24, 0x02	; 2
     be4:	48 f0       	brcs	.+18     	; 0xbf8 <xTaskIncrementTick+0x15a>
			{
				xSwitchRequired = pdTRUE;
     be6:	dd 24       	eor	r13, r13
     be8:	d3 94       	inc	r13
     bea:	06 c0       	rjmp	.+12     	; 0xbf8 <xTaskIncrementTick+0x15a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     bec:	80 91 10 0b 	lds	r24, 0x0B10
     bf0:	8f 5f       	subi	r24, 0xFF	; 255
     bf2:	80 93 10 0b 	sts	0x0B10, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     bf6:	d1 2c       	mov	r13, r1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     bf8:	80 91 0f 0b 	lds	r24, 0x0B0F
     bfc:	88 23       	and	r24, r24
     bfe:	11 f0       	breq	.+4      	; 0xc04 <xTaskIncrementTick+0x166>
		{
			xSwitchRequired = pdTRUE;
     c00:	dd 24       	eor	r13, r13
     c02:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     c04:	8d 2d       	mov	r24, r13
     c06:	df 91       	pop	r29
     c08:	cf 91       	pop	r28
     c0a:	1f 91       	pop	r17
     c0c:	0f 91       	pop	r16
     c0e:	ff 90       	pop	r15
     c10:	ef 90       	pop	r14
     c12:	df 90       	pop	r13
     c14:	cf 90       	pop	r12
     c16:	08 95       	ret

00000c18 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     c18:	df 92       	push	r13
     c1a:	ef 92       	push	r14
     c1c:	ff 92       	push	r15
     c1e:	0f 93       	push	r16
     c20:	1f 93       	push	r17
     c22:	cf 93       	push	r28
     c24:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     c26:	0f b6       	in	r0, 0x3f	; 63
     c28:	f8 94       	cli
     c2a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     c2c:	80 91 0a 0b 	lds	r24, 0x0B0A
     c30:	81 50       	subi	r24, 0x01	; 1
     c32:	80 93 0a 0b 	sts	0x0B0A, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c36:	80 91 0a 0b 	lds	r24, 0x0B0A
     c3a:	81 11       	cpse	r24, r1
     c3c:	62 c0       	rjmp	.+196    	; 0xd02 <xTaskResumeAll+0xea>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     c3e:	80 91 15 0b 	lds	r24, 0x0B15
     c42:	81 11       	cpse	r24, r1
     c44:	33 c0       	rjmp	.+102    	; 0xcac <xTaskResumeAll+0x94>
     c46:	60 c0       	rjmp	.+192    	; 0xd08 <xTaskResumeAll+0xf0>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     c48:	d7 01       	movw	r26, r14
     c4a:	15 96       	adiw	r26, 0x05	; 5
     c4c:	ed 91       	ld	r30, X+
     c4e:	fc 91       	ld	r31, X
     c50:	16 97       	sbiw	r26, 0x06	; 6
     c52:	c6 81       	ldd	r28, Z+6	; 0x06
     c54:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     c56:	ce 01       	movw	r24, r28
     c58:	0c 96       	adiw	r24, 0x0c	; 12
     c5a:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     c5e:	8e 01       	movw	r16, r28
     c60:	0e 5f       	subi	r16, 0xFE	; 254
     c62:	1f 4f       	sbci	r17, 0xFF	; 255
     c64:	c8 01       	movw	r24, r16
     c66:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     c6a:	2e 89       	ldd	r18, Y+22	; 0x16
     c6c:	80 91 12 0b 	lds	r24, 0x0B12
     c70:	82 17       	cp	r24, r18
     c72:	10 f4       	brcc	.+4      	; 0xc78 <xTaskResumeAll+0x60>
     c74:	20 93 12 0b 	sts	0x0B12, r18
     c78:	30 e0       	ldi	r19, 0x00	; 0
     c7a:	c9 01       	movw	r24, r18
     c7c:	88 0f       	add	r24, r24
     c7e:	99 1f       	adc	r25, r25
     c80:	88 0f       	add	r24, r24
     c82:	99 1f       	adc	r25, r25
     c84:	88 0f       	add	r24, r24
     c86:	99 1f       	adc	r25, r25
     c88:	82 0f       	add	r24, r18
     c8a:	93 1f       	adc	r25, r19
     c8c:	b8 01       	movw	r22, r16
     c8e:	88 5b       	subi	r24, 0xB8	; 184
     c90:	94 4f       	sbci	r25, 0xF4	; 244
     c92:	0e 94 90 01 	call	0x320	; 0x320 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     c96:	e0 91 7e 0b 	lds	r30, 0x0B7E
     c9a:	f0 91 7f 0b 	lds	r31, 0x0B7F
     c9e:	9e 89       	ldd	r25, Y+22	; 0x16
     ca0:	86 89       	ldd	r24, Z+22	; 0x16
     ca2:	98 17       	cp	r25, r24
     ca4:	58 f0       	brcs	.+22     	; 0xcbc <xTaskResumeAll+0xa4>
					{
						xYieldPending = pdTRUE;
     ca6:	d0 92 0f 0b 	sts	0x0B0F, r13
     caa:	08 c0       	rjmp	.+16     	; 0xcbc <xTaskResumeAll+0xa4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     cac:	0f 2e       	mov	r0, r31
     cae:	f9 e2       	ldi	r31, 0x29	; 41
     cb0:	ef 2e       	mov	r14, r31
     cb2:	fb e0       	ldi	r31, 0x0B	; 11
     cb4:	ff 2e       	mov	r15, r31
     cb6:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     cb8:	dd 24       	eor	r13, r13
     cba:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     cbc:	f7 01       	movw	r30, r14
     cbe:	80 81       	ld	r24, Z
     cc0:	81 11       	cpse	r24, r1
     cc2:	c2 cf       	rjmp	.-124    	; 0xc48 <xTaskResumeAll+0x30>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
     cc4:	80 91 10 0b 	lds	r24, 0x0B10
     cc8:	88 23       	and	r24, r24
     cca:	99 f0       	breq	.+38     	; 0xcf2 <xTaskResumeAll+0xda>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     ccc:	80 91 10 0b 	lds	r24, 0x0B10
     cd0:	88 23       	and	r24, r24
     cd2:	79 f0       	breq	.+30     	; 0xcf2 <xTaskResumeAll+0xda>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
     cd4:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
     cd6:	0e 94 4f 05 	call	0xa9e	; 0xa9e <xTaskIncrementTick>
     cda:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
     cdc:	c0 93 0f 0b 	sts	0x0B0F, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
     ce0:	80 91 10 0b 	lds	r24, 0x0B10
     ce4:	81 50       	subi	r24, 0x01	; 1
     ce6:	80 93 10 0b 	sts	0x0B10, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     cea:	80 91 10 0b 	lds	r24, 0x0B10
     cee:	81 11       	cpse	r24, r1
     cf0:	f2 cf       	rjmp	.-28     	; 0xcd6 <xTaskResumeAll+0xbe>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
     cf2:	80 91 0f 0b 	lds	r24, 0x0B0F
     cf6:	81 30       	cpi	r24, 0x01	; 1
     cf8:	31 f4       	brne	.+12     	; 0xd06 <xTaskResumeAll+0xee>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     cfa:	0e 94 b2 02 	call	0x564	; 0x564 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     cfe:	81 e0       	ldi	r24, 0x01	; 1
     d00:	03 c0       	rjmp	.+6      	; 0xd08 <xTaskResumeAll+0xf0>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
     d02:	80 e0       	ldi	r24, 0x00	; 0
     d04:	01 c0       	rjmp	.+2      	; 0xd08 <xTaskResumeAll+0xf0>
     d06:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     d08:	0f 90       	pop	r0
     d0a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     d0c:	df 91       	pop	r29
     d0e:	cf 91       	pop	r28
     d10:	1f 91       	pop	r17
     d12:	0f 91       	pop	r16
     d14:	ff 90       	pop	r15
     d16:	ef 90       	pop	r14
     d18:	df 90       	pop	r13
     d1a:	08 95       	ret

00000d1c <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     d1c:	0f 93       	push	r16
     d1e:	1f 93       	push	r17
     d20:	cf 93       	push	r28
     d22:	df 93       	push	r29
     d24:	8c 01       	movw	r16, r24
     d26:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     d28:	0e 94 3f 05 	call	0xa7e	; 0xa7e <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     d2c:	80 91 13 0b 	lds	r24, 0x0B13
     d30:	90 91 14 0b 	lds	r25, 0x0B14

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     d34:	f8 01       	movw	r30, r16
     d36:	20 81       	ld	r18, Z
     d38:	31 81       	ldd	r19, Z+1	; 0x01
     d3a:	c2 0f       	add	r28, r18
     d3c:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
     d3e:	82 17       	cp	r24, r18
     d40:	93 07       	cpc	r25, r19
     d42:	48 f4       	brcc	.+18     	; 0xd56 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     d44:	c2 17       	cp	r28, r18
     d46:	d3 07       	cpc	r29, r19
     d48:	10 f5       	brcc	.+68     	; 0xd8e <vTaskDelayUntil+0x72>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     d4a:	d1 83       	std	Z+1, r29	; 0x01
     d4c:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
     d4e:	8c 17       	cp	r24, r28
     d50:	9d 07       	cpc	r25, r29
     d52:	90 f4       	brcc	.+36     	; 0xd78 <vTaskDelayUntil+0x5c>
     d54:	07 c0       	rjmp	.+14     	; 0xd64 <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     d56:	c2 17       	cp	r28, r18
     d58:	d3 07       	cpc	r29, r19
     d5a:	a8 f0       	brcs	.+42     	; 0xd86 <vTaskDelayUntil+0x6a>
     d5c:	8c 17       	cp	r24, r28
     d5e:	9d 07       	cpc	r25, r29
     d60:	90 f0       	brcs	.+36     	; 0xd86 <vTaskDelayUntil+0x6a>
     d62:	15 c0       	rjmp	.+42     	; 0xd8e <vTaskDelayUntil+0x72>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     d64:	80 91 7e 0b 	lds	r24, 0x0B7E
     d68:	90 91 7f 0b 	lds	r25, 0x0B7F
     d6c:	02 96       	adiw	r24, 0x02	; 2
     d6e:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
     d72:	ce 01       	movw	r24, r28
     d74:	0e 94 bf 03 	call	0x77e	; 0x77e <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     d78:	0e 94 0c 06 	call	0xc18	; 0xc18 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     d7c:	81 11       	cpse	r24, r1
     d7e:	0b c0       	rjmp	.+22     	; 0xd96 <vTaskDelayUntil+0x7a>
		{
			portYIELD_WITHIN_API();
     d80:	0e 94 b2 02 	call	0x564	; 0x564 <vPortYield>
     d84:	08 c0       	rjmp	.+16     	; 0xd96 <vTaskDelayUntil+0x7a>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     d86:	f8 01       	movw	r30, r16
     d88:	d1 83       	std	Z+1, r29	; 0x01
     d8a:	c0 83       	st	Z, r28
     d8c:	eb cf       	rjmp	.-42     	; 0xd64 <vTaskDelayUntil+0x48>
     d8e:	f8 01       	movw	r30, r16
     d90:	d1 83       	std	Z+1, r29	; 0x01
     d92:	c0 83       	st	Z, r28
     d94:	f1 cf       	rjmp	.-30     	; 0xd78 <vTaskDelayUntil+0x5c>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     d96:	df 91       	pop	r29
     d98:	cf 91       	pop	r28
     d9a:	1f 91       	pop	r17
     d9c:	0f 91       	pop	r16
     d9e:	08 95       	ret

00000da0 <prvIdleTask>:
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     da0:	00 e2       	ldi	r16, 0x20	; 32
     da2:	1b e0       	ldi	r17, 0x0B	; 11

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     da4:	0f 2e       	mov	r0, r31
     da6:	f8 e4       	ldi	r31, 0x48	; 72
     da8:	ef 2e       	mov	r14, r31
     daa:	fb e0       	ldi	r31, 0x0B	; 11
     dac:	ff 2e       	mov	r15, r31
     dae:	f0 2d       	mov	r31, r0
     db0:	29 c0       	rjmp	.+82     	; 0xe04 <prvIdleTask+0x64>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
     db2:	0e 94 3f 05 	call	0xa7e	; 0xa7e <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     db6:	d8 01       	movw	r26, r16
     db8:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
     dba:	0e 94 0c 06 	call	0xc18	; 0xc18 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
     dbe:	cc 23       	and	r28, r28
     dc0:	09 f1       	breq	.+66     	; 0xe04 <prvIdleTask+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
     dc2:	0f b6       	in	r0, 0x3f	; 63
     dc4:	f8 94       	cli
     dc6:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
     dc8:	d8 01       	movw	r26, r16
     dca:	15 96       	adiw	r26, 0x05	; 5
     dcc:	ed 91       	ld	r30, X+
     dce:	fc 91       	ld	r31, X
     dd0:	16 97       	sbiw	r26, 0x06	; 6
     dd2:	c6 81       	ldd	r28, Z+6	; 0x06
     dd4:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     dd6:	ce 01       	movw	r24, r28
     dd8:	02 96       	adiw	r24, 0x02	; 2
     dda:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <uxListRemove>
					--uxCurrentNumberOfTasks;
     dde:	80 91 15 0b 	lds	r24, 0x0B15
     de2:	81 50       	subi	r24, 0x01	; 1
     de4:	80 93 15 0b 	sts	0x0B15, r24
					--uxTasksDeleted;
     de8:	80 91 1f 0b 	lds	r24, 0x0B1F
     dec:	81 50       	subi	r24, 0x01	; 1
     dee:	80 93 1f 0b 	sts	0x0B1F, r24
				}
				taskEXIT_CRITICAL();
     df2:	0f 90       	pop	r0
     df4:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
     df6:	8f 89       	ldd	r24, Y+23	; 0x17
     df8:	98 8d       	ldd	r25, Y+24	; 0x18
     dfa:	0e 94 9f 03 	call	0x73e	; 0x73e <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
     dfe:	ce 01       	movw	r24, r28
     e00:	0e 94 9f 03 	call	0x73e	; 0x73e <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
     e04:	80 91 1f 0b 	lds	r24, 0x0B1F
     e08:	81 11       	cpse	r24, r1
     e0a:	d3 cf       	rjmp	.-90     	; 0xdb2 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     e0c:	f7 01       	movw	r30, r14
     e0e:	80 81       	ld	r24, Z
     e10:	82 30       	cpi	r24, 0x02	; 2
     e12:	c0 f3       	brcs	.-16     	; 0xe04 <prvIdleTask+0x64>
			{
				taskYIELD();
     e14:	0e 94 b2 02 	call	0x564	; 0x564 <vPortYield>
     e18:	f5 cf       	rjmp	.-22     	; 0xe04 <prvIdleTask+0x64>

00000e1a <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     e1a:	80 91 0a 0b 	lds	r24, 0x0B0A
     e1e:	88 23       	and	r24, r24
     e20:	21 f0       	breq	.+8      	; 0xe2a <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     e22:	81 e0       	ldi	r24, 0x01	; 1
     e24:	80 93 0f 0b 	sts	0x0B0F, r24
     e28:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     e2a:	10 92 0f 0b 	sts	0x0B0F, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     e2e:	80 91 12 0b 	lds	r24, 0x0B12
     e32:	90 e0       	ldi	r25, 0x00	; 0
     e34:	fc 01       	movw	r30, r24
     e36:	ee 0f       	add	r30, r30
     e38:	ff 1f       	adc	r31, r31
     e3a:	ee 0f       	add	r30, r30
     e3c:	ff 1f       	adc	r31, r31
     e3e:	ee 0f       	add	r30, r30
     e40:	ff 1f       	adc	r31, r31
     e42:	8e 0f       	add	r24, r30
     e44:	9f 1f       	adc	r25, r31
     e46:	fc 01       	movw	r30, r24
     e48:	e8 5b       	subi	r30, 0xB8	; 184
     e4a:	f4 4f       	sbci	r31, 0xF4	; 244
     e4c:	80 81       	ld	r24, Z
     e4e:	81 11       	cpse	r24, r1
     e50:	17 c0       	rjmp	.+46     	; 0xe80 <vTaskSwitchContext+0x66>
     e52:	80 91 12 0b 	lds	r24, 0x0B12
     e56:	81 50       	subi	r24, 0x01	; 1
     e58:	80 93 12 0b 	sts	0x0B12, r24
     e5c:	80 91 12 0b 	lds	r24, 0x0B12
     e60:	90 e0       	ldi	r25, 0x00	; 0
     e62:	fc 01       	movw	r30, r24
     e64:	ee 0f       	add	r30, r30
     e66:	ff 1f       	adc	r31, r31
     e68:	ee 0f       	add	r30, r30
     e6a:	ff 1f       	adc	r31, r31
     e6c:	ee 0f       	add	r30, r30
     e6e:	ff 1f       	adc	r31, r31
     e70:	8e 0f       	add	r24, r30
     e72:	9f 1f       	adc	r25, r31
     e74:	fc 01       	movw	r30, r24
     e76:	e8 5b       	subi	r30, 0xB8	; 184
     e78:	f4 4f       	sbci	r31, 0xF4	; 244
     e7a:	80 81       	ld	r24, Z
     e7c:	88 23       	and	r24, r24
     e7e:	49 f3       	breq	.-46     	; 0xe52 <vTaskSwitchContext+0x38>
     e80:	80 91 12 0b 	lds	r24, 0x0B12
     e84:	90 e0       	ldi	r25, 0x00	; 0
     e86:	9c 01       	movw	r18, r24
     e88:	22 0f       	add	r18, r18
     e8a:	33 1f       	adc	r19, r19
     e8c:	22 0f       	add	r18, r18
     e8e:	33 1f       	adc	r19, r19
     e90:	22 0f       	add	r18, r18
     e92:	33 1f       	adc	r19, r19
     e94:	28 0f       	add	r18, r24
     e96:	39 1f       	adc	r19, r25
     e98:	d9 01       	movw	r26, r18
     e9a:	a8 5b       	subi	r26, 0xB8	; 184
     e9c:	b4 4f       	sbci	r27, 0xF4	; 244
     e9e:	11 96       	adiw	r26, 0x01	; 1
     ea0:	ed 91       	ld	r30, X+
     ea2:	fc 91       	ld	r31, X
     ea4:	12 97       	sbiw	r26, 0x02	; 2
     ea6:	02 80       	ldd	r0, Z+2	; 0x02
     ea8:	f3 81       	ldd	r31, Z+3	; 0x03
     eaa:	e0 2d       	mov	r30, r0
     eac:	12 96       	adiw	r26, 0x02	; 2
     eae:	fc 93       	st	X, r31
     eb0:	ee 93       	st	-X, r30
     eb2:	11 97       	sbiw	r26, 0x01	; 1
     eb4:	25 5b       	subi	r18, 0xB5	; 181
     eb6:	34 4f       	sbci	r19, 0xF4	; 244
     eb8:	e2 17       	cp	r30, r18
     eba:	f3 07       	cpc	r31, r19
     ebc:	29 f4       	brne	.+10     	; 0xec8 <vTaskSwitchContext+0xae>
     ebe:	22 81       	ldd	r18, Z+2	; 0x02
     ec0:	33 81       	ldd	r19, Z+3	; 0x03
     ec2:	fd 01       	movw	r30, r26
     ec4:	32 83       	std	Z+2, r19	; 0x02
     ec6:	21 83       	std	Z+1, r18	; 0x01
     ec8:	fc 01       	movw	r30, r24
     eca:	ee 0f       	add	r30, r30
     ecc:	ff 1f       	adc	r31, r31
     ece:	ee 0f       	add	r30, r30
     ed0:	ff 1f       	adc	r31, r31
     ed2:	ee 0f       	add	r30, r30
     ed4:	ff 1f       	adc	r31, r31
     ed6:	8e 0f       	add	r24, r30
     ed8:	9f 1f       	adc	r25, r31
     eda:	fc 01       	movw	r30, r24
     edc:	e8 5b       	subi	r30, 0xB8	; 184
     ede:	f4 4f       	sbci	r31, 0xF4	; 244
     ee0:	01 80       	ldd	r0, Z+1	; 0x01
     ee2:	f2 81       	ldd	r31, Z+2	; 0x02
     ee4:	e0 2d       	mov	r30, r0
     ee6:	86 81       	ldd	r24, Z+6	; 0x06
     ee8:	97 81       	ldd	r25, Z+7	; 0x07
     eea:	90 93 7f 0b 	sts	0x0B7F, r25
     eee:	80 93 7e 0b 	sts	0x0B7E, r24
     ef2:	08 95       	ret

00000ef4 <vMCUStatusTask>:
/* MCU Status task
 * Toggles the MCU status LED, to blink at 2Hz
 * Rate: 4Hz
 * Priority: 1 (lowest)
 */
void vMCUStatusTask(void *pvParameters) {
     ef4:	cf 93       	push	r28
     ef6:	df 93       	push	r29
     ef8:	00 d0       	rcall	.+0      	; 0xefa <vMCUStatusTask+0x6>
     efa:	cd b7       	in	r28, 0x3d	; 61
     efc:	de b7       	in	r29, 0x3e	; 62
	// Make compiler happy
	(void) pvParameters;
	
	// Previous wake time pointer, initialized to current tick count.
	// This gets updated by vTaskDelayUntil every time it is called
	TickType_t xLastWakeTime = xTaskGetTickCount();
     efe:	0e 94 45 05 	call	0xa8a	; 0xa8a <xTaskGetTickCount>
     f02:	9a 83       	std	Y+2, r25	; 0x02
     f04:	89 83       	std	Y+1, r24	; 0x01
	
	// Task variables
	bool currentValue = 0;	// false
	
	// Setup MCU status pin as output
	pinMode(MCU_STATUS_PORT, MCU_STATUS_CH, IO_DIR_OUTPUT);
     f06:	41 e0       	ldi	r20, 0x01	; 1
     f08:	60 e0       	ldi	r22, 0x00	; 0
     f0a:	81 e0       	ldi	r24, 0x01	; 1
     f0c:	0e 94 7e 08 	call	0x10fc	; 0x10fc <pinMode>
	
	// Period
	const TickType_t xPeriod = 1000 / MCU_STATUS_TASK_RATE;		// In ticks (ms)
	
	// Task variables
	bool currentValue = 0;	// false
     f10:	10 e0       	ldi	r17, 0x00	; 0
	pinMode(MCU_STATUS_PORT, MCU_STATUS_CH, IO_DIR_OUTPUT);
	
	// Executes infinitely with defined period using vTaskDelayUntil
	for(;;) {
		// Flip value
		currentValue = !currentValue;
     f12:	01 e0       	ldi	r16, 0x01	; 1
     f14:	10 27       	eor	r17, r16
		// Write out value
		setPin(MCU_STATUS_PORT, MCU_STATUS_CH, currentValue);
     f16:	41 2f       	mov	r20, r17
     f18:	60 e0       	ldi	r22, 0x00	; 0
     f1a:	80 2f       	mov	r24, r16
     f1c:	0e 94 bd 08 	call	0x117a	; 0x117a <setPin>
		// Delay until next period
		vTaskDelayUntil(&xLastWakeTime, xPeriod); 
     f20:	6a ef       	ldi	r22, 0xFA	; 250
     f22:	70 e0       	ldi	r23, 0x00	; 0
     f24:	ce 01       	movw	r24, r28
     f26:	01 96       	adiw	r24, 0x01	; 1
     f28:	0e 94 8e 06 	call	0xd1c	; 0xd1c <vTaskDelayUntil>
	}
     f2c:	f3 cf       	rjmp	.-26     	; 0xf14 <vMCUStatusTask+0x20>

00000f2e <vADCSampleTask>:
/* ADC sample task
 * Samples all ADC channels
 * Rate: 100Hz
 * Priority: 5 (highest)
 */
void vADCSampleTask(void *pvParameters) {
     f2e:	cf 93       	push	r28
     f30:	df 93       	push	r29
     f32:	00 d0       	rcall	.+0      	; 0xf34 <vADCSampleTask+0x6>
     f34:	cd b7       	in	r28, 0x3d	; 61
     f36:	de b7       	in	r29, 0x3e	; 62
	
	volatile uint16_t j;
	
	// Previous wake time pointer, initialized to current tick count.
	// This gets updated by vTaskDelayUntil every time it is called
	TickType_t xLastWakeTime = xTaskGetTickCount();
     f38:	0e 94 45 05 	call	0xa8a	; 0xa8a <xTaskGetTickCount>
     f3c:	9a 83       	std	Y+2, r25	; 0x02
     f3e:	89 83       	std	Y+1, r24	; 0x01
/* ADC sample task
 * Samples all ADC channels
 * Rate: 100Hz
 * Priority: 5 (highest)
 */
void vADCSampleTask(void *pvParameters) {
     f40:	00 e0       	ldi	r16, 0x00	; 0
     f42:	10 2f       	mov	r17, r16
	// Executes infinitely with defined period using vTaskDelayUntil
	for(;;) {
		// Loop through and sample all thermistors
		for(i = THERM1; i <= THERM8; i++) {
			// Update ADC value in struct
			updateADC(i);
     f44:	81 2f       	mov	r24, r17
     f46:	0e 94 9d 00 	call	0x13a	; 0x13a <updateADC>
     f4a:	1f 5f       	subi	r17, 0xFF	; 255
	unsigned i;
	
	// Executes infinitely with defined period using vTaskDelayUntil
	for(;;) {
		// Loop through and sample all thermistors
		for(i = THERM1; i <= THERM8; i++) {
     f4c:	18 30       	cpi	r17, 0x08	; 8
     f4e:	d1 f7       	brne	.-12     	; 0xf44 <vADCSampleTask+0x16>
			// Update ADC value in struct
			updateADC(i);
		}
		
		// Delay until next period
   		vTaskDelayUntil(&xLastWakeTime, xPeriod);
     f50:	6a e0       	ldi	r22, 0x0A	; 10
     f52:	70 e0       	ldi	r23, 0x00	; 0
     f54:	ce 01       	movw	r24, r28
     f56:	01 96       	adiw	r24, 0x01	; 1
     f58:	0e 94 8e 06 	call	0xd1c	; 0xd1c <vTaskDelayUntil>
	}
     f5c:	f2 cf       	rjmp	.-28     	; 0xf42 <vADCSampleTask+0x14>

00000f5e <vWatchdogTask>:
/* Watchdog kick task
 * Checks to make sure all tasks have run, and kicks the external watchdog
 * Rate: 2Hz
 * Priority: 5
 */
void vWatchdogTask(void *pvParameters) {
     f5e:	cf 93       	push	r28
     f60:	df 93       	push	r29
     f62:	00 d0       	rcall	.+0      	; 0xf64 <vWatchdogTask+0x6>
     f64:	cd b7       	in	r28, 0x3d	; 61
     f66:	de b7       	in	r29, 0x3e	; 62
	// Function variables
	int i;
	
	// Previous wake time pointer, initialized to current tick count.
	// This gets updated by vTaskDelayUntil every time it is called
	TickType_t xLastWakeTime = xTaskGetTickCount();
     f68:	0e 94 45 05 	call	0xa8a	; 0xa8a <xTaskGetTickCount>
     f6c:	9a 83       	std	Y+2, r25	; 0x02
     f6e:	89 83       	std	Y+1, r24	; 0x01
	
	// Period
	const TickType_t xPeriod = 1000 / WATCHDOG_TASK_RATE;		// In ticks (ms)
	
	// Set watchdog kick as output
	pinMode(EXT_WD_KICK_PORT, EXT_WD_KICK_CH, IO_DIR_OUTPUT);
     f70:	41 e0       	ldi	r20, 0x01	; 1
     f72:	61 e0       	ldi	r22, 0x01	; 1
     f74:	82 e0       	ldi	r24, 0x02	; 2
     f76:	0e 94 7e 08 	call	0x10fc	; 0x10fc <pinMode>
	setPin(EXT_WD_KICK_PORT, EXT_WD_KICK_CH, LOW);
     f7a:	40 e0       	ldi	r20, 0x00	; 0
     f7c:	61 e0       	ldi	r22, 0x01	; 1
     f7e:	82 e0       	ldi	r24, 0x02	; 2
     f80:	0e 94 bd 08 	call	0x117a	; 0x117a <setPin>
	
	// Executes infinitely with defined period using vTaskDelayUntil
	for(;;) {
		// Kick the watchdog
		setPin(EXT_WD_KICK_PORT, EXT_WD_KICK_CH, HIGH);
     f84:	04 e6       	ldi	r16, 0x64	; 100
     f86:	10 e0       	ldi	r17, 0x00	; 0
     f88:	41 e0       	ldi	r20, 0x01	; 1
     f8a:	61 e0       	ldi	r22, 0x01	; 1
     f8c:	82 e0       	ldi	r24, 0x02	; 2
     f8e:	0e 94 bd 08 	call	0x117a	; 0x117a <setPin>
     f92:	80 2f       	mov	r24, r16
     f94:	91 2f       	mov	r25, r17
		
		// Wait a little bit
		for(i = 0; i < 100; i++) {
			asm("NOP");
     f96:	00 00       	nop
     f98:	01 97       	sbiw	r24, 0x01	; 1
	for(;;) {
		// Kick the watchdog
		setPin(EXT_WD_KICK_PORT, EXT_WD_KICK_CH, HIGH);
		
		// Wait a little bit
		for(i = 0; i < 100; i++) {
     f9a:	e9 f7       	brne	.-6      	; 0xf96 <vWatchdogTask+0x38>
			asm("NOP");
		}
		
		// Set back to low
		setPin(EXT_WD_KICK_PORT, EXT_WD_KICK_CH, LOW);
     f9c:	40 e0       	ldi	r20, 0x00	; 0
     f9e:	61 e0       	ldi	r22, 0x01	; 1
     fa0:	82 e0       	ldi	r24, 0x02	; 2
     fa2:	0e 94 bd 08 	call	0x117a	; 0x117a <setPin>
		
		// Delay until next period
		vTaskDelayUntil(&xLastWakeTime, xPeriod);
     fa6:	6a ef       	ldi	r22, 0xFA	; 250
     fa8:	70 e0       	ldi	r23, 0x00	; 0
     faa:	ce 01       	movw	r24, r28
     fac:	01 96       	adiw	r24, 0x01	; 1
     fae:	0e 94 8e 06 	call	0xd1c	; 0xd1c <vTaskDelayUntil>
	}
     fb2:	ea cf       	rjmp	.-44     	; 0xf88 <vWatchdogTask+0x2a>

00000fb4 <vThermistorWriteTask>:
/* Thermistor Write Task
 * Writes out the thermistor value to the digital pots
 * Rate: 100Hz
 * Priority: 3
 */
void vThermistorWriteTask(void *pvParameters) {
     fb4:	cf 93       	push	r28
     fb6:	df 93       	push	r29
     fb8:	cd b7       	in	r28, 0x3d	; 61
     fba:	de b7       	in	r29, 0x3e	; 62
     fbc:	27 97       	sbiw	r28, 0x07	; 7
     fbe:	0f b6       	in	r0, 0x3f	; 63
     fc0:	f8 94       	cli
     fc2:	de bf       	out	0x3e, r29	; 62
     fc4:	0f be       	out	0x3f, r0	; 63
     fc6:	cd bf       	out	0x3d, r28	; 61
	// Make compiler happy
	(void) pvParameters;
	
	// Function variables
	volatile uint8_t valueToWrite1 = 0x1F;
     fc8:	8f e1       	ldi	r24, 0x1F	; 31
     fca:	89 83       	std	Y+1, r24	; 0x01
	volatile uint8_t valueToWrite2 = 0x00;
     fcc:	1a 82       	std	Y+2, r1	; 0x02
	volatile uint8_t upperByte, lowerByte;
	volatile uint8_t command;
	SPISlave thermPots = spiSlaves[POT_SYNC];
     fce:	01 e0       	ldi	r16, 0x01	; 1
     fd0:	11 e0       	ldi	r17, 0x01	; 1
	
	// Previous wake time pointer, initialized to current tick count.
	// This gets updated by vTaskDelayUntil every time it is called
	TickType_t xLastWakeTime = xTaskGetTickCount();
     fd2:	0e 94 45 05 	call	0xa8a	; 0xa8a <xTaskGetTickCount>
     fd6:	9f 83       	std	Y+7, r25	; 0x07
     fd8:	8e 83       	std	Y+6, r24	; 0x06
	
	// Period
	const TickType_t xPeriod = 1000 / THERMISTOR_WRITE_TASK_RATE;		// In ticks (ms)
	
	// Send a bunch of zeros for good measure
	taskENTER_CRITICAL();
     fda:	0f b6       	in	r0, 0x3f	; 63
     fdc:	f8 94       	cli
     fde:	0f 92       	push	r0
	spiSelect(thermPots);
     fe0:	81 e0       	ldi	r24, 0x01	; 1
     fe2:	91 e0       	ldi	r25, 0x01	; 1
     fe4:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <spiSelect>
	spiWrite(0x00);
     fe8:	80 e0       	ldi	r24, 0x00	; 0
     fea:	0e 94 10 01 	call	0x220	; 0x220 <spiWrite>
	spiWrite(0x00);
     fee:	80 e0       	ldi	r24, 0x00	; 0
     ff0:	0e 94 10 01 	call	0x220	; 0x220 <spiWrite>
	spiWrite(0x00);
     ff4:	80 e0       	ldi	r24, 0x00	; 0
     ff6:	0e 94 10 01 	call	0x220	; 0x220 <spiWrite>
	spiWrite(0x00);
     ffa:	80 e0       	ldi	r24, 0x00	; 0
     ffc:	0e 94 10 01 	call	0x220	; 0x220 <spiWrite>
	spiDeselect(thermPots);
    1000:	81 e0       	ldi	r24, 0x01	; 1
    1002:	91 e0       	ldi	r25, 0x01	; 1
    1004:	0e 94 da 00 	call	0x1b4	; 0x1b4 <spiDeselect>
	taskEXIT_CRITICAL();
    1008:	0f 90       	pop	r0
    100a:	0f be       	out	0x3f, r0	; 63
	
	// Initialize the pot
	
	// Enable high impedance on SDO output for daisy chain
	taskENTER_CRITICAL();
    100c:	0f b6       	in	r0, 0x3f	; 63
    100e:	f8 94       	cli
    1010:	0f 92       	push	r0
	spiSelect(thermPots);
    1012:	81 e0       	ldi	r24, 0x01	; 1
    1014:	91 e0       	ldi	r25, 0x01	; 1
    1016:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <spiSelect>
	spiWrite(0x80);
    101a:	80 e8       	ldi	r24, 0x80	; 128
    101c:	0e 94 10 01 	call	0x220	; 0x220 <spiWrite>
	spiWrite(0x01);
    1020:	81 e0       	ldi	r24, 0x01	; 1
    1022:	0e 94 10 01 	call	0x220	; 0x220 <spiWrite>
	spiWrite(0x00);
    1026:	80 e0       	ldi	r24, 0x00	; 0
    1028:	0e 94 10 01 	call	0x220	; 0x220 <spiWrite>
	spiWrite(0x00);
    102c:	80 e0       	ldi	r24, 0x00	; 0
    102e:	0e 94 10 01 	call	0x220	; 0x220 <spiWrite>
	spiDeselect(thermPots);
    1032:	81 e0       	ldi	r24, 0x01	; 1
    1034:	91 e0       	ldi	r25, 0x01	; 1
    1036:	0e 94 da 00 	call	0x1b4	; 0x1b4 <spiDeselect>
	taskEXIT_CRITICAL();
    103a:	0f 90       	pop	r0
    103c:	0f be       	out	0x3f, r0	; 63
	
	// Enable RDAC register write access
	upperByte = 0x1C;
    103e:	8c e1       	ldi	r24, 0x1C	; 28
    1040:	8b 83       	std	Y+3, r24	; 0x03
	lowerByte = 0x02;
    1042:	82 e0       	ldi	r24, 0x02	; 2
    1044:	8c 83       	std	Y+4, r24	; 0x04
	taskENTER_CRITICAL();
    1046:	0f b6       	in	r0, 0x3f	; 63
    1048:	f8 94       	cli
    104a:	0f 92       	push	r0
	spiSelect(thermPots);
    104c:	81 e0       	ldi	r24, 0x01	; 1
    104e:	91 e0       	ldi	r25, 0x01	; 1
    1050:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <spiSelect>
	spiWrite(upperByte);
    1054:	8b 81       	ldd	r24, Y+3	; 0x03
    1056:	0e 94 10 01 	call	0x220	; 0x220 <spiWrite>
	spiWrite(lowerByte);
    105a:	8c 81       	ldd	r24, Y+4	; 0x04
    105c:	0e 94 10 01 	call	0x220	; 0x220 <spiWrite>
	spiWrite(upperByte);
    1060:	8b 81       	ldd	r24, Y+3	; 0x03
    1062:	0e 94 10 01 	call	0x220	; 0x220 <spiWrite>
	spiWrite(lowerByte);
    1066:	8c 81       	ldd	r24, Y+4	; 0x04
    1068:	0e 94 10 01 	call	0x220	; 0x220 <spiWrite>
	spiDeselect(thermPots);
    106c:	81 e0       	ldi	r24, 0x01	; 1
    106e:	91 e0       	ldi	r25, 0x01	; 1
    1070:	0e 94 da 00 	call	0x1b4	; 0x1b4 <spiDeselect>
	taskEXIT_CRITICAL();
    1074:	0f 90       	pop	r0
    1076:	0f be       	out	0x3f, r0	; 63
	
	
	// Executes infinitely with defined period using vTaskDelayUntil
	for(;;) {
		// Setup bytes to write
		command = 0x01;
    1078:	ff 24       	eor	r15, r15
    107a:	f3 94       	inc	r15
    107c:	fd 82       	std	Y+5, r15	; 0x05
		upperByte = (command << 2) | (valueToWrite1 >> 6);
    107e:	8d 81       	ldd	r24, Y+5	; 0x05
    1080:	29 81       	ldd	r18, Y+1	; 0x01
    1082:	88 0f       	add	r24, r24
    1084:	88 0f       	add	r24, r24
    1086:	22 95       	swap	r18
    1088:	26 95       	lsr	r18
    108a:	26 95       	lsr	r18
    108c:	23 70       	andi	r18, 0x03	; 3
    108e:	28 2b       	or	r18, r24
    1090:	2b 83       	std	Y+3, r18	; 0x03
		lowerByte = valueToWrite1 << 2;
    1092:	29 81       	ldd	r18, Y+1	; 0x01
    1094:	22 0f       	add	r18, r18
    1096:	22 0f       	add	r18, r18
    1098:	2c 83       	std	Y+4, r18	; 0x04
		
		// Write
		taskENTER_CRITICAL();
    109a:	0f b6       	in	r0, 0x3f	; 63
    109c:	f8 94       	cli
    109e:	0f 92       	push	r0
		spiSelect(thermPots);
    10a0:	80 2f       	mov	r24, r16
    10a2:	91 2f       	mov	r25, r17
    10a4:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <spiSelect>
		spiWrite(upperByte);
    10a8:	8b 81       	ldd	r24, Y+3	; 0x03
    10aa:	0e 94 10 01 	call	0x220	; 0x220 <spiWrite>
		spiWrite(lowerByte);
    10ae:	8c 81       	ldd	r24, Y+4	; 0x04
    10b0:	0e 94 10 01 	call	0x220	; 0x220 <spiWrite>
		upperByte = (command << 2) | (valueToWrite2 >> 6);
    10b4:	3d 81       	ldd	r19, Y+5	; 0x05
    10b6:	2a 81       	ldd	r18, Y+2	; 0x02
    10b8:	33 0f       	add	r19, r19
    10ba:	33 0f       	add	r19, r19
    10bc:	22 95       	swap	r18
    10be:	26 95       	lsr	r18
    10c0:	26 95       	lsr	r18
    10c2:	23 70       	andi	r18, 0x03	; 3
    10c4:	23 2b       	or	r18, r19
    10c6:	2b 83       	std	Y+3, r18	; 0x03
		lowerByte = valueToWrite2 << 2;
    10c8:	2a 81       	ldd	r18, Y+2	; 0x02
    10ca:	22 0f       	add	r18, r18
    10cc:	22 0f       	add	r18, r18
    10ce:	2c 83       	std	Y+4, r18	; 0x04
  		spiWrite(upperByte);
    10d0:	8b 81       	ldd	r24, Y+3	; 0x03
    10d2:	0e 94 10 01 	call	0x220	; 0x220 <spiWrite>
		spiWrite(lowerByte);
    10d6:	8c 81       	ldd	r24, Y+4	; 0x04
    10d8:	0e 94 10 01 	call	0x220	; 0x220 <spiWrite>
		spiDeselect(thermPots);
    10dc:	80 2f       	mov	r24, r16
    10de:	91 2f       	mov	r25, r17
    10e0:	0e 94 da 00 	call	0x1b4	; 0x1b4 <spiDeselect>
		taskEXIT_CRITICAL();
    10e4:	0f 90       	pop	r0
    10e6:	0f be       	out	0x3f, r0	; 63

		valueToWrite2++;
    10e8:	2a 81       	ldd	r18, Y+2	; 0x02
    10ea:	2f 5f       	subi	r18, 0xFF	; 255
    10ec:	2a 83       	std	Y+2, r18	; 0x02
		
		// Delay until next period
		vTaskDelayUntil(&xLastWakeTime, xPeriod);
    10ee:	64 e6       	ldi	r22, 0x64	; 100
    10f0:	70 e0       	ldi	r23, 0x00	; 0
    10f2:	ce 01       	movw	r24, r28
    10f4:	06 96       	adiw	r24, 0x06	; 6
    10f6:	0e 94 8e 06 	call	0xd1c	; 0xd1c <vTaskDelayUntil>
	}
    10fa:	c0 cf       	rjmp	.-128    	; 0x107c <vThermistorWriteTask+0xc8>

000010fc <pinMode>:
 *  port_ch: the channel to set, 0-7
 *  dir: the direction, IO_DIR_INPUT or IO_DIR_OUTPUT
 * Returns: void
 */
void pinMode(uint8_t port, uint8_t port_ch, uint8_t dir) {
	switch(port){
    10fc:	81 30       	cpi	r24, 0x01	; 1
    10fe:	b9 f0       	breq	.+46     	; 0x112e <__stack+0x2f>
    1100:	18 f0       	brcs	.+6      	; 0x1108 <__stack+0x9>
    1102:	82 30       	cpi	r24, 0x02	; 2
    1104:	39 f1       	breq	.+78     	; 0x1154 <__stack+0x55>
    1106:	08 95       	ret
		case IO_PORTB:
			// Crazy bit trickery that sets specific bit to value
			// without touching other bits
			DDRB ^= ((-dir) ^ DDRB) & (1 << port_ch);
    1108:	84 b1       	in	r24, 0x04	; 4
    110a:	24 b1       	in	r18, 0x04	; 4
    110c:	50 e0       	ldi	r21, 0x00	; 0
    110e:	51 95       	neg	r21
    1110:	41 95       	neg	r20
    1112:	51 09       	sbc	r21, r1
    1114:	48 27       	eor	r20, r24
    1116:	81 e0       	ldi	r24, 0x01	; 1
    1118:	90 e0       	ldi	r25, 0x00	; 0
    111a:	02 c0       	rjmp	.+4      	; 0x1120 <__stack+0x21>
    111c:	88 0f       	add	r24, r24
    111e:	99 1f       	adc	r25, r25
    1120:	6a 95       	dec	r22
    1122:	e2 f7       	brpl	.-8      	; 0x111c <__stack+0x1d>
    1124:	48 23       	and	r20, r24
    1126:	59 23       	and	r21, r25
    1128:	42 27       	eor	r20, r18
    112a:	44 b9       	out	0x04, r20	; 4
			break;
    112c:	08 95       	ret
		case IO_PORTC:
			DDRC ^= ((-dir) ^ DDRC) & (1 << port_ch);
    112e:	87 b1       	in	r24, 0x07	; 7
    1130:	27 b1       	in	r18, 0x07	; 7
    1132:	50 e0       	ldi	r21, 0x00	; 0
    1134:	51 95       	neg	r21
    1136:	41 95       	neg	r20
    1138:	51 09       	sbc	r21, r1
    113a:	48 27       	eor	r20, r24
    113c:	81 e0       	ldi	r24, 0x01	; 1
    113e:	90 e0       	ldi	r25, 0x00	; 0
    1140:	02 c0       	rjmp	.+4      	; 0x1146 <__stack+0x47>
    1142:	88 0f       	add	r24, r24
    1144:	99 1f       	adc	r25, r25
    1146:	6a 95       	dec	r22
    1148:	e2 f7       	brpl	.-8      	; 0x1142 <__stack+0x43>
    114a:	48 23       	and	r20, r24
    114c:	59 23       	and	r21, r25
    114e:	42 27       	eor	r20, r18
    1150:	47 b9       	out	0x07, r20	; 7
			break;
    1152:	08 95       	ret
		case IO_PORTD:
			DDRD ^= ((-dir) ^ DDRD) & (1 << port_ch);
    1154:	8a b1       	in	r24, 0x0a	; 10
    1156:	2a b1       	in	r18, 0x0a	; 10
    1158:	50 e0       	ldi	r21, 0x00	; 0
    115a:	51 95       	neg	r21
    115c:	41 95       	neg	r20
    115e:	51 09       	sbc	r21, r1
    1160:	48 27       	eor	r20, r24
    1162:	81 e0       	ldi	r24, 0x01	; 1
    1164:	90 e0       	ldi	r25, 0x00	; 0
    1166:	02 c0       	rjmp	.+4      	; 0x116c <__stack+0x6d>
    1168:	88 0f       	add	r24, r24
    116a:	99 1f       	adc	r25, r25
    116c:	6a 95       	dec	r22
    116e:	e2 f7       	brpl	.-8      	; 0x1168 <__stack+0x69>
    1170:	48 23       	and	r20, r24
    1172:	59 23       	and	r21, r25
    1174:	42 27       	eor	r20, r18
    1176:	4a b9       	out	0x0a, r20	; 10
    1178:	08 95       	ret

0000117a <setPin>:
 *  port_ch: the channel to set, 0-7
 *  val: the value, HIGH or LOW
 * Returns: void
 */
void setPin(uint8_t port, uint8_t port_ch, uint8_t val) {
	switch(port){
    117a:	81 30       	cpi	r24, 0x01	; 1
    117c:	b9 f0       	breq	.+46     	; 0x11ac <setPin+0x32>
    117e:	18 f0       	brcs	.+6      	; 0x1186 <setPin+0xc>
    1180:	82 30       	cpi	r24, 0x02	; 2
    1182:	39 f1       	breq	.+78     	; 0x11d2 <setPin+0x58>
    1184:	08 95       	ret
		case IO_PORTB:
			// Crazy bit trickery that sets specific bit to value
			// without touching other bits
			PORTB ^= ((-val) ^ PORTB) & (1 << port_ch);
    1186:	85 b1       	in	r24, 0x05	; 5
    1188:	25 b1       	in	r18, 0x05	; 5
    118a:	50 e0       	ldi	r21, 0x00	; 0
    118c:	51 95       	neg	r21
    118e:	41 95       	neg	r20
    1190:	51 09       	sbc	r21, r1
    1192:	48 27       	eor	r20, r24
    1194:	81 e0       	ldi	r24, 0x01	; 1
    1196:	90 e0       	ldi	r25, 0x00	; 0
    1198:	02 c0       	rjmp	.+4      	; 0x119e <setPin+0x24>
    119a:	88 0f       	add	r24, r24
    119c:	99 1f       	adc	r25, r25
    119e:	6a 95       	dec	r22
    11a0:	e2 f7       	brpl	.-8      	; 0x119a <setPin+0x20>
    11a2:	48 23       	and	r20, r24
    11a4:	59 23       	and	r21, r25
    11a6:	42 27       	eor	r20, r18
    11a8:	45 b9       	out	0x05, r20	; 5
			break;
    11aa:	08 95       	ret
		case IO_PORTC:
			PORTC ^= ((-val) ^ PORTC) & (1 << port_ch);
    11ac:	88 b1       	in	r24, 0x08	; 8
    11ae:	28 b1       	in	r18, 0x08	; 8
    11b0:	50 e0       	ldi	r21, 0x00	; 0
    11b2:	51 95       	neg	r21
    11b4:	41 95       	neg	r20
    11b6:	51 09       	sbc	r21, r1
    11b8:	48 27       	eor	r20, r24
    11ba:	81 e0       	ldi	r24, 0x01	; 1
    11bc:	90 e0       	ldi	r25, 0x00	; 0
    11be:	02 c0       	rjmp	.+4      	; 0x11c4 <setPin+0x4a>
    11c0:	88 0f       	add	r24, r24
    11c2:	99 1f       	adc	r25, r25
    11c4:	6a 95       	dec	r22
    11c6:	e2 f7       	brpl	.-8      	; 0x11c0 <setPin+0x46>
    11c8:	48 23       	and	r20, r24
    11ca:	59 23       	and	r21, r25
    11cc:	42 27       	eor	r20, r18
    11ce:	48 b9       	out	0x08, r20	; 8
			break;
    11d0:	08 95       	ret
		case IO_PORTD:
			PORTD ^= ((-val) ^ PORTD) & (1 << port_ch);
    11d2:	8b b1       	in	r24, 0x0b	; 11
    11d4:	2b b1       	in	r18, 0x0b	; 11
    11d6:	50 e0       	ldi	r21, 0x00	; 0
    11d8:	51 95       	neg	r21
    11da:	41 95       	neg	r20
    11dc:	51 09       	sbc	r21, r1
    11de:	48 27       	eor	r20, r24
    11e0:	81 e0       	ldi	r24, 0x01	; 1
    11e2:	90 e0       	ldi	r25, 0x00	; 0
    11e4:	02 c0       	rjmp	.+4      	; 0x11ea <setPin+0x70>
    11e6:	88 0f       	add	r24, r24
    11e8:	99 1f       	adc	r25, r25
    11ea:	6a 95       	dec	r22
    11ec:	e2 f7       	brpl	.-8      	; 0x11e6 <setPin+0x6c>
    11ee:	48 23       	and	r20, r24
    11f0:	59 23       	and	r21, r25
    11f2:	42 27       	eor	r20, r18
    11f4:	4b b9       	out	0x0b, r20	; 11
    11f6:	08 95       	ret

000011f8 <_exit>:
    11f8:	f8 94       	cli

000011fa <__stop_program>:
    11fa:	ff cf       	rjmp	.-2      	; 0x11fa <__stop_program>
